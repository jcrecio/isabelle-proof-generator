{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/NegInfinityUni.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma convert_allZero : \n  assumes \"convert_poly var p (xs'@x#xs) = Some p'\"\n  assumes \"length xs' = var\"\n  shows \"eval (allZero p var) (xs'@x#xs) = evalUni (allZero' p') x\"", "lemma convert_alternateNegInfinity : \n  assumes \"convert_poly var p (xs'@x#xs) = Some X\"\n  assumes \"length xs' = var\"\n  shows \"eval (alternateNegInfinity p var) (xs'@x#xs) = evalUni (alternateNegInfinity' X) x\"", "lemma convert_substNegInfinity : \n  assumes \"convert_atom var A (xs'@x#xs) = Some(A')\"\n  assumes \"length xs' = var\"\n  shows \"eval (substNegInfinity var A) (xs'@x#xs) = evalUni (substNegInfinityUni A') x\"", "lemma change_eval_eq:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (EqUni(a,b,c)) x \\<noteq> aEvalUni (EqUni(a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"", "lemma change_eval_lt:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (LessUni (a,b,c)) x \\<noteq> aEvalUni (LessUni (a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"", "lemma no_change_eval_lt:\n  fixes x y:: \"real\"\n  assumes \"x < y\"\n  assumes \"\\<not>(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"\n  shows \"((aEvalUni (LessUni (a,b,c)) x = aEvalUni (LessUni (a,b,c)) y))\"", "lemma change_eval_neq:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (NeqUni (a,b,c)) x \\<noteq> aEvalUni (NeqUni (a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"", "lemma change_eval_leq:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (LeqUni (a,b,c)) x \\<noteq> aEvalUni (LeqUni (a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"", "lemma change_eval:\n  fixes x y:: \"real\"\n  fixes At:: \"atomUni\" \n  assumes xlt: \"x < y\"\n  assumes noteq: \"((aEvalUni At) x \\<noteq> aEvalUni (At) y)\"\n  assumes \"getPoly At = (a, b, c)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"", "lemma no_change_eval:\n  fixes x y:: \"real\"\n  assumes \"getPoly At = (a, b, c)\"\n  assumes \"x < y\"\n  assumes \"\\<not>(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"\n  shows  \"((aEvalUni At) x = aEvalUni (At) y \\<and> x < y)\"", "lemma same_eval'' :\n  assumes \"getPoly At = (a, b, c)\"\n  assumes nonz: \"a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\"\n  shows \"\\<exists>x. \\<forall>y<x. (aEvalUni At y = aEvalUni At x)\"", "lemma inequality_case : \"(\\<exists>(x::real). \\<forall>(y::real)<x. (a::real) * y\\<^sup>2 + (b::real) * y + (c::real) < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\"", "lemma inequality_case_geq : \"(\\<exists>(x::real). \\<forall>(y::real)<x. (a::real) * y\\<^sup>2 + (b::real) * y + (c::real) > 0) =\n    (a > 0 \\<or> a = 0 \\<and> (0 > b \\<or> b = 0 \\<and> c > 0))\"", "lemma infinity_evalUni_LessUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) = (evalUni (substNegInfinityUni (LessUni p)) x)\"", "lemma infinity_evalUni_EqUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) = (evalUni (substNegInfinityUni (EqUni p)) x)\"", "lemma infinity_evalUni_NeqUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) = (evalUni (substNegInfinityUni (NeqUni p)) x)\"", "lemma infinity_evalUni_LeqUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) = (evalUni (substNegInfinityUni (LeqUni p)) x)\"", "lemma infinity_evalUni :\n  shows \"(\\<exists>x. \\<forall>y<x. aEvalUni At y) = (evalUni (substNegInfinityUni At) x)\""], "translations": [["", "lemma convert_allZero : \n  assumes \"convert_poly var p (xs'@x#xs) = Some p'\"\n  assumes \"length xs' = var\"\n  shows \"eval (allZero p var) (xs'@x#xs) = evalUni (allZero' p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "proof(cases p')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p' = (a, b, c) \\<Longrightarrow>\n       eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "case (fields a b c)"], ["proof (state)\nthis:\n  p' = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p' = (a, b, c) \\<Longrightarrow>\n       eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  p' = (a, b, c)", "show ?thesis"], ["proof (prove)\nusing this:\n  p' = (a, b, c)\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "proof(cases \"MPoly_Type.degree p var = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x\n 2. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x\n 2. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using assms fields"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n  convert_poly var p (xs' @ x # xs) = Some p'\n  length xs' = var\n  p' = (a, b, c)\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "by(simp add:eval_list_conj isovar_greater_degree)"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "have nonzero : \"MPoly_Type.degree p var \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p' = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using assms fields"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n  convert_poly var p (xs' @ x # xs) = Some p'\n  length xs' = var\n  p' = (a, b, c)\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "apply(simp add:eval_list_conj isovar_greater_degree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = Suc 0;\n     a = 0 \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)) =\n     b \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     length xs' = var; p' = (0, b, c)\\<rbrakk>\n    \\<Longrightarrow> (c = 0 \\<and> b = 0) = (b = 0 \\<and> c = 0)", "by (metis)"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have degree2 : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using degree_convert_eq[OF assms(1)] nonzero"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var < 3\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (allZero p var) (xs' @ x # xs) =\n                      evalUni (allZero' p') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n  convert_poly var p (xs' @ x # xs) = Some p'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "apply(simp add:eval_list_conj isovar_greater_degree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = 2;\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var 2),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var 0)) =\n     p';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>{0..<3}.\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var f) =\n                          0) =\n                      evalUni (allZero' p') x", "using insertion_isovarspars_free list_update_code(2)"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (?L[?var := ?x]))\n   (isolate_variable_sparse ?p ?var ?i) =\n  insertion (nth_default 0 (?L[?var := ?y]))\n   (isolate_variable_sparse ?p ?var ?i)\n  (?x # ?xs)[0 := ?y] = ?y # ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = 2;\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var 2),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var 0)) =\n     p';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>{0..<3}.\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var f) =\n                          0) =\n                      evalUni (allZero' p') x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>MPoly_Type.degree p (length xs') = 2;\n        \\<And>L var x p i y.\n           insertion (nth_default 0 (L[var := x]))\n            (isolate_variable_sparse p var i) =\n           insertion (nth_default 0 (L[var := y]))\n            (isolate_variable_sparse p var i);\n        p' = (0, 0, 0); var = length xs'; f < 3;\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 2) =\n        0;\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0)) =\n        0;\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 0) =\n        0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p (length xs') f) =\n                         0", "by (metis One_nat_def Suc_1 less_2_cases less_Suc_eq numeral_3_eq_3)"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun alternateNegInfinity' :: \"real * real * real \\<Rightarrow> atomUni fmUni\" where\n  \"alternateNegInfinity' (a,b,c) = \nOrUni(AtomUni(LessUni(0,0,a)))(\nAndUni(AtomUni(EqUni(0,0,a))) (\n  OrUni(AtomUni(LessUni(0,0,-b)))(\n  AndUni(AtomUni(EqUni(0,0,b)))(\n    AtomUni(LessUni(0,0,c))\n  ))\n))\n\""], ["", "lemma convert_alternateNegInfinity : \n  assumes \"convert_poly var p (xs'@x#xs) = Some X\"\n  assumes \"length xs' = var\"\n  shows \"eval (alternateNegInfinity p var) (xs'@x#xs) = evalUni (alternateNegInfinity' X) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "proof(cases X)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       X = (a, b, c) \\<Longrightarrow>\n       eval (alternateNegInfinity p var) (xs' @ x # xs) =\n       evalUni (alternateNegInfinity' X) x", "case (fields a b c)"], ["proof (state)\nthis:\n  X = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       X = (a, b, c) \\<Longrightarrow>\n       eval (alternateNegInfinity p var) (xs' @ x # xs) =\n       evalUni (alternateNegInfinity' X) x", "then"], ["proof (chain)\npicking this:\n  X = (a, b, c)", "show ?thesis"], ["proof (prove)\nusing this:\n  X = (a, b, c)\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "proof(cases \"MPoly_Type.degree p var = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x\n 2. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x\n 2. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n  convert_poly var p (xs' @ x # xs) = Some X\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "apply (simp add: isovar_greater_degree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = 0;\n     (0, 0,\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var 0)) =\n     X;\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (let a_n = isolate_variable_sparse p var 0\n                        in or (fm.Atom (Less (Const 1 * a_n)))\n                            (and (fm.Atom (Eq a_n)) FalseF))\n                       (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p (length xs') = 0;\n     X =\n     (0, 0,\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 0));\n     var = length xs';\n     eval\n      (let a_n = isolate_variable_sparse p (length xs') 0\n       in or (fm.Atom (Less (Const 1 * a_n)))\n           (and (fm.Atom (Eq a_n)) FalseF))\n      (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') 0)\n                      < 0\n 2. \\<lbrakk>MPoly_Type.degree p (length xs') = 0;\n     X =\n     (0, 0,\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 0));\n     var = length xs';\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 0)\n     < 0\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (let a_n = isolate_variable_sparse p (length xs') 0\n                        in or (fm.Atom (Less (Const 1 * a_n)))\n                            (and (fm.Atom (Eq a_n)) FalseF))\n                       (xs' @ x # xs)", "apply (metis aEval.simps(2) eval.simps(1) eval_and eval_false eval_or  mult_one_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p (length xs') = 0;\n     X =\n     (0, 0,\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 0));\n     var = length xs';\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 0)\n     < 0\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (let a_n = isolate_variable_sparse p (length xs') 0\n                        in or (fm.Atom (Less (Const 1 * a_n)))\n                            (and (fm.Atom (Eq a_n)) FalseF))\n                       (xs' @ x # xs)", "by (metis aEval.simps(2) eval.simps(1) eval_or  mult_one_left)"], ["proof (state)\nthis:\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' X) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "have nonzero : \"MPoly_Type.degree p var \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = (a, b, c); MPoly_Type.degree p var \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "have letbind: \"eval\n     (let a_n = isolate_variable_sparse p var (Suc 0)\n      in or (fm.Atom (Less (Const (- 1) * a_n)))\n          (and (fm.Atom (Eq a_n))\n            (let a_n = isolate_variable_sparse p var 0\n             in or (fm.Atom (Less (Const 1 * a_n))) (and (fm.Atom (Eq a_n)) FalseF))))\n     (xs'@x#xs) = \n    eval\n     (or (fm.Atom (Less (Const (- 1) * (isolate_variable_sparse p var (Suc 0)))))\n          (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n            (or (fm.Atom (Less (Const 1 * (isolate_variable_sparse p var 0)))) (and (fm.Atom (Eq (isolate_variable_sparse p var 0))) FalseF))))\n     (xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (let a_n = isolate_variable_sparse p var (Suc 0)\n      in or (fm.Atom (Less (Const (- 1) * a_n)))\n          (and (fm.Atom (Eq a_n))\n            (let a_n = isolate_variable_sparse p var 0\n             in or (fm.Atom (Less (Const 1 * a_n)))\n                 (and (fm.Atom (Eq a_n)) FalseF))))\n     (xs' @ x # xs) =\n    eval\n     (or (fm.Atom\n           (Less (Const (- 1) * isolate_variable_sparse p var (Suc 0))))\n       (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n         (or (fm.Atom (Less (Const 1 * isolate_variable_sparse p var 0)))\n           (and (fm.Atom (Eq (isolate_variable_sparse p var 0))) FalseF))))\n     (xs' @ x # xs)", "by meson"], ["proof (state)\nthis:\n  eval\n   (let a_n = isolate_variable_sparse p var (Suc 0)\n    in or (fm.Atom (Less (Const (- 1) * a_n)))\n        (and (fm.Atom (Eq a_n))\n          (let a_n = isolate_variable_sparse p var 0\n           in or (fm.Atom (Less (Const 1 * a_n)))\n               (and (fm.Atom (Eq a_n)) FalseF))))\n   (xs' @ x # xs) =\n  eval\n   (or (fm.Atom\n         (Less (Const (- 1) * isolate_variable_sparse p var (Suc 0))))\n     (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n       (or (fm.Atom (Less (Const 1 * isolate_variable_sparse p var 0)))\n         (and (fm.Atom (Eq (isolate_variable_sparse p var 0))) FalseF))))\n   (xs' @ x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "using assms True"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some X\n  length xs' = var\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "unfolding fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' (a, b, c)) x", "by (simp add: isovar_greater_degree letbind eval_or eval_and insertion_mult insertion_const)"], ["proof (state)\nthis:\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' X) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have degree2 : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using degree_convert_eq[OF assms(1)] nonzero"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var < 3\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "have \"[0..<3] = [0,1,2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<3] = [0, 1, 2]", "by (simp add: upt_rec)"], ["proof (state)\nthis:\n  [0..<3] = [0, 1, 2]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "then"], ["proof (chain)\npicking this:\n  [0..<3] = [0, 1, 2]", "have unfold : \" (foldl\n       (\\<lambda>F i. let a_n = isolate_variable_sparse p var i\n               in or (fm.Atom (Less ((if i mod 2 = 0 then Const 1 else Const (- 1)) * a_n)))\n                   (and (fm.Atom (Eq a_n)) F))\n       FalseF [0..<3]) =  \n     (let a_n = isolate_variable_sparse p var 2\n               in or (fm.Atom (Less ((Const 1) * a_n)))\n                   (and (fm.Atom (Eq a_n))\n       (let a_n = isolate_variable_sparse p var (Suc 0)\n      in or (fm.Atom (Less (Const (- 1) * a_n)))\n          (and (fm.Atom (Eq a_n))\n            (let a_n = isolate_variable_sparse p var 0\n             in or (fm.Atom (Less (Const 1 * a_n))) (and (fm.Atom (Eq a_n)) FalseF))))))\""], ["proof (prove)\nusing this:\n  [0..<3] = [0, 1, 2]\n\ngoal (1 subgoal):\n 1. foldl\n     (\\<lambda>F i.\n         let a_n = isolate_variable_sparse p var i\n         in or (fm.Atom\n                 (Less\n                   ((if i mod 2 = 0 then Const 1 else Const (- 1)) * a_n)))\n             (and (fm.Atom (Eq a_n)) F))\n     FalseF [0..<3] =\n    (let a_n = isolate_variable_sparse p var 2\n     in or (fm.Atom (Less (Const 1 * a_n)))\n         (and (fm.Atom (Eq a_n))\n           (let a_n = isolate_variable_sparse p var (Suc 0)\n            in or (fm.Atom (Less (Const (- 1) * a_n)))\n                (and (fm.Atom (Eq a_n))\n                  (let a_n = isolate_variable_sparse p var 0\n                   in or (fm.Atom (Less (Const 1 * a_n)))\n                       (and (fm.Atom (Eq a_n)) FalseF))))))", "by auto"], ["proof (state)\nthis:\n  foldl\n   (\\<lambda>F i.\n       let a_n = isolate_variable_sparse p var i\n       in or (fm.Atom\n               (Less\n                 ((if i mod 2 = 0 then Const 1 else Const (- 1)) * a_n)))\n           (and (fm.Atom (Eq a_n)) F))\n   FalseF [0..<3] =\n  (let a_n = isolate_variable_sparse p var 2\n   in or (fm.Atom (Less (Const 1 * a_n)))\n       (and (fm.Atom (Eq a_n))\n         (let a_n = isolate_variable_sparse p var (Suc 0)\n          in or (fm.Atom (Less (Const (- 1) * a_n)))\n              (and (fm.Atom (Eq a_n))\n                (let a_n = isolate_variable_sparse p var 0\n                 in or (fm.Atom (Less (Const 1 * a_n)))\n                     (and (fm.Atom (Eq a_n)) FalseF))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "have letbind : \"eval\n     (foldl\n       (\\<lambda>F i. let a_n = isolate_variable_sparse p var i\n               in or (fm.Atom (Less ((if i mod 2 = 0 then Const 1 else Const (- 1)) * a_n)))\n                   (and (fm.Atom (Eq a_n)) F))\n       FalseF [0..<3]) (xs'@x#xs) = \n      eval\n     \n(or (fm.Atom (Less ( Const 1 * (isolate_variable_sparse p var 2))))\n                   (and (fm.Atom (Eq (isolate_variable_sparse p var 2)))\n(or (fm.Atom (Less (Const (- 1) * (isolate_variable_sparse p var (Suc 0)))))\n          (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n            (or (fm.Atom (Less (Const 1 * (isolate_variable_sparse p var 0)))) (and (fm.Atom (Eq (isolate_variable_sparse p var 0))) FalseF))))))\n(xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (foldl\n       (\\<lambda>F i.\n           let a_n = isolate_variable_sparse p var i\n           in or (fm.Atom\n                   (Less\n                     ((if i mod 2 = 0 then Const 1 else Const (- 1)) *\n                      a_n)))\n               (and (fm.Atom (Eq a_n)) F))\n       FalseF [0..<3])\n     (xs' @ x # xs) =\n    eval\n     (or (fm.Atom (Less (Const 1 * isolate_variable_sparse p var 2)))\n       (and (fm.Atom (Eq (isolate_variable_sparse p var 2)))\n         (or (fm.Atom\n               (Less (Const (- 1) * isolate_variable_sparse p var (Suc 0))))\n           (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n             (or (fm.Atom\n                   (Less (Const 1 * isolate_variable_sparse p var 0)))\n               (and (fm.Atom (Eq (isolate_variable_sparse p var 0)))\n                 FalseF))))))\n     (xs' @ x # xs)", "apply (simp add:unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (let a_n = isolate_variable_sparse p var 2\n      in or (fm.Atom (Less (Const 1 * a_n)))\n          (and (fm.Atom (Eq a_n))\n            (let a_n = isolate_variable_sparse p var (Suc 0)\n             in or (fm.Atom (Less (Const (- 1) * a_n)))\n                 (and (fm.Atom (Eq a_n))\n                   (let a_n = isolate_variable_sparse p var 0\n                    in or (fm.Atom (Less (Const 1 * a_n)))\n                        (and (fm.Atom (Eq a_n)) FalseF))))))\n     (xs' @ x # xs) =\n    eval\n     (or (fm.Atom (Less (Const 1 * isolate_variable_sparse p var 2)))\n       (and (fm.Atom (Eq (isolate_variable_sparse p var 2)))\n         (or (fm.Atom\n               (Less (Const (- 1) * isolate_variable_sparse p var (Suc 0))))\n           (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n             (or (fm.Atom\n                   (Less (Const 1 * isolate_variable_sparse p var 0)))\n               (and (fm.Atom (Eq (isolate_variable_sparse p var 0)))\n                 FalseF))))))\n     (xs' @ x # xs)", "by metis"], ["proof (state)\nthis:\n  eval\n   (foldl\n     (\\<lambda>F i.\n         let a_n = isolate_variable_sparse p var i\n         in or (fm.Atom\n                 (Less\n                   ((if i mod 2 = 0 then Const 1 else Const (- 1)) * a_n)))\n             (and (fm.Atom (Eq a_n)) F))\n     FalseF [0..<3])\n   (xs' @ x # xs) =\n  eval\n   (or (fm.Atom (Less (Const 1 * isolate_variable_sparse p var 2)))\n     (and (fm.Atom (Eq (isolate_variable_sparse p var 2)))\n       (or (fm.Atom\n             (Less (Const (- 1) * isolate_variable_sparse p var (Suc 0))))\n         (and (fm.Atom (Eq (isolate_variable_sparse p var (Suc 0))))\n           (or (fm.Atom (Less (Const 1 * isolate_variable_sparse p var 0)))\n             (and (fm.Atom (Eq (isolate_variable_sparse p var 0)))\n               FalseF))))))\n   (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (alternateNegInfinity p var) (xs' @ x # xs) =\n                      evalUni (alternateNegInfinity' X) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "using degree2 assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n  convert_poly var p (xs' @ x # xs) = Some X\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' X) x", "unfolding fields"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' (a, b, c)) x", "by (simp add: isovar_greater_degree eval_or eval_and letbind insertion_mult insertion_const)"], ["proof (state)\nthis:\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' X) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' X) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' X) x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun substNegInfinityUni :: \"atomUni \\<Rightarrow> atomUni fmUni\" where\n  \"substNegInfinityUni (EqUni p) = allZero' p \" |\n  \"substNegInfinityUni (LessUni p) = alternateNegInfinity' p\"|\n  \"substNegInfinityUni (LeqUni p) = OrUni (alternateNegInfinity' p) (allZero' p)\"|\n  \"substNegInfinityUni (NeqUni p) = negUni (allZero' p)\""], ["", "lemma convert_substNegInfinity : \n  assumes \"convert_atom var A (xs'@x#xs) = Some(A')\"\n  assumes \"length xs' = var\"\n  shows \"eval (substNegInfinity var A) (xs'@x#xs) = evalUni (substNegInfinityUni A') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "proof(cases A)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "case (Less p)"], ["proof (state)\nthis:\n  A = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "have \"\\<exists>X. convert_poly var p (xs' @ x # xs) = Some X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X", "using assms Less"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  A = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A'; length xs' = var;\n     A = Less p; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X\n 2. \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A'; length xs' = var;\n     A = Less p; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X", "by (simp_all)"], ["proof (state)\nthis:\n  \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "then"], ["proof (chain)\npicking this:\n  \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X", "obtain X where X_def: \"convert_poly var p (xs' @ x # xs) = Some X\""], ["proof (prove)\nusing this:\n  \\<exists>X. convert_poly var p (xs' @ x # xs) = Some X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        convert_poly var p (xs' @ x # xs) = Some X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_poly var p (xs' @ x # xs) = Some X\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "then"], ["proof (chain)\npicking this:\n  convert_poly var p (xs' @ x # xs) = Some X", "have A' : \"A' = LessUni X\""], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some X\n\ngoal (1 subgoal):\n 1. A' = LessUni X", "using assms Less"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some X\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  A = Less p\n\ngoal (1 subgoal):\n 1. A' = LessUni X", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_poly var p (xs' @ x # xs) = Some X;\n     convert_atom var A (xs' @ x # xs) = Some A'; length xs' = var;\n     A = Less p; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> A' = LessUni X\n 2. \\<lbrakk>convert_poly var p (xs' @ x # xs) = Some X;\n     convert_atom var A (xs' @ x # xs) = Some A'; length xs' = var;\n     A = Less p; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> A' = LessUni X", "by (simp_all)"], ["proof (state)\nthis:\n  A' = LessUni X\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "unfolding Less substNegInfinity.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "unfolding convert_alternateNegInfinity[OF X_def assms(2)] A'"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (alternateNegInfinity' X) x =\n    evalUni (substNegInfinityUni (LessUni X)) x", "apply(cases X)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       X = (a, b, c) \\<Longrightarrow>\n       evalUni (alternateNegInfinity' X) x =\n       evalUni (substNegInfinityUni (LessUni X)) x", "by simp"], ["proof (state)\nthis:\n  eval (substNegInfinity var A) (xs' @ x # xs) =\n  evalUni (substNegInfinityUni A') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "case (Eq p)"], ["proof (state)\nthis:\n  A = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "then"], ["proof (chain)\npicking this:\n  A = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  A = Eq p\n\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "using assms convert_allZero"], ["proof (prove)\nusing this:\n  A = Eq p\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?p';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (allZero ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (allZero' ?p') ?x\n\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "by auto"], ["proof (state)\nthis:\n  eval (substNegInfinity var A) (xs' @ x # xs) =\n  evalUni (substNegInfinityUni A') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "case (Leq p)"], ["proof (state)\nthis:\n  A = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "define p' where \"p' = (case convert_poly var p (xs'@x#xs) of Some p' \\<Rightarrow> p')\""], ["proof (state)\nthis:\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "have A'_simp :  \"A' = LeqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = LeqUni p'", "using assms Leq"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  A = Leq p\n\ngoal (1 subgoal):\n 1. A' = LeqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  A = Leq p\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. A' = LeqUni p'", "by auto"], ["proof (state)\nthis:\n  A' = LeqUni p'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "have allZ : \"eval (allZero p var) (xs'@x#xs) = evalUni (allZero' p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using convert_allZero"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?p';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (allZero ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (allZero' ?p') ?x\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using Leq assms p'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?p';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (allZero ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (allZero' ?p') ?x\n  A = Leq p\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "by auto"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "have altNeg : \"eval (alternateNegInfinity p var) (xs'@x#xs) = evalUni (alternateNegInfinity' p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' p') x", "using convert_alternateNegInfinity"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?X;\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (alternateNegInfinity ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (alternateNegInfinity' ?X) ?x\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' p') x", "using Leq assms p'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?X;\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (alternateNegInfinity ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (alternateNegInfinity' ?X) ?x\n  A = Leq p\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. eval (alternateNegInfinity p var) (xs' @ x # xs) =\n    evalUni (alternateNegInfinity' p') x", "by auto"], ["proof (state)\nthis:\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' p') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "unfolding Leq substNegInfinity.simps eval_Or A'_simp substNegInfinityUni.simps evalUni.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval (alternateNegInfinity p var) (xs' @ x # xs) \\<or>\n     eval (allZero p var) (xs' @ x # xs)) =\n    (evalUni (alternateNegInfinity' p') x \\<or> evalUni (allZero' p') x)", "using allZ altNeg"], ["proof (prove)\nusing this:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n  eval (alternateNegInfinity p var) (xs' @ x # xs) =\n  evalUni (alternateNegInfinity' p') x\n\ngoal (1 subgoal):\n 1. (eval (alternateNegInfinity p var) (xs' @ x # xs) \\<or>\n     eval (allZero p var) (xs' @ x # xs)) =\n    (evalUni (alternateNegInfinity' p') x \\<or> evalUni (allZero' p') x)", "by auto"], ["proof (state)\nthis:\n  eval (substNegInfinity var A) (xs' @ x # xs) =\n  evalUni (substNegInfinityUni A') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "case (Neq p)"], ["proof (state)\nthis:\n  A = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var A (xs' @ x # xs) = Some A';\n        length xs' = var; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substNegInfinity var A) (xs' @ x # xs) =\n                         evalUni (substNegInfinityUni A') x", "then"], ["proof (chain)\npicking this:\n  A = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  A = Neq p\n\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "using assms convert_allZero convert_neg"], ["proof (prove)\nusing this:\n  A = Neq p\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?p';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (allZero ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (allZero' ?p') ?x\n  \\<lbrakk>convert_fm ?var ?F (?xs' @ ?x # ?xs) = Some ?F';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg ?F) (?xs' @ ?x # ?xs) =\n                    evalUni (negUni ?F') ?x\n\ngoal (1 subgoal):\n 1. eval (substNegInfinity var A) (xs' @ x # xs) =\n    evalUni (substNegInfinityUni A') x", "by auto"], ["proof (state)\nthis:\n  eval (substNegInfinity var A) (xs' @ x # xs) =\n  evalUni (substNegInfinityUni A') x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_eval_eq:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (EqUni(a,b,c)) x \\<noteq> aEvalUni (EqUni(a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "using assms"], ["proof (prove)\nusing this:\n  aEvalUni (EqUni (a, b, c)) x \\<noteq> aEvalUni (EqUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "by auto"], ["", "lemma change_eval_lt:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (LessUni (a,b,c)) x \\<noteq> aEvalUni (LessUni (a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "let ?p = \"[:c, b, a:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have \"sign ?p x \\<noteq> sign ?p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y", "using assms"], ["proof (prove)\nusing this:\n  aEvalUni (LessUni (a, b, c)) x \\<noteq>\n  aEvalUni (LessUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y", "unfolding sign_def"], ["proof (prove)\nusing this:\n  aEvalUni (LessUni (a, b, c)) x \\<noteq>\n  aEvalUni (LessUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. (if poly [:c, b, a:] x = 0 then 0\n     else if 0 < poly [:c, b, a:] x then 1 else - 1) \\<noteq>\n    (if poly [:c, b, a:] y = 0 then 0\n     else if 0 < poly [:c, b, a:] y then 1 else - 1)", "apply (simp add: distrib_left mult.commute mult.left_commute power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * (x * x) + b * x + c < 0) =\n    (\\<not> a * (y * y) + b * y + c < 0) \\<and>\n    x < y \\<Longrightarrow>\n    (0 < c + (b * x + a * (x * x)) \\<longrightarrow>\n     \\<not> 0 < c + (b * y + a * (y * y))) \\<and>\n    (\\<not> 0 < c + (b * x + a * (x * x)) \\<longrightarrow>\n     (c + (b * x + a * (x * x)) = 0 \\<longrightarrow>\n      \\<not> 0 < c + (b * y + a * (y * y)) \\<longrightarrow>\n      c + (b * y + a * (y * y)) \\<noteq> 0) \\<and>\n     (c + (b * x + a * (x * x)) \\<noteq> 0 \\<longrightarrow>\n      \\<not> 0 < c + (b * y + a * (y * y)) \\<longrightarrow>\n      c + (b * y + a * (y * y)) = 0))", "by linarith"], ["proof (state)\nthis:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y", "have \"(\\<exists>w \\<in> (root_list ?p). x \\<le> w \\<and> w \\<le> y)\""], ["proof (prove)\nusing this:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y", "using changes_sign \n      assms"], ["proof (prove)\nusing this:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y\n  \\<forall>x y.\n     sign ?p x \\<noteq> sign ?p y \\<and> x < y \\<longrightarrow>\n     (\\<exists>c\\<in>root_list ?p. x \\<le> c \\<and> c \\<le> y)\n  aEvalUni (LessUni (a, b, c)) x \\<noteq>\n  aEvalUni (LessUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y", "obtain w where w_prop: \"w \\<in> (root_list ?p) \\<and> x \\<le> w \\<and> w \\<le> y\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> root_list [:c, b, a:] \\<and>\n        x \\<le> w \\<and> w \\<le> y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y", "have \"a*w^2 + b*w + c = 0\""], ["proof (prove)\nusing this:\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "unfolding root_list_def"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly [:c, b, a:] x = 0} \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "using add.commute distrib_right mult.assoc mult.commute power2_eq_square"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly [:c, b, a:] x = 0} \\<and> x \\<le> w \\<and> w \\<le> y\n  ?a + ?b = ?b + ?a\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  ?a * ?b = ?b * ?a\n  ?a\\<^sup>2 = ?a * ?a\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "using quadratic_poly_eval"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly [:c, b, a:] x = 0} \\<and> x \\<le> w \\<and> w \\<le> y\n  ?a + ?b = ?b + ?a\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  ?a * ?b = ?b * ?a\n  ?a\\<^sup>2 = ?a * ?a\n  poly [:?c, ?b, ?a:] ?x = ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "by force"], ["proof (state)\nthis:\n  a * w\\<^sup>2 + b * w + c = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  a * w\\<^sup>2 + b * w + c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a * w\\<^sup>2 + b * w + c = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "using w_prop"], ["proof (prove)\nusing this:\n  a * w\\<^sup>2 + b * w + c = 0\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_change_eval_lt:\n  fixes x y:: \"real\"\n  assumes \"x < y\"\n  assumes \"\\<not>(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"\n  shows \"((aEvalUni (LessUni (a,b,c)) x = aEvalUni (LessUni (a,b,c)) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "using change_eval_lt"], ["proof (prove)\nusing this:\n  aEvalUni (LessUni (?a, ?b, ?c)) ?x \\<noteq>\n  aEvalUni (LessUni (?a, ?b, ?c)) ?y \\<and>\n  ?x < ?y \\<Longrightarrow>\n  \\<exists>w\\<ge>?x. w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n\ngoal (1 subgoal):\n 1. aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  aEvalUni (LessUni (?a, ?b, ?c)) ?x \\<noteq>\n  aEvalUni (LessUni (?a, ?b, ?c)) ?y \\<and>\n  ?x < ?y \\<Longrightarrow>\n  \\<exists>w\\<ge>?x. w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n  x < y\n  \\<not> (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "by blast"], ["", "lemma change_eval_neq:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (NeqUni (a,b,c)) x \\<noteq> aEvalUni (NeqUni (a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "using assms"], ["proof (prove)\nusing this:\n  aEvalUni (NeqUni (a, b, c)) x \\<noteq>\n  aEvalUni (NeqUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "by auto"], ["", "lemma change_eval_leq:\n  fixes x y:: \"real\"\n  assumes \"((aEvalUni (LeqUni (a,b,c)) x \\<noteq> aEvalUni (LeqUni (a,b,c)) y) \\<and> x < y)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "let ?p = \"[:c, b, a:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have \"sign ?p x \\<noteq> sign ?p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y", "using assms"], ["proof (prove)\nusing this:\n  aEvalUni (LeqUni (a, b, c)) x \\<noteq>\n  aEvalUni (LeqUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y", "unfolding sign_def"], ["proof (prove)\nusing this:\n  aEvalUni (LeqUni (a, b, c)) x \\<noteq>\n  aEvalUni (LeqUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. (if poly [:c, b, a:] x = 0 then 0\n     else if 0 < poly [:c, b, a:] x then 1 else - 1) \\<noteq>\n    (if poly [:c, b, a:] y = 0 then 0\n     else if 0 < poly [:c, b, a:] y then 1 else - 1)", "apply (simp add: distrib_left mult.commute mult.left_commute power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * (x * x) + b * x + c \\<le> 0) =\n    (\\<not> a * (y * y) + b * y + c \\<le> 0) \\<and>\n    x < y \\<Longrightarrow>\n    (0 < c + (b * x + a * (x * x)) \\<longrightarrow>\n     \\<not> 0 < c + (b * y + a * (y * y))) \\<and>\n    (\\<not> 0 < c + (b * x + a * (x * x)) \\<longrightarrow>\n     (c + (b * x + a * (x * x)) = 0 \\<longrightarrow>\n      \\<not> 0 < c + (b * y + a * (y * y)) \\<longrightarrow>\n      c + (b * y + a * (y * y)) \\<noteq> 0) \\<and>\n     (c + (b * x + a * (x * x)) \\<noteq> 0 \\<longrightarrow>\n      \\<not> 0 < c + (b * y + a * (y * y)) \\<longrightarrow>\n      c + (b * y + a * (y * y)) = 0))", "by linarith"], ["proof (state)\nthis:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y", "have \"(\\<exists>w \\<in> (root_list ?p). x \\<le> w \\<and> w \\<le> y)\""], ["proof (prove)\nusing this:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y", "using changes_sign \n      assms"], ["proof (prove)\nusing this:\n  sign [:c, b, a:] x \\<noteq> sign [:c, b, a:] y\n  \\<forall>x y.\n     sign ?p x \\<noteq> sign ?p y \\<and> x < y \\<longrightarrow>\n     (\\<exists>c\\<in>root_list ?p. x \\<le> c \\<and> c \\<le> y)\n  aEvalUni (LeqUni (a, b, c)) x \\<noteq>\n  aEvalUni (LeqUni (a, b, c)) y \\<and>\n  x < y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y", "obtain w where w_prop: \"w \\<in> (root_list ?p) \\<and> x \\<le> w \\<and> w \\<le> y\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>root_list [:c, b, a:]. x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> root_list [:c, b, a:] \\<and>\n        x \\<le> w \\<and> w \\<le> y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y", "have \"a*w^2 + b*w + c = 0\""], ["proof (prove)\nusing this:\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "unfolding root_list_def"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly [:c, b, a:] x = 0} \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "using add.commute distrib_right mult.assoc mult.commute power2_eq_square"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly [:c, b, a:] x = 0} \\<and> x \\<le> w \\<and> w \\<le> y\n  ?a + ?b = ?b + ?a\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  ?a * ?b = ?b * ?a\n  ?a\\<^sup>2 = ?a * ?a\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "using quadratic_poly_eval"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly [:c, b, a:] x = 0} \\<and> x \\<le> w \\<and> w \\<le> y\n  ?a + ?b = ?b + ?a\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  ?a * ?b = ?b * ?a\n  ?a\\<^sup>2 = ?a * ?a\n  poly [:?c, ?b, ?a:] ?x = ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. a * w\\<^sup>2 + b * w + c = 0", "by force"], ["proof (state)\nthis:\n  a * w\\<^sup>2 + b * w + c = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "then"], ["proof (chain)\npicking this:\n  a * w\\<^sup>2 + b * w + c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a * w\\<^sup>2 + b * w + c = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "using w_prop"], ["proof (prove)\nusing this:\n  a * w\\<^sup>2 + b * w + c = 0\n  w \\<in> root_list [:c, b, a:] \\<and> x \\<le> w \\<and> w \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_eval:\n  fixes x y:: \"real\"\n  fixes At:: \"atomUni\" \n  assumes xlt: \"x < y\"\n  assumes noteq: \"((aEvalUni At) x \\<noteq> aEvalUni (At) y)\"\n  assumes \"getPoly At = (a, b, c)\"\n  shows \"(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have four_types: \"At = (EqUni (a,b,c)) \\<or> At = (LessUni (a,b,c)) \\<or> At = (LeqUni (a,b,c)) \\<or> At = (NeqUni (a,b,c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At = EqUni (a, b, c) \\<or>\n    At = LessUni (a, b, c) \\<or>\n    At = LeqUni (a, b, c) \\<or> At = NeqUni (a, b, c)", "using getPoly.elims assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>getPoly ?x = ?y;\n   \\<And>p. \\<lbrakk>?x = EqUni p; ?y = p\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>p. \\<lbrakk>?x = LeqUni p; ?y = p\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>p. \\<lbrakk>?x = NeqUni p; ?y = p\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>p.\n      \\<lbrakk>?x = LessUni p; ?y = p\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  getPoly At = (a, b, c)\n\ngoal (1 subgoal):\n 1. At = EqUni (a, b, c) \\<or>\n    At = LessUni (a, b, c) \\<or>\n    At = LeqUni (a, b, c) \\<or> At = NeqUni (a, b, c)", "by force"], ["proof (state)\nthis:\n  At = EqUni (a, b, c) \\<or>\n  At = LessUni (a, b, c) \\<or>\n  At = LeqUni (a, b, c) \\<or> At = NeqUni (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have eq_h: \"At = (EqUni (a,b,c)) \\<longrightarrow> (\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At = EqUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "using assms(1) assms(2) change_eval_eq"], ["proof (prove)\nusing this:\n  x < y\n  aEvalUni At x \\<noteq> aEvalUni At y\n  aEvalUni (EqUni (?a, ?b, ?c)) ?x \\<noteq>\n  aEvalUni (EqUni (?a, ?b, ?c)) ?y \\<and>\n  ?x < ?y \\<Longrightarrow>\n  \\<exists>w\\<ge>?x. w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n\ngoal (1 subgoal):\n 1. At = EqUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "by blast"], ["proof (state)\nthis:\n  At = EqUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have less_h: \"At = (LessUni(a,b,c)) \\<longrightarrow> (\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At = LessUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "using change_eval_lt assms"], ["proof (prove)\nusing this:\n  aEvalUni (LessUni (?a, ?b, ?c)) ?x \\<noteq>\n  aEvalUni (LessUni (?a, ?b, ?c)) ?y \\<and>\n  ?x < ?y \\<Longrightarrow>\n  \\<exists>w\\<ge>?x. w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n  x < y\n  aEvalUni At x \\<noteq> aEvalUni At y\n  getPoly At = (a, b, c)\n\ngoal (1 subgoal):\n 1. At = LessUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "by blast"], ["proof (state)\nthis:\n  At = LessUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have leq_h: \"At = (LeqUni(a,b,c)) \\<longrightarrow> (\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At = LeqUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "using change_eval_leq assms"], ["proof (prove)\nusing this:\n  aEvalUni (LeqUni (?a, ?b, ?c)) ?x \\<noteq>\n  aEvalUni (LeqUni (?a, ?b, ?c)) ?y \\<and>\n  ?x < ?y \\<Longrightarrow>\n  \\<exists>w\\<ge>?x. w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n  x < y\n  aEvalUni At x \\<noteq> aEvalUni At y\n  getPoly At = (a, b, c)\n\ngoal (1 subgoal):\n 1. At = LeqUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "by blast"], ["proof (state)\nthis:\n  At = LeqUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "have neq_h: \"At = (NeqUni(a,b,c)) \\<longrightarrow> (\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At = NeqUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "using change_eval_neq assms"], ["proof (prove)\nusing this:\n  aEvalUni (NeqUni (?a, ?b, ?c)) ?x \\<noteq>\n  aEvalUni (NeqUni (?a, ?b, ?c)) ?y \\<and>\n  ?x < ?y \\<Longrightarrow>\n  \\<exists>w\\<ge>?x. w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n  x < y\n  aEvalUni At x \\<noteq> aEvalUni At y\n  getPoly At = (a, b, c)\n\ngoal (1 subgoal):\n 1. At = NeqUni (a, b, c) \\<longrightarrow>\n    (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)", "by blast"], ["proof (state)\nthis:\n  At = NeqUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "using four_types eq_h less_h leq_h neq_h"], ["proof (prove)\nusing this:\n  At = EqUni (a, b, c) \\<or>\n  At = LessUni (a, b, c) \\<or>\n  At = LeqUni (a, b, c) \\<or> At = NeqUni (a, b, c)\n  At = EqUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n  At = LessUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n  At = LeqUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n  At = NeqUni (a, b, c) \\<longrightarrow>\n  (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_change_eval:\n  fixes x y:: \"real\"\n  assumes \"getPoly At = (a, b, c)\"\n  assumes \"x < y\"\n  assumes \"\\<not>(\\<exists>w. x \\<le> w \\<and> w \\<le> y \\<and> a*w^2 + b*w + c = 0)\"\n  shows  \"((aEvalUni At) x = aEvalUni (At) y \\<and> x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni At x = aEvalUni At y \\<and> x < y", "using change_eval"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; aEvalUni ?At ?x \\<noteq> aEvalUni ?At ?y;\n   getPoly ?At = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w\\<ge>?x.\n                       w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n\ngoal (1 subgoal):\n 1. aEvalUni At x = aEvalUni At y \\<and> x < y", "using assms(1) assms(2) assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; aEvalUni ?At ?x \\<noteq> aEvalUni ?At ?y;\n   getPoly ?At = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w\\<ge>?x.\n                       w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n  getPoly At = (a, b, c)\n  x < y\n  \\<not> (\\<exists>w\\<ge>x. w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\n\ngoal (1 subgoal):\n 1. aEvalUni At x = aEvalUni At y \\<and> x < y", "by blast"], ["", "lemma same_eval'' :\n  assumes \"getPoly At = (a, b, c)\"\n  assumes nonz: \"a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\"\n  shows \"\\<exists>x. \\<forall>y<x. (aEvalUni At y = aEvalUni At x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "let ?p = \"[:c, b, a:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have poly_eval: \"\\<forall>y. poly ?p y = a*y^2 + b*y + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. poly [:c, b, a:] y = a * y\\<^sup>2 + b * y + c", "by (simp add: distrib_left power2_eq_square)"], ["proof (state)\nthis:\n  \\<forall>y. poly [:c, b, a:] y = a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have \"?p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c, b, a:] \\<noteq> 0", "using nonz"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:c, b, a:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  [:c, b, a:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  [:c, b, a:] \\<noteq> 0", "have \"finite {y. poly ?p y = 0}\""], ["proof (prove)\nusing this:\n  [:c, b, a:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {y. poly [:c, b, a:] y = 0}", "using poly_roots_finite"], ["proof (prove)\nusing this:\n  [:c, b, a:] \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite {y. poly [:c, b, a:] y = 0}", "by blast"], ["proof (state)\nthis:\n  finite {y. poly [:c, b, a:] y = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  finite {y. poly [:c, b, a:] y = 0}", "have \"finite {y. c + (a * y\\<^sup>2 + b * y) = 0} \\<Longrightarrow>\n    \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y \\<Longrightarrow>\n    finite {y. a * y\\<^sup>2 + b * y + c = 0}\""], ["proof (prove)\nusing this:\n  finite {y. poly [:c, b, a:] y = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n     \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y\\<rbrakk>\n    \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n     \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y;\n     finite {y. poly [:c, b, a:] y = 0}\\<rbrakk>\n    \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}", "assume a1: \"finite {y. c + (a * y\\<^sup>2 + b * y) = 0}\""], ["proof (state)\nthis:\n  finite {y. c + (a * y\\<^sup>2 + b * y) = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n     \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y;\n     finite {y. poly [:c, b, a:] y = 0}\\<rbrakk>\n    \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}", "have \"\\<forall>x0. c + (a * x0\\<^sup>2 + b * x0) = a * x0\\<^sup>2 + b * x0 + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0. c + (a * x0\\<^sup>2 + b * x0) = a * x0\\<^sup>2 + b * x0 + c", "by simp"], ["proof (state)\nthis:\n  \\<forall>x0. c + (a * x0\\<^sup>2 + b * x0) = a * x0\\<^sup>2 + b * x0 + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n     \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y;\n     finite {y. poly [:c, b, a:] y = 0}\\<rbrakk>\n    \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0. c + (a * x0\\<^sup>2 + b * x0) = a * x0\\<^sup>2 + b * x0 + c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x0. c + (a * x0\\<^sup>2 + b * x0) = a * x0\\<^sup>2 + b * x0 + c\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0}", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>x0. c + (a * x0\\<^sup>2 + b * x0) = a * x0\\<^sup>2 + b * x0 + c\n  finite {y. c + (a * y\\<^sup>2 + b * y) = 0}\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0}", "by presburger"], ["proof (state)\nthis:\n  finite {y. a * y\\<^sup>2 + b * y + c = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n   \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y\\<rbrakk>\n  \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n   \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y\\<rbrakk>\n  \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}", "have finset: \"finite {y. a*y^2 + b*y + c = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n   \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y\\<rbrakk>\n  \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0}", "using poly_eval"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {y. c + (a * y\\<^sup>2 + b * y) = 0};\n   \\<forall>y. y * (b + y * a) = a * y\\<^sup>2 + b * y\\<rbrakk>\n  \\<Longrightarrow> finite {y. a * y\\<^sup>2 + b * y + c = 0}\n  \\<forall>y. poly [:c, b, a:] y = a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0}", "by (metis \\<open>finite {y. poly [:c, b, a:] y = 0}\\<close> poly_roots_set_same)"], ["proof (state)\nthis:\n  finite {y. a * y\\<^sup>2 + b * y + c = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  finite {y. a * y\\<^sup>2 + b * y + c = 0}", "have \"\\<exists>x. (\\<forall>y. a*y^2 + b*y + c = 0 \\<longrightarrow> x < y)\""], ["proof (prove)\nusing this:\n  finite {y. a * y\\<^sup>2 + b * y + c = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0} \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "let ?l = \"sorted_list_of_set {y. a*y^2 + b*y + c = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0} \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "have \"\\<exists>x. x < ?l ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0", "using infzeros nonz"], ["proof (prove)\nusing this:\n  \\<forall>x<?y. ?a * x\\<^sup>2 + ?b * x + ?c = 0 \\<Longrightarrow>\n  ?a = 0 \\<and> ?b = 0 \\<and> ?c = 0\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0} \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0", "obtain x where x_prop: \"x < ?l! 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n            0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0} \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0", "have \"\\<forall> y. List.member ?l y \\<longrightarrow> x < y\""], ["proof (prove)\nusing this:\n  x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n        y \\<longrightarrow>\n       x < y", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "assume \"List.member ?l y\""], ["proof (state)\nthis:\n  List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}) y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}) y", "have \"\\<exists>n. n < length ?l \\<and> ?l ! n = y\""], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}) y\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n       sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n = y", "by (meson in_set_conv_nth in_set_member)"], ["proof (state)\nthis:\n  \\<exists>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n = y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  \\<exists>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n = y", "obtain n where n_prop: \"n < length ?l \\<and> ?l ! n = y\""], ["proof (prove)\nusing this:\n  \\<exists>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n = y\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n < length\n             (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}) \\<and>\n        sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n =\n        y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}) \\<and>\n  sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n = y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "have h: \"\\<forall>n < length ?l. ?l ! n \\<ge> ?l !0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length\n                (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n       sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n       \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n", "using sorted_iff_nth_mono"], ["proof (prove)\nusing this:\n  sorted ?xs =\n  (\\<forall>i j.\n      i \\<le> j \\<longrightarrow>\n      j < length ?xs \\<longrightarrow> ?xs ! i \\<le> ?xs ! j)\n\ngoal (1 subgoal):\n 1. \\<forall>n<length\n                (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n       sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n       \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n", "using sorted_sorted_list_of_set"], ["proof (prove)\nusing this:\n  sorted ?xs =\n  (\\<forall>i j.\n      i \\<le> j \\<longrightarrow>\n      j < length ?xs \\<longrightarrow> ?xs ! i \\<le> ?xs ! j)\n  sorted (sorted_list_of_set ?A)\n\ngoal (1 subgoal):\n 1. \\<forall>n<length\n                (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n       sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n       \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n", "by blast"], ["proof (state)\nthis:\n  \\<forall>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n     \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  \\<forall>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n     \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n", "have h: \"y \\<ge> ?l ! 0\""], ["proof (prove)\nusing this:\n  \\<forall>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n     \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0 \\<le> y", "using n_prop"], ["proof (prove)\nusing this:\n  \\<forall>n<length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}).\n     sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n     \\<le> sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n\n  n < length (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0}) \\<and>\n  sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! n = y\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0 \\<le> y", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} !\n                    0;\n        List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n         y\\<rbrakk>\n       \\<Longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0 \\<le> y", "show \"x < y\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0 \\<le> y\n\ngoal (1 subgoal):\n 1. x < y", "using x_prop"], ["proof (prove)\nusing this:\n  sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0 \\<le> y\n  x < sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0} ! 0\n\ngoal (1 subgoal):\n 1. x < y", "by auto"], ["proof (state)\nthis:\n  x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y.\n     List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n      y \\<longrightarrow>\n     x < y\n\ngoal (1 subgoal):\n 1. finite {y. a * y\\<^sup>2 + b * y + c = 0} \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "then"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n      y \\<longrightarrow>\n     x < y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n      y \\<longrightarrow>\n     x < y\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "using finset set_sorted_list_of_set in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     List.member (sorted_list_of_set {y. a * y\\<^sup>2 + b * y + c = 0})\n      y \\<longrightarrow>\n     x < y\n  finite {y. a * y\\<^sup>2 + b * y + c = 0}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "by (metis (mono_tags, lifting) mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "obtain x where x_prop: \"(\\<forall>y. a*y^2 + b*y + c = 0 \\<longrightarrow> x < y)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<forall>y.\n           a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow>\n           x < y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y", "have same_as: \"\\<forall>y<x. (aEvalUni At y = aEvalUni At x)\""], ["proof (prove)\nusing this:\n  \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n\ngoal (1 subgoal):\n 1. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "using no_change_eval change_eval assms"], ["proof (prove)\nusing this:\n  \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n  \\<lbrakk>getPoly ?At = (?a, ?b, ?c); ?x < ?y;\n   \\<not> (\\<exists>w\\<ge>?x.\n              w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0)\\<rbrakk>\n  \\<Longrightarrow> aEvalUni ?At ?x = aEvalUni ?At ?y \\<and> ?x < ?y\n  \\<lbrakk>?x < ?y; aEvalUni ?At ?x \\<noteq> aEvalUni ?At ?y;\n   getPoly ?At = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w\\<ge>?x.\n                       w \\<le> ?y \\<and> ?a * w\\<^sup>2 + ?b * w + ?c = 0\n  getPoly At = (a, b, c)\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f1: \"\\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f2: \"(0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f3: \"v0_0 + - 1 * x = - 1 * x + v0_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0_0 + - 1 * x = - 1 * x + v0_0", "by auto"], ["proof (state)\nthis:\n  v0_0 + - 1 * x = - 1 * x + v0_0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f4: \"\\<forall>x0 x1 x2 x3. (x3::real) * x0\\<^sup>2 + x2 * x0 + x1 = x1 + x3 * x0\\<^sup>2 + x2 * x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x1 x2 x3.\n       x3 * x0\\<^sup>2 + x2 * x0 + x1 = x1 + x3 * x0\\<^sup>2 + x2 * x0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2 x3.\n     x3 * x0\\<^sup>2 + x2 * x0 + x1 = x1 + x3 * x0\\<^sup>2 + x2 * x0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f5: \"\\<forall>x3 x4 x5. (aEvalUni x3 x5 \\<noteq> aEvalUni x3 x4) = ((\\<not> aEvalUni x3 x5) = aEvalUni x3 x4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x3 x4 x5.\n       (aEvalUni x3 x5 \\<noteq> aEvalUni x3 x4) =\n       ((\\<not> aEvalUni x3 x5) = aEvalUni x3 x4)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x3 x4 x5.\n     (aEvalUni x3 x5 \\<noteq> aEvalUni x3 x4) =\n     ((\\<not> aEvalUni x3 x5) = aEvalUni x3 x4)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f6: \"\\<forall>x0 x1 x2 x3 x4 x5. (x5 < x4 \\<and> (\\<not> aEvalUni x3 x5) = aEvalUni x3 x4 \\<and> getPoly x3 = (x2, x1, x0) \\<longrightarrow> (\\<exists>v6\\<ge>x5. v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0)) = ((\\<not> x5 < x4 \\<or> (\\<not> aEvalUni x3 x5) \\<noteq> aEvalUni x3 x4 \\<or> getPoly x3 \\<noteq> (x2, x1, x0)) \\<or> (\\<exists>v6\\<ge>x5. v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x1 x2 x3 x4 x5.\n       (x5 < x4 \\<and>\n        (\\<not> aEvalUni x3 x5) = aEvalUni x3 x4 \\<and>\n        getPoly x3 = (x2, x1, x0) \\<longrightarrow>\n        (\\<exists>v6\\<ge>x5.\n            v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0)) =\n       ((\\<not> x5 < x4 \\<or>\n         (\\<not> aEvalUni x3 x5) \\<noteq> aEvalUni x3 x4 \\<or>\n         getPoly x3 \\<noteq> (x2, x1, x0)) \\<or>\n        (\\<exists>v6\\<ge>x5.\n            v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2 x3 x4 x5.\n     (x5 < x4 \\<and>\n      (\\<not> aEvalUni x3 x5) = aEvalUni x3 x4 \\<and>\n      getPoly x3 = (x2, x1, x0) \\<longrightarrow>\n      (\\<exists>v6\\<ge>x5.\n          v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0)) =\n     ((\\<not> x5 < x4 \\<or>\n       (\\<not> aEvalUni x3 x5) \\<noteq> aEvalUni x3 x4 \\<or>\n       getPoly x3 \\<noteq> (x2, x1, x0)) \\<or>\n      (\\<exists>v6\\<ge>x5.\n          v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f7: \"\\<forall>x0 x5. ((x0::real) \\<le> x5) = (x0 + - 1 * x5 \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x5. (x0 \\<le> x5) = (x0 + - 1 * x5 \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x0 x5. (x0 \\<le> x5) = (x0 + - 1 * x5 \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f8: \"\\<forall>x0 x6. ((x6::real) \\<le> x0) = (0 \\<le> x0 + - 1 * x6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x6. (x6 \\<le> x0) = (0 \\<le> x0 + - 1 * x6)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x0 x6. (x6 \\<le> x0) = (0 \\<le> x0 + - 1 * x6)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have \"\\<forall>x4 x5. ((x5::real) < x4) = (\\<not> x4 + - 1 * x5 \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x4 x5. (x5 < x4) = (\\<not> x4 + - 1 * x5 \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x4 x5. (x5 < x4) = (\\<not> x4 + - 1 * x5 \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x4 x5. (x5 < x4) = (\\<not> x4 + - 1 * x5 \\<le> 0)", "have \"(\\<forall>r ra a rb rc rd. r < ra \\<and> aEvalUni a r \\<noteq> aEvalUni a ra \\<and> getPoly a = (rb, rc, rd) \\<longrightarrow> (\\<exists>re\\<ge>r. re \\<le> ra \\<and> rb * re\\<^sup>2 + rc * re + rd = 0)) = (\\<forall>r ra a rb rc rd. (ra + - 1 * r \\<le> 0 \\<or> (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or> getPoly a \\<noteq> (rb, rc, rd)) \\<or> (\\<exists>re. 0 \\<le> re + - 1 * r \\<and> re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0))\""], ["proof (prove)\nusing this:\n  \\<forall>x4 x5. (x5 < x4) = (\\<not> x4 + - 1 * x5 \\<le> 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>r ra a rb rc rd.\n        r < ra \\<and>\n        aEvalUni a r \\<noteq> aEvalUni a ra \\<and>\n        getPoly a = (rb, rc, rd) \\<longrightarrow>\n        (\\<exists>re\\<ge>r.\n            re \\<le> ra \\<and> rb * re\\<^sup>2 + rc * re + rd = 0)) =\n    (\\<forall>r ra a rb rc rd.\n        (ra + - 1 * r \\<le> 0 \\<or>\n         (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n         getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n        (\\<exists>re.\n            0 \\<le> re + - 1 * r \\<and>\n            re + - 1 * ra \\<le> 0 \\<and>\n            rd + rb * re\\<^sup>2 + rc * re = 0))", "using f8 f7 f6 f5 f4"], ["proof (prove)\nusing this:\n  \\<forall>x4 x5. (x5 < x4) = (\\<not> x4 + - 1 * x5 \\<le> 0)\n  \\<forall>x0 x6. (x6 \\<le> x0) = (0 \\<le> x0 + - 1 * x6)\n  \\<forall>x0 x5. (x0 \\<le> x5) = (x0 + - 1 * x5 \\<le> 0)\n  \\<forall>x0 x1 x2 x3 x4 x5.\n     (x5 < x4 \\<and>\n      (\\<not> aEvalUni x3 x5) = aEvalUni x3 x4 \\<and>\n      getPoly x3 = (x2, x1, x0) \\<longrightarrow>\n      (\\<exists>v6\\<ge>x5.\n          v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0)) =\n     ((\\<not> x5 < x4 \\<or>\n       (\\<not> aEvalUni x3 x5) \\<noteq> aEvalUni x3 x4 \\<or>\n       getPoly x3 \\<noteq> (x2, x1, x0)) \\<or>\n      (\\<exists>v6\\<ge>x5.\n          v6 \\<le> x4 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0))\n  \\<forall>x3 x4 x5.\n     (aEvalUni x3 x5 \\<noteq> aEvalUni x3 x4) =\n     ((\\<not> aEvalUni x3 x5) = aEvalUni x3 x4)\n  \\<forall>x0 x1 x2 x3.\n     x3 * x0\\<^sup>2 + x2 * x0 + x1 = x1 + x3 * x0\\<^sup>2 + x2 * x0\n\ngoal (1 subgoal):\n 1. (\\<forall>r ra a rb rc rd.\n        r < ra \\<and>\n        aEvalUni a r \\<noteq> aEvalUni a ra \\<and>\n        getPoly a = (rb, rc, rd) \\<longrightarrow>\n        (\\<exists>re\\<ge>r.\n            re \\<le> ra \\<and> rb * re\\<^sup>2 + rc * re + rd = 0)) =\n    (\\<forall>r ra a rb rc rd.\n        (ra + - 1 * r \\<le> 0 \\<or>\n         (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n         getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n        (\\<exists>re.\n            0 \\<le> re + - 1 * r \\<and>\n            re + - 1 * ra \\<le> 0 \\<and>\n            rd + rb * re\\<^sup>2 + rc * re = 0))", "by presburger"], ["proof (state)\nthis:\n  (\\<forall>r ra a rb rc rd.\n      r < ra \\<and>\n      aEvalUni a r \\<noteq> aEvalUni a ra \\<and>\n      getPoly a = (rb, rc, rd) \\<longrightarrow>\n      (\\<exists>re\\<ge>r.\n          re \\<le> ra \\<and> rb * re\\<^sup>2 + rc * re + rd = 0)) =\n  (\\<forall>r ra a rb rc rd.\n      (ra + - 1 * r \\<le> 0 \\<or>\n       (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n       getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n      (\\<exists>re.\n          0 \\<le> re + - 1 * r \\<and>\n          re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  (\\<forall>r ra a rb rc rd.\n      r < ra \\<and>\n      aEvalUni a r \\<noteq> aEvalUni a ra \\<and>\n      getPoly a = (rb, rc, rd) \\<longrightarrow>\n      (\\<exists>re\\<ge>r.\n          re \\<le> ra \\<and> rb * re\\<^sup>2 + rc * re + rd = 0)) =\n  (\\<forall>r ra a rb rc rd.\n      (ra + - 1 * r \\<le> 0 \\<or>\n       (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n       getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n      (\\<exists>re.\n          0 \\<le> re + - 1 * r \\<and>\n          re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0))", "have f9: \"\\<forall>r ra a rb rc rd. (ra + - 1 * r \\<le> 0 \\<or> (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or> getPoly a \\<noteq> (rb, rc, rd)) \\<or> (\\<exists>re. 0 \\<le> re + - 1 * r \\<and> re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0)\""], ["proof (prove)\nusing this:\n  (\\<forall>r ra a rb rc rd.\n      r < ra \\<and>\n      aEvalUni a r \\<noteq> aEvalUni a ra \\<and>\n      getPoly a = (rb, rc, rd) \\<longrightarrow>\n      (\\<exists>re\\<ge>r.\n          re \\<le> ra \\<and> rb * re\\<^sup>2 + rc * re + rd = 0)) =\n  (\\<forall>r ra a rb rc rd.\n      (ra + - 1 * r \\<le> 0 \\<or>\n       (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n       getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n      (\\<exists>re.\n          0 \\<le> re + - 1 * r \\<and>\n          re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0))\n\ngoal (1 subgoal):\n 1. \\<forall>r ra a rb rc rd.\n       (ra + - 1 * r \\<le> 0 \\<or>\n        (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n        getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n       (\\<exists>re.\n           0 \\<le> re + - 1 * r \\<and>\n           re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0)", "by (meson change_eval)"], ["proof (state)\nthis:\n  \\<forall>r ra a rb rc rd.\n     (ra + - 1 * r \\<le> 0 \\<or>\n      (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n      getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n     (\\<exists>re.\n         0 \\<le> re + - 1 * r \\<and>\n         re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "obtain rr :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n      \"\\<forall>x0 x1 x2 x4 x5. (\\<exists>v6. 0 \\<le> v6 + - 1 * x5 \\<and> v6 + - 1 * x4 \\<le> 0 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0) = (0 \\<le> rr x0 x1 x2 x4 x5 + - 1 * x5 \\<and> rr x0 x1 x2 x4 x5 + - 1 * x4 \\<le> 0 \\<and> x0 + x2 * (rr x0 x1 x2 x4 x5)\\<^sup>2 + x1 * rr x0 x1 x2 x4 x5 = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        \\<forall>x0 x1 x2 x4 x5.\n           (\\<exists>v6.\n               0 \\<le> v6 + - 1 * x5 \\<and>\n               v6 + - 1 * x4 \\<le> 0 \\<and>\n               x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0) =\n           (0 \\<le> rr x0 x1 x2 x4 x5 + - 1 * x5 \\<and>\n            rr x0 x1 x2 x4 x5 + - 1 * x4 \\<le> 0 \\<and>\n            x0 + x2 * (rr x0 x1 x2 x4 x5)\\<^sup>2 + x1 * rr x0 x1 x2 x4 x5 =\n            0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2 x4 x5.\n     (\\<exists>v6.\n         0 \\<le> v6 + - 1 * x5 \\<and>\n         v6 + - 1 * x4 \\<le> 0 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0) =\n     (0 \\<le> rr x0 x1 x2 x4 x5 + - 1 * x5 \\<and>\n      rr x0 x1 x2 x4 x5 + - 1 * x4 \\<le> 0 \\<and>\n      x0 + x2 * (rr x0 x1 x2 x4 x5)\\<^sup>2 + x1 * rr x0 x1 x2 x4 x5 = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2 x4 x5.\n     (\\<exists>v6.\n         0 \\<le> v6 + - 1 * x5 \\<and>\n         v6 + - 1 * x4 \\<le> 0 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0) =\n     (0 \\<le> rr x0 x1 x2 x4 x5 + - 1 * x5 \\<and>\n      rr x0 x1 x2 x4 x5 + - 1 * x4 \\<le> 0 \\<and>\n      x0 + x2 * (rr x0 x1 x2 x4 x5)\\<^sup>2 + x1 * rr x0 x1 x2 x4 x5 = 0)", "have f10: \"\\<forall>r ra a rb rc rd. ra + - 1 * r \\<le> 0 \\<or> aEvalUni a r = aEvalUni a ra \\<or> getPoly a \\<noteq> (rb, rc, rd) \\<or> r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and> 0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and> rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2 x4 x5.\n     (\\<exists>v6.\n         0 \\<le> v6 + - 1 * x5 \\<and>\n         v6 + - 1 * x4 \\<le> 0 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0) =\n     (0 \\<le> rr x0 x1 x2 x4 x5 + - 1 * x5 \\<and>\n      rr x0 x1 x2 x4 x5 + - 1 * x4 \\<le> 0 \\<and>\n      x0 + x2 * (rr x0 x1 x2 x4 x5)\\<^sup>2 + x1 * rr x0 x1 x2 x4 x5 = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>r ra a rb rc rd.\n       ra + - 1 * r \\<le> 0 \\<or>\n       aEvalUni a r = aEvalUni a ra \\<or>\n       getPoly a \\<noteq> (rb, rc, rd) \\<or>\n       r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n       0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n       rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0", "using f9"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2 x4 x5.\n     (\\<exists>v6.\n         0 \\<le> v6 + - 1 * x5 \\<and>\n         v6 + - 1 * x4 \\<le> 0 \\<and> x0 + x2 * v6\\<^sup>2 + x1 * v6 = 0) =\n     (0 \\<le> rr x0 x1 x2 x4 x5 + - 1 * x5 \\<and>\n      rr x0 x1 x2 x4 x5 + - 1 * x4 \\<le> 0 \\<and>\n      x0 + x2 * (rr x0 x1 x2 x4 x5)\\<^sup>2 + x1 * rr x0 x1 x2 x4 x5 = 0)\n  \\<forall>r ra a rb rc rd.\n     (ra + - 1 * r \\<le> 0 \\<or>\n      (\\<not> aEvalUni a r) \\<noteq> aEvalUni a ra \\<or>\n      getPoly a \\<noteq> (rb, rc, rd)) \\<or>\n     (\\<exists>re.\n         0 \\<le> re + - 1 * r \\<and>\n         re + - 1 * ra \\<le> 0 \\<and> rd + rb * re\\<^sup>2 + rc * re = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>r ra a rb rc rd.\n       ra + - 1 * r \\<le> 0 \\<or>\n       aEvalUni a r = aEvalUni a ra \\<or>\n       getPoly a \\<noteq> (rb, rc, rd) \\<or>\n       r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n       0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n       rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>r ra a rb rc rd.\n     ra + - 1 * r \\<le> 0 \\<or>\n     aEvalUni a r = aEvalUni a ra \\<or>\n     getPoly a \\<noteq> (rb, rc, rd) \\<or>\n     r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n     0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n     rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f11: \"(rr c b a x v0_0 + - 1 * x \\<le> 0) = (0 \\<le> x + - 1 * rr c b a x v0_0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rr c b a x v0_0 + - 1 * x \\<le> 0) =\n    (0 \\<le> x + - 1 * rr c b a x v0_0)", "by force"], ["proof (state)\nthis:\n  (rr c b a x v0_0 + - 1 * x \\<le> 0) = (0 \\<le> x + - 1 * rr c b a x v0_0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have \"\\<forall>x0. (x < x0) = (\\<not> x0 + - 1 * x \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0. (x < x0) = (\\<not> x0 + - 1 * x \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x0. (x < x0) = (\\<not> x0 + - 1 * x \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0. (x < x0) = (\\<not> x0 + - 1 * x \\<le> 0)", "have f12: \"\\<forall>r. c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or> \\<not> r + - 1 * x \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x0. (x < x0) = (\\<not> x0 + - 1 * x \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or> \\<not> r + - 1 * x \\<le> 0", "using x_prop"], ["proof (prove)\nusing this:\n  \\<forall>x0. (x < x0) = (\\<not> x0 + - 1 * x \\<le> 0)\n  \\<forall>y. a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or> \\<not> r + - 1 * x \\<le> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>r.\n     c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or> \\<not> r + - 1 * x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "obtain rra :: real where\n      \"(\\<exists>v0. \\<not> 0 \\<le> v0 + - 1 * x \\<and> aEvalUni At v0 \\<noteq> aEvalUni At x) = (\\<not> 0 \\<le> rra + - 1 * x \\<and> aEvalUni At rra \\<noteq> aEvalUni At x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rra.\n        (\\<exists>v0.\n            \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n            aEvalUni At v0 \\<noteq> aEvalUni At x) =\n        (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n         aEvalUni At rra \\<noteq> aEvalUni At x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n   aEvalUni At rra \\<noteq> aEvalUni At x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y.\n                a * y\\<^sup>2 + b * y + c = 0 \\<longrightarrow> x < y;\n     \\<And>At a b c x y.\n        \\<lbrakk>getPoly At = (a, b, c); x < y;\n         \\<not> (\\<exists>w\\<ge>x.\n                    w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0)\\<rbrakk>\n        \\<Longrightarrow> aEvalUni At x = aEvalUni At y \\<and> x < y;\n     \\<And>x y At a b c.\n        \\<lbrakk>x < y; aEvalUni At x \\<noteq> aEvalUni At y;\n         getPoly At = (a, b, c)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>w\\<ge>x.\n                             w \\<le> y \\<and> a * w\\<^sup>2 + b * w + c = 0;\n     getPoly At = (a, b, c);\n     a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n   aEvalUni At rra \\<noteq> aEvalUni At x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n   aEvalUni At rra \\<noteq> aEvalUni At x)\n\ngoal (1 subgoal):\n 1. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "using f12 f11 f10 f3 f2 f1"], ["proof (prove)\nusing this:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n   aEvalUni At rra \\<noteq> aEvalUni At x)\n  \\<forall>r.\n     c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or> \\<not> r + - 1 * x \\<le> 0\n  (rr c b a x v0_0 + - 1 * x \\<le> 0) = (0 \\<le> x + - 1 * rr c b a x v0_0)\n  \\<forall>r ra a rb rc rd.\n     ra + - 1 * r \\<le> 0 \\<or>\n     aEvalUni a r = aEvalUni a ra \\<or>\n     getPoly a \\<noteq> (rb, rc, rd) \\<or>\n     r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n     0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n     rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0\n  v0_0 + - 1 * x = - 1 * x + v0_0\n  (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0)\n  \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\n\ngoal (1 subgoal):\n 1. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>v0.\n                 \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n                 aEvalUni At v0 \\<noteq> aEvalUni At x) =\n             (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n              aEvalUni At rra \\<noteq> aEvalUni At x);\n     \\<forall>r.\n        c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or>\n        \\<not> r + - 1 * x \\<le> 0;\n     (rr c b a x v0_0 + - 1 * x \\<le> 0) =\n     (0 \\<le> x + - 1 * rr c b a x v0_0);\n     \\<forall>r ra a rb rc rd.\n        ra + - 1 * r \\<le> 0 \\<or>\n        aEvalUni a r = aEvalUni a ra \\<or>\n        getPoly a \\<noteq> (rb, rc, rd) \\<or>\n        r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n        0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n        rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0;\n     v0_0 + - 1 * x = - 1 * x + v0_0;\n     (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0);\n     \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f1: \"\\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>v0.\n                 \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n                 aEvalUni At v0 \\<noteq> aEvalUni At x) =\n             (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n              aEvalUni At rra \\<noteq> aEvalUni At x);\n     \\<forall>r.\n        c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or>\n        \\<not> r + - 1 * x \\<le> 0;\n     (rr c b a x v0_0 + - 1 * x \\<le> 0) =\n     (0 \\<le> x + - 1 * rr c b a x v0_0);\n     \\<forall>r ra a rb rc rd.\n        ra + - 1 * r \\<le> 0 \\<or>\n        aEvalUni a r = aEvalUni a ra \\<or>\n        getPoly a \\<noteq> (rb, rc, rd) \\<or>\n        r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n        0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n        rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0;\n     v0_0 + - 1 * x = - 1 * x + v0_0;\n     (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0);\n     \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f2: \"(0 \\<le> v0_0a + - 1 * x) = (x + - 1 * v0_0a \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> v0_0a + - 1 * x) = (x + - 1 * v0_0a \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  (0 \\<le> v0_0a + - 1 * x) = (x + - 1 * v0_0a \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>v0.\n                 \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n                 aEvalUni At v0 \\<noteq> aEvalUni At x) =\n             (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n              aEvalUni At rra \\<noteq> aEvalUni At x);\n     \\<forall>r.\n        c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or>\n        \\<not> r + - 1 * x \\<le> 0;\n     (rr c b a x v0_0 + - 1 * x \\<le> 0) =\n     (0 \\<le> x + - 1 * rr c b a x v0_0);\n     \\<forall>r ra a rb rc rd.\n        ra + - 1 * r \\<le> 0 \\<or>\n        aEvalUni a r = aEvalUni a ra \\<or>\n        getPoly a \\<noteq> (rb, rc, rd) \\<or>\n        r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n        0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n        rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0;\n     v0_0 + - 1 * x = - 1 * x + v0_0;\n     (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0);\n     \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "have f3: \"(rr c b a x v0_0a + - 1 * x \\<le> 0) = (0 \\<le> x + - 1 * rr c b a x v0_0a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rr c b a x v0_0a + - 1 * x \\<le> 0) =\n    (0 \\<le> x + - 1 * rr c b a x v0_0a)", "by auto"], ["proof (state)\nthis:\n  (rr c b a x v0_0a + - 1 * x \\<le> 0) =\n  (0 \\<le> x + - 1 * rr c b a x v0_0a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>v0.\n                 \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n                 aEvalUni At v0 \\<noteq> aEvalUni At x) =\n             (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n              aEvalUni At rra \\<noteq> aEvalUni At x);\n     \\<forall>r.\n        c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or>\n        \\<not> r + - 1 * x \\<le> 0;\n     (rr c b a x v0_0 + - 1 * x \\<le> 0) =\n     (0 \\<le> x + - 1 * rr c b a x v0_0);\n     \\<forall>r ra a rb rc rd.\n        ra + - 1 * r \\<le> 0 \\<or>\n        aEvalUni a r = aEvalUni a ra \\<or>\n        getPoly a \\<noteq> (rb, rc, rd) \\<or>\n        r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n        0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n        rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0;\n     v0_0 + - 1 * x = - 1 * x + v0_0;\n     (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0);\n     \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "obtain rrb :: real where\n        \"(\\<exists>v0. \\<not> 0 \\<le> v0 + - 1 * x \\<and> aEvalUni At v0 \\<noteq> aEvalUni At x) = (\\<not> 0 \\<le> rrb + - 1 * x \\<and> aEvalUni At rrb \\<noteq> aEvalUni At x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rrb.\n        (\\<exists>v0.\n            \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n            aEvalUni At v0 \\<noteq> aEvalUni At x) =\n        (\\<not> 0 \\<le> rrb + - 1 * x \\<and>\n         aEvalUni At rrb \\<noteq> aEvalUni At x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rrb + - 1 * x \\<and>\n   aEvalUni At rrb \\<noteq> aEvalUni At x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>v0.\n                 \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n                 aEvalUni At v0 \\<noteq> aEvalUni At x) =\n             (\\<not> 0 \\<le> rra + - 1 * x \\<and>\n              aEvalUni At rra \\<noteq> aEvalUni At x);\n     \\<forall>r.\n        c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or>\n        \\<not> r + - 1 * x \\<le> 0;\n     (rr c b a x v0_0 + - 1 * x \\<le> 0) =\n     (0 \\<le> x + - 1 * rr c b a x v0_0);\n     \\<forall>r ra a rb rc rd.\n        ra + - 1 * r \\<le> 0 \\<or>\n        aEvalUni a r = aEvalUni a ra \\<or>\n        getPoly a \\<noteq> (rb, rc, rd) \\<or>\n        r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n        0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n        rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0;\n     v0_0 + - 1 * x = - 1 * x + v0_0;\n     (0 \\<le> - 1 * x + v0_0) = (x + - 1 * v0_0 \\<le> 0);\n     \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rrb + - 1 * x \\<and>\n   aEvalUni At rrb \\<noteq> aEvalUni At x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rrb + - 1 * x \\<and>\n   aEvalUni At rrb \\<noteq> aEvalUni At x)\n\ngoal (1 subgoal):\n 1. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "using f3 f2 f1 assms(1) f10 f12"], ["proof (prove)\nusing this:\n  (\\<exists>v0.\n      \\<not> 0 \\<le> v0 + - 1 * x \\<and>\n      aEvalUni At v0 \\<noteq> aEvalUni At x) =\n  (\\<not> 0 \\<le> rrb + - 1 * x \\<and>\n   aEvalUni At rrb \\<noteq> aEvalUni At x)\n  (rr c b a x v0_0a + - 1 * x \\<le> 0) =\n  (0 \\<le> x + - 1 * rr c b a x v0_0a)\n  (0 \\<le> v0_0a + - 1 * x) = (x + - 1 * v0_0a \\<le> 0)\n  \\<forall>x0. (x0 < x) = (\\<not> 0 \\<le> x0 + - 1 * x)\n  getPoly At = (a, b, c)\n  \\<forall>r ra a rb rc rd.\n     ra + - 1 * r \\<le> 0 \\<or>\n     aEvalUni a r = aEvalUni a ra \\<or>\n     getPoly a \\<noteq> (rb, rc, rd) \\<or>\n     r + - 1 * rr rd rc rb ra r \\<le> 0 \\<and>\n     0 \\<le> ra + - 1 * rr rd rc rb ra r \\<and>\n     rd + rb * (rr rd rc rb ra r)\\<^sup>2 + rc * rr rd rc rb ra r = 0\n  \\<forall>r.\n     c + a * r\\<^sup>2 + b * r \\<noteq> 0 \\<or> \\<not> r + - 1 * x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "by smt"], ["proof (state)\nthis:\n  \\<forall>y<x. aEvalUni At y = aEvalUni At x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<x. aEvalUni At y = aEvalUni At x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<x. aEvalUni At y = aEvalUni At x\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<x. aEvalUni At y = aEvalUni At x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y<x. aEvalUni At y = aEvalUni At x\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. aEvalUni At y = aEvalUni At x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inequality_case : \"(\\<exists>(x::real). \\<forall>(y::real)<x. (a::real) * y\\<^sup>2 + (b::real) * y + (c::real) < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "let ?At = \"(LessUni (a, b, c))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "have firsth : \"\\<And>x. (\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> a\\<le>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "assume lt: \"\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\""], ["proof (state)\nthis:\n  \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "have \"\\<exists>w. \\<forall>y < w. y^2 > (-b/a)*y - c/a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - b / a * y - c / a < y\\<^sup>2", "using ysq_dom_y_plus_coeff[where b = \"-b/a\", where c = \"-c/a\"]"], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - b / a * y - c / a < y\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>y<w. - b / a * y - c / a < y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>y<w. - b / a * y - c / a < y\\<^sup>2", "have gtdomhelp: \"a > 0 \\<Longrightarrow> \\<exists>w. \\<forall>y < w. a*y^2 > a*((-b/a)*y - c/a)\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. - b / a * y - c / a < y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    \\<exists>w. \\<forall>y<w. a * (- b / a * y - c / a) < a * y\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 < a \\<Longrightarrow>\n  \\<exists>w. \\<forall>y<w. a * (- b / a * y - c / a) < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "have \"\\<forall>y. (a > 0 \\<longrightarrow> a*((-b/a)*y - c/a) = -b*y - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       0 < a \\<longrightarrow> a * (- b / a * y - c / a) = - b * y - c", "by (simp add: right_diff_distrib')"], ["proof (state)\nthis:\n  \\<forall>y.\n     0 < a \\<longrightarrow> a * (- b / a * y - c / a) = - b * y - c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     0 < a \\<longrightarrow> a * (- b / a * y - c / a) = - b * y - c", "have gtdom: \"a > 0 \\<Longrightarrow> \\<exists>w.\\<forall>y < w. a*y^2 > -b*y - c\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     0 < a \\<longrightarrow> a * (- b / a * y - c / a) = - b * y - c\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2", "using gtdomhelp"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     0 < a \\<longrightarrow> a * (- b / a * y - c / a) = - b * y - c\n  0 < a \\<Longrightarrow>\n  \\<exists>w. \\<forall>y<w. a * (- b / a * y - c / a) < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow>\n    \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 < a \\<Longrightarrow>\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "then"], ["proof (chain)\npicking this:\n  0 < a \\<Longrightarrow>\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2", "have \" a > 0 \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  0 < a \\<Longrightarrow>\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < a", "have \"\\<exists>w.\\<forall>y < w. a*y^2 > -b*y - c\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2", "using gtdom"], ["proof (prove)\nusing this:\n  0 < a\n  0 < a \\<Longrightarrow>\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2", "obtain w where w_prop: \"\\<forall>y < w. a*y^2 + b*y + c > 0\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>y<w. 0 < a * y\\<^sup>2 + b * y + c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y<w. 0 < a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "let ?mn = \"min w x - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "have gtz: \"a*?mn^2 + b*?mn + c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c", "using w_prop"], ["proof (prove)\nusing this:\n  \\<forall>y<w. 0 < a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. 0 < a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c", "by auto"], ["proof (state)\nthis:\n  0 < a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "have ltz: \"a*?mn^2 + b*?mn + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0", "using lt"], ["proof (prove)\nusing this:\n  \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal (1 subgoal):\n 1. a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0", "by auto"], ["proof (state)\nthis:\n  a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a;\n     0 < a \\<Longrightarrow>\n     \\<exists>w. \\<forall>y<w. - b * y - c < a * y\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0", "show \"False\""], ["proof (prove)\nusing this:\n  a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0\n\ngoal (1 subgoal):\n 1. False", "using gtz ltz"], ["proof (prove)\nusing this:\n  a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0\n  0 < a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c\n  a * (min w x - 1)\\<^sup>2 + b * (min w x - 1) + c < 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < a \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n       a \\<le> 0", "then"], ["proof (chain)\npicking this:\n  0 < a \\<Longrightarrow> False", "show \"a \\<le> 0\""], ["proof (prove)\nusing this:\n  0 < a \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<le> 0", "by fastforce"], ["proof (state)\nthis:\n  a \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> a \\<le> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "have bleq0 : \"\\<And>x. (\\<forall>y<x. b * y + c < 0 \\<Longrightarrow> b\\<ge>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y<x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y<x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y<x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b", "assume lt: \"\\<forall>y<x. b * y + c < 0\""], ["proof (state)\nthis:\n  \\<forall>y<x. b * y + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y<x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b", "have gtdom: \"b < 0 \\<Longrightarrow> \\<exists>w.\\<forall>y < w. b*y > - c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y", "by (metis mult.commute neg_less_divide_eq)"], ["proof (state)\nthis:\n  b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y<x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b", "then"], ["proof (chain)\npicking this:\n  b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y", "have \"b < 0 \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\n\ngoal (1 subgoal):\n 1. b < 0 \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"b < 0\""], ["proof (state)\nthis:\n  b < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b < 0", "have \"\\<exists>w.\\<forall>y < w. b*y > - c\""], ["proof (prove)\nusing this:\n  b < 0\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - c < b * y", "using gtdom"], ["proof (prove)\nusing this:\n  b < 0\n  b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - c < b * y", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>y<w. - c < b * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>y<w. - c < b * y", "obtain w where w_prop: \"\\<forall>y < w .b*y + c > 0\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. - c < b * y\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>y<w. 0 < b * y + c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y<w. 0 < b * y + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "let ?mn = \"min w x - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "have gtz: \"b*?mn + c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b * (min w x - 1) + c", "using w_prop"], ["proof (prove)\nusing this:\n  \\<forall>y<w. 0 < b * y + c\n\ngoal (1 subgoal):\n 1. 0 < b * (min w x - 1) + c", "by auto"], ["proof (state)\nthis:\n  0 < b * (min w x - 1) + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "have ltz: \"b*?mn + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * (min w x - 1) + c < 0", "using lt"], ["proof (prove)\nusing this:\n  \\<forall>y<x. b * y + c < 0\n\ngoal (1 subgoal):\n 1. b * (min w x - 1) + c < 0", "by auto"], ["proof (state)\nthis:\n  b * (min w x - 1) + c < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b < 0;\n     b < 0 \\<Longrightarrow> \\<exists>w. \\<forall>y<w. - c < b * y\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b * (min w x - 1) + c < 0", "show \"False\""], ["proof (prove)\nusing this:\n  b * (min w x - 1) + c < 0\n\ngoal (1 subgoal):\n 1. False", "using gtz ltz"], ["proof (prove)\nusing this:\n  b * (min w x - 1) + c < 0\n  0 < b * (min w x - 1) + c\n  b * (min w x - 1) + c < 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y<x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b", "then"], ["proof (chain)\npicking this:\n  b < 0 \\<Longrightarrow> False", "show \"b \\<ge> 0\""], ["proof (prove)\nusing this:\n  b < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 \\<le> b", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<?x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "have secondh: \"\\<And>x. (\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> \\<not> a < 0 \\<Longrightarrow> \\<not> 0 < b \\<Longrightarrow> b = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> b = 0", "using firsth bleq0"], ["proof (prove)\nusing this:\n  \\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> a \\<le> 0\n  \\<forall>y<?x. b * y + c < 0 \\<Longrightarrow> 0 \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> b = 0", "by (metis add.commute add.right_neutral less_eq_real_def mult_zero_class.mult_zero_left)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n   \\<not> 0 < b\\<rbrakk>\n  \\<Longrightarrow> b = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "have thirdh : \"\\<And>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> \\<not> a < 0 \\<Longrightarrow> \\<not> 0 < b \\<Longrightarrow> c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0", "using firsth secondh add.commute add.right_neutral infzeros mult_zero_class.mult_zero_left not_numeral_le_zero order_refl"], ["proof (prove)\nusing this:\n  \\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> a \\<le> 0\n  \\<lbrakk>\\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n   \\<not> 0 < b\\<rbrakk>\n  \\<Longrightarrow> b = 0\n  ?a + ?b = ?b + ?a\n  ?a + (0::?'a) = ?a\n  \\<forall>x<?y. ?a * x\\<^sup>2 + ?b * x + ?c = 0 \\<Longrightarrow>\n  ?a = 0 \\<and> ?b = 0 \\<and> ?c = 0\n  (0::?'a) * ?a = (0::?'a)\n  \\<not> numeral ?n \\<le> (0::?'a)\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0", "by (metis less_eq_real_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n   \\<not> 0 < b\\<rbrakk>\n  \\<Longrightarrow> c < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "have fourthh : \"a < 0 \\<Longrightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "assume aleq: \"a < 0\""], ["proof (state)\nthis:\n  a < 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "have \"\\<exists>(w::real). \\<forall>(y::real). (y < w \\<longrightarrow> y^2 > (-b/a)*y + (-c/a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2", "using ysq_dom_y_plus_coeff[where b = \"-b/a\", where c = \"-c/a\"]"], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2", "have hyp:\"\\<exists>(w::real). \\<forall>(y::real). (y < w \\<longrightarrow> a*y^2 \\<le> a*(-b/a)*y + a*(-c/a))\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. - b / a * y + - c / a < y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       \\<forall>y<w. a * y\\<^sup>2 \\<le> a * (- b / a) * y + a * (- c / a)", "by (metis (no_types, hide_lams) \\<open>a < 0\\<close> distrib_left less_eq_real_def linorder_not_le mult.assoc mult_less_cancel_left)"], ["proof (state)\nthis:\n  \\<exists>w.\n     \\<forall>y<w. a * y\\<^sup>2 \\<le> a * (- b / a) * y + a * (- c / a)\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "have \"\\<forall>y. a*(-b/a)*y + a*(-c/a) = -b*y -c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. a * (- b / a) * y + a * (- c / a) = - b * y - c", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<forall>y. a * (- b / a) * y + a * (- c / a) = - b * y - c", "by auto"], ["proof (state)\nthis:\n  \\<forall>y. a * (- b / a) * y + a * (- c / a) = - b * y - c\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>y. a * (- b / a) * y + a * (- c / a) = - b * y - c", "have \"\\<exists>(w::real). \\<forall>(y::real). (y < w \\<longrightarrow> a*y^2 \\<le> -b*y - c)\""], ["proof (prove)\nusing this:\n  \\<forall>y. a * (- b / a) * y + a * (- c / a) = - b * y - c\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 \\<le> - b * y - c", "using hyp"], ["proof (prove)\nusing this:\n  \\<forall>y. a * (- b / a) * y + a * (- c / a) = - b * y - c\n  \\<exists>w.\n     \\<forall>y<w. a * y\\<^sup>2 \\<le> a * (- b / a) * y + a * (- c / a)\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 \\<le> - b * y - c", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 \\<le> - b * y - c\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 \\<le> - b * y - c", "have \"\\<exists>(w::real). \\<forall>(y::real). (y < w \\<longrightarrow> a*y^2 + b*y + c \\<le> 0)\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 \\<le> - b * y - c\n\ngoal (1 subgoal):\n 1. \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0", "by (metis add.commute add_uminus_conv_diff le_diff_eq mult_minus_left real_add_le_0_iff)"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0", "obtain w where w_prop: \"\\<forall>(y::real). (y < w \\<longrightarrow> a*y^2 + b*y + c \\<le> 0)\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "have \"\\<exists>x. \\<forall>y < x. aEvalUni ?At x = aEvalUni ?At y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "using same_eval''"], ["proof (prove)\nusing this:\n  \\<lbrakk>getPoly ?At = (?a, ?b, ?c);\n   ?a \\<noteq> 0 \\<or> ?b \\<noteq> 0 \\<or> ?c \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       \\<forall>y<x. aEvalUni ?At y = aEvalUni ?At x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>At a b c.\n        \\<lbrakk>getPoly At = (a, b, c);\n         a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             \\<forall>y<x.\n                                aEvalUni At y =\n                                aEvalUni At x) \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "have f1: \"\\<forall>x0 x1. ((x0::real) < x1) = (\\<not> 0 \\<le> x0 + - 1 * x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x1. (x0 < x1) = (\\<not> 0 \\<le> x0 + - 1 * x1)", "by linarith"], ["proof (state)\nthis:\n  \\<forall>x0 x1. (x0 < x1) = (\\<not> 0 \\<le> x0 + - 1 * x1)\n\ngoal (1 subgoal):\n 1. (\\<And>At a b c.\n        \\<lbrakk>getPoly At = (a, b, c);\n         a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             \\<forall>y<x.\n                                aEvalUni At y =\n                                aEvalUni At x) \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "have \"a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>At a b c.\n        \\<lbrakk>getPoly At = (a, b, c);\n         a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             \\<forall>y<x.\n                                aEvalUni At y =\n                                aEvalUni At x) \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "obtain rr :: \"atomUni \\<Rightarrow> real\" where\n        \"\\<forall>r. 0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or> aEvalUni (LessUni (a, b, c)) r = aEvalUni (LessUni (a, b, c)) (rr (LessUni (a, b, c)))\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        \\<forall>r.\n           0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or>\n           aEvalUni (LessUni (a, b, c)) r =\n           aEvalUni (LessUni (a, b, c))\n            (rr (LessUni (a, b, c))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using f1"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  \\<forall>x0 x1. (x0 < x1) = (\\<not> 0 \\<le> x0 + - 1 * x1)\n\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        \\<forall>r.\n           0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or>\n           aEvalUni (LessUni (a, b, c)) r =\n           aEvalUni (LessUni (a, b, c))\n            (rr (LessUni (a, b, c))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis getPoly.simps(4) same_eval'')"], ["proof (state)\nthis:\n  \\<forall>r.\n     0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or>\n     aEvalUni (LessUni (a, b, c)) r =\n     aEvalUni (LessUni (a, b, c)) (rr (LessUni (a, b, c)))\n\ngoal (1 subgoal):\n 1. (\\<And>At a b c.\n        \\<lbrakk>getPoly At = (a, b, c);\n         a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             \\<forall>y<x.\n                                aEvalUni At y =\n                                aEvalUni At x) \\<Longrightarrow>\n    \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "then"], ["proof (chain)\npicking this:\n  \\<forall>r.\n     0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or>\n     aEvalUni (LessUni (a, b, c)) r =\n     aEvalUni (LessUni (a, b, c)) (rr (LessUni (a, b, c)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r.\n     0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or>\n     aEvalUni (LessUni (a, b, c)) r =\n     aEvalUni (LessUni (a, b, c)) (rr (LessUni (a, b, c)))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>r.\n     0 \\<le> r + - 1 * rr (LessUni (a, b, c)) \\<or>\n     aEvalUni (LessUni (a, b, c)) r =\n     aEvalUni (LessUni (a, b, c)) (rr (LessUni (a, b, c)))\n  \\<forall>x0 x1. (x0 < x1) = (\\<not> 0 \\<le> x0 + - 1 * x1)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x.\n          aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "by meson"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>y<x.\n        aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>y<x.\n        aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     \\<forall>y<x.\n        aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y", "obtain x where x_prop: \"\\<forall>y < x. aEvalUni ?At x = aEvalUni ?At y\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     \\<forall>y<x.\n        aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<forall>y<x.\n           aEvalUni (LessUni (a, b, c)) x =\n           aEvalUni (LessUni (a, b, c)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>y<x.\n     aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "let ?mn = \"min x w - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "have \"\\<forall>y < ?mn.  aEvalUni ?At y = True \\<or> aEvalUni ?At y = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = True \\<or>\n       aEvalUni (LessUni (a, b, c)) y = False", "using x_prop"], ["proof (prove)\nusing this:\n  \\<forall>y<x.\n     aEvalUni (LessUni (a, b, c)) x = aEvalUni (LessUni (a, b, c)) y\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = True \\<or>\n       aEvalUni (LessUni (a, b, c)) y = False", "by auto"], ["proof (state)\nthis:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = True \\<or>\n     aEvalUni (LessUni (a, b, c)) y = False\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "have \"\\<forall> y < ?mn. aEvalUni ?At y = False \\<longrightarrow> a*y^2 + b*y + c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n       0 \\<le> a * y\\<^sup>2 + b * y + c", "by auto"], ["proof (state)\nthis:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     0 \\<le> a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     0 \\<le> a * y\\<^sup>2 + b * y + c", "have \"\\<And>y. \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n         y < min x w - 1 \\<Longrightarrow>\n         \\<not> a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow>\n         a * y\\<^sup>2 + b * y + c = 0\""], ["proof (prove)\nusing this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     0 \\<le> a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0;\n        \\<forall>y<min x w - 1.\n           aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n           0 \\<le> a * y\\<^sup>2 + b * y + c\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "fix y :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0;\n        \\<forall>y<min x w - 1.\n           aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n           0 \\<le> a * y\\<^sup>2 + b * y + c\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "assume a1: \"y < min x w - 1\""], ["proof (state)\nthis:\n  y < min x w - 1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0;\n        \\<forall>y<min x w - 1.\n           aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n           0 \\<le> a * y\\<^sup>2 + b * y + c\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "assume a2: \"\\<not> a * y\\<^sup>2 + b * y + c < 0\""], ["proof (state)\nthis:\n  \\<not> a * y\\<^sup>2 + b * y + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0;\n        \\<forall>y<min x w - 1.\n           aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n           0 \\<le> a * y\\<^sup>2 + b * y + c\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "assume a3: \"\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\""], ["proof (state)\nthis:\n  \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0;\n        \\<forall>y<min x w - 1.\n           aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n           0 \\<le> a * y\\<^sup>2 + b * y + c\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "have \"y < w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < w", "using a1"], ["proof (prove)\nusing this:\n  y < min x w - 1\n\ngoal (1 subgoal):\n 1. y < w", "by linarith"], ["proof (state)\nthis:\n  y < w\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n        y < min x w - 1; \\<not> a * y\\<^sup>2 + b * y + c < 0;\n        \\<forall>y<min x w - 1.\n           aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n           0 \\<le> a * y\\<^sup>2 + b * y + c\\<rbrakk>\n       \\<Longrightarrow> a * y\\<^sup>2 + b * y + c = 0", "then"], ["proof (chain)\npicking this:\n  y < w", "show \"a * y\\<^sup>2 + b * y + c = 0\""], ["proof (prove)\nusing this:\n  y < w\n\ngoal (1 subgoal):\n 1. a * y\\<^sup>2 + b * y + c = 0", "using a3 a2 less_eq_real_def"], ["proof (prove)\nusing this:\n  y < w\n  \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\n  \\<not> a * y\\<^sup>2 + b * y + c < 0\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. a * y\\<^sup>2 + b * y + c = 0", "by blast"], ["proof (state)\nthis:\n  a * y\\<^sup>2 + b * y + c = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n   ?y < min x w - 1; \\<not> a * ?y\\<^sup>2 + b * ?y + c < 0\\<rbrakk>\n  \\<Longrightarrow> a * ?y\\<^sup>2 + b * ?y + c = 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n   ?y < min x w - 1; \\<not> a * ?y\\<^sup>2 + b * ?y + c < 0\\<rbrakk>\n  \\<Longrightarrow> a * ?y\\<^sup>2 + b * ?y + c = 0", "have \"\\<forall> y < ?mn. aEvalUni ?At y = False \\<longrightarrow> a*y^2 + b*y + c = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n   ?y < min x w - 1; \\<not> a * ?y\\<^sup>2 + b * ?y + c < 0\\<rbrakk>\n  \\<Longrightarrow> a * ?y\\<^sup>2 + b * ?y + c = 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n       a * y\\<^sup>2 + b * y + c = 0", "using w_prop"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0;\n   ?y < min x w - 1; \\<not> a * ?y\\<^sup>2 + b * ?y + c < 0\\<rbrakk>\n  \\<Longrightarrow> a * ?y\\<^sup>2 + b * ?y + c = 0\n  \\<forall>y<w. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n       a * y\\<^sup>2 + b * y + c = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     a * y\\<^sup>2 + b * y + c = 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     a * y\\<^sup>2 + b * y + c = 0", "have \"\\<forall> y < ?mn. aEvalUni ?At y = False \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     a * y\\<^sup>2 + b * y + c = 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n    False", "using infzeros aleq"], ["proof (prove)\nusing this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<longrightarrow>\n     a * y\\<^sup>2 + b * y + c = 0\n  \\<forall>x<?y. ?a * x\\<^sup>2 + ?b * x + ?c = 0 \\<Longrightarrow>\n  ?a = 0 \\<and> ?b = 0 \\<and> ?c = 0\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1.\n       aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n    False", "by (metis power_zero_numeral zero_less_power2)"], ["proof (state)\nthis:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n  False", "have \"\\<forall> y < ?mn. aEvalUni ?At y = True\""], ["proof (prove)\nusing this:\n  \\<forall>y<min x w - 1.\n     aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>y<min x w - 1.\n        aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n     False) \\<Longrightarrow>\n    \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>y<min x w - 1.\n        aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n     False) \\<Longrightarrow>\n    \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "fix rr :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>y<min x w - 1.\n        aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n     False) \\<Longrightarrow>\n    \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "have \"\\<forall>r ra. (ra::real) < r \\<or> \\<not> ra < r + - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra. ra < r \\<or> \\<not> ra < r + - 1", "by linarith"], ["proof (state)\nthis:\n  \\<forall>r ra. ra < r \\<or> \\<not> ra < r + - 1\n\ngoal (1 subgoal):\n 1. (\\<forall>y<min x w - 1.\n        aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n     False) \\<Longrightarrow>\n    \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "then"], ["proof (chain)\npicking this:\n  \\<forall>r ra. ra < r \\<or> \\<not> ra < r + - 1", "have \"\\<not> rr < min x w - 1 \\<or> aEvalUni (LessUni (a, b, c)) rr\""], ["proof (prove)\nusing this:\n  \\<forall>r ra. ra < r \\<or> \\<not> ra < r + - 1\n\ngoal (1 subgoal):\n 1. \\<not> rr < min x w - 1 \\<or> aEvalUni (LessUni (a, b, c)) rr", "by (metis (no_types) \\<open>\\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow> False\\<close> ab_group_add_class.ab_diff_conv_add_uminus less_eq_real_def min_less_iff_disj not_le x_prop)"], ["proof (state)\nthis:\n  \\<not> rr < min x w - 1 \\<or> aEvalUni (LessUni (a, b, c)) rr\n\ngoal (1 subgoal):\n 1. (\\<forall>y<min x w - 1.\n        aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n     False) \\<Longrightarrow>\n    \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "}"], ["proof (state)\nthis:\n  \\<not> ?rr2 < min x w - 1 \\<or> aEvalUni (LessUni (a, b, c)) ?rr2\n\ngoal (1 subgoal):\n 1. (\\<forall>y<min x w - 1.\n        aEvalUni (LessUni (a, b, c)) y = False \\<Longrightarrow>\n     False) \\<Longrightarrow>\n    \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "then"], ["proof (chain)\npicking this:\n  \\<not> ?rr2 < min x w - 1 \\<or> aEvalUni (LessUni (a, b, c)) ?rr2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> ?rr2 < min x w - 1 \\<or> aEvalUni (LessUni (a, b, c)) ?rr2\n\ngoal (1 subgoal):\n 1. \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "by blast"], ["proof (state)\nthis:\n  \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y<min x w - 1. aEvalUni (LessUni (a, b, c)) y = True\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < 0 \\<Longrightarrow>\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "have fifthh : \"b > 0 \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "assume bh : \"b > 0\""], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "show \"\\<exists>x. \\<forall>y<x. b * y + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. b * y + c < 0", "apply(rule exI[where x=\"-c/b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<- c / b. b * y + c < 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y < - (c / b) \\<Longrightarrow> b * y + c < 0", "using bh"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<And>y. y < - (c / b) \\<Longrightarrow> b * y + c < 0", "by (simp add: mult.commute pos_less_minus_divide_eq)"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. b * y + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < b \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "apply(auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0;\n        \\<not> a < 0\\<rbrakk>\n       \\<Longrightarrow> a = 0\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0\n 4. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 5. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "using firsth"], ["proof (prove)\nusing this:\n  \\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0 \\<Longrightarrow> a \\<le> 0\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0;\n        \\<not> a < 0\\<rbrakk>\n       \\<Longrightarrow> a = 0\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0\n 4. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 5. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0\n 3. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 4. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "using secondh"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n   \\<not> 0 < b\\<rbrakk>\n  \\<Longrightarrow> b = 0\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0\n 3. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 4. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0\n 2. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 3. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "using thirdh"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y<?x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n   \\<not> 0 < b\\<rbrakk>\n  \\<Longrightarrow> c < 0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0; \\<not> a < 0;\n        \\<not> 0 < b\\<rbrakk>\n       \\<Longrightarrow> c < 0\n 2. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 3. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 2. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "using fourthh"], ["proof (prove)\nusing this:\n  a < 0 \\<Longrightarrow>\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal (2 subgoals):\n 1. a < 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n 2. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "using fifthh"], ["proof (prove)\nusing this:\n  0 < b \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; 0 < b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. \\<forall>y<x. b * y + c < 0", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n  (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inequality_case_geq : \"(\\<exists>(x::real). \\<forall>(y::real)<x. (a::real) * y\\<^sup>2 + (b::real) * y + (c::real) > 0) =\n    (a > 0 \\<or> a = 0 \\<and> (0 > b \\<or> b = 0 \\<and> c > 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "have s1: \"\\<forall>y. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0 \\<longleftrightarrow>  a * y\\<^sup>2 +  b * y +  c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (- 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n       (0 < a * y\\<^sup>2 + b * y + c)", "by auto"], ["proof (state)\nthis:\n  \\<forall>y.\n     (- 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n     (0 < a * y\\<^sup>2 + b * y + c)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "have s2: \"(- 1 * a < 0 \\<or> - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0)) \\<longleftrightarrow>\n   (a > 0 \\<or> a = 0 \\<and> (0 > b \\<or>  b = 0 \\<and> c > 0))  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1 * a < 0 \\<or>\n     - 1 * a = 0 \\<and>\n     (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0)) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "by auto"], ["proof (state)\nthis:\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0)) =\n  (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "have \"(\\<exists>x. \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n  (- 1 * a < 0 \\<or> - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n    (- 1 * a < 0 \\<or>\n     - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))", "using inequality_case[where a = \"-1*a\", where b = \"-1*b\", where c= \"-1*c\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n    (- 1 * a < 0 \\<or>\n     - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x.\n      \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "using s1 s2"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      \\<forall>y<x. - 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0))\n  \\<forall>y.\n     (- 1 * a * y\\<^sup>2 + - 1 * b * y + - 1 * c < 0) =\n     (0 < a * y\\<^sup>2 + b * y + c)\n  (- 1 * a < 0 \\<or>\n   - 1 * a = 0 \\<and> (0 < - 1 * b \\<or> - 1 * b = 0 \\<and> - 1 * c < 0)) =\n  (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n    (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n  (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinity_evalUni_LessUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) = (evalUni (substNegInfinityUni (LessUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n    evalUni (substNegInfinityUni (LessUni p)) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n       evalUni (substNegInfinityUni (LessUni p)) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n       evalUni (substNegInfinityUni (LessUni p)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n    evalUni (substNegInfinityUni (LessUni p)) x", "unfolding fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni (a, b, c)) y) =\n    evalUni (substNegInfinityUni (LessUni (a, b, c))) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "using inequality_case[of a b c]"], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n  (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))", "."], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n  evalUni (substNegInfinityUni (LessUni p)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinity_evalUni_EqUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) = (evalUni (substNegInfinityUni (EqUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n    evalUni (substNegInfinityUni (EqUni p)) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n       evalUni (substNegInfinityUni (EqUni p)) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n       evalUni (substNegInfinityUni (EqUni p)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n    evalUni (substNegInfinityUni (EqUni p)) x", "using infzeros[of _ a b c]"], ["proof (prove)\nusing this:\n  \\<forall>x<?y. a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n  a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n    evalUni (substNegInfinityUni (EqUni p)) x", "by(auto simp add: fields)"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n  evalUni (substNegInfinityUni (EqUni p)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinity_evalUni_NeqUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) = (evalUni (substNegInfinityUni (NeqUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n    evalUni (substNegInfinityUni (NeqUni p)) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n       evalUni (substNegInfinityUni (NeqUni p)) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n       evalUni (substNegInfinityUni (NeqUni p)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n    evalUni (substNegInfinityUni (NeqUni p)) x", "unfolding fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni (a, b, c)) y) =\n    evalUni (substNegInfinityUni (NeqUni (a, b, c))) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) =\n    (a = 0 \\<longrightarrow> b = 0 \\<longrightarrow> c \\<noteq> 0)", "using inequality_case[of a b c]"], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n  (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) =\n    (a = 0 \\<longrightarrow> b = 0 \\<longrightarrow> c \\<noteq> 0)", "using inequality_case_geq[of a b c]"], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n  (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\n  (\\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c) =\n  (0 < a \\<or> a = 0 \\<and> (b < 0 \\<or> b = 0 \\<and> 0 < c))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) =\n    (a = 0 \\<longrightarrow> b = 0 \\<longrightarrow> c \\<noteq> 0)", "by (metis less_numeral_extra(3) linorder_neqE_linordered_idom mult_eq_0_iff)"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n  evalUni (substNegInfinityUni (NeqUni p)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinity_evalUni_LeqUni : \"(\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) = (evalUni (substNegInfinityUni (LeqUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n    evalUni (substNegInfinityUni (LeqUni p)) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n       evalUni (substNegInfinityUni (LeqUni p)) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n       evalUni (substNegInfinityUni (LeqUni p)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n    evalUni (substNegInfinityUni (LeqUni p)) x", "unfolding fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni (a, b, c)) y) =\n    evalUni (substNegInfinityUni (LeqUni (a, b, c))) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "have h1: \"((\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or> (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)) \\<longrightarrow> (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x.\n        \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<longrightarrow>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)", "using less_eq_real_def"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x.\n        \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<longrightarrow>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x.\n      \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<longrightarrow>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "have h2: \"(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<Longrightarrow> ((\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or> (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "assume a1: \"(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)\""], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "have \"\\<not>(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<Longrightarrow> (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "assume a2: \"\\<not>(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\""], ["proof (state)\nthis:\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0", "have \"a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0", "have \"(a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0 \\<Longrightarrow>\n    a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "have x1: \"a > 0 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "assume \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < a", "have \"(\\<exists>(x::real). \\<forall>(y::real)<x. (a::real) * y\\<^sup>2 + (b::real) * y + (c::real) > 0)\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c", "using inequality_case_geq"], ["proof (prove)\nusing this:\n  0 < a\n  (\\<exists>x. \\<forall>y<x. 0 < ?a * y\\<^sup>2 + ?b * y + ?c) =\n  (0 < ?a \\<or> ?a = 0 \\<and> (?b < 0 \\<or> ?b = 0 \\<and> 0 < ?c))\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. False", "using a1"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by (meson a2 linorder_not_le min_less_iff_conj)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < a \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0 \\<Longrightarrow>\n    a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "then"], ["proof (chain)\npicking this:\n  0 < a \\<Longrightarrow> False", "have x2: \"a = 0 \\<and> 0 > b \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  0 < a \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a = 0 \\<and> b < 0 \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0 \\<and> b < 0; 0 < a \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"a = 0 \\<and> 0 > b\""], ["proof (state)\nthis:\n  a = 0 \\<and> b < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0 \\<and> b < 0; 0 < a \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a = 0 \\<and> b < 0", "have \"(\\<exists>(x::real). \\<forall>(y::real)<x. (a::real) * y\\<^sup>2 + (b::real) * y + (c::real) > 0)\""], ["proof (prove)\nusing this:\n  a = 0 \\<and> b < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c", "using inequality_case_geq"], ["proof (prove)\nusing this:\n  a = 0 \\<and> b < 0\n  (\\<exists>x. \\<forall>y<x. 0 < ?a * y\\<^sup>2 + ?b * y + ?c) =\n  (0 < ?a \\<or> ?a = 0 \\<and> (?b < 0 \\<or> ?b = 0 \\<and> 0 < ?c))\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0 \\<and> b < 0; 0 < a \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c\n\ngoal (1 subgoal):\n 1. False", "using a1"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<forall>y<x. 0 < a * y\\<^sup>2 + b * y + c\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by (meson a2 linorder_not_le min_less_iff_conj)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = 0 \\<and> b < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0 \\<Longrightarrow>\n    a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "then"], ["proof (chain)\npicking this:\n  a = 0 \\<and> b < 0 \\<Longrightarrow> False", "have x3: \"a = 0 \\<and> b = 0 \\<and> c > 0 \\<Longrightarrow> False \""], ["proof (prove)\nusing this:\n  a = 0 \\<and> b < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a = 0 \\<and> b = 0 \\<and> 0 < c \\<Longrightarrow> False", "using a1 a2"], ["proof (prove)\nusing this:\n  a = 0 \\<and> b < 0 \\<Longrightarrow> False\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0\n\ngoal (1 subgoal):\n 1. a = 0 \\<and> b = 0 \\<and> 0 < c \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  a = 0 \\<and> b = 0 \\<and> 0 < c \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0 \\<Longrightarrow>\n    a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "using x1 x2 x3"], ["proof (prove)\nusing this:\n  0 < a \\<Longrightarrow> False\n  a = 0 \\<and> b < 0 \\<Longrightarrow> False\n  a = 0 \\<and> b = 0 \\<and> 0 < c \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "by (meson \\<open>a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\\<close> linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n    \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "then"], ["proof (chain)\npicking this:\n  a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)", "show \"(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0)\""], ["proof (prove)\nusing this:\n  a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "using inequality_case"], ["proof (prove)\nusing this:\n  a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0)\n  (\\<exists>x. \\<forall>y<x. ?a * y\\<^sup>2 + ?b * y + ?c < 0) =\n  (?a < 0 \\<or> ?a = 0 \\<and> (0 < ?b \\<or> ?b = 0 \\<and> ?c < 0))\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0 \\<Longrightarrow>\n  \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "have \"(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) = (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or> (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "using h1 h2"], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x.\n      \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<longrightarrow>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)\n  \\<exists>x.\n     \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0 \\<Longrightarrow>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n    (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)", "show \"(\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or> a = 0 \\<and> b = 0 \\<and> c = 0)\""], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "using inequality_case[of a b c] infzeros[of _ a b c]"], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<or>\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) =\n  (a < 0 \\<or> a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0))\n  \\<forall>x<?y. a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n  a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n    (a < 0 \\<or>\n     a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n     a = 0 \\<and> b = 0 \\<and> c = 0)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) =\n  (a < 0 \\<or>\n   a = 0 \\<and> (0 < b \\<or> b = 0 \\<and> c < 0) \\<or>\n   a = 0 \\<and> b = 0 \\<and> c = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n  evalUni (substNegInfinityUni (LeqUni p)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \"This is the vertical translation for substNegInfinityUni where we represent the virtual\nsubstution of negative infinity in the univariate case\""], ["", "lemma infinity_evalUni :\n  shows \"(\\<exists>x. \\<forall>y<x. aEvalUni At y) = (evalUni (substNegInfinityUni At) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "using infinity_evalUni_LessUni"], ["proof (prove)\nusing this:\n  At = LessUni p\n  (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni ?p) y) =\n  evalUni (substNegInfinityUni (LessUni ?p)) ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n  evalUni (substNegInfinityUni At) x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "then"], ["proof (chain)\npicking this:\n  At = EqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "using infinity_evalUni_EqUni"], ["proof (prove)\nusing this:\n  At = EqUni p\n  (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni ?p) y) =\n  evalUni (substNegInfinityUni (EqUni ?p)) ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n  evalUni (substNegInfinityUni At) x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "then"], ["proof (chain)\npicking this:\n  At = LeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "using infinity_evalUni_LeqUni"], ["proof (prove)\nusing this:\n  At = LeqUni p\n  (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni ?p) y) =\n  evalUni (substNegInfinityUni (LeqUni ?p)) ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n  evalUni (substNegInfinityUni At) x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n       evalUni (substNegInfinityUni At) x", "then"], ["proof (chain)\npicking this:\n  At = NeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "using infinity_evalUni_NeqUni"], ["proof (prove)\nusing this:\n  At = NeqUni p\n  (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni ?p) y) =\n  evalUni (substNegInfinityUni (NeqUni ?p)) ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n    evalUni (substNegInfinityUni At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni At y) =\n  evalUni (substNegInfinityUni At) x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}