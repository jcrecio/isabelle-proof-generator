{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/OptimizationProofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma neg_nnf : \"\\<forall>\\<Gamma>. (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) = eval (nnf \\<phi>) \\<Gamma>\"", "theorem eval_nnf : \"\\<forall>\\<Gamma>. eval \\<phi> \\<Gamma> = eval (nnf \\<phi>) \\<Gamma>\"", "theorem negation_free_nnf : \"negation_free (nnf \\<phi>)\"", "lemma groupQuantifiers_eval : \"eval F L = eval (groupQuantifiers F) L\"", "theorem simp_atom_eval : \"aEval a xs = eval (simp_atom a) xs\"", "lemma simpfm_eval : \"\\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L\"", "lemma exQ_clearQuantifiers:\n  assumes ExQ : \"\\<And>xs. eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\"\n  shows \"eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\"", "lemma allQ_clearQuantifiers :\n  assumes AllQ : \"\\<And>xs. eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\"\n  shows \"eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\"", "lemma clearQuantifiers_eval : \"eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\"", "lemma  push_forall_eval_AllQ : \"\\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\"", "lemma push_forall_eval : \"\\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\"", "lemma map_fm_binders_negation_free : \n  assumes \"negation_free \\<phi>\"\n  shows \"negation_free (map_fm_binders f \\<phi> n)\"", "lemma negation_free_and : \n  assumes \"negation_free \\<phi>\"\n  assumes \"negation_free \\<psi>\"\n  shows \"negation_free (and \\<phi> \\<psi>)\"", "lemma negation_free_or : \n  assumes \"negation_free \\<phi>\"\n  assumes \"negation_free \\<psi>\"\n  shows \"negation_free (or \\<phi> \\<psi>)\"", "lemma push_forall_negation_free_all :\n  assumes \"negation_free \\<phi>\"\n  shows \"negation_free (push_forall (AllQ \\<phi>))\"", "lemma push_forall_negation_free : \n  assumes \"negation_free \\<phi>\"  \n  shows \"negation_free(push_forall \\<phi>)\"", "lemma to_list_insertion: \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>(to_list v p)]\"", "lemma to_list_p: \"p = sum_list [term * (Var v) ^ i. (term,i)\\<leftarrow>(to_list v p)]\"", "lemma preserve :\n  assumes \"(a,b)=chophelper L L'\"\n  shows \"a@b=L'@L\"", "lemma compare : \n  assumes \"(a,b)=chophelper L L'\"\n  shows \"chop L = b\"", "lemma allzero:\n  assumes \"\\<forall>(p,i)\\<in>set(L'). p=0\"\n  assumes \"(a,b)=chophelper L L'\"\n  shows \"\\<forall>(p,i)\\<in>set(a). p=0\"", "lemma separate:\n  assumes \"(a,b)=chophelper (to_list v p) []\"\n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>a] + sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>b]\"", "lemma chopped : \n  assumes \"(a,b)=chophelper (to_list v p) []\"\n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>b]\"", "lemma insertion_chop : \n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>(chop (to_list v p))]\"", "lemma sorted : \"sorted_wrt (\\<lambda>(_,i).\\<lambda>(_,i'). i<i') (to_list v p)\"", "lemma sublist : \"sublist (chop L) L\"", "lemma move_exp :\n  assumes \"(p',i)#L = (chop (to_list v p))\"\n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ (d-i). (term,d)\\<leftarrow>(chop (to_list v p))] * (f v)^i\"", "lemma insert_Var_Zero : \"insertion f (Var v) = f v\"", "lemma decreasePower_insertion :\n  assumes \"decreasePower v p = (p',i)\"\n  shows \"insertion f p = insertion f p'* (f v)^i\"", "lemma unpower_eval: \"eval (unpower v \\<phi>) L = eval \\<phi> L\"", "lemma to_list_filter: \"p = sum_list [term * (Var v) ^ i. (term,i)\\<leftarrow>((filter (\\<lambda>(x,_). x\\<noteq>0) (to_list v p)))]\""], "translations": [["", "lemma neg_nnf : \"\\<forall>\\<Gamma>. (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) = eval (nnf \\<phi>) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Gamma>.\n       (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n       eval (nnf \\<phi>) \\<Gamma>", "apply(induction \\<phi>)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<forall>\\<Gamma>.\n       (\\<not> eval (nnf (Neg TrueF)) \\<Gamma>) = eval (nnf TrueF) \\<Gamma>\n 2. \\<forall>\\<Gamma>.\n       (\\<not> eval (nnf (Neg FalseF)) \\<Gamma>) =\n       eval (nnf FalseF) \\<Gamma>\n 3. \\<And>x.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg (fm.Atom x))) \\<Gamma>) =\n          eval (nnf (fm.Atom x)) \\<Gamma>\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>\\<Gamma>.\n                   (\\<not> eval (nnf (Neg \\<phi>1)) \\<Gamma>) =\n                   eval (nnf \\<phi>1) \\<Gamma>;\n        \\<forall>\\<Gamma>.\n           (\\<not> eval (nnf (Neg \\<phi>2)) \\<Gamma>) =\n           eval (nnf \\<phi>2) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<Gamma>.\n                            (\\<not> eval (nnf (Neg (And \\<phi>1 \\<phi>2)))\n                                     \\<Gamma>) =\n                            eval (nnf (And \\<phi>1 \\<phi>2)) \\<Gamma>\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>\\<Gamma>.\n                   (\\<not> eval (nnf (Neg \\<phi>1)) \\<Gamma>) =\n                   eval (nnf \\<phi>1) \\<Gamma>;\n        \\<forall>\\<Gamma>.\n           (\\<not> eval (nnf (Neg \\<phi>2)) \\<Gamma>) =\n           eval (nnf \\<phi>2) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<Gamma>.\n                            (\\<not> eval (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n                                     \\<Gamma>) =\n                            eval (nnf (Or \\<phi>1 \\<phi>2)) \\<Gamma>\n 6. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg (Neg \\<phi>))) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>\n 7. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg (ExQ \\<phi>))) \\<Gamma>) =\n          eval (nnf (ExQ \\<phi>)) \\<Gamma>\n 8. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg (AllQ \\<phi>))) \\<Gamma>) =\n          eval (nnf (AllQ \\<phi>)) \\<Gamma>\n 9. \\<And>x1 \\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg (ExN x1 \\<phi>))) \\<Gamma>) =\n          eval (nnf (ExN x1 \\<phi>)) \\<Gamma>\n 10. \\<And>x1 \\<phi>.\n        \\<forall>\\<Gamma>.\n           (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n           eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n        \\<forall>\\<Gamma>.\n           (\\<not> eval (nnf (Neg (AllN x1 \\<phi>))) \\<Gamma>) =\n           eval (nnf (AllN x1 \\<phi>)) \\<Gamma>", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>\\<Gamma>.\n          (\\<not> aEval (aNeg x) \\<Gamma>) = aEval x \\<Gamma>\n 2. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf \\<phi>) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>", "using aNeg_aEval"], ["proof (prove)\nusing this:\n  aEval ?a ?L = (\\<not> aEval (aNeg ?a) ?L)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>\\<Gamma>.\n          (\\<not> aEval (aNeg x) \\<Gamma>) = aEval x \\<Gamma>\n 2. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf \\<phi>) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf \\<phi>) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>", "using aNeg_aEval"], ["proof (prove)\nusing this:\n  aEval ?a ?L = (\\<not> aEval (aNeg ?a) ?L)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf (Neg \\<phi>)) \\<Gamma>) =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf \\<phi>) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>", "by blast"], ["", "theorem eval_nnf : \"\\<forall>\\<Gamma>. eval \\<phi> \\<Gamma> = eval (nnf \\<phi>) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Gamma>. eval \\<phi> \\<Gamma> = eval (nnf \\<phi>) \\<Gamma>", "apply(induction \\<phi>)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<forall>\\<Gamma>. eval TrueF \\<Gamma> = eval (nnf TrueF) \\<Gamma>\n 2. \\<forall>\\<Gamma>. eval FalseF \\<Gamma> = eval (nnf FalseF) \\<Gamma>\n 3. \\<And>x.\n       \\<forall>\\<Gamma>.\n          eval (fm.Atom x) \\<Gamma> = eval (nnf (fm.Atom x)) \\<Gamma>\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>\\<Gamma>.\n                   eval \\<phi>1 \\<Gamma> = eval (nnf \\<phi>1) \\<Gamma>;\n        \\<forall>\\<Gamma>.\n           eval \\<phi>2 \\<Gamma> = eval (nnf \\<phi>2) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<Gamma>.\n                            eval (And \\<phi>1 \\<phi>2) \\<Gamma> =\n                            eval (nnf (And \\<phi>1 \\<phi>2)) \\<Gamma>\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>\\<Gamma>.\n                   eval \\<phi>1 \\<Gamma> = eval (nnf \\<phi>1) \\<Gamma>;\n        \\<forall>\\<Gamma>.\n           eval \\<phi>2 \\<Gamma> = eval (nnf \\<phi>2) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<Gamma>.\n                            eval (Or \\<phi>1 \\<phi>2) \\<Gamma> =\n                            eval (nnf (Or \\<phi>1 \\<phi>2)) \\<Gamma>\n 6. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          eval \\<phi> \\<Gamma> =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          eval (Neg \\<phi>) \\<Gamma> = eval (nnf (Neg \\<phi>)) \\<Gamma>\n 7. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          eval \\<phi> \\<Gamma> =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          eval (ExQ \\<phi>) \\<Gamma> = eval (nnf (ExQ \\<phi>)) \\<Gamma>\n 8. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          eval \\<phi> \\<Gamma> =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          eval (AllQ \\<phi>) \\<Gamma> = eval (nnf (AllQ \\<phi>)) \\<Gamma>\n 9. \\<And>x1 \\<phi>.\n       \\<forall>\\<Gamma>.\n          eval \\<phi> \\<Gamma> =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          eval (ExN x1 \\<phi>) \\<Gamma> =\n          eval (nnf (ExN x1 \\<phi>)) \\<Gamma>\n 10. \\<And>x1 \\<phi>.\n        \\<forall>\\<Gamma>.\n           eval \\<phi> \\<Gamma> =\n           eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n        \\<forall>\\<Gamma>.\n           eval (AllN x1 \\<phi>) \\<Gamma> =\n           eval (nnf (AllN x1 \\<phi>)) \\<Gamma>", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          eval \\<phi> \\<Gamma> =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf \\<phi>) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>", "using neg_nnf"], ["proof (prove)\nusing this:\n  \\<forall>\\<Gamma>.\n     (\\<not> eval (nnf (Neg ?\\<phi>)) \\<Gamma>) =\n     eval (nnf ?\\<phi>) \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>\\<Gamma>.\n          eval \\<phi> \\<Gamma> =\n          eval (nnf \\<phi>) \\<Gamma> \\<Longrightarrow>\n       \\<forall>\\<Gamma>.\n          (\\<not> eval (nnf \\<phi>) \\<Gamma>) =\n          eval (nnf (Neg \\<phi>)) \\<Gamma>", "by blast"], ["", "theorem negation_free_nnf : \"negation_free (nnf \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (nnf \\<phi>)", "proof(induction \"depth \\<phi>\" arbitrary : \\<phi> rule: nat_less_induct )"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>m<depth \\<phi>.\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf \\<phi>)", "case 1"], ["proof (state)\nthis:\n  \\<forall>m<depth \\<phi>.\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>m<depth \\<phi>.\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf \\<phi>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<depth \\<phi>.\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>m<depth \\<phi>.\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf \\<phi>)", "proof(induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (And \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Or \\<phi>1 \\<phi>2))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>\\<forall>m<depth \\<phi>.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>);\n         \\<forall>m<depth (AllN x1 \\<phi>).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>m<depth \\<phi>1.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>1)\n  \\<forall>m<depth \\<phi>2.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>2)\n  \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (10 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (And \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Or \\<phi>1 \\<phi>2))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>\\<forall>m<depth \\<phi>.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>);\n         \\<forall>m<depth (AllN x1 \\<phi>).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<depth \\<phi>1.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>1)\n  \\<forall>m<depth \\<phi>2.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>2)\n  \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>m<depth \\<phi>1.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>1)\n  \\<forall>m<depth \\<phi>2.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>2)\n  \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf (And \\<phi>1 \\<phi>2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf \\<phi>1);\n     \\<forall>m<depth \\<phi>2.\n        \\<forall>x.\n           m = depth x \\<longrightarrow>\n           negation_free (nnf x) \\<Longrightarrow>\n     negation_free (nnf \\<phi>2);\n     \\<forall>m<Suc (max (depth \\<phi>1) (depth \\<phi>2)).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf \\<phi>1) \\<and>\n                      negation_free (nnf \\<phi>2)", "by (metis less_Suc_eq_le max.cobounded1 max.cobounded2)"], ["proof (state)\nthis:\n  negation_free (nnf (And \\<phi>1 \\<phi>2))\n\ngoal (9 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Or \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Or \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>m<depth \\<phi>1.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>1)\n  \\<forall>m<depth \\<phi>2.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>2)\n  \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (9 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>1);\n        \\<forall>m<depth \\<phi>2.\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf \\<phi>2);\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Or \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<depth \\<phi>1.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>1)\n  \\<forall>m<depth \\<phi>2.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>2)\n  \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>m<depth \\<phi>1.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>1)\n  \\<forall>m<depth \\<phi>2.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>2)\n  \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf (Or \\<phi>1 \\<phi>2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<depth \\<phi>1.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf \\<phi>1);\n     \\<forall>m<depth \\<phi>2.\n        \\<forall>x.\n           m = depth x \\<longrightarrow>\n           negation_free (nnf x) \\<Longrightarrow>\n     negation_free (nnf \\<phi>2);\n     \\<forall>m<Suc (max (depth \\<phi>1) (depth \\<phi>2)).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf \\<phi>1) \\<and>\n                      negation_free (nnf \\<phi>2)", "by (metis less_Suc_eq_le max.cobounded1 max.cobounded2)"], ["proof (state)\nthis:\n  negation_free (nnf (Or \\<phi>1 \\<phi>2))\n\ngoal (8 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>m<depth \\<phi>.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>)\n  \\<forall>m<depth (Neg \\<phi>).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (8 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<depth \\<phi>.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>)\n  \\<forall>m<depth (Neg \\<phi>).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>m<depth \\<phi>.\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf \\<phi>)\n  \\<forall>m<depth (Neg \\<phi>).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf (Neg \\<phi>))", "proof (induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (And \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (And \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (And \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Or \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                             \\<forall>x.\n                                m = depth x \\<longrightarrow>\n                                negation_free (nnf x) \\<Longrightarrow>\n                          negation_free (nnf \\<phi>);\n                  \\<forall>m<depth (Neg \\<phi>).\n                     \\<forall>x.\n                        m = depth x \\<longrightarrow>\n                        negation_free (nnf x)\\<rbrakk>\n                 \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n         \\<forall>m<depth (AllN x1 \\<phi>).\n            \\<forall>x.\n               m = depth x \\<longrightarrow>\n               negation_free (nnf x) \\<Longrightarrow>\n         negation_free (nnf (AllN x1 \\<phi>));\n         \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>m<depth \\<phi>1.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>1);\n   \\<forall>m<depth (Neg \\<phi>1).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1))\n  \\<lbrakk>\\<forall>m<depth \\<phi>2.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>2);\n   \\<forall>m<depth (Neg \\<phi>2).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2))\n  \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (And \\<phi>1 \\<phi>2))\n  \\<forall>m<depth (Neg (And \\<phi>1 \\<phi>2)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (And \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (And \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (And \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Or \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                             \\<forall>x.\n                                m = depth x \\<longrightarrow>\n                                negation_free (nnf x) \\<Longrightarrow>\n                          negation_free (nnf \\<phi>);\n                  \\<forall>m<depth (Neg \\<phi>).\n                     \\<forall>x.\n                        m = depth x \\<longrightarrow>\n                        negation_free (nnf x)\\<rbrakk>\n                 \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n         \\<forall>m<depth (AllN x1 \\<phi>).\n            \\<forall>x.\n               m = depth x \\<longrightarrow>\n               negation_free (nnf x) \\<Longrightarrow>\n         negation_free (nnf (AllN x1 \\<phi>));\n         \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>m<depth \\<phi>1.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>1);\n   \\<forall>m<depth (Neg \\<phi>1).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1))\n  \\<lbrakk>\\<forall>m<depth \\<phi>2.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>2);\n   \\<forall>m<depth (Neg \\<phi>2).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2))\n  \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (And \\<phi>1 \\<phi>2))\n  \\<forall>m<depth (Neg (And \\<phi>1 \\<phi>2)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>m<depth \\<phi>1.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>1);\n   \\<forall>m<depth (Neg \\<phi>1).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1))\n  \\<lbrakk>\\<forall>m<depth \\<phi>2.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>2);\n   \\<forall>m<depth (Neg \\<phi>2).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2))\n  \\<forall>m<depth (And \\<phi>1 \\<phi>2).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (And \\<phi>1 \\<phi>2))\n  \\<forall>m<depth (Neg (And \\<phi>1 \\<phi>2)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf (Neg (And \\<phi>1 \\<phi>2)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                         \\<forall>x.\n                            m = depth x \\<longrightarrow>\n                            negation_free (nnf x) \\<Longrightarrow>\n                      negation_free (nnf \\<phi>1);\n              \\<forall>m<Suc (depth \\<phi>1).\n                 \\<forall>x.\n                    m = depth x \\<longrightarrow>\n                    negation_free (nnf x)\\<rbrakk>\n             \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n     \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                 \\<forall>x.\n                    m = depth x \\<longrightarrow>\n                    negation_free (nnf x) \\<Longrightarrow>\n              negation_free (nnf \\<phi>2);\n      \\<forall>m<Suc (depth \\<phi>2).\n         \\<forall>x.\n            m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n     \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n     \\<forall>m<Suc (max (depth \\<phi>1) (depth \\<phi>2)).\n        \\<forall>x.\n           m = depth x \\<longrightarrow>\n           negation_free (nnf x) \\<Longrightarrow>\n     negation_free (nnf \\<phi>1) \\<and> negation_free (nnf \\<phi>2);\n     \\<forall>m<Suc (Suc (max (depth \\<phi>1) (depth \\<phi>2))).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1)) \\<and>\n                      negation_free (nnf (Neg \\<phi>2))", "by (metis less_Suc_eq max_less_iff_conj not_less_eq)"], ["proof (state)\nthis:\n  negation_free (nnf (Neg (And \\<phi>1 \\<phi>2)))\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Or \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Or \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>m<depth \\<phi>1.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>1);\n   \\<forall>m<depth (Neg \\<phi>1).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1))\n  \\<lbrakk>\\<forall>m<depth \\<phi>2.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>2);\n   \\<forall>m<depth (Neg \\<phi>2).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2))\n  \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (Or \\<phi>1 \\<phi>2))\n  \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>1);\n                 \\<forall>m<depth (Neg \\<phi>1).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n        \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x) \\<Longrightarrow>\n                 negation_free (nnf \\<phi>2);\n         \\<forall>m<depth (Neg \\<phi>2).\n            \\<forall>x.\n               m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n        \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n        \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Or \\<phi>1 \\<phi>2));\n        \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>m<depth \\<phi>1.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>1);\n   \\<forall>m<depth (Neg \\<phi>1).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1))\n  \\<lbrakk>\\<forall>m<depth \\<phi>2.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>2);\n   \\<forall>m<depth (Neg \\<phi>2).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2))\n  \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (Or \\<phi>1 \\<phi>2))\n  \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>m<depth \\<phi>1.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>1);\n   \\<forall>m<depth (Neg \\<phi>1).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1))\n  \\<lbrakk>\\<forall>m<depth \\<phi>2.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>2);\n   \\<forall>m<depth (Neg \\<phi>2).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2))\n  \\<forall>m<depth (Or \\<phi>1 \\<phi>2).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (Or \\<phi>1 \\<phi>2))\n  \\<forall>m<depth (Neg (Or \\<phi>1 \\<phi>2)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>1.\n                         \\<forall>x.\n                            m = depth x \\<longrightarrow>\n                            negation_free (nnf x) \\<Longrightarrow>\n                      negation_free (nnf \\<phi>1);\n              \\<forall>m<Suc (depth \\<phi>1).\n                 \\<forall>x.\n                    m = depth x \\<longrightarrow>\n                    negation_free (nnf x)\\<rbrakk>\n             \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1));\n     \\<lbrakk>\\<forall>m<depth \\<phi>2.\n                 \\<forall>x.\n                    m = depth x \\<longrightarrow>\n                    negation_free (nnf x) \\<Longrightarrow>\n              negation_free (nnf \\<phi>2);\n      \\<forall>m<Suc (depth \\<phi>2).\n         \\<forall>x.\n            m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n     \\<Longrightarrow> negation_free (nnf (Neg \\<phi>2));\n     \\<forall>m<Suc (max (depth \\<phi>1) (depth \\<phi>2)).\n        \\<forall>x.\n           m = depth x \\<longrightarrow>\n           negation_free (nnf x) \\<Longrightarrow>\n     negation_free (nnf \\<phi>1) \\<and> negation_free (nnf \\<phi>2);\n     \\<forall>m<Suc (Suc (max (depth \\<phi>1) (depth \\<phi>2))).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg \\<phi>1)) \\<and>\n                      negation_free (nnf (Neg \\<phi>2))", "by (metis less_Suc_eq max_less_iff_conj not_less_eq)"], ["proof (state)\nthis:\n  negation_free (nnf (Neg (Or \\<phi>1 \\<phi>2)))\n\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>m<depth \\<phi>.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>);\n   \\<forall>m<depth (Neg \\<phi>).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n  \\<forall>m<depth (Neg \\<phi>).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (Neg \\<phi>))\n  \\<forall>m<depth (Neg (Neg \\<phi>)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (Neg (Neg \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>m<depth \\<phi>.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>);\n   \\<forall>m<depth (Neg \\<phi>).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n  \\<forall>m<depth (Neg \\<phi>).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (Neg \\<phi>))\n  \\<forall>m<depth (Neg (Neg \\<phi>)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>m<depth \\<phi>.\n              \\<forall>x.\n                 m = depth x \\<longrightarrow>\n                 negation_free (nnf x) \\<Longrightarrow>\n           negation_free (nnf \\<phi>);\n   \\<forall>m<depth (Neg \\<phi>).\n      \\<forall>x.\n         m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n  \\<Longrightarrow> negation_free (nnf (Neg \\<phi>))\n  \\<forall>m<depth (Neg \\<phi>).\n     \\<forall>x.\n        m = depth x \\<longrightarrow>\n        negation_free (nnf x) \\<Longrightarrow>\n  negation_free (nnf (Neg \\<phi>))\n  \\<forall>m<depth (Neg (Neg \\<phi>)).\n     \\<forall>x. m = depth x \\<longrightarrow> negation_free (nnf x)\n\ngoal (1 subgoal):\n 1. negation_free (nnf (Neg (Neg \\<phi>)))", "by (metis Suc_eq_plus1 add_lessD1 depth.simps(6) lessI nnf.simps(12))"], ["proof (state)\nthis:\n  negation_free (nnf (Neg (Neg \\<phi>)))\n\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<forall>m<depth TrueF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf TrueF);\n     \\<forall>m<depth (Neg TrueF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg TrueF))\n 2. \\<lbrakk>\\<forall>m<depth FalseF.\n                \\<forall>x.\n                   m = depth x \\<longrightarrow>\n                   negation_free (nnf x) \\<Longrightarrow>\n             negation_free (nnf FalseF);\n     \\<forall>m<depth (Neg FalseF).\n        \\<forall>x.\n           m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n    \\<Longrightarrow> negation_free (nnf (Neg FalseF))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>m<depth (fm.Atom x).\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf (fm.Atom x));\n        \\<forall>m<depth (Neg (fm.Atom x)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExQ \\<phi>));\n        \\<forall>m<depth (Neg (ExQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExQ \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllQ \\<phi>));\n        \\<forall>m<depth (Neg (AllQ \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllQ \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (ExN x1 \\<phi>));\n        \\<forall>m<depth (Neg (ExN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (ExN x1 \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<lbrakk>\\<forall>m<depth \\<phi>.\n                            \\<forall>x.\n                               m = depth x \\<longrightarrow>\n                               negation_free (nnf x) \\<Longrightarrow>\n                         negation_free (nnf \\<phi>);\n                 \\<forall>m<depth (Neg \\<phi>).\n                    \\<forall>x.\n                       m = depth x \\<longrightarrow>\n                       negation_free (nnf x)\\<rbrakk>\n                \\<Longrightarrow> negation_free (nnf (Neg \\<phi>));\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow>\n              negation_free (nnf x) \\<Longrightarrow>\n        negation_free (nnf (AllN x1 \\<phi>));\n        \\<forall>m<depth (Neg (AllN x1 \\<phi>)).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (Neg (AllN x1 \\<phi>)))", "qed auto"], ["proof (state)\nthis:\n  negation_free (nnf (Neg \\<phi>))\n\ngoal (7 subgoals):\n 1. \\<forall>m<depth TrueF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf TrueF)\n 2. \\<forall>m<depth FalseF.\n       \\<forall>x.\n          m = depth x \\<longrightarrow>\n          negation_free (nnf x) \\<Longrightarrow>\n    negation_free (nnf FalseF)\n 3. \\<And>x.\n       \\<forall>m<depth (fm.Atom x).\n          \\<forall>x.\n             m = depth x \\<longrightarrow>\n             negation_free (nnf x) \\<Longrightarrow>\n       negation_free (nnf (fm.Atom x))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExQ \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllQ \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllQ \\<phi>))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (ExN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (ExN x1 \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<forall>m<depth \\<phi>.\n                   \\<forall>x.\n                      m = depth x \\<longrightarrow>\n                      negation_free (nnf x) \\<Longrightarrow>\n                negation_free (nnf \\<phi>);\n        \\<forall>m<depth (AllN x1 \\<phi>).\n           \\<forall>x.\n              m = depth x \\<longrightarrow> negation_free (nnf x)\\<rbrakk>\n       \\<Longrightarrow> negation_free (nnf (AllN x1 \\<phi>))", "qed auto"], ["proof (state)\nthis:\n  negation_free (nnf \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma groupQuantifiers_eval : \"eval F L = eval (groupQuantifiers F) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F L = eval (groupQuantifiers F) L", "apply(induction F arbitrary: L  rule:groupQuantifiers.induct)"], ["proof (prove)\ngoal (46 subgoals):\n 1. \\<And>L. eval TrueF L = eval (groupQuantifiers TrueF) L\n 2. \\<And>L. eval FalseF L = eval (groupQuantifiers FalseF) L\n 3. \\<And>A B L.\n       \\<lbrakk>\\<And>L. eval A L = eval (groupQuantifiers A) L;\n        \\<And>L. eval B L = eval (groupQuantifiers B) L\\<rbrakk>\n       \\<Longrightarrow> eval (And A B) L =\n                         eval (groupQuantifiers (And A B)) L\n 4. \\<And>A B L.\n       \\<lbrakk>\\<And>L. eval A L = eval (groupQuantifiers A) L;\n        \\<And>L. eval B L = eval (groupQuantifiers B) L\\<rbrakk>\n       \\<Longrightarrow> eval (Or A B) L =\n                         eval (groupQuantifiers (Or A B)) L\n 5. \\<And>A L.\n       (\\<And>L. eval A L = eval (groupQuantifiers A) L) \\<Longrightarrow>\n       eval (Neg A) L = eval (groupQuantifiers (Neg A)) L\n 6. \\<And>A L. eval (fm.Atom A) L = eval (groupQuantifiers (fm.Atom A)) L\n 7. \\<And>A L.\n       (\\<And>L.\n           eval (ExN 2 A) L =\n           eval (groupQuantifiers (ExN 2 A)) L) \\<Longrightarrow>\n       eval (ExQ (ExQ A)) L = eval (groupQuantifiers (ExQ (ExQ A))) L\n 8. \\<And>j A L.\n       (\\<And>L.\n           eval (ExN (j + 1) A) L =\n           eval (groupQuantifiers (ExN (j + 1) A)) L) \\<Longrightarrow>\n       eval (ExQ (ExN j A)) L = eval (groupQuantifiers (ExQ (ExN j A))) L\n 9. \\<And>j A L.\n       (\\<And>L.\n           eval (ExN (j + 1) A) L =\n           eval (groupQuantifiers (ExN (j + 1) A)) L) \\<Longrightarrow>\n       eval (ExN j (ExQ A)) L = eval (groupQuantifiers (ExN j (ExQ A))) L\n 10. \\<And>i j A L.\n        (\\<And>L.\n            eval (ExN (i + j) A) L =\n            eval (groupQuantifiers (ExN (i + j) A)) L) \\<Longrightarrow>\n        eval (ExN i (ExN j A)) L =\n        eval (groupQuantifiers (ExN i (ExN j A))) L\nA total of 46 subgoals...", "unfolding doubleExist unwrapExist unwrapExist' unwrapExist'' doubleForall unwrapForall unwrapForall' unwrapForall''"], ["proof (prove)\ngoal (46 subgoals):\n 1. \\<And>L. eval TrueF L = eval (groupQuantifiers TrueF) L\n 2. \\<And>L. eval FalseF L = eval (groupQuantifiers FalseF) L\n 3. \\<And>A B L.\n       \\<lbrakk>\\<And>L. eval A L = eval (groupQuantifiers A) L;\n        \\<And>L. eval B L = eval (groupQuantifiers B) L\\<rbrakk>\n       \\<Longrightarrow> eval (And A B) L =\n                         eval (groupQuantifiers (And A B)) L\n 4. \\<And>A B L.\n       \\<lbrakk>\\<And>L. eval A L = eval (groupQuantifiers A) L;\n        \\<And>L. eval B L = eval (groupQuantifiers B) L\\<rbrakk>\n       \\<Longrightarrow> eval (Or A B) L =\n                         eval (groupQuantifiers (Or A B)) L\n 5. \\<And>A L.\n       (\\<And>L. eval A L = eval (groupQuantifiers A) L) \\<Longrightarrow>\n       eval (Neg A) L = eval (groupQuantifiers (Neg A)) L\n 6. \\<And>A L. eval (fm.Atom A) L = eval (groupQuantifiers (fm.Atom A)) L\n 7. \\<And>A L.\n       (\\<And>L.\n           eval (ExQ (ExQ A)) L =\n           eval (groupQuantifiers (ExN 2 A)) L) \\<Longrightarrow>\n       eval (ExQ (ExQ A)) L = eval (groupQuantifiers (ExQ (ExQ A))) L\n 8. \\<And>j A L.\n       (\\<And>L.\n           eval (ExN j (ExN 1 A)) L =\n           eval (groupQuantifiers (ExN (j + 1) A)) L) \\<Longrightarrow>\n       eval (ExQ (ExN j A)) L = eval (groupQuantifiers (ExQ (ExN j A))) L\n 9. \\<And>j A L.\n       (\\<And>L.\n           eval (ExN j (ExN 1 A)) L =\n           eval (groupQuantifiers (ExN (j + 1) A)) L) \\<Longrightarrow>\n       eval (ExN j (ExQ A)) L = eval (groupQuantifiers (ExN j (ExQ A))) L\n 10. \\<And>i j A L.\n        (\\<And>L.\n            eval (ExN i (ExN j A)) L =\n            eval (groupQuantifiers (ExN (i + j) A)) L) \\<Longrightarrow>\n        eval (ExN i (ExN j A)) L =\n        eval (groupQuantifiers (ExN i (ExN j A))) L\nA total of 46 subgoals...", "apply (auto)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>A L x l.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>la.\n                       length la = length l \\<and>\n                       (\\<exists>l.\n                           length l = Suc 0 \\<and> eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (ExN (Suc (length l)) A)) L;\n        eval A (l @ x # L)\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (ExN (Suc (length l)) A)) L\n 2. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>l.\n                       length l = j \\<and>\n                       (\\<exists>la.\n                           length la = Suc 0 \\<and> eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (ExN (Suc j) A)) L;\n        eval (groupQuantifiers (ExN (Suc j) A)) L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x l.\n                            length l = j \\<and> eval A (l @ x # L)\n 3. \\<And>A L l x.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>la.\n                       length la = length l \\<and>\n                       (\\<exists>l.\n                           length l = Suc 0 \\<and> eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (ExN (Suc (length l)) A)) L;\n        eval A (x # l @ L)\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (ExN (Suc (length l)) A)) L\n 4. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>l.\n                       length l = j \\<and>\n                       (\\<exists>la.\n                           length la = Suc 0 \\<and> eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (ExN (Suc j) A)) L;\n        eval (groupQuantifiers (ExN (Suc j) A)) L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = j \\<and>\n                            (\\<exists>x. eval A (x # l @ L))\n 5. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>l.\n                       length l = j \\<longrightarrow>\n                       (\\<forall>la.\n                           length la = Suc 0 \\<longrightarrow>\n                           eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (AllN (Suc j) A)) L;\n        \\<forall>x l.\n           length l = j \\<longrightarrow> eval A (l @ x # L)\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (AllN (Suc j) A)) L\n 6. \\<And>A L x l.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>la.\n                       length la = length l \\<longrightarrow>\n                       (\\<forall>l.\n                           length l = Suc 0 \\<longrightarrow>\n                           eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (AllN (Suc (length l)) A)) L;\n        eval (groupQuantifiers (AllN (Suc (length l)) A)) L\\<rbrakk>\n       \\<Longrightarrow> eval A (l @ x # L)\n 7. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>l.\n                       length l = j \\<longrightarrow>\n                       (\\<forall>la.\n                           length la = Suc 0 \\<longrightarrow>\n                           eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (AllN (Suc j) A)) L;\n        \\<forall>l.\n           length l = j \\<longrightarrow>\n           (\\<forall>x. eval A (x # l @ L))\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (AllN (Suc j) A)) L\n 8. \\<And>A L l x.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>la.\n                       length la = length l \\<longrightarrow>\n                       (\\<forall>l.\n                           length l = Suc 0 \\<longrightarrow>\n                           eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (AllN (Suc (length l)) A)) L;\n        eval (groupQuantifiers (AllN (Suc (length l)) A)) L\\<rbrakk>\n       \\<Longrightarrow> eval A (x # l @ L)", "using doubleExist doubleExist unwrapExist unwrapExist' unwrapExist'' doubleForall unwrapForall unwrapForall' unwrapForall''"], ["proof (prove)\nusing this:\n  eval (ExN 2 ?A) ?L = eval (ExQ (ExQ ?A)) ?L\n  eval (ExN 2 ?A) ?L = eval (ExQ (ExQ ?A)) ?L\n  eval (ExN (?j + 1) ?A) ?L = eval (ExQ (ExN ?j ?A)) ?L\n  eval (ExN (?j + 1) ?A) ?L = eval (ExN ?j (ExQ ?A)) ?L\n  eval (ExN (?i + ?j) ?A) ?L = eval (ExN ?i (ExN ?j ?A)) ?L\n  eval (AllN 2 ?A) ?L = eval (AllQ (AllQ ?A)) ?L\n  eval (AllN (?j + 1) ?A) ?L = eval (AllQ (AllN ?j ?A)) ?L\n  eval (AllN (?j + 1) ?A) ?L = eval (AllN ?j (AllQ ?A)) ?L\n  eval (AllN (?i + ?j) ?A) ?L = eval (AllN ?i (AllN ?j ?A)) ?L\n\ngoal (8 subgoals):\n 1. \\<And>A L x l.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>la.\n                       length la = length l \\<and>\n                       (\\<exists>l.\n                           length l = Suc 0 \\<and> eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (ExN (Suc (length l)) A)) L;\n        eval A (l @ x # L)\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (ExN (Suc (length l)) A)) L\n 2. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>l.\n                       length l = j \\<and>\n                       (\\<exists>la.\n                           length la = Suc 0 \\<and> eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (ExN (Suc j) A)) L;\n        eval (groupQuantifiers (ExN (Suc j) A)) L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x l.\n                            length l = j \\<and> eval A (l @ x # L)\n 3. \\<And>A L l x.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>la.\n                       length la = length l \\<and>\n                       (\\<exists>l.\n                           length l = Suc 0 \\<and> eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (ExN (Suc (length l)) A)) L;\n        eval A (x # l @ L)\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (ExN (Suc (length l)) A)) L\n 4. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>l.\n                       length l = j \\<and>\n                       (\\<exists>la.\n                           length la = Suc 0 \\<and> eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (ExN (Suc j) A)) L;\n        eval (groupQuantifiers (ExN (Suc j) A)) L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = j \\<and>\n                            (\\<exists>x. eval A (x # l @ L))\n 5. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>l.\n                       length l = j \\<longrightarrow>\n                       (\\<forall>la.\n                           length la = Suc 0 \\<longrightarrow>\n                           eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (AllN (Suc j) A)) L;\n        \\<forall>x l.\n           length l = j \\<longrightarrow> eval A (l @ x # L)\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (AllN (Suc j) A)) L\n 6. \\<And>A L x l.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>la.\n                       length la = length l \\<longrightarrow>\n                       (\\<forall>l.\n                           length l = Suc 0 \\<longrightarrow>\n                           eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (AllN (Suc (length l)) A)) L;\n        eval (groupQuantifiers (AllN (Suc (length l)) A)) L\\<rbrakk>\n       \\<Longrightarrow> eval A (l @ x # L)\n 7. \\<And>j A L.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>l.\n                       length l = j \\<longrightarrow>\n                       (\\<forall>la.\n                           length la = Suc 0 \\<longrightarrow>\n                           eval A (la @ l @ L))) =\n                   eval (groupQuantifiers (AllN (Suc j) A)) L;\n        \\<forall>l.\n           length l = j \\<longrightarrow>\n           (\\<forall>x. eval A (x # l @ L))\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (AllN (Suc j) A)) L\n 8. \\<And>A L l x.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>la.\n                       length la = length l \\<longrightarrow>\n                       (\\<forall>l.\n                           length l = Suc 0 \\<longrightarrow>\n                           eval A (l @ la @ L))) =\n                   eval (groupQuantifiers (AllN (Suc (length l)) A)) L;\n        eval (groupQuantifiers (AllN (Suc (length l)) A)) L\\<rbrakk>\n       \\<Longrightarrow> eval A (x # l @ L)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A L x l.\n       \\<lbrakk>\\<And>L.\n                   (\\<exists>la.\n                       length la = length l \\<and>\n                       (\\<exists>x. eval A (x # la @ L))) =\n                   eval (groupQuantifiers (ExN (Suc (length l)) A)) L;\n        eval A (l @ x # L);\n        \\<And>A L.\n           (\\<exists>l. length l = 2 \\<and> eval A (l @ L)) =\n           (\\<exists>x xa. eval A (xa # x # L));\n        \\<And>j A L.\n           (\\<exists>l. length l = Suc j \\<and> eval A (l @ L)) =\n           (\\<exists>l.\n               length l = j \\<and> (\\<exists>x. eval A (x # l @ L)));\n        \\<And>j A L.\n           (\\<exists>x l. length l = j \\<and> eval A (l @ x # L)) =\n           (\\<exists>l.\n               length l = j \\<and> (\\<exists>x. eval A (x # l @ L)));\n        \\<And>i j A L.\n           (\\<exists>l. length l = i + j \\<and> eval A (l @ L)) =\n           (\\<exists>l.\n               length l = i \\<and>\n               (\\<exists>la. length la = j \\<and> eval A (la @ l @ L)));\n        \\<And>A L.\n           (\\<forall>l. length l = 2 \\<longrightarrow> eval A (l @ L)) =\n           (\\<forall>x xa. eval A (xa # x # L));\n        \\<And>j A L.\n           (\\<forall>l. length l = Suc j \\<longrightarrow> eval A (l @ L)) =\n           (\\<forall>l.\n               length l = j \\<longrightarrow>\n               (\\<forall>x. eval A (x # l @ L)));\n        \\<And>j A L.\n           (\\<forall>x l.\n               length l = j \\<longrightarrow> eval A (l @ x # L)) =\n           (\\<forall>l.\n               length l = j \\<longrightarrow>\n               (\\<forall>x. eval A (x # l @ L)));\n        \\<And>i j A L.\n           (\\<forall>l. length l = i + j \\<longrightarrow> eval A (l @ L)) =\n           (\\<forall>l.\n               length l = i \\<longrightarrow>\n               (\\<forall>la.\n                   length la = j \\<longrightarrow>\n                   eval A (la @ l @ L)))\\<rbrakk>\n       \\<Longrightarrow> eval (groupQuantifiers (ExN (Suc (length l)) A)) L\n 2. \\<And>A L x l.\n       \\<lbrakk>\\<And>L.\n                   (\\<forall>la.\n                       length la = length l \\<longrightarrow>\n                       (\\<forall>x. eval A (x # la @ L))) =\n                   eval (groupQuantifiers (AllN (Suc (length l)) A)) L;\n        eval (groupQuantifiers (AllN (Suc (length l)) A)) L;\n        \\<And>A L.\n           (\\<exists>l. length l = 2 \\<and> eval A (l @ L)) =\n           (\\<exists>x xa. eval A (xa # x # L));\n        \\<And>j A L.\n           (\\<exists>l. length l = Suc j \\<and> eval A (l @ L)) =\n           (\\<exists>l.\n               length l = j \\<and> (\\<exists>x. eval A (x # l @ L)));\n        \\<And>j A L.\n           (\\<exists>x l. length l = j \\<and> eval A (l @ x # L)) =\n           (\\<exists>l.\n               length l = j \\<and> (\\<exists>x. eval A (x # l @ L)));\n        \\<And>i j A L.\n           (\\<exists>l. length l = i + j \\<and> eval A (l @ L)) =\n           (\\<exists>l.\n               length l = i \\<and>\n               (\\<exists>la. length la = j \\<and> eval A (la @ l @ L)));\n        \\<And>A L.\n           (\\<forall>l. length l = 2 \\<longrightarrow> eval A (l @ L)) =\n           (\\<forall>x xa. eval A (xa # x # L));\n        \\<And>j A L.\n           (\\<forall>l. length l = Suc j \\<longrightarrow> eval A (l @ L)) =\n           (\\<forall>l.\n               length l = j \\<longrightarrow>\n               (\\<forall>x. eval A (x # l @ L)));\n        \\<And>j A L.\n           (\\<forall>x l.\n               length l = j \\<longrightarrow> eval A (l @ x # L)) =\n           (\\<forall>l.\n               length l = j \\<longrightarrow>\n               (\\<forall>x. eval A (x # l @ L)));\n        \\<And>i j A L.\n           (\\<forall>l. length l = i + j \\<longrightarrow> eval A (l @ L)) =\n           (\\<forall>l.\n               length l = i \\<longrightarrow>\n               (\\<forall>la.\n                   length la = j \\<longrightarrow>\n                   eval A (la @ l @ L)))\\<rbrakk>\n       \\<Longrightarrow> eval A (l @ x # L)", "by metis+"], ["", "theorem simp_atom_eval : \"aEval a xs = eval (simp_atom a) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval a xs = eval (simp_atom a) xs", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       a = Less x1 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x2. a = Eq x2 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 3. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 4. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       a = Less x1 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x2. a = Eq x2 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 3. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 4. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "then"], ["proof (chain)\npicking this:\n  a = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Less p\n\ngoal (1 subgoal):\n 1. aEval a xs = eval (simp_atom a) xs", "by(cases \"get_if_const p\")(simp_all add:get_if_const_insertion)"], ["proof (state)\nthis:\n  aEval a xs = eval (simp_atom a) xs\n\ngoal (3 subgoals):\n 1. \\<And>x2. a = Eq x2 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 3. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2. a = Eq x2 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 3. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2. a = Eq x2 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 3. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "then"], ["proof (chain)\npicking this:\n  a = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Eq p\n\ngoal (1 subgoal):\n 1. aEval a xs = eval (simp_atom a) xs", "by(cases \"get_if_const p\")(simp_all add:get_if_const_insertion)"], ["proof (state)\nthis:\n  aEval a xs = eval (simp_atom a) xs\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs\n 2. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "then"], ["proof (chain)\npicking this:\n  a = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Leq p\n\ngoal (1 subgoal):\n 1. aEval a xs = eval (simp_atom a) xs", "by(cases \"get_if_const p\")(simp_all add:get_if_const_insertion)"], ["proof (state)\nthis:\n  aEval a xs = eval (simp_atom a) xs\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a xs = eval (simp_atom a) xs", "then"], ["proof (chain)\npicking this:\n  a = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. aEval a xs = eval (simp_atom a) xs", "by(cases \"get_if_const p\")(simp_all add:get_if_const_insertion)"], ["proof (state)\nthis:\n  aEval a xs = eval (simp_atom a) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simpfm_eval : \"\\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L", "apply(induction \\<phi>)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<forall>L. eval TrueF L = eval (simpfm TrueF) L\n 2. \\<forall>L. eval FalseF L = eval (simpfm FalseF) L\n 3. \\<And>x. \\<forall>L. eval (fm.Atom x) L = eval (simpfm (fm.Atom x)) L\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>L. eval \\<phi>1 L = eval (simpfm \\<phi>1) L;\n        \\<forall>L. eval \\<phi>2 L = eval (simpfm \\<phi>2) L\\<rbrakk>\n       \\<Longrightarrow> \\<forall>L.\n                            eval (And \\<phi>1 \\<phi>2) L =\n                            eval (simpfm (And \\<phi>1 \\<phi>2)) L\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>L. eval \\<phi>1 L = eval (simpfm \\<phi>1) L;\n        \\<forall>L. eval \\<phi>2 L = eval (simpfm \\<phi>2) L\\<rbrakk>\n       \\<Longrightarrow> \\<forall>L.\n                            eval (Or \\<phi>1 \\<phi>2) L =\n                            eval (simpfm (Or \\<phi>1 \\<phi>2)) L\n 6. \\<And>\\<phi>.\n       \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n       \\<forall>L. eval (Neg \\<phi>) L = eval (simpfm (Neg \\<phi>)) L\n 7. \\<And>\\<phi>.\n       \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n       \\<forall>L. eval (ExQ \\<phi>) L = eval (simpfm (ExQ \\<phi>)) L\n 8. \\<And>\\<phi>.\n       \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n       \\<forall>L. eval (AllQ \\<phi>) L = eval (simpfm (AllQ \\<phi>)) L\n 9. \\<And>x1 \\<phi>.\n       \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n       \\<forall>L. eval (ExN x1 \\<phi>) L = eval (simpfm (ExN x1 \\<phi>)) L\n 10. \\<And>x1 \\<phi>.\n        \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n        \\<forall>L.\n           eval (AllN x1 \\<phi>) L = eval (simpfm (AllN x1 \\<phi>)) L", "apply(simp_all add: simp_atom_eval eval_and eval_or)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n       \\<forall>L.\n          (\\<not> eval (simpfm \\<phi>) L) = eval (neg (simpfm \\<phi>)) L", "using eval_neg"], ["proof (prove)\nusing this:\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<forall>L. eval \\<phi> L = eval (simpfm \\<phi>) L \\<Longrightarrow>\n       \\<forall>L.\n          (\\<not> eval (simpfm \\<phi>) L) = eval (neg (simpfm \\<phi>)) L", "by blast"], ["", "lemma exQ_clearQuantifiers:\n  assumes ExQ : \"\\<And>xs. eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\"\n  shows \"eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "define \\<phi>' where \"\\<phi>' = clearQuantifiers \\<phi>\""], ["proof (state)\nthis:\n  \\<phi>' = clearQuantifiers \\<phi>\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "have h : \"freeIn 0 \\<phi>' \\<Longrightarrow> (eval (lowerFm 0 1 \\<phi>') xs = eval (ExQ \\<phi>') xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (lowerFm 0 1 \\<phi>') xs = eval (ExQ \\<phi>') xs", "using eval_lowerFm"], ["proof (prove)\nusing this:\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (lowerFm 0 1 \\<phi>') xs = eval (ExQ \\<phi>') xs", "by simp"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (lowerFm 0 1 \\<phi>') xs = eval (ExQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "have \"eval (clearQuantifiers (ExQ \\<phi>)) xs = \n      eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>') xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs =\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>') xs", "using \\<phi>'_def"], ["proof (prove)\nusing this:\n  \\<phi>' = clearQuantifiers \\<phi>\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs =\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>') xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExQ \\<phi>)) xs =\n  eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "also"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExQ \\<phi>)) xs =\n  eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "have \"... = eval (ExQ \\<phi>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>')\n     xs =\n    eval (ExQ \\<phi>) xs", "apply(cases \"freeIn 0 \\<phi>'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>')\n     xs =\n    eval (ExQ \\<phi>) xs\n 2. \\<not> freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>')\n     xs =\n    eval (ExQ \\<phi>) xs", "using h ExQ \\<phi>'_def"], ["proof (prove)\nusing this:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (lowerFm 0 1 \\<phi>') xs = eval (ExQ \\<phi>') xs\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n  \\<phi>' = clearQuantifiers \\<phi>\n\ngoal (2 subgoals):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>')\n     xs =\n    eval (ExQ \\<phi>) xs\n 2. \\<not> freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>')\n     xs =\n    eval (ExQ \\<phi>) xs", "by(simp_all)"], ["proof (state)\nthis:\n  eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else ExQ \\<phi>') xs =\n  eval (ExQ \\<phi>) xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "finally"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allQ_clearQuantifiers :\n  assumes AllQ : \"\\<And>xs. eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\"\n  shows \"eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "define \\<phi>' where \"\\<phi>' = clearQuantifiers \\<phi>\""], ["proof (state)\nthis:\n  \\<phi>' = clearQuantifiers \\<phi>\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "have \"freeIn 0 \\<phi>' \\<Longrightarrow> (eval (ExQ \\<phi>') xs) = eval (AllQ \\<phi>') xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (ExQ \\<phi>') xs = eval (AllQ \\<phi>') xs", "by (simp add: var_not_in_eval2)"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (ExQ \\<phi>') xs = eval (AllQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (ExQ \\<phi>') xs = eval (AllQ \\<phi>') xs", "have h : \"freeIn 0 \\<phi>' \\<Longrightarrow> (eval (lowerFm 0 1 \\<phi>') xs = eval (AllQ \\<phi>') xs)\""], ["proof (prove)\nusing this:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (ExQ \\<phi>') xs = eval (AllQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (lowerFm 0 1 \\<phi>') xs = eval (AllQ \\<phi>') xs", "using eval_lowerFm"], ["proof (prove)\nusing this:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (ExQ \\<phi>') xs = eval (AllQ \\<phi>') xs\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (lowerFm 0 1 \\<phi>') xs = eval (AllQ \\<phi>') xs", "by simp"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (lowerFm 0 1 \\<phi>') xs = eval (AllQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "have \"eval (clearQuantifiers (AllQ \\<phi>)) xs = \n      eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>') xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs =\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>') xs", "using \\<phi>'_def"], ["proof (prove)\nusing this:\n  \\<phi>' = clearQuantifiers \\<phi>\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs =\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>') xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllQ \\<phi>)) xs =\n  eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "also"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllQ \\<phi>)) xs =\n  eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>') xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "have \"... = eval (AllQ \\<phi>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>')\n     xs =\n    eval (AllQ \\<phi>) xs", "apply(cases \"freeIn 0 \\<phi>'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>')\n     xs =\n    eval (AllQ \\<phi>) xs\n 2. \\<not> freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>')\n     xs =\n    eval (AllQ \\<phi>) xs", "using h AllQ \\<phi>'_def"], ["proof (prove)\nusing this:\n  freeIn 0 \\<phi>' \\<Longrightarrow>\n  eval (lowerFm 0 1 \\<phi>') xs = eval (AllQ \\<phi>') xs\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n  \\<phi>' = clearQuantifiers \\<phi>\n\ngoal (2 subgoals):\n 1. freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>')\n     xs =\n    eval (AllQ \\<phi>) xs\n 2. \\<not> freeIn 0 \\<phi>' \\<Longrightarrow>\n    eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>')\n     xs =\n    eval (AllQ \\<phi>) xs", "by(simp_all)"], ["proof (state)\nthis:\n  eval (if freeIn 0 \\<phi>' then lowerFm 0 1 \\<phi>' else AllQ \\<phi>') xs =\n  eval (AllQ \\<phi>) xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "finally"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clearQuantifiers_eval : \"eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs", "proof(induction \\<phi> arbitrary : xs)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x xs. eval (clearQuantifiers (fm.Atom x)) xs = eval (fm.Atom x) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 8. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 10. \\<And>x1 \\<phi> xs.\n        (\\<And>xs.\n            eval (clearQuantifiers \\<phi>) xs =\n            eval \\<phi> xs) \\<Longrightarrow>\n        eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n        eval (AllN x1 \\<phi>) xs", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x xs. eval (clearQuantifiers (fm.Atom x)) xs = eval (fm.Atom x) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 8. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 10. \\<And>x1 \\<phi> xs.\n        (\\<And>xs.\n            eval (clearQuantifiers \\<phi>) xs =\n            eval \\<phi> xs) \\<Longrightarrow>\n        eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n        eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (fm.Atom x)) xs = eval (fm.Atom x) xs", "using simp_atom_eval"], ["proof (prove)\nusing this:\n  aEval ?a ?xs = eval (simp_atom ?a) ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (fm.Atom x)) xs = eval (fm.Atom x) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (fm.Atom x)) xs = eval (fm.Atom x) xs\n\ngoal (9 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (9 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n    eval (And \\<phi>1 \\<phi>2) xs", "using eval_and"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs\n  eval (and ?a ?b) ?L = (eval ?a ?L \\<and> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n    eval (And \\<phi>1 \\<phi>2) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (And \\<phi>1 \\<phi>2)) xs =\n  eval (And \\<phi>1 \\<phi>2) xs\n\ngoal (8 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (8 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (clearQuantifiers \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n    eval (Or \\<phi>1 \\<phi>2) xs", "using eval_or"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (clearQuantifiers \\<phi>2) ?xs = eval \\<phi>2 ?xs\n  eval (or ?a ?b) ?L = (eval ?a ?L \\<or> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n    eval (Or \\<phi>1 \\<phi>2) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (Or \\<phi>1 \\<phi>2)) xs =\n  eval (Or \\<phi>1 \\<phi>2) xs\n\ngoal (7 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (7 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs", "using eval_neg"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs", "by auto"], ["proof (state)\nthis:\n  eval (clearQuantifiers (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (ExQ \\<phi>)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "using exQ_clearQuantifiers"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n  (\\<And>xs.\n      eval (clearQuantifiers ?\\<phi>) xs =\n      eval ?\\<phi> xs) \\<Longrightarrow>\n  eval (clearQuantifiers (ExQ ?\\<phi>)) ?xs = eval (ExQ ?\\<phi>) ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "using allQ_clearQuantifiers"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n  (\\<And>xs.\n      eval (clearQuantifiers ?\\<phi>) xs =\n      eval ?\\<phi> xs) \\<Longrightarrow>\n  eval (clearQuantifiers (AllQ ?\\<phi>)) ?xs = eval (AllQ ?\\<phi>) ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "by simp"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "proof(induction x1 arbitrary:\\<phi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN 0 \\<phi>)) xs = eval (ExN 0 \\<phi>) xs\n 2. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (ExN x1 \\<phi>)) xs =\n                   eval (ExN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n                         eval (ExN (Suc x1) \\<phi>) xs", "case 0"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (ExN 0 \\<phi>)) xs = eval (ExN 0 \\<phi>) xs\n 2. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (ExN x1 \\<phi>)) xs =\n                   eval (ExN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n                         eval (ExN (Suc x1) \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExN 0 \\<phi>)) xs = eval (ExN 0 \\<phi>) xs", "by auto"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExN 0 \\<phi>)) xs = eval (ExN 0 \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (ExN x1 \\<phi>)) xs =\n                   eval (ExN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n                         eval (ExN (Suc x1) \\<phi>) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (ExN x1 \\<phi>)) xs =\n                   eval (ExN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n                         eval (ExN (Suc x1) \\<phi>) xs", "case (Suc x1)"], ["proof (state)\nthis:\n  (\\<And>xs.\n      eval (clearQuantifiers ?\\<phi>) xs =\n      eval ?\\<phi> xs) \\<Longrightarrow>\n  eval (clearQuantifiers (ExN x1 ?\\<phi>)) xs = eval (ExN x1 ?\\<phi>) xs\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (ExN x1 \\<phi>)) xs =\n                   eval (ExN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n                         eval (ExN (Suc x1) \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n    eval (ExN (Suc x1) \\<phi>) xs", "using Suc(1)[of \"ExQ \\<phi>\", OF exQ_clearQuantifiers[OF Suc(2)]]"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers (ExN x1 (ExQ \\<phi>))) xs =\n  eval (ExN x1 (ExQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n    eval (ExN (Suc x1) \\<phi>) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExN x1 (ExQ \\<phi>))) xs =\n    (\\<exists>l.\n        length l = x1 \\<and>\n        (\\<exists>x. eval \\<phi> (x # l @ xs))) \\<Longrightarrow>\n    (\\<exists>l.\n        length l = x1 \\<and> (\\<exists>x. eval \\<phi> (x # l @ xs))) =\n    (\\<exists>l. length l = Suc x1 \\<and> eval \\<phi> (l @ xs))", "using Suc_eq_plus1 \\<open>eval (clearQuantifiers (ExN x1 (ExQ \\<phi>))) xs = eval (ExN x1 (ExQ \\<phi>)) xs\\<close> eval.simps(10) unwrapExist'"], ["proof (prove)\nusing this:\n  Suc ?n = ?n + 1\n  eval (clearQuantifiers (ExN x1 (ExQ \\<phi>))) xs =\n  eval (ExN x1 (ExQ \\<phi>)) xs\n  eval (ExN ?i ?\\<phi>) ?\\<Gamma> =\n  (\\<exists>l. length l = ?i \\<and> eval ?\\<phi> (l @ ?\\<Gamma>))\n  eval (ExN (?j + 1) ?A) ?L = eval (ExN ?j (ExQ ?A)) ?L\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (ExN x1 (ExQ \\<phi>))) xs =\n    (\\<exists>l.\n        length l = x1 \\<and>\n        (\\<exists>x. eval \\<phi> (x # l @ xs))) \\<Longrightarrow>\n    (\\<exists>l.\n        length l = x1 \\<and> (\\<exists>x. eval \\<phi> (x # l @ xs))) =\n    (\\<exists>l. length l = Suc x1 \\<and> eval \\<phi> (l @ xs))", "by presburger"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExN (Suc x1) \\<phi>)) xs =\n  eval (ExN (Suc x1) \\<phi>) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (clearQuantifiers (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n\ngoal (3 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (3 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "proof(induction x1 arbitrary:\\<phi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN 0 \\<phi>)) xs = eval (AllN 0 \\<phi>) xs\n 2. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n                   eval (AllN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n                         eval (AllN (Suc x1) \\<phi>) xs", "case 0"], ["proof (state)\nthis:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       (\\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (clearQuantifiers (AllN 0 \\<phi>)) xs = eval (AllN 0 \\<phi>) xs\n 2. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n                   eval (AllN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n                         eval (AllN (Suc x1) \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllN 0 \\<phi>)) xs = eval (AllN 0 \\<phi>) xs", "by auto"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllN 0 \\<phi>)) xs = eval (AllN 0 \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n                   eval (AllN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n                         eval (AllN (Suc x1) \\<phi>) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n                   eval (AllN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n                         eval (AllN (Suc x1) \\<phi>) xs", "case (Suc x1)"], ["proof (state)\nthis:\n  (\\<And>xs.\n      eval (clearQuantifiers ?\\<phi>) xs =\n      eval ?\\<phi> xs) \\<Longrightarrow>\n  eval (clearQuantifiers (AllN x1 ?\\<phi>)) xs = eval (AllN x1 ?\\<phi>) xs\n  eval (clearQuantifiers \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<lbrakk>\\<And>\\<phi>.\n                   (\\<And>xs.\n                       eval (clearQuantifiers \\<phi>) xs =\n                       eval \\<phi> xs) \\<Longrightarrow>\n                   eval (clearQuantifiers (AllN x1 \\<phi>)) xs =\n                   eval (AllN x1 \\<phi>) xs;\n        \\<And>xs.\n           eval (clearQuantifiers \\<phi>) xs = eval \\<phi> xs\\<rbrakk>\n       \\<Longrightarrow> eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n                         eval (AllN (Suc x1) \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n    eval (AllN (Suc x1) \\<phi>) xs", "using Suc(1)[of \"AllQ \\<phi>\", OF allQ_clearQuantifiers[OF Suc(2)]]"], ["proof (prove)\nusing this:\n  eval (clearQuantifiers (AllN x1 (AllQ \\<phi>))) xs =\n  eval (AllN x1 (AllQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n    eval (AllN (Suc x1) \\<phi>) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllN x1 (AllQ \\<phi>))) xs =\n    (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        (\\<forall>x. eval \\<phi> (x # l @ xs))) \\<Longrightarrow>\n    (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        (\\<forall>x. eval \\<phi> (x # l @ xs))) =\n    (\\<forall>l. length l = Suc x1 \\<longrightarrow> eval \\<phi> (l @ xs))", "using unwrapForall'"], ["proof (prove)\nusing this:\n  eval (AllN (?j + 1) ?A) ?L = eval (AllN ?j (AllQ ?A)) ?L\n\ngoal (1 subgoal):\n 1. eval (clearQuantifiers (AllN x1 (AllQ \\<phi>))) xs =\n    (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        (\\<forall>x. eval \\<phi> (x # l @ xs))) \\<Longrightarrow>\n    (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        (\\<forall>x. eval \\<phi> (x # l @ xs))) =\n    (\\<forall>l. length l = Suc x1 \\<longrightarrow> eval \\<phi> (l @ xs))", "by force"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllN (Suc x1) \\<phi>)) xs =\n  eval (AllN (Suc x1) \\<phi>) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (clearQuantifiers (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. eval (clearQuantifiers TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (clearQuantifiers FalseF) xs = eval FalseF xs", "qed auto"], ["", "lemma  push_forall_eval_AllQ : \"\\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs", "proof(induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<forall>xs. eval (AllQ TrueF) xs = eval (push_forall (AllQ TrueF)) xs\n 2. \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs\n 3. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 8. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 10. \\<And>x1 \\<phi>.\n        \\<forall>xs.\n           eval (AllQ \\<phi>) xs =\n           eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n        \\<forall>xs.\n           eval (AllQ (AllN x1 \\<phi>)) xs =\n           eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case TrueF"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<forall>xs. eval (AllQ TrueF) xs = eval (push_forall (AllQ TrueF)) xs\n 2. \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs\n 3. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 8. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 10. \\<And>x1 \\<phi>.\n        \\<forall>xs.\n           eval (AllQ \\<phi>) xs =\n           eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n        \\<forall>xs.\n           eval (AllQ (AllN x1 \\<phi>)) xs =\n           eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (AllQ TrueF) xs = eval (push_forall (AllQ TrueF)) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ TrueF) xs = eval (push_forall (AllQ TrueF)) xs\n\ngoal (9 subgoals):\n 1. \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs\n 2. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs\n 2. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case FalseF"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs\n 2. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ FalseF) xs = eval (push_forall (AllQ FalseF)) xs\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<forall>xs.\n          eval (AllQ (fm.Atom x)) xs =\n          eval (push_forall (AllQ (fm.Atom x))) xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (fm.Atom x)) xs = eval (push_forall (AllQ (fm.Atom x))) xs", "using aEval_lowerAtom eval.simps(1) eval.simps(8) push_forall.simps(11)"], ["proof (prove)\nusing this:\n  freeIn 0 (fm.Atom ?A) \\<Longrightarrow>\n  aEval ?A (?x # ?L) = aEval (lowerAtom 0 1 ?A) ?L\n  eval (fm.Atom ?a) ?\\<Gamma> = aEval ?a ?\\<Gamma>\n  eval (AllQ ?\\<phi>) ?\\<Gamma> = (\\<forall>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  push_forall (AllQ (fm.Atom ?a)) =\n  (if freeIn 0 (fm.Atom ?a) then fm.Atom (lowerAtom 0 1 ?a)\n   else AllQ (fm.Atom ?a))\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (fm.Atom x)) xs = eval (push_forall (AllQ (fm.Atom x))) xs", "by presburger"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (fm.Atom x)) xs = eval (push_forall (AllQ (fm.Atom x))) xs\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>1) xs = eval (push_forall (AllQ \\<phi>1)) xs\n  \\<forall>xs. eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "{"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>1) xs = eval (push_forall (AllQ \\<phi>1)) xs\n  \\<forall>xs. eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "fix xs"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"eval (AllQ (And \\<phi>1 \\<phi>2)) xs = (\\<forall>x. eval \\<phi>1 (x#xs) \\<and> eval \\<phi>2 (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n    (\\<forall>x. eval \\<phi>1 (x # xs) \\<and> eval \\<phi>2 (x # xs))", "by simp"], ["proof (state)\nthis:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n  (\\<forall>x. eval \\<phi>1 (x # xs) \\<and> eval \\<phi>2 (x # xs))\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "also"], ["proof (state)\nthis:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n  (\\<forall>x. eval \\<phi>1 (x # xs) \\<and> eval \\<phi>2 (x # xs))\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"... = ((\\<forall>x. eval \\<phi>1 (x#xs)) \\<and> (\\<forall>x. eval \\<phi>2 (x#xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. eval \\<phi>1 (x # xs) \\<and> eval \\<phi>2 (x # xs)) =\n    ((\\<forall>x. eval \\<phi>1 (x # xs)) \\<and>\n     (\\<forall>x. eval \\<phi>2 (x # xs)))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x. eval \\<phi>1 (x # xs) \\<and> eval \\<phi>2 (x # xs)) =\n  ((\\<forall>x. eval \\<phi>1 (x # xs)) \\<and>\n   (\\<forall>x. eval \\<phi>2 (x # xs)))\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "also"], ["proof (state)\nthis:\n  (\\<forall>x. eval \\<phi>1 (x # xs) \\<and> eval \\<phi>2 (x # xs)) =\n  ((\\<forall>x. eval \\<phi>1 (x # xs)) \\<and>\n   (\\<forall>x. eval \\<phi>2 (x # xs)))\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"... = eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x. eval \\<phi>1 (x # xs)) \\<and>\n     (\\<forall>x. eval \\<phi>2 (x # xs))) =\n    eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs", "using And eval_and"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval (AllQ \\<phi>1) xs = eval (push_forall (AllQ \\<phi>1)) xs\n  \\<forall>xs. eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs\n  eval (and ?a ?b) ?L = (eval ?a ?L \\<and> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. ((\\<forall>x. eval \\<phi>1 (x # xs)) \\<and>\n     (\\<forall>x. eval \\<phi>2 (x # xs))) =\n    eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs", "by(simp)"], ["proof (state)\nthis:\n  ((\\<forall>x. eval \\<phi>1 (x # xs)) \\<and>\n   (\\<forall>x. eval \\<phi>2 (x # xs))) =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "finally"], ["proof (chain)\npicking this:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs", "have \"eval (AllQ (And \\<phi>1 \\<phi>2)) xs = eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs\""], ["proof (prove)\nusing this:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs\n\ngoal (1 subgoal):\n 1. eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n    eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs", "by simp"], ["proof (state)\nthis:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "}"], ["proof (state)\nthis:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) ?xs2", "show ?case"], ["proof (prove)\nusing this:\n  eval (AllQ (And \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (And \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (And \\<phi>1 \\<phi>2))) xs\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>1) xs = eval (push_forall (AllQ \\<phi>1)) xs\n  \\<forall>xs. eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval (AllQ \\<phi>1) xs =\n                   eval (push_forall (AllQ \\<phi>1)) xs;\n        \\<forall>xs.\n           eval (AllQ \\<phi>2) xs =\n           eval (push_forall (AllQ \\<phi>2)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                            eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n                             xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval (AllQ \\<phi>1) xs = eval (push_forall (AllQ \\<phi>1)) xs\n  \\<forall>xs. eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval (AllQ \\<phi>1) xs = eval (push_forall (AllQ \\<phi>1)) xs\n  \\<forall>xs. eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "proof(cases \"freeIn 0 \\<phi>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "case True"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  freeIn 0 \\<phi>1", "have h : \"freeIn 0 \\<phi>1\""], ["proof (prove)\nusing this:\n  freeIn 0 \\<phi>1\n\ngoal (1 subgoal):\n 1. freeIn 0 \\<phi>1", "by simp"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  freeIn 0 \\<phi>1", "show ?thesis"], ["proof (prove)\nusing this:\n  freeIn 0 \\<phi>1\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "proof(cases \"freeIn 0 \\<phi>2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "case True"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "{"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "have \"\\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "using eval_lowerFm h eval.simps(7)"], ["proof (prove)\nusing this:\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n  freeIn 0 \\<phi>1\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "have h1 : \"\\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\""], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "using h var_not_in_eval2"], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n  freeIn 0 \\<phi>1\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "have \"\\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "using eval_lowerFm True eval.simps(7)"], ["proof (prove)\nusing this:\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n  freeIn 0 \\<phi>2\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "have h2 : \"\\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\""], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "using True var_not_in_eval2"], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n  freeIn 0 \\<phi>2\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "have \"eval (AllQ (Or \\<phi>1 \\<phi>2)) xs = eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n    eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by(simp add:h h1 h2 True eval_or)"], ["proof (state)\nthis:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "}"], ["proof (state)\nthis:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "case False"], ["proof (state)\nthis:\n  \\<not> freeIn 0 \\<phi>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "{"], ["proof (state)\nthis:\n  \\<not> freeIn 0 \\<phi>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "have \"\\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "using eval_lowerFm h eval.simps(7)"], ["proof (prove)\nusing this:\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n  freeIn 0 \\<phi>1\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "have \"\\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\""], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "using True var_not_in_eval2"], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n  freeIn 0 \\<phi>1\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs", "have \"eval (AllQ (Or \\<phi>1 \\<phi>2)) xs = eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\""], ["proof (prove)\nusing this:\n  \\<forall>x. eval \\<phi>1 (x # xs) = eval (lowerFm 0 1 \\<phi>1) xs\n\ngoal (1 subgoal):\n 1. eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n    eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by(simp add:h False eval_or)"], ["proof (state)\nthis:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "}"], ["proof (state)\nthis:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "case False"], ["proof (state)\nthis:\n  \\<not> freeIn 0 \\<phi>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<not> freeIn 0 \\<phi>1", "have h : \"\\<not>freeIn 0 \\<phi>1\""], ["proof (prove)\nusing this:\n  \\<not> freeIn 0 \\<phi>1\n\ngoal (1 subgoal):\n 1. \\<not> freeIn 0 \\<phi>1", "by simp"], ["proof (state)\nthis:\n  \\<not> freeIn 0 \\<phi>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xs.\n                eval (AllQ \\<phi>1) xs =\n                eval (push_forall (AllQ \\<phi>1)) xs;\n     \\<forall>xs.\n        eval (AllQ \\<phi>2) xs = eval (push_forall (AllQ \\<phi>2)) xs;\n     \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<not> freeIn 0 \\<phi>1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> freeIn 0 \\<phi>1\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "proof(cases \"freeIn 0 \\<phi>2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "case True"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "{"], ["proof (state)\nthis:\n  freeIn 0 \\<phi>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "have \"\\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "using eval_lowerFm True eval.simps(7)"], ["proof (prove)\nusing this:\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n  freeIn 0 \\<phi>2\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "have \"\\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\""], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "using True var_not_in_eval2"], ["proof (prove)\nusing this:\n  \\<exists>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n  freeIn 0 \\<phi>2\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs", "have \"eval (AllQ (Or \\<phi>1 \\<phi>2)) xs = eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\""], ["proof (prove)\nusing this:\n  \\<forall>x. eval \\<phi>2 (x # xs) = eval (lowerFm 0 1 \\<phi>2) xs\n\ngoal (1 subgoal):\n 1. eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n    eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by(simp add:h True eval_or)"], ["proof (state)\nthis:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "}"], ["proof (state)\nthis:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n 2. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (AllQ (Or \\<phi>1 \\<phi>2)) ?xs2 =\n  eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "case False"], ["proof (state)\nthis:\n  \\<not> freeIn 0 \\<phi>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> freeIn 0 \\<phi>1; \\<not> freeIn 0 \\<phi>2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs.\n                         eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "then"], ["proof (chain)\npicking this:\n  \\<not> freeIn 0 \\<phi>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> freeIn 0 \\<phi>2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n       eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs", "by(simp add:h False eval_or)"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Or \\<phi>1 \\<phi>2)) xs =\n     eval (push_forall (AllQ (Or \\<phi>1 \\<phi>2))) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "{"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "fix xs"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"freeIn 0 (Neg \\<phi>) \\<Longrightarrow> (eval (ExQ (Neg \\<phi>)) xs) = eval (AllQ (Neg \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval (ExQ (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs", "using var_not_in_eval2 eval.simps(7) eval.simps(8)"], ["proof (prove)\nusing this:\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  eval (AllQ ?\\<phi>) ?\\<Gamma> = (\\<forall>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval (ExQ (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n  eval (ExQ (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n  eval (ExQ (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs", "have h : \"freeIn 0 (Neg \\<phi>) \\<Longrightarrow> (eval (lowerFm 0 1 (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs)\""], ["proof (prove)\nusing this:\n  freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n  eval (ExQ (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval (lowerFm 0 1 (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs", "using eval_lowerFm"], ["proof (prove)\nusing this:\n  freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n  eval (ExQ (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval (lowerFm 0 1 (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n  eval (lowerFm 0 1 (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"eval (push_forall (AllQ (Neg \\<phi>))) xs = \n      eval (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>) else AllQ (Neg \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (push_forall (AllQ (Neg \\<phi>))) xs =\n    eval\n     (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n      else AllQ (Neg \\<phi>))\n     xs", "by simp"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (Neg \\<phi>))) xs =\n  eval\n   (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n    else AllQ (Neg \\<phi>))\n   xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "also"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (Neg \\<phi>))) xs =\n  eval\n   (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n    else AllQ (Neg \\<phi>))\n   xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"... = eval (AllQ (Neg \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n      else AllQ (Neg \\<phi>))\n     xs =\n    eval (AllQ (Neg \\<phi>)) xs", "apply(cases \"freeIn 0 (Neg \\<phi>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n      else AllQ (Neg \\<phi>))\n     xs =\n    eval (AllQ (Neg \\<phi>)) xs\n 2. \\<not> freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n      else AllQ (Neg \\<phi>))\n     xs =\n    eval (AllQ (Neg \\<phi>)) xs", "using h"], ["proof (prove)\nusing this:\n  freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n  eval (lowerFm 0 1 (Neg \\<phi>)) xs = eval (AllQ (Neg \\<phi>)) xs\n\ngoal (2 subgoals):\n 1. freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n      else AllQ (Neg \\<phi>))\n     xs =\n    eval (AllQ (Neg \\<phi>)) xs\n 2. \\<not> freeIn 0 (Neg \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n      else AllQ (Neg \\<phi>))\n     xs =\n    eval (AllQ (Neg \\<phi>)) xs", "by(simp_all)"], ["proof (state)\nthis:\n  eval\n   (if freeIn 0 (Neg \\<phi>) then lowerFm 0 1 (Neg \\<phi>)\n    else AllQ (Neg \\<phi>))\n   xs =\n  eval (AllQ (Neg \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "finally"], ["proof (chain)\npicking this:\n  eval (push_forall (AllQ (Neg \\<phi>))) xs = eval (AllQ (Neg \\<phi>)) xs", "have \"eval (push_forall (AllQ (Neg \\<phi>))) xs = eval (AllQ (Neg \\<phi>)) xs\""], ["proof (prove)\nusing this:\n  eval (push_forall (AllQ (Neg \\<phi>))) xs = eval (AllQ (Neg \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. eval (push_forall (AllQ (Neg \\<phi>))) xs = eval (AllQ (Neg \\<phi>)) xs", "by simp"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (Neg \\<phi>))) xs = eval (AllQ (Neg \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "}"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (Neg \\<phi>))) ?xs2 =\n  eval (AllQ (Neg \\<phi>)) ?xs2\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (Neg \\<phi>)) xs =\n          eval (push_forall (AllQ (Neg \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  eval (push_forall (AllQ (Neg \\<phi>))) ?xs2 =\n  eval (AllQ (Neg \\<phi>)) ?xs2", "show ?case"], ["proof (prove)\nusing this:\n  eval (push_forall (AllQ (Neg \\<phi>))) ?xs2 =\n  eval (AllQ (Neg \\<phi>)) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (Neg \\<phi>)) xs =\n       eval (push_forall (AllQ (Neg \\<phi>))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (Neg \\<phi>)) xs = eval (push_forall (AllQ (Neg \\<phi>))) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (ExQ \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "{"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "fix xs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"freeIn 0 (ExQ \\<phi>) \\<Longrightarrow> (eval (ExQ (ExQ \\<phi>)) xs) = eval (AllQ (ExQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval (ExQ (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs", "using var_not_in_eval2 eval.simps(7) eval.simps(8)"], ["proof (prove)\nusing this:\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  eval (AllQ ?\\<phi>) ?\\<Gamma> = (\\<forall>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval (ExQ (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs", "have h : \"freeIn 0 (ExQ \\<phi>) \\<Longrightarrow> (eval (lowerFm 0 1 (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs)\""], ["proof (prove)\nusing this:\n  freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval (lowerFm 0 1 (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs", "using eval_lowerFm"], ["proof (prove)\nusing this:\n  freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval (lowerFm 0 1 (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n  eval (lowerFm 0 1 (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"eval (push_forall (AllQ (ExQ \\<phi>))) xs = \n      eval (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>) else AllQ (ExQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (push_forall (AllQ (ExQ \\<phi>))) xs =\n    eval\n     (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n      else AllQ (ExQ \\<phi>))\n     xs", "by simp"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (ExQ \\<phi>))) xs =\n  eval\n   (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n    else AllQ (ExQ \\<phi>))\n   xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "also"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (ExQ \\<phi>))) xs =\n  eval\n   (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n    else AllQ (ExQ \\<phi>))\n   xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"... = eval (AllQ (ExQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n      else AllQ (ExQ \\<phi>))\n     xs =\n    eval (AllQ (ExQ \\<phi>)) xs", "apply(cases \"freeIn 0 (ExQ \\<phi>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n      else AllQ (ExQ \\<phi>))\n     xs =\n    eval (AllQ (ExQ \\<phi>)) xs\n 2. \\<not> freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n      else AllQ (ExQ \\<phi>))\n     xs =\n    eval (AllQ (ExQ \\<phi>)) xs", "using h"], ["proof (prove)\nusing this:\n  freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n  eval (lowerFm 0 1 (ExQ \\<phi>)) xs = eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (2 subgoals):\n 1. freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n      else AllQ (ExQ \\<phi>))\n     xs =\n    eval (AllQ (ExQ \\<phi>)) xs\n 2. \\<not> freeIn 0 (ExQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n      else AllQ (ExQ \\<phi>))\n     xs =\n    eval (AllQ (ExQ \\<phi>)) xs", "by(simp_all)"], ["proof (state)\nthis:\n  eval\n   (if freeIn 0 (ExQ \\<phi>) then lowerFm 0 1 (ExQ \\<phi>)\n    else AllQ (ExQ \\<phi>))\n   xs =\n  eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "finally"], ["proof (chain)\npicking this:\n  eval (push_forall (AllQ (ExQ \\<phi>))) xs = eval (AllQ (ExQ \\<phi>)) xs", "have \"eval (push_forall (AllQ (ExQ \\<phi>))) xs = eval (AllQ (ExQ \\<phi>)) xs\""], ["proof (prove)\nusing this:\n  eval (push_forall (AllQ (ExQ \\<phi>))) xs = eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. eval (push_forall (AllQ (ExQ \\<phi>))) xs = eval (AllQ (ExQ \\<phi>)) xs", "by simp"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (ExQ \\<phi>))) xs = eval (AllQ (ExQ \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "}"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (ExQ \\<phi>))) ?xs2 =\n  eval (AllQ (ExQ \\<phi>)) ?xs2\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExQ \\<phi>)) xs =\n          eval (push_forall (AllQ (ExQ \\<phi>))) xs\n 2. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  eval (push_forall (AllQ (ExQ \\<phi>))) ?xs2 =\n  eval (AllQ (ExQ \\<phi>)) ?xs2", "show ?case"], ["proof (prove)\nusing this:\n  eval (push_forall (AllQ (ExQ \\<phi>))) ?xs2 =\n  eval (AllQ (ExQ \\<phi>)) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (ExQ \\<phi>)) xs =\n       eval (push_forall (AllQ (ExQ \\<phi>))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (ExQ \\<phi>)) xs = eval (push_forall (AllQ (ExQ \\<phi>))) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "{"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "fix xs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"freeIn 0 (AllQ \\<phi>) \\<Longrightarrow> (eval (ExQ (AllQ \\<phi>)) xs) = eval (AllQ (AllQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval (ExQ (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs", "using var_not_in_eval2 eval.simps(7) eval.simps(8)"], ["proof (prove)\nusing this:\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  eval (AllQ ?\\<phi>) ?\\<Gamma> = (\\<forall>x. eval ?\\<phi> (x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval (ExQ (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs", "have h : \"freeIn 0 (AllQ \\<phi>) \\<Longrightarrow> (eval (lowerFm 0 1 (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs)\""], ["proof (prove)\nusing this:\n  freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval (lowerFm 0 1 (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs", "using eval_lowerFm"], ["proof (prove)\nusing this:\n  freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n  eval (ExQ (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n\ngoal (1 subgoal):\n 1. freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval (lowerFm 0 1 (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n  eval (lowerFm 0 1 (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"eval (push_forall (AllQ (AllQ \\<phi>))) xs = \n      eval (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>) else AllQ (AllQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (push_forall (AllQ (AllQ \\<phi>))) xs =\n    eval\n     (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n      else AllQ (AllQ \\<phi>))\n     xs", "by simp"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (AllQ \\<phi>))) xs =\n  eval\n   (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n    else AllQ (AllQ \\<phi>))\n   xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "also"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (AllQ \\<phi>))) xs =\n  eval\n   (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n    else AllQ (AllQ \\<phi>))\n   xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "have \"... = eval (AllQ (AllQ \\<phi>)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n      else AllQ (AllQ \\<phi>))\n     xs =\n    eval (AllQ (AllQ \\<phi>)) xs", "apply(cases \"freeIn 0 (AllQ \\<phi>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n      else AllQ (AllQ \\<phi>))\n     xs =\n    eval (AllQ (AllQ \\<phi>)) xs\n 2. \\<not> freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n      else AllQ (AllQ \\<phi>))\n     xs =\n    eval (AllQ (AllQ \\<phi>)) xs", "using h AllQ"], ["proof (prove)\nusing this:\n  freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n  eval (lowerFm 0 1 (AllQ \\<phi>)) xs = eval (AllQ (AllQ \\<phi>)) xs\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (2 subgoals):\n 1. freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n      else AllQ (AllQ \\<phi>))\n     xs =\n    eval (AllQ (AllQ \\<phi>)) xs\n 2. \\<not> freeIn 0 (AllQ \\<phi>) \\<Longrightarrow>\n    eval\n     (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n      else AllQ (AllQ \\<phi>))\n     xs =\n    eval (AllQ (AllQ \\<phi>)) xs", "by(simp_all)"], ["proof (state)\nthis:\n  eval\n   (if freeIn 0 (AllQ \\<phi>) then lowerFm 0 1 (AllQ \\<phi>)\n    else AllQ (AllQ \\<phi>))\n   xs =\n  eval (AllQ (AllQ \\<phi>)) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "finally"], ["proof (chain)\npicking this:\n  eval (push_forall (AllQ (AllQ \\<phi>))) xs = eval (AllQ (AllQ \\<phi>)) xs", "have \"eval (push_forall (AllQ (AllQ \\<phi>))) xs = eval (AllQ (AllQ \\<phi>)) xs\""], ["proof (prove)\nusing this:\n  eval (push_forall (AllQ (AllQ \\<phi>))) xs = eval (AllQ (AllQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. eval (push_forall (AllQ (AllQ \\<phi>))) xs =\n    eval (AllQ (AllQ \\<phi>)) xs", "by simp"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (AllQ \\<phi>))) xs = eval (AllQ (AllQ \\<phi>)) xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "}"], ["proof (state)\nthis:\n  eval (push_forall (AllQ (AllQ \\<phi>))) ?xs2 =\n  eval (AllQ (AllQ \\<phi>)) ?xs2\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllQ \\<phi>)) xs =\n          eval (push_forall (AllQ (AllQ \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 3. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  eval (push_forall (AllQ (AllQ \\<phi>))) ?xs2 =\n  eval (AllQ (AllQ \\<phi>)) ?xs2", "show ?case"], ["proof (prove)\nusing this:\n  eval (push_forall (AllQ (AllQ \\<phi>))) ?xs2 =\n  eval (AllQ (AllQ \\<phi>)) ?xs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (AllQ \\<phi>)) xs =\n       eval (push_forall (AllQ (AllQ \\<phi>))) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (AllQ \\<phi>)) xs =\n     eval (push_forall (AllQ (AllQ \\<phi>))) xs\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (ExN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n 2. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (ExN x1 \\<phi>)) xs =\n       eval (push_forall (AllQ (ExN x1 \\<phi>))) xs", "using eval.simps(7) eval.simps(8) eval_lowerFm push_forall.simps(17) var_not_in_eval2"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  eval (AllQ ?\\<phi>) ?\\<Gamma> = (\\<forall>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n  push_forall (AllQ (ExN ?v ?va)) =\n  (if freeIn 0 (ExN ?v ?va) then lowerFm 0 1 (ExN ?v ?va)\n   else AllQ (ExN ?v ?va))\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (ExN x1 \\<phi>)) xs =\n       eval (push_forall (AllQ (ExN x1 \\<phi>))) xs", "by presburger"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (ExN x1 \\<phi>)) xs =\n     eval (push_forall (AllQ (ExN x1 \\<phi>))) xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs =\n          eval (push_forall (AllQ \\<phi>)) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ (AllN x1 \\<phi>)) xs =\n          eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (AllN x1 \\<phi>)) xs =\n       eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "using eval.simps(7) eval.simps(8) eval_lowerFm push_forall.simps(18) var_not_in_eval2"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n  eval (ExQ ?\\<phi>) ?\\<Gamma> = (\\<exists>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  eval (AllQ ?\\<phi>) ?\\<Gamma> = (\\<forall>x. eval ?\\<phi> (x # ?\\<Gamma>))\n  freeIn 0 ?F \\<Longrightarrow>\n  \\<forall>xs. eval (lowerFm 0 1 ?F) xs = eval (ExQ ?F) xs\n  push_forall (AllQ (AllN ?v ?va)) =\n  (if freeIn 0 (AllN ?v ?va) then lowerFm 0 1 (AllN ?v ?va)\n   else AllQ (AllN ?v ?va))\n  \\<forall>L.\n     freeIn 0 ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (x # L)) = (\\<forall>x. eval ?\\<phi> (x # L))\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (AllQ (AllN x1 \\<phi>)) xs =\n       eval (push_forall (AllQ (AllN x1 \\<phi>))) xs", "by presburger"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (AllQ (AllN x1 \\<phi>)) xs =\n     eval (push_forall (AllQ (AllN x1 \\<phi>))) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma push_forall_eval : \"\\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs", "proof(induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>x.\n       \\<forall>xs. eval (fm.Atom x) xs = eval (push_forall (fm.Atom x)) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (And \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (And \\<phi>1 \\<phi>2)) xs\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 8. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 10. \\<And>x1 \\<phi>.\n        \\<forall>xs.\n           eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n        \\<forall>xs.\n           eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>x.\n       \\<forall>xs. eval (fm.Atom x) xs = eval (push_forall (fm.Atom x)) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (And \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (And \\<phi>1 \\<phi>2)) xs\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 8. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 10. \\<And>x1 \\<phi>.\n        \\<forall>xs.\n           eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n        \\<forall>xs.\n           eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (fm.Atom x) xs = eval (push_forall (fm.Atom x)) xs", "using simp_atom_eval"], ["proof (prove)\nusing this:\n  aEval ?a ?xs = eval (simp_atom ?a) ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (fm.Atom x) xs = eval (push_forall (fm.Atom x)) xs", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs. eval (fm.Atom x) xs = eval (push_forall (fm.Atom x)) xs\n\ngoal (9 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (And \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (And \\<phi>1 \\<phi>2)) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (And \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (And \\<phi>1 \\<phi>2)) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\n\ngoal (9 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (And \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (And \\<phi>1 \\<phi>2)) xs\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 7. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 9. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (And \\<phi>1 \\<phi>2) xs =\n       eval (push_forall (And \\<phi>1 \\<phi>2)) xs", "using eval_and"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\n  eval (and ?a ?b) ?L = (eval ?a ?L \\<and> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (And \\<phi>1 \\<phi>2) xs =\n       eval (push_forall (And \\<phi>1 \\<phi>2)) xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (And \\<phi>1 \\<phi>2) xs =\n     eval (push_forall (And \\<phi>1 \\<phi>2)) xs\n\ngoal (8 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\n\ngoal (8 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>xs.\n                   eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs;\n        \\<forall>xs.\n           eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs.\n                            eval (Or \\<phi>1 \\<phi>2) xs =\n                            eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 6. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 8. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (Or \\<phi>1 \\<phi>2) xs =\n       eval (push_forall (Or \\<phi>1 \\<phi>2)) xs", "using eval_or"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi>1 xs = eval (push_forall \\<phi>1) xs\n  \\<forall>xs. eval \\<phi>2 xs = eval (push_forall \\<phi>2) xs\n  eval (or ?a ?b) ?L = (eval ?a ?L \\<or> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (Or \\<phi>1 \\<phi>2) xs =\n       eval (push_forall (Or \\<phi>1 \\<phi>2)) xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (Or \\<phi>1 \\<phi>2) xs =\n     eval (push_forall (Or \\<phi>1 \\<phi>2)) xs\n\ngoal (7 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n\ngoal (7 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 5. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 7. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs", "using eval_neg"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs. eval (Neg \\<phi>) xs = eval (push_forall (Neg \\<phi>)) xs\n\ngoal (6 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n\ngoal (6 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 6. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs", "using push_forall_eval_AllQ"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n  \\<forall>xs. eval (AllQ ?\\<phi>) xs = eval (push_forall (AllQ ?\\<phi>)) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs", "by blast"], ["proof (state)\nthis:\n  \\<forall>xs. eval (AllQ \\<phi>) xs = eval (push_forall (AllQ \\<phi>)) xs\n\ngoal (5 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n\ngoal (5 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n 5. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs", "using eval.simps(10) push_forall.simps(7)"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval \\<phi> xs = eval (push_forall \\<phi>) xs\n  eval (ExN ?i ?\\<phi>) ?\\<Gamma> =\n  (\\<exists>l. length l = ?i \\<and> eval ?\\<phi> (l @ ?\\<Gamma>))\n  push_forall (ExN ?i ?\\<phi>) = ExN ?i (push_forall ?\\<phi>)\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs", "by presburger"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (ExN x1 \\<phi>) xs = eval (push_forall (ExN x1 \\<phi>)) xs\n\ngoal (4 subgoals):\n 1. \\<forall>xs. eval TrueF xs = eval (push_forall TrueF) xs\n 2. \\<forall>xs. eval FalseF xs = eval (push_forall FalseF) xs\n 3. \\<And>\\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExQ \\<phi>) xs = eval (push_forall (ExQ \\<phi>)) xs\n 4. \\<And>x1 \\<phi>.\n       \\<forall>xs.\n          eval \\<phi> xs = eval (push_forall \\<phi>) xs \\<Longrightarrow>\n       \\<forall>xs.\n          eval (AllN x1 \\<phi>) xs = eval (push_forall (AllN x1 \\<phi>)) xs", "qed auto"], ["", "lemma map_fm_binders_negation_free : \n  assumes \"negation_free \\<phi>\"\n  shows \"negation_free (map_fm_binders f \\<phi> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (map_fm_binders f \\<phi> n)", "using assms"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n\ngoal (1 subgoal):\n 1. negation_free (map_fm_binders f \\<phi> n)", "apply(induction \\<phi> arbitrary : n)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>n.\n       negation_free TrueF \\<Longrightarrow>\n       negation_free (map_fm_binders f TrueF n)\n 2. \\<And>n.\n       negation_free FalseF \\<Longrightarrow>\n       negation_free (map_fm_binders f FalseF n)\n 3. \\<And>x n.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (map_fm_binders f (fm.Atom x) n)\n 4. \\<And>\\<phi>1 \\<phi>2 n.\n       \\<lbrakk>\\<And>n.\n                   negation_free \\<phi>1 \\<Longrightarrow>\n                   negation_free (map_fm_binders f \\<phi>1 n);\n        \\<And>n.\n           negation_free \\<phi>2 \\<Longrightarrow>\n           negation_free (map_fm_binders f \\<phi>2 n);\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (map_fm_binders f (And \\<phi>1 \\<phi>2) n)\n 5. \\<And>\\<phi>1 \\<phi>2 n.\n       \\<lbrakk>\\<And>n.\n                   negation_free \\<phi>1 \\<Longrightarrow>\n                   negation_free (map_fm_binders f \\<phi>1 n);\n        \\<And>n.\n           negation_free \\<phi>2 \\<Longrightarrow>\n           negation_free (map_fm_binders f \\<phi>2 n);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (map_fm_binders f (Or \\<phi>1 \\<phi>2) n)\n 6. \\<And>\\<phi> n.\n       \\<lbrakk>\\<And>n.\n                   negation_free \\<phi> \\<Longrightarrow>\n                   negation_free (map_fm_binders f \\<phi> n);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (map_fm_binders f (Neg \\<phi>) n)\n 7. \\<And>\\<phi> n.\n       \\<lbrakk>\\<And>n.\n                   negation_free \\<phi> \\<Longrightarrow>\n                   negation_free (map_fm_binders f \\<phi> n);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (map_fm_binders f (ExQ \\<phi>) n)\n 8. \\<And>\\<phi> n.\n       \\<lbrakk>\\<And>n.\n                   negation_free \\<phi> \\<Longrightarrow>\n                   negation_free (map_fm_binders f \\<phi> n);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (map_fm_binders f (AllQ \\<phi>) n)\n 9. \\<And>x1 \\<phi> n.\n       \\<lbrakk>\\<And>n.\n                   negation_free \\<phi> \\<Longrightarrow>\n                   negation_free (map_fm_binders f \\<phi> n);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (map_fm_binders f (ExN x1 \\<phi>) n)\n 10. \\<And>x1 \\<phi> n.\n        \\<lbrakk>\\<And>n.\n                    negation_free \\<phi> \\<Longrightarrow>\n                    negation_free (map_fm_binders f \\<phi> n);\n         negation_free (AllN x1 \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> negation_free\n                           (map_fm_binders f (AllN x1 \\<phi>) n)", "by auto"], ["", "lemma negation_free_and : \n  assumes \"negation_free \\<phi>\"\n  assumes \"negation_free \\<psi>\"\n  shows \"negation_free (and \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (and \\<phi> \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n  negation_free \\<psi>\n\ngoal (1 subgoal):\n 1. negation_free (and \\<phi> \\<psi>)", "unfolding and_def"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n  negation_free \\<psi>\n\ngoal (1 subgoal):\n 1. negation_free\n     (if \\<phi> = TrueF then \\<psi>\n      else if \\<psi> = TrueF then \\<phi>\n           else if \\<phi> = FalseF \\<or> \\<psi> = FalseF then FalseF\n                else And \\<phi> \\<psi>)", "by simp"], ["", "lemma negation_free_or : \n  assumes \"negation_free \\<phi>\"\n  assumes \"negation_free \\<psi>\"\n  shows \"negation_free (or \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (or \\<phi> \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n  negation_free \\<psi>\n\ngoal (1 subgoal):\n 1. negation_free (or \\<phi> \\<psi>)", "unfolding or_def"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n  negation_free \\<psi>\n\ngoal (1 subgoal):\n 1. negation_free\n     (if \\<phi> = FalseF then \\<psi>\n      else if \\<psi> = FalseF then \\<phi>\n           else if \\<phi> = TrueF \\<or> \\<psi> = TrueF then TrueF\n                else Or \\<phi> \\<psi>)", "by simp"], ["", "lemma push_forall_negation_free_all :\n  assumes \"negation_free \\<phi>\"\n  shows \"negation_free (push_forall (AllQ \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ \\<phi>))", "using assms"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ \\<phi>))", "proof(induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                 negation_free (push_forall (AllQ \\<phi>));\n         negation_free (AllN x1 \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> negation_free\n                           (push_forall (AllQ (AllN x1 \\<phi>)))", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>1))\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>2))\n  negation_free (And \\<phi>1 \\<phi>2)\n\ngoal (10 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                 negation_free (push_forall (AllQ \\<phi>));\n         negation_free (AllN x1 \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> negation_free\n                           (push_forall (AllQ (AllN x1 \\<phi>)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (And \\<phi>1 \\<phi>2)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free\n     (and (push_forall (AllQ \\<phi>1)) (push_forall (AllQ \\<phi>2)))", "apply(rule negation_free_and)"], ["proof (prove)\ngoal (2 subgoals):\n 1. negation_free (push_forall (AllQ \\<phi>1))\n 2. negation_free (push_forall (AllQ \\<phi>2))", "using And"], ["proof (prove)\nusing this:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>1))\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>2))\n  negation_free (And \\<phi>1 \\<phi>2)\n\ngoal (2 subgoals):\n 1. negation_free (push_forall (AllQ \\<phi>1))\n 2. negation_free (push_forall (AllQ \\<phi>2))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ (And \\<phi>1 \\<phi>2)))\n\ngoal (9 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>1))\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>2))\n  negation_free (Or \\<phi>1 \\<phi>2)\n\ngoal (9 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>1));\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall (AllQ \\<phi>2));\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free\n                          (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (map_fm_binders\n                             (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>1\n                             0)\n                         (map_fm_binders\n                           (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>2 0))\n 2. \\<lbrakk>freeIn 0 \\<phi>2; \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (AllQ \\<phi>1)\n                         (map_fm_binders\n                           (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>2 0))\n 3. \\<lbrakk>\\<not> freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (map_fm_binders\n                             (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>1\n                             0)\n                         (AllQ \\<phi>2))\n 4. \\<lbrakk>\\<not> freeIn 0 \\<phi>2; \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free (or \\<phi>1 \\<phi>2)", "apply(rule negation_free_or)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (map_fm_binders (\\<lambda>a x. lowerAtom x (Suc 0) a)\n                         \\<phi>1 0)\n 2. \\<lbrakk>freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (map_fm_binders (\\<lambda>a x. lowerAtom x (Suc 0) a)\n                         \\<phi>2 0)\n 3. \\<lbrakk>freeIn 0 \\<phi>2; \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (AllQ \\<phi>1)\n                         (map_fm_binders\n                           (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>2 0))\n 4. \\<lbrakk>\\<not> freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (map_fm_binders\n                             (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>1\n                             0)\n                         (AllQ \\<phi>2))\n 5. \\<lbrakk>\\<not> freeIn 0 \\<phi>2; \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free (or \\<phi>1 \\<phi>2)", "using Or map_fm_binders_negation_free negation_free_or"], ["proof (prove)\nusing this:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>1))\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>2))\n  negation_free (Or \\<phi>1 \\<phi>2)\n  negation_free ?\\<phi> \\<Longrightarrow>\n  negation_free (map_fm_binders ?f ?\\<phi> ?n)\n  \\<lbrakk>negation_free ?\\<phi>; negation_free ?\\<psi>\\<rbrakk>\n  \\<Longrightarrow> negation_free (or ?\\<phi> ?\\<psi>)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (map_fm_binders (\\<lambda>a x. lowerAtom x (Suc 0) a)\n                         \\<phi>1 0)\n 2. \\<lbrakk>freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (map_fm_binders (\\<lambda>a x. lowerAtom x (Suc 0) a)\n                         \\<phi>2 0)\n 3. \\<lbrakk>freeIn 0 \\<phi>2; \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (AllQ \\<phi>1)\n                         (map_fm_binders\n                           (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>2 0))\n 4. \\<lbrakk>\\<not> freeIn 0 \\<phi>2; freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free\n                       (or (map_fm_binders\n                             (\\<lambda>a x. lowerAtom x (Suc 0) a) \\<phi>1\n                             0)\n                         (AllQ \\<phi>2))\n 5. \\<lbrakk>\\<not> freeIn 0 \\<phi>2; \\<not> freeIn 0 \\<phi>1\\<rbrakk>\n    \\<Longrightarrow> negation_free (or \\<phi>1 \\<phi>2)", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ (Or \\<phi>1 \\<phi>2)))\n\ngoal (8 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "case (ExQ \\<phi>)"], ["proof (state)\nthis:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExQ \\<phi>)\n\ngoal (8 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExQ \\<phi>)))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExQ \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExQ \\<phi>)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (ExQ \\<phi>)))", "using map_fm_binders_negation_free"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExQ \\<phi>)\n  negation_free ?\\<phi> \\<Longrightarrow>\n  negation_free (map_fm_binders ?f ?\\<phi> ?n)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (ExQ \\<phi>)))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ (ExQ \\<phi>)))\n\ngoal (7 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllQ \\<phi>)\n\ngoal (7 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllQ \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllQ \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllQ \\<phi>)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (AllQ \\<phi>)))", "using map_fm_binders_negation_free"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllQ \\<phi>)\n  negation_free ?\\<phi> \\<Longrightarrow>\n  negation_free (map_fm_binders ?f ?\\<phi> ?n)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (AllQ \\<phi>)))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ (AllQ \\<phi>)))\n\ngoal (6 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExN x1 \\<phi>)\n\ngoal (6 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExN x1 \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExN x1 \\<phi>)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (ExN x1 \\<phi>)))", "using map_fm_binders_negation_free"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (ExN x1 \\<phi>)\n  negation_free ?\\<phi> \\<Longrightarrow>\n  negation_free (map_fm_binders ?f ?\\<phi> ?n)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (ExN x1 \\<phi>)))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ (ExN x1 \\<phi>)))\n\ngoal (5 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllN x1 \\<phi>)\n\ngoal (5 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllN x1 \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllN x1 \\<phi>)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "using map_fm_binders_negation_free"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ \\<phi>))\n  negation_free (AllN x1 \\<phi>)\n  negation_free ?\\<phi> \\<Longrightarrow>\n  negation_free (map_fm_binders ?f ?\\<phi> ?n)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ (AllN x1 \\<phi>)))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ (AllN x1 \\<phi>)))\n\ngoal (4 subgoals):\n 1. negation_free TrueF \\<Longrightarrow>\n    negation_free (push_forall (AllQ TrueF))\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall (AllQ FalseF))\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (AllQ (fm.Atom x)))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall (AllQ \\<phi>));\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ (Neg \\<phi>)))", "qed auto"], ["", "lemma push_forall_negation_free : \n  assumes \"negation_free \\<phi>\"  \n  shows \"negation_free(push_forall \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negation_free (push_forall \\<phi>)", "using assms"], ["proof (prove)\nusing this:\n  negation_free \\<phi>\n\ngoal (1 subgoal):\n 1. negation_free (push_forall \\<phi>)", "proof(induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (And \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                 negation_free (push_forall \\<phi>);\n         negation_free (AllN x1 \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "case (Atom A)"], ["proof (state)\nthis:\n  negation_free (fm.Atom A)\n\ngoal (10 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>x.\n       negation_free (fm.Atom x) \\<Longrightarrow>\n       negation_free (push_forall (fm.Atom x))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (And \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 8. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 10. \\<And>x1 \\<phi>.\n        \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                 negation_free (push_forall \\<phi>);\n         negation_free (AllN x1 \\<phi>)\\<rbrakk>\n        \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  negation_free (fm.Atom A)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free (fm.Atom A)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (fm.Atom A))", "apply(cases A)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>negation_free (fm.Atom A); A = Less x1\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (fm.Atom A))\n 2. \\<And>x2.\n       \\<lbrakk>negation_free (fm.Atom A); A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (fm.Atom A))\n 3. \\<And>x3.\n       \\<lbrakk>negation_free (fm.Atom A); A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (fm.Atom A))\n 4. \\<And>x4.\n       \\<lbrakk>negation_free (fm.Atom A); A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (fm.Atom A))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (fm.Atom A))\n\ngoal (9 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (And \\<phi>1 \\<phi>2))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (And \\<phi>1 \\<phi>2))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>1)\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>2)\n  negation_free (And \\<phi>1 \\<phi>2)\n\ngoal (9 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (And \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (And \\<phi>1 \\<phi>2))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 7. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 9. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>1)\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>2)\n  negation_free (And \\<phi>1 \\<phi>2)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>1)\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>2)\n  negation_free (And \\<phi>1 \\<phi>2)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (And \\<phi>1 \\<phi>2))", "by (auto simp add: and_def)"], ["proof (state)\nthis:\n  negation_free (push_forall (And \\<phi>1 \\<phi>2))\n\ngoal (8 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>1)\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>2)\n  negation_free (Or \\<phi>1 \\<phi>2)\n\ngoal (8 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>negation_free \\<phi>1 \\<Longrightarrow>\n                negation_free (push_forall \\<phi>1);\n        negation_free \\<phi>2 \\<Longrightarrow>\n        negation_free (push_forall \\<phi>2);\n        negation_free (Or \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 6. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 8. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>1)\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>2)\n  negation_free (Or \\<phi>1 \\<phi>2)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi>1 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>1)\n  negation_free \\<phi>2 \\<Longrightarrow>\n  negation_free (push_forall \\<phi>2)\n  negation_free (Or \\<phi>1 \\<phi>2)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (Or \\<phi>1 \\<phi>2))", "by (auto simp add: or_def)"], ["proof (state)\nthis:\n  negation_free (push_forall (Or \\<phi>1 \\<phi>2))\n\ngoal (7 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  negation_free \\<phi> \\<Longrightarrow> negation_free (push_forall \\<phi>)\n  negation_free (AllQ \\<phi>)\n\ngoal (7 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 5. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllQ \\<phi>))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "then"], ["proof (chain)\npicking this:\n  negation_free \\<phi> \\<Longrightarrow> negation_free (push_forall \\<phi>)\n  negation_free (AllQ \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow> negation_free (push_forall \\<phi>)\n  negation_free (AllQ \\<phi>)\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ \\<phi>))", "using push_forall_negation_free_all"], ["proof (prove)\nusing this:\n  negation_free \\<phi> \\<Longrightarrow> negation_free (push_forall \\<phi>)\n  negation_free (AllQ \\<phi>)\n  negation_free ?\\<phi> \\<Longrightarrow>\n  negation_free (push_forall (AllQ ?\\<phi>))\n\ngoal (1 subgoal):\n 1. negation_free (push_forall (AllQ \\<phi>))", "by auto"], ["proof (state)\nthis:\n  negation_free (push_forall (AllQ \\<phi>))\n\ngoal (6 subgoals):\n 1. negation_free TrueF \\<Longrightarrow> negation_free (push_forall TrueF)\n 2. negation_free FalseF \\<Longrightarrow>\n    negation_free (push_forall FalseF)\n 3. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (Neg \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (Neg \\<phi>))\n 4. \\<And>\\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExQ \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExQ \\<phi>))\n 5. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (ExN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (ExN x1 \\<phi>))\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>negation_free \\<phi> \\<Longrightarrow>\n                negation_free (push_forall \\<phi>);\n        negation_free (AllN x1 \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> negation_free (push_forall (AllN x1 \\<phi>))", "qed auto"], ["", "lemma to_list_insertion: \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>(to_list v p)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "have h1 :  \"insertion f p = insertion f (\\<Sum>i\\<le>MPoly_Type.degree p v. isolate_variable_sparse p v i * Var v ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    insertion f\n     (\\<Sum>i\\<le>MPoly_Type.degree p v.\n         isolate_variable_sparse p v i * Var v ^ i)", "using sum_over_zero"], ["proof (prove)\nusing this:\n  ?mp =\n  (\\<Sum>i\\<le>MPoly_Type.degree ?mp ?x.\n      isolate_variable_sparse ?mp ?x i * Var ?x ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    insertion f\n     (\\<Sum>i\\<le>MPoly_Type.degree p v.\n         isolate_variable_sparse p v i * Var v ^ i)", "by auto"], ["proof (state)\nthis:\n  insertion f p =\n  insertion f\n   (\\<Sum>i\\<le>MPoly_Type.degree p v.\n       isolate_variable_sparse p v i * Var v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "have h2 : \"insertion f (Var v) = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Var v) = f v", "by (auto simp: monomials_Var coeff_Var insertion_code)"], ["proof (state)\nthis:\n  insertion f (Var v) = f v\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "define d where \"d = MPoly_Type.degree p v\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p v\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "define g where \"g = (\\<lambda>x. insertion f (isolate_variable_sparse p v x) * f v ^ x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. insertion f (isolate_variable_sparse p v x) * f v ^ x)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "have h3 : \"insertion f (isolate_variable_sparse p v d) * f v ^ d = g d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (isolate_variable_sparse p v d) * f v ^ d = g d", "using g_def"], ["proof (prove)\nusing this:\n  g = (\\<lambda>x. insertion f (isolate_variable_sparse p v x) * f v ^ x)\n\ngoal (1 subgoal):\n 1. insertion f (isolate_variable_sparse p v d) * f v ^ d = g d", "by auto"], ["proof (state)\nthis:\n  insertion f (isolate_variable_sparse p v d) * f v ^ d = g d\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "unfolding h1\n      insertion_sum' insertion_mult insertion_pow h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>MPoly_Type.degree p v.\n        insertion f (isolate_variable_sparse p v i) * f v ^ i) =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>MPoly_Type.degree p v.\n        insertion f (isolate_variable_sparse p v i) * f v ^ i) =\n    sum_list\n     (map ((\\<lambda>(term, i). insertion f term * f v ^ i) \\<circ>\n           (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n       [0..<MPoly_Type.degree p v]) +\n    insertion f (isolate_variable_sparse p v (MPoly_Type.degree p v)) *\n    f v ^ MPoly_Type.degree p v", "unfolding d_def[symmetric] g_def[symmetric]\n      h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {..d} =\n    sum_list\n     (map ((\\<lambda>(term, i). insertion f term * f v ^ i) \\<circ>\n           (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n       [0..<d]) +\n    g d", "proof(induction d)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum g {..0} =\n    sum_list\n     (map ((\\<lambda>a.\n               case a of\n               (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n           (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n       [0..<0]) +\n    g 0\n 2. \\<And>d.\n       sum g {..d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<d]) +\n       g d \\<Longrightarrow>\n       sum g {..Suc d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<Suc d]) +\n       g (Suc d)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum g {..0} =\n    sum_list\n     (map ((\\<lambda>a.\n               case a of\n               (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n           (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n       [0..<0]) +\n    g 0\n 2. \\<And>d.\n       sum g {..d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<d]) +\n       g d \\<Longrightarrow>\n       sum g {..Suc d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<Suc d]) +\n       g (Suc d)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {..0} =\n    sum_list\n     (map ((\\<lambda>a.\n               case a of\n               (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n           (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n       [0..<0]) +\n    g 0", "by auto"], ["proof (state)\nthis:\n  sum g {..0} =\n  sum_list\n   (map ((\\<lambda>a.\n             case a of\n             (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n         (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n     [0..<0]) +\n  g 0\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       sum g {..d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<d]) +\n       g d \\<Longrightarrow>\n       sum g {..Suc d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<Suc d]) +\n       g (Suc d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       sum g {..d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<d]) +\n       g d \\<Longrightarrow>\n       sum g {..Suc d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<Suc d]) +\n       g (Suc d)", "case (Suc d)"], ["proof (state)\nthis:\n  sum g {..d} =\n  sum_list\n   (map ((\\<lambda>a.\n             case a of\n             (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n         (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n     [0..<d]) +\n  g d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       sum g {..d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<d]) +\n       g d \\<Longrightarrow>\n       sum g {..Suc d} =\n       sum_list\n        (map ((\\<lambda>a.\n                  case a of\n                  (term, i) \\<Rightarrow>\n                    insertion f term * f v ^ i) \\<circ>\n              (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n          [0..<Suc d]) +\n       g (Suc d)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {..Suc d} =\n    sum_list\n     (map ((\\<lambda>a.\n               case a of\n               (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n           (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n       [0..<Suc d]) +\n    g (Suc d)", "apply (auto simp add: Suc )"], ["proof (prove)\ngoal (1 subgoal):\n 1. g d = insertion f (isolate_variable_sparse p v d) * f v ^ d", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (isolate_variable_sparse p v d) * f v ^ d =\n    insertion f (isolate_variable_sparse p v d) * f v ^ d", "by auto"], ["proof (state)\nthis:\n  sum g {..Suc d} =\n  sum_list\n   (map ((\\<lambda>a.\n             case a of\n             (term, i) \\<Rightarrow> insertion f term * f v ^ i) \\<circ>\n         (\\<lambda>x. (isolate_variable_sparse p v x, x)))\n     [0..<Suc d]) +\n  g (Suc d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion f p =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_list_p: \"p = sum_list [term * (Var v) ^ i. (term,i)\\<leftarrow>(to_list v p)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "define d where \"d = MPoly_Type.degree p v\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p v\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "have \"(\\<Sum>i\\<le>MPoly_Type.degree p v. isolate_variable_sparse p v i * Var v ^ i) = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>MPoly_Type.degree p v.\n        isolate_variable_sparse p v i * Var v ^ i) =\n    (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "unfolding to_list.simps d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>d. isolate_variable_sparse p v i * Var v ^ i) =\n    (\\<Sum>(term,\n        i)\\<leftarrow>map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n                       [0..<d + 1]. term * Var v ^ i)", "apply(induction d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i\\<le>0. isolate_variable_sparse p v i * Var v ^ i) =\n    (\\<Sum>a\\<leftarrow>map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n                         [0..<\n                          0 +\n                          1]. case a of\n                              (term, i) \\<Rightarrow> term * Var v ^ i)\n 2. \\<And>d.\n       (\\<Sum>i\\<le>d. isolate_variable_sparse p v i * Var v ^ i) =\n       (\\<Sum>a\\<leftarrow>map (\\<lambda>x.\n                                   (isolate_variable_sparse p v x, x))\n                            [0..<\n                             d +\n                             1]. case a of\n                                 (term, i) \\<Rightarrow>\n                                   term * Var v ^ i) \\<Longrightarrow>\n       (\\<Sum>i\\<le>Suc d. isolate_variable_sparse p v i * Var v ^ i) =\n       (\\<Sum>a\\<leftarrow>map (\\<lambda>x.\n                                   (isolate_variable_sparse p v x, x))\n                            [0..<\n                             Suc d +\n                             1]. case a of\n                                 (term, i) \\<Rightarrow> term * Var v ^ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>MPoly_Type.degree p v.\n      isolate_variable_sparse p v i * Var v ^ i) =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>MPoly_Type.degree p v.\n      isolate_variable_sparse p v i * Var v ^ i) =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>MPoly_Type.degree p v.\n      isolate_variable_sparse p v i * Var v ^ i) =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "using sum_over_zero[of p v]"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>MPoly_Type.degree p v.\n      isolate_variable_sparse p v i * Var v ^ i) =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p v.\n      isolate_variable_sparse p v i * Var v ^ i)\n\ngoal (1 subgoal):\n 1. p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)", "by auto"], ["proof (state)\nthis:\n  p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun chophelper :: \"(real mpoly * nat) list \\<Rightarrow> (real mpoly * nat) list \\<Rightarrow> (real mpoly * nat) list * (real mpoly * nat) list\" where\n  \"chophelper [] L = (L,[])\"|\n  \"chophelper ((p,i)#L) R = (if p=0 then chophelper L (R @ [(p,i)]) else (R,(p,i)#L))\""], ["", "lemma preserve :\n  assumes \"(a,b)=chophelper L L'\"\n  shows \"a@b=L'@L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ b = L' @ L", "using assms"], ["proof (prove)\nusing this:\n  (a, b) = chophelper L L'\n\ngoal (1 subgoal):\n 1. a @ b = L' @ L", "proof(induction L arbitrary : a b L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b L'.\n       (a, b) = chophelper [] L' \\<Longrightarrow> a @ b = L' @ []\n 2. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> aa @ b = L' @ a # L", "case Nil"], ["proof (state)\nthis:\n  (a, b) = chophelper [] L'\n\ngoal (2 subgoals):\n 1. \\<And>a b L'.\n       (a, b) = chophelper [] L' \\<Longrightarrow> a @ b = L' @ []\n 2. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> aa @ b = L' @ a # L", "then"], ["proof (chain)\npicking this:\n  (a, b) = chophelper [] L'", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) = chophelper [] L'\n\ngoal (1 subgoal):\n 1. a @ b = L' @ []", "using assms"], ["proof (prove)\nusing this:\n  (a, b) = chophelper [] L'\n  (a, b) = chophelper L L'\n\ngoal (1 subgoal):\n 1. a @ b = L' @ []", "by auto"], ["proof (state)\nthis:\n  a @ b = L' @ []\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> aa @ b = L' @ a # L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> aa @ b = L' @ a # L", "case (Cons A L)"], ["proof (state)\nthis:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> ?a @ ?b = ?L' @ L\n  (a, b) = chophelper (A # L) L'\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> aa @ b = L' @ a # L", "then"], ["proof (chain)\npicking this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> ?a @ ?b = ?L' @ L\n  (a, b) = chophelper (A # L) L'", "show ?case"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> ?a @ ?b = ?L' @ L\n  (a, b) = chophelper (A # L) L'\n\ngoal (1 subgoal):\n 1. a @ b = L' @ A # L", "proof(cases A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (a, b) = chophelper (A # L) L'; A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a @ b = L' @ A # L", "case (Pair p i)"], ["proof (state)\nthis:\n  A = (p, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow>\n                   a @ b = L' @ L;\n        (a, b) = chophelper (A # L) L'; A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a @ b = L' @ A # L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ b = L' @ A # L", "using Cons"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> ?a @ ?b = ?L' @ L\n  (a, b) = chophelper (A # L) L'\n\ngoal (1 subgoal):\n 1. a @ b = L' @ A # L", "unfolding Pair"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> ?a @ ?b = ?L' @ L\n  (a, b) = chophelper ((p, i) # L) L'\n\ngoal (1 subgoal):\n 1. a @ b = L' @ (p, i) # L", "apply(cases \"p=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a b L'.\n                (a, b) = chophelper L L' \\<Longrightarrow> a @ b = L' @ L;\n     (a, b) = chophelper ((p, i) # L) L'; p = 0\\<rbrakk>\n    \\<Longrightarrow> a @ b = L' @ (p, i) # L\n 2. \\<lbrakk>\\<And>a b L'.\n                (a, b) = chophelper L L' \\<Longrightarrow> a @ b = L' @ L;\n     (a, b) = chophelper ((p, i) # L) L'; p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> a @ b = L' @ (p, i) # L", "by auto"], ["proof (state)\nthis:\n  a @ b = L' @ A # L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a @ b = L' @ A # L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compare : \n  assumes \"(a,b)=chophelper L L'\"\n  shows \"chop L = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop L = b", "using assms"], ["proof (prove)\nusing this:\n  (a, b) = chophelper L L'\n\ngoal (1 subgoal):\n 1. chop L = b", "proof(induction L arbitrary : a b L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b L'. (a, b) = chophelper [] L' \\<Longrightarrow> chop [] = b\n 2. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> chop (a # L) = b", "case Nil"], ["proof (state)\nthis:\n  (a, b) = chophelper [] L'\n\ngoal (2 subgoals):\n 1. \\<And>a b L'. (a, b) = chophelper [] L' \\<Longrightarrow> chop [] = b\n 2. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> chop (a # L) = b", "then"], ["proof (chain)\npicking this:\n  (a, b) = chophelper [] L'", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) = chophelper [] L'\n\ngoal (1 subgoal):\n 1. chop [] = b", "by auto"], ["proof (state)\nthis:\n  chop [] = b\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> chop (a # L) = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> chop (a # L) = b", "case (Cons A L)"], ["proof (state)\nthis:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> chop L = ?b\n  (a, b) = chophelper (A # L) L'\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> chop (a # L) = b", "then"], ["proof (chain)\npicking this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> chop L = ?b\n  (a, b) = chophelper (A # L) L'", "show ?case"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> chop L = ?b\n  (a, b) = chophelper (A # L) L'\n\ngoal (1 subgoal):\n 1. chop (A # L) = b", "proof(cases A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (a, b) = chophelper (A # L) L'; A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> chop (A # L) = b", "case (Pair p i)"], ["proof (state)\nthis:\n  A = (p, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b L'.\n                   (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n        (a, b) = chophelper (A # L) L'; A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> chop (A # L) = b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chop (A # L) = b", "using Cons"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> chop L = ?b\n  (a, b) = chophelper (A # L) L'\n\ngoal (1 subgoal):\n 1. chop (A # L) = b", "unfolding Pair"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L ?L' \\<Longrightarrow> chop L = ?b\n  (a, b) = chophelper ((p, i) # L) L'\n\ngoal (1 subgoal):\n 1. chop ((p, i) # L) = b", "apply(cases \"p=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a b L'.\n                (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n     (a, b) = chophelper ((p, i) # L) L'; p = 0\\<rbrakk>\n    \\<Longrightarrow> chop ((p, i) # L) = b\n 2. \\<lbrakk>\\<And>a b L'.\n                (a, b) = chophelper L L' \\<Longrightarrow> chop L = b;\n     (a, b) = chophelper ((p, i) # L) L'; p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> chop ((p, i) # L) = b", "by auto"], ["proof (state)\nthis:\n  chop (A # L) = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chop (A # L) = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allzero:\n  assumes \"\\<forall>(p,i)\\<in>set(L'). p=0\"\n  assumes \"(a,b)=chophelper L L'\"\n  shows \"\\<forall>(p,i)\\<in>set(a). p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(p, i)\\<in>set a. p = 0", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(p, i)\\<in>set L'. p = 0\n  (a, b) = chophelper L L'\n\ngoal (1 subgoal):\n 1. \\<forall>(p, i)\\<in>set a. p = 0", "proof(induction L arbitrary : a b L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b L'.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n        (a, b) = chophelper [] L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0\n 2. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0;\n        \\<forall>(p, i)\\<in>set L'. p = 0;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set aa. p = 0", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper [] L'\n\ngoal (2 subgoals):\n 1. \\<And>a b L'.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n        (a, b) = chophelper [] L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0\n 2. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0;\n        \\<forall>(p, i)\\<in>set L'. p = 0;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set aa. p = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper [] L'", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper [] L'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0;\n        \\<forall>(p, i)\\<in>set L'. p = 0;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set aa. p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0;\n        \\<forall>(p, i)\\<in>set L'. p = 0;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set aa. p = 0", "case (Cons t L)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set ?L'. case a of (p, i) \\<Rightarrow> p = 0;\n   (?a, ?b) = chophelper L ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ?a.\n                       case a of (p, i) \\<Rightarrow> p = 0\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper (t # L) L'\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b L'.\n       \\<lbrakk>\\<And>a b L'.\n                   \\<lbrakk>\\<forall>(p, i)\\<in>set L'. p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(p, i)\\<in>set a. p = 0;\n        \\<forall>(p, i)\\<in>set L'. p = 0;\n        (aa, b) = chophelper (a # L) L'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, i)\\<in>set aa. p = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>a\\<in>set ?L'. case a of (p, i) \\<Rightarrow> p = 0;\n   (?a, ?b) = chophelper L ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ?a.\n                       case a of (p, i) \\<Rightarrow> p = 0\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper (t # L) L'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a\\<in>set ?L'. case a of (p, i) \\<Rightarrow> p = 0;\n   (?a, ?b) = chophelper L ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ?a.\n                       case a of (p, i) \\<Rightarrow> p = 0\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper (t # L) L'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "proof(cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>L' a b.\n                   \\<lbrakk>\\<forall>a\\<in>set L'.\n                               case a of (p, i) \\<Rightarrow> p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>a\\<in>set a.\n  case a of (p, i) \\<Rightarrow> p = 0;\n        \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0;\n        (a, b) = chophelper (t # L) L'; t = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a\\<in>set a.\n                            case a of (p, i) \\<Rightarrow> p = 0", "case (Pair p i)"], ["proof (state)\nthis:\n  t = (p, i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>L' a b.\n                   \\<lbrakk>\\<forall>a\\<in>set L'.\n                               case a of (p, i) \\<Rightarrow> p = 0;\n                    (a, b) = chophelper L L'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>a\\<in>set a.\n  case a of (p, i) \\<Rightarrow> p = 0;\n        \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0;\n        (a, b) = chophelper (t # L) L'; t = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a\\<in>set a.\n                            case a of (p, i) \\<Rightarrow> p = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "proof(cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "have h1: \"\\<forall>x\\<in>set (L' @ [(0, i)]). case x of (p, i) \\<Rightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (L' @ [(0, i)]). case x of (p, i) \\<Rightarrow> p = 0", "using Cons(2)"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (L' @ [(0, i)]). case x of (p, i) \\<Rightarrow> p = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (L' @ [(0, i)]). case x of (p, i) \\<Rightarrow> p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "using Cons(1)[OF h1] Cons(3) True"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L (L' @ [(0, i)]) \\<Longrightarrow>\n  \\<forall>a\\<in>set ?a. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper (t # L) L'\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "unfolding Pair"], ["proof (prove)\nusing this:\n  (?a, ?b) = chophelper L (L' @ [(0, i)]) \\<Longrightarrow>\n  \\<forall>a\\<in>set ?a. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper ((p, i) # L) L'\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "using Cons"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<lbrakk>\\<forall>a\\<in>set ?L'. case a of (p, i) \\<Rightarrow> p = 0;\n   (?a, ?b) = chophelper L ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ?a.\n                       case a of (p, i) \\<Rightarrow> p = 0\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper (t # L) L'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "unfolding Pair"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<lbrakk>\\<forall>a\\<in>set ?L'. case a of (p, i) \\<Rightarrow> p = 0;\n   (?a, ?b) = chophelper L ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ?a.\n                       case a of (p, i) \\<Rightarrow> p = 0\n  \\<forall>a\\<in>set L'. case a of (p, i) \\<Rightarrow> p = 0\n  (a, b) = chophelper ((p, i) # L) L'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separate:\n  assumes \"(a,b)=chophelper (to_list v p) []\"\n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>a] + sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) +\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "using to_list_insertion[of f p v]  preserve[OF assms, symmetric]"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)\n  [] @ to_list v p = a @ b\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) +\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "unfolding List.append.left_neutral"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. insertion f term * f v ^ i)\n  to_list v p = a @ b\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) +\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "by (simp del: to_list.simps)"], ["", "lemma chopped : \n  assumes \"(a,b)=chophelper (to_list v p) []\"\n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "have h1 : \"\\<forall>(p, i)\\<in>set []. p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(p, i)\\<in>set []. p = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>(p, i)\\<in>set []. p = (0::?'a1)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "have \"(\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0", "using allzero[OF h1 assms]"], ["proof (prove)\nusing this:\n  \\<forall>(p, i)\\<in>set a. p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0", "proof(induction a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(p, i)\\<in>set []. p = 0 \\<Longrightarrow>\n    (\\<Sum>(term, i)\\<leftarrow>[]. insertion f term * f v ^ i) = 0\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set a2. p = 0 \\<Longrightarrow>\n                (\\<Sum>(term,\n                    i)\\<leftarrow>a2. insertion f term * f v ^ i) =\n                0;\n        \\<forall>(p, i)\\<in>set (a1 # a2). p = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(term,\n                             i)\\<leftarrow>a1 #\n     a2. insertion f term * f v ^ i) =\n                         0", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (2 subgoals):\n 1. \\<forall>(p, i)\\<in>set []. p = 0 \\<Longrightarrow>\n    (\\<Sum>(term, i)\\<leftarrow>[]. insertion f term * f v ^ i) = 0\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set a2. p = 0 \\<Longrightarrow>\n                (\\<Sum>(term,\n                    i)\\<leftarrow>a2. insertion f term * f v ^ i) =\n                0;\n        \\<forall>(p, i)\\<in>set (a1 # a2). p = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(term,\n                             i)\\<leftarrow>a1 #\n     a2. insertion f term * f v ^ i) =\n                         0", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set []. case a of (p, i) \\<Rightarrow> p = 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>[]. case a of\n                            (term, i) \\<Rightarrow>\n                              insertion f term * f v ^ i) =\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>[]. case a of\n                          (term, i) \\<Rightarrow>\n                            insertion f term * f v ^ i) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set a2. p = 0 \\<Longrightarrow>\n                (\\<Sum>(term,\n                    i)\\<leftarrow>a2. insertion f term * f v ^ i) =\n                0;\n        \\<forall>(p, i)\\<in>set (a1 # a2). p = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(term,\n                             i)\\<leftarrow>a1 #\n     a2. insertion f term * f v ^ i) =\n                         0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set a2. p = 0 \\<Longrightarrow>\n                (\\<Sum>(term,\n                    i)\\<leftarrow>a2. insertion f term * f v ^ i) =\n                0;\n        \\<forall>(p, i)\\<in>set (a1 # a2). p = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(term,\n                             i)\\<leftarrow>a1 #\n     a2. insertion f term * f v ^ i) =\n                         0", "case (Cons a1 a2)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a2.\n     case a of (p, i) \\<Rightarrow> p = 0 \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>a2. case a of\n                          (term, i) \\<Rightarrow>\n                            insertion f term * f v ^ i) =\n  0\n  \\<forall>a\\<in>set (a1 # a2). case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<forall>(p, i)\\<in>set a2. p = 0 \\<Longrightarrow>\n                (\\<Sum>(term,\n                    i)\\<leftarrow>a2. insertion f term * f v ^ i) =\n                0;\n        \\<forall>(p, i)\\<in>set (a1 # a2). p = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(term,\n                             i)\\<leftarrow>a1 #\n     a2. insertion f term * f v ^ i) =\n                         0", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set a2.\n     case a of (p, i) \\<Rightarrow> p = 0 \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>a2. case a of\n                          (term, i) \\<Rightarrow>\n                            insertion f term * f v ^ i) =\n  0\n  \\<forall>a\\<in>set (a1 # a2). case a of (p, i) \\<Rightarrow> p = 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set a2.\n     case a of (p, i) \\<Rightarrow> p = 0 \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>a2. case a of\n                          (term, i) \\<Rightarrow>\n                            insertion f term * f v ^ i) =\n  0\n  \\<forall>a\\<in>set (a1 # a2). case a of (p, i) \\<Rightarrow> p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>a1 #\n                        a2. case a of\n                            (term, i) \\<Rightarrow>\n                              insertion f term * f v ^ i) =\n    0", "apply(cases a1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a\\<in>set a2.\n                   case a of (p, i) \\<Rightarrow> p = 0 \\<Longrightarrow>\n                (\\<Sum>a\\<leftarrow>a2. case a of\n  (term, i) \\<Rightarrow> insertion f term * f v ^ i) =\n                0;\n        \\<forall>a\\<in>set (a1 # a2). case a of (p, i) \\<Rightarrow> p = 0;\n        a1 = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<leftarrow>a1 #\n       a2. case a of (term, i) \\<Rightarrow> insertion f term * f v ^ i) =\n                         0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>a1 #\n                      a2. case a of\n                          (term, i) \\<Rightarrow>\n                            insertion f term * f v ^ i) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "using separate[OF assms, of f]"], ["proof (prove)\nusing this:\n  (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) = 0\n  insertion f p =\n  (\\<Sum>(term, i)\\<leftarrow>a. insertion f term * f v ^ i) +\n  (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)", "by auto"], ["proof (state)\nthis:\n  insertion f p = (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_chop : \n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>(chop (to_list v p))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "proof(cases \"chophelper (to_list v p) []\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       chophelper (to_list v p) [] = (a, b) \\<Longrightarrow>\n       insertion f p =\n       (\\<Sum>(term,\n           i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "case (Pair a b)"], ["proof (state)\nthis:\n  chophelper (to_list v p) [] = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       chophelper (to_list v p) [] = (a, b) \\<Longrightarrow>\n       insertion f p =\n       (\\<Sum>(term,\n           i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "using chopped[OF Pair[symmetric], of f]"], ["proof (prove)\nusing this:\n  insertion f p = (\\<Sum>(term, i)\\<leftarrow>b. insertion f term * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "unfolding compare[OF Pair[symmetric], symmetric]"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "."], ["proof (state)\nthis:\n  insertion f p =\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted : \"sorted_wrt (\\<lambda>(_,i).\\<lambda>(_,i'). i<i') (to_list v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') (to_list v p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') (to_list v p)", "define d  where \"d = MPoly_Type.degree p v\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p v\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') (to_list v p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') (to_list v p)", "unfolding to_list.simps d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i')\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<d + 1])", "proof(induction d)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt\n     (\\<lambda>a.\n         case a of\n         (uu_, i) \\<Rightarrow>\n           \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<0 + 1])\n 2. \\<And>d.\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<d + 1]) \\<Longrightarrow>\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<Suc d + 1])", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sorted_wrt\n     (\\<lambda>a.\n         case a of\n         (uu_, i) \\<Rightarrow>\n           \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<0 + 1])\n 2. \\<And>d.\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<d + 1]) \\<Longrightarrow>\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<Suc d + 1])", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt\n     (\\<lambda>a.\n         case a of\n         (uu_, i) \\<Rightarrow>\n           \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<0 + 1])", "by auto"], ["proof (state)\nthis:\n  sorted_wrt\n   (\\<lambda>a.\n       case a of\n       (uu_, i) \\<Rightarrow>\n         \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n   (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<0 + 1])\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<d + 1]) \\<Longrightarrow>\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<Suc d + 1])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<d + 1]) \\<Longrightarrow>\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<Suc d + 1])", "case (Suc d)"], ["proof (state)\nthis:\n  sorted_wrt\n   (\\<lambda>a.\n       case a of\n       (uu_, i) \\<Rightarrow>\n         \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n   (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<d + 1])\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<d + 1]) \\<Longrightarrow>\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<Suc d + 1])", "have h : \"(map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d + 1]) = \n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d]) @ [(isolate_variable_sparse p v (Suc d), (Suc d))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d + 1] =\n    map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d] @\n    [(isolate_variable_sparse p v (Suc d), Suc d)]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d + 1] =\n  map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d] @\n  [(isolate_variable_sparse p v (Suc d), Suc d)]\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<d + 1]) \\<Longrightarrow>\n       sorted_wrt\n        (\\<lambda>a.\n            case a of\n            (uu_, i) \\<Rightarrow>\n              \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n        (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n          [0..<Suc d + 1])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt\n     (\\<lambda>a.\n         case a of\n         (uu_, i) \\<Rightarrow>\n           \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d + 1])", "unfolding sorted_wrt_append h"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y)\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n       [0..<Suc d]) \\<and>\n    sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y)\n     [(isolate_variable_sparse p v (Suc d), Suc d)] \\<and>\n    (\\<forall>x\\<in>set (map (\\<lambda>x.\n                                 (isolate_variable_sparse p v x, x))\n                          [0..<Suc d]).\n        Ball (set [(isolate_variable_sparse p v (Suc d), Suc d)])\n         (case x of (uu_, i) \\<Rightarrow> \\<lambda>(uu_, y). i < y))", "using Suc"], ["proof (prove)\nusing this:\n  sorted_wrt\n   (\\<lambda>a.\n       case a of\n       (uu_, i) \\<Rightarrow>\n         \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n   (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<d + 1])\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y)\n     (map (\\<lambda>x. (isolate_variable_sparse p v x, x))\n       [0..<Suc d]) \\<and>\n    sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y)\n     [(isolate_variable_sparse p v (Suc d), Suc d)] \\<and>\n    (\\<forall>x\\<in>set (map (\\<lambda>x.\n                                 (isolate_variable_sparse p v x, x))\n                          [0..<Suc d]).\n        Ball (set [(isolate_variable_sparse p v (Suc d), Suc d)])\n         (case x of (uu_, i) \\<Rightarrow> \\<lambda>(uu_, y). i < y))", "by auto"], ["proof (state)\nthis:\n  sorted_wrt\n   (\\<lambda>a.\n       case a of\n       (uu_, i) \\<Rightarrow>\n         \\<lambda>a. case a of (uu_, i') \\<Rightarrow> i < i')\n   (map (\\<lambda>x. (isolate_variable_sparse p v x, x)) [0..<Suc d + 1])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') (to_list v p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sublist : \"sublist (chop L) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (chop L) L", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. sublist (chop []) []\n 2. \\<And>a L.\n       sublist (chop L) L \\<Longrightarrow> sublist (chop (a # L)) (a # L)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sublist (chop []) []\n 2. \\<And>a L.\n       sublist (chop L) L \\<Longrightarrow> sublist (chop (a # L)) (a # L)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (chop []) []", "by auto"], ["proof (state)\nthis:\n  sublist (chop []) []\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       sublist (chop L) L \\<Longrightarrow> sublist (chop (a # L)) (a # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       sublist (chop L) L \\<Longrightarrow> sublist (chop (a # L)) (a # L)", "case (Cons a L)"], ["proof (state)\nthis:\n  sublist (chop L) L\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       sublist (chop L) L \\<Longrightarrow> sublist (chop (a # L)) (a # L)", "then"], ["proof (chain)\npicking this:\n  sublist (chop L) L", "show ?case"], ["proof (prove)\nusing this:\n  sublist (chop L) L\n\ngoal (1 subgoal):\n 1. sublist (chop (a # L)) (a # L)", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>sublist (chop L) L; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> sublist (chop (a # L)) (a # L)", "case (Pair a b)"], ["proof (state)\nthis:\n  a__ = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>sublist (chop L) L; a__ = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> sublist (chop (a__ # L)) (a__ # L)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist (chop (a__ # L)) (a__ # L)", "using Cons"], ["proof (prove)\nusing this:\n  sublist (chop L) L\n\ngoal (1 subgoal):\n 1. sublist (chop (a__ # L)) (a__ # L)", "unfolding Pair"], ["proof (prove)\nusing this:\n  sublist (chop L) L\n\ngoal (1 subgoal):\n 1. sublist (chop ((a, b) # L)) ((a, b) # L)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sublist (chop L) L; a = 0\\<rbrakk>\n    \\<Longrightarrow> sublist (chop L) ((0, b) # L)", "by (simp add: sublist_Cons_right)"], ["proof (state)\nthis:\n  sublist (chop (a__ # L)) (a__ # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sublist (chop (a # L)) (a # L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma move_exp :\n  assumes \"(p',i)#L = (chop (to_list v p))\"\n  shows \"insertion f p = sum_list [insertion f term * (f v) ^ (d-i). (term,d)\\<leftarrow>(chop (to_list v p))] * (f v)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "have h : \"sorted_wrt (\\<lambda>(_, i) (_, y). i < y) (chop (to_list v p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))", "define L where \"L = to_list v p\""], ["proof (state)\nthis:\n  L = to_list v p\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))", "using sublist[of \"to_list v p\"] sorted[of v p]"], ["proof (prove)\nusing this:\n  sublist (chop (to_list v p)) (to_list v p)\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') (to_list v p)\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))", "unfolding L_def[symmetric]"], ["proof (prove)\nusing this:\n  sublist (chop L) L\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, i'). i < i') L\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop L)", "by (metis sorted_wrt_append sublist_def)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))", "have \"\\<forall>(term,d)\\<in>set(chop (to_list v p)). d\\<ge>i\""], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) (chop (to_list v p))\n\ngoal (1 subgoal):\n 1. \\<forall>(term, d)\\<in>set (chop (to_list v p)). i \\<le> d", "unfolding assms[symmetric]"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>(uu_, i) (uu_, y). i < y) ((p', i) # L)\n\ngoal (1 subgoal):\n 1. \\<forall>(term, d)\\<in>set ((p', i) # L). i \\<le> d", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(term, d)\\<in>set (chop (to_list v p)). i \\<le> d\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "then"], ["proof (chain)\npicking this:\n  \\<forall>(term, d)\\<in>set (chop (to_list v p)). i \\<le> d", "have simp : \"\\<forall>(term,d)\\<in>set(chop(to_list v p)). f v ^ (d - i) * f v ^ i = f v ^ d\""], ["proof (prove)\nusing this:\n  \\<forall>(term, d)\\<in>set (chop (to_list v p)). i \\<le> d\n\ngoal (1 subgoal):\n 1. \\<forall>(term, d)\\<in>set (chop (to_list v p)).\n       f v ^ (d - i) * f v ^ i = f v ^ d", "unfolding HOL.no_atp(118)"], ["proof (prove)\nusing this:\n  \\<forall>(term, d)\\<in>set (chop (to_list v p)). i \\<le> d\n\ngoal (1 subgoal):\n 1. \\<forall>(term, d)\\<in>set (chop (to_list v p)).\n       f v ^ (d - i + i) = f v ^ d", "by(auto simp del: to_list.simps)"], ["proof (state)\nthis:\n  \\<forall>(term, d)\\<in>set (chop (to_list v p)).\n     f v ^ (d - i) * f v ^ i = f v ^ d\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "have \"insertion f p = sum_list [insertion f term * (f v) ^ i. (term,i)\\<leftarrow>(chop (to_list v p))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "using insertion_chop[of f p v]"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)", "."], ["proof (state)\nthis:\n  insertion f p =\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "also"], ["proof (state)\nthis:\n  insertion f p =\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "have \"...= (\\<Sum>(term, d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d-i) * f v ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i)", "using simp"], ["proof (prove)\nusing this:\n  \\<forall>(term, d)\\<in>set (chop (to_list v p)).\n     f v ^ (d - i) * f v ^ i = f v ^ d\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i)", "by (smt Pair_inject case_prodE map_eq_conv mult.assoc split_cong)"], ["proof (state)\nthis:\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i) =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop\n                     (to_list v\n                       p). insertion f term * f v ^ (d - i) * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>(term,\n      i)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ i) =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop\n                     (to_list v\n                       p). insertion f term * f v ^ (d - i) * f v ^ i)\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "have \"... =  (\\<Sum>(term, d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) * f v ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "define d where \"d = chop(to_list v p)\""], ["proof (state)\nthis:\n  d = chop (to_list v p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "define a where \"a = f v ^ i\""], ["proof (state)\nthis:\n  a = f v ^ i\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "define b where \"b = (\\<lambda>(term, d). insertion f term * f v ^ (d - i))\""], ["proof (state)\nthis:\n  b = (\\<lambda>(term, d). insertion f term * f v ^ (d - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "have h : \"(\\<Sum>(term, d)\\<leftarrow>d. insertion f term * f v ^ (d - i) * a) = (\\<Sum>(term, d)\\<leftarrow>d. b (term,d) * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term, d)\\<leftarrow>d. insertion f term * f v ^ (d - i) * a) =\n    (\\<Sum>(term, d)\\<leftarrow>d. b (term, d) * a)", "using b_def"], ["proof (prove)\nusing this:\n  b = (\\<lambda>(term, d). insertion f term * f v ^ (d - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term, d)\\<leftarrow>d. insertion f term * f v ^ (d - i) * a) =\n    (\\<Sum>(term, d)\\<leftarrow>d. b (term, d) * a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(term, d)\\<leftarrow>d. insertion f term * f v ^ (d - i) * a) =\n  (\\<Sum>(term, d)\\<leftarrow>d. b (term, d) * a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f term * f v ^ (d - i) * f v ^ i) =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "unfolding d_def[symmetric] a_def[symmetric]  b_def[symmetric] h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term, d)\\<leftarrow>d. b (term, d) * a) = sum_list (map b d) * a", "apply(induction d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>c\\<leftarrow>[]. case c of\n                            (term, d) \\<Rightarrow> b (term, d) * a) =\n    sum_list (map b []) * a\n 2. \\<And>aa d.\n       (\\<Sum>c\\<leftarrow>d. case c of\n                              (term, d) \\<Rightarrow> b (term, d) * a) =\n       sum_list (map b d) * a \\<Longrightarrow>\n       (\\<Sum>c\\<leftarrow>aa #\n                           d. case c of\n                              (term, d) \\<Rightarrow> b (term, d) * a) =\n       sum_list (map b (aa # d)) * a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa d.\n       (\\<Sum>c\\<leftarrow>d. case c of\n                              (term, d) \\<Rightarrow> b (term, d) * a) =\n       sum_list (map b d) * a \\<Longrightarrow>\n       (\\<Sum>c\\<leftarrow>aa #\n                           d. case c of\n                              (term, d) \\<Rightarrow> b (term, d) * a) =\n       sum_list (map b (aa # d)) * a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba d.\n       (\\<Sum>c\\<leftarrow>d. b c * a) =\n       sum_list (map b d) * a \\<Longrightarrow>\n       b (aa, ba) * a + sum_list (map b d) * a =\n       (b (aa, ba) + sum_list (map b d)) * a", "by (simp add: ring_class.ring_distribs(2))"], ["proof (state)\nthis:\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop\n                     (to_list v\n                       p). insertion f term * f v ^ (d - i) * f v ^ i) =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) *\n  f v ^ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop\n                     (to_list v\n                       p). insertion f term * f v ^ (d - i) * f v ^ i) =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) *\n  f v ^ i\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "finally"], ["proof (chain)\npicking this:\n  insertion f p =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) *\n  f v ^ i", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) *\n  f v ^ i\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        d)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (d - i)) *\n    f v ^ i", "by auto"], ["proof (state)\nthis:\n  insertion f p =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) *\n  f v ^ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_Var_Zero : \"insertion f (Var v) = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Var v) = f v", "unfolding insertion_code monomials_Var"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{monomial 1 v}.\n       MPoly_Type.coeff (Var v) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    f v", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var v) (monomial (Suc 0) v) * f v = f v", "unfolding coeff_Var"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) when monomial (Suc 0) v = monomial 1 v) * f v = f v", "by simp"], ["", "lemma decreasePower_insertion :\n  assumes \"decreasePower v p = (p',i)\"\n  shows \"insertion f p = insertion f p'* (f v)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p = insertion f p' * f v ^ i", "proof(cases \"chop (to_list v p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. chop (to_list v p) = [] \\<Longrightarrow>\n    insertion f p = insertion f p' * f v ^ i\n 2. \\<And>a list.\n       chop (to_list v p) = a # list \\<Longrightarrow>\n       insertion f p = insertion f p' * f v ^ i", "case Nil"], ["proof (state)\nthis:\n  chop (to_list v p) = []\n\ngoal (2 subgoals):\n 1. chop (to_list v p) = [] \\<Longrightarrow>\n    insertion f p = insertion f p' * f v ^ i\n 2. \\<And>a list.\n       chop (to_list v p) = a # list \\<Longrightarrow>\n       insertion f p = insertion f p' * f v ^ i", "then"], ["proof (chain)\npicking this:\n  chop (to_list v p) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  chop (to_list v p) = []\n\ngoal (1 subgoal):\n 1. insertion f p = insertion f p' * f v ^ i", "using assms"], ["proof (prove)\nusing this:\n  chop (to_list v p) = []\n  decreasePower v p = (p', i)\n\ngoal (1 subgoal):\n 1. insertion f p = insertion f p' * f v ^ i", "by auto"], ["proof (state)\nthis:\n  insertion f p = insertion f p' * f v ^ i\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       chop (to_list v p) = a # list \\<Longrightarrow>\n       insertion f p = insertion f p' * f v ^ i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       chop (to_list v p) = a # list \\<Longrightarrow>\n       insertion f p = insertion f p' * f v ^ i", "case (Cons a list)"], ["proof (state)\nthis:\n  chop (to_list v p) = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       chop (to_list v p) = a # list \\<Longrightarrow>\n       insertion f p = insertion f p' * f v ^ i", "then"], ["proof (chain)\npicking this:\n  chop (to_list v p) = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  chop (to_list v p) = a # list\n\ngoal (1 subgoal):\n 1. insertion f p = insertion f p' * f v ^ i", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "case (Pair coef i')"], ["proof (state)\nthis:\n  a = (coef, i')\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "have i'_def : \"i'=i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = i", "using Cons assms Pair"], ["proof (prove)\nusing this:\n  chop (to_list v p) = a # list\n  decreasePower v p = (p', i)\n  a = (coef, i')\n\ngoal (1 subgoal):\n 1. i' = i", "by auto"], ["proof (state)\nthis:\n  i' = i\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "have chop: \"chop (to_list v p) = (coef, i) # list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop (to_list v p) = (coef, i) # list", "using Cons assms"], ["proof (prove)\nusing this:\n  chop (to_list v p) = a # list\n  decreasePower v p = (p', i)\n\ngoal (1 subgoal):\n 1. chop (to_list v p) = (coef, i) # list", "unfolding i'_def Pair"], ["proof (prove)\nusing this:\n  chop (to_list v p) = (coef, i) # list\n  decreasePower v p = (p', i)\n\ngoal (1 subgoal):\n 1. chop (to_list v p) = (coef, i) # list", "by auto"], ["proof (state)\nthis:\n  chop (to_list v p) = (coef, i) # list\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "have p'_def :  \"p' = (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' =\n    (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))", "using assms Cons Pair"], ["proof (prove)\nusing this:\n  decreasePower v p = (p', i)\n  chop (to_list v p) = a # list\n  a = (coef, i')\n\ngoal (1 subgoal):\n 1. p' =\n    (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))", "by auto"], ["proof (state)\nthis:\n  p' =\n  (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "have p'_insertion : \"insertion f p' = (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "define d where \"d = chop (to_list v p)\""], ["proof (state)\nthis:\n  d = chop (to_list v p)\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "have \"insertion f p' = insertion f (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p' =\n    insertion f\n     (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))", "using p'_def"], ["proof (prove)\nusing this:\n  p' =\n  (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    insertion f\n     (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))", "by auto"], ["proof (state)\nthis:\n  insertion f p' =\n  insertion f\n   (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "also"], ["proof (state)\nthis:\n  insertion f p' =\n  insertion f\n   (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "have \"... = (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p).  insertion f (term * Var v ^ (x - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f\n     (\\<Sum>(term,\n         x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i)) =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop\n                       (to_list v p). insertion f (term * Var v ^ (x - i)))", "unfolding d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (\\<Sum>(term, x)\\<leftarrow>d. term * Var v ^ (x - i)) =\n    (\\<Sum>(term, x)\\<leftarrow>d. insertion f (term * Var v ^ (x - i)))", "apply(induction d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. insertion f\n     (\\<Sum>a\\<leftarrow>[]. case a of\n                             (term, x) \\<Rightarrow>\n                               term * Var v ^ (x - i)) =\n    (\\<Sum>a\\<leftarrow>[]. case a of\n                            (term, x) \\<Rightarrow>\n                              insertion f (term * Var v ^ (x - i)))\n 2. \\<And>a d.\n       insertion f\n        (\\<Sum>a\\<leftarrow>d. case a of\n                               (term, x) \\<Rightarrow>\n                                 term * Var v ^ (x - i)) =\n       (\\<Sum>a\\<leftarrow>d. case a of\n                              (term, x) \\<Rightarrow>\n                                insertion f\n                                 (term * Var v ^ (x - i))) \\<Longrightarrow>\n       insertion f\n        (\\<Sum>a\\<leftarrow>a #\n                            d. case a of\n                               (term, x) \\<Rightarrow>\n                                 term * Var v ^ (x - i)) =\n       (\\<Sum>a\\<leftarrow>a #\n                           d. case a of\n                              (term, x) \\<Rightarrow>\n                                insertion f (term * Var v ^ (x - i)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a d.\n       insertion f\n        (\\<Sum>a\\<leftarrow>d. case a of\n                               (term, x) \\<Rightarrow>\n                                 term * Var v ^ (x - i)) =\n       (\\<Sum>a\\<leftarrow>d. case a of\n                              (term, x) \\<Rightarrow>\n                                insertion f\n                                 (term * Var v ^ (x - i))) \\<Longrightarrow>\n       insertion f\n        (\\<Sum>a\\<leftarrow>a #\n                            d. case a of\n                               (term, x) \\<Rightarrow>\n                                 term * Var v ^ (x - i)) =\n       (\\<Sum>a\\<leftarrow>a #\n                           d. case a of\n                              (term, x) \\<Rightarrow>\n                                insertion f (term * Var v ^ (x - i)))", "apply(simp add:insertion_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a d.\n       insertion f\n        (\\<Sum>a\\<leftarrow>d. case a of\n                               (term, x) \\<Rightarrow>\n                                 term * Var v ^ (x - i)) =\n       (\\<Sum>a\\<leftarrow>d. case a of\n                              (term, x) \\<Rightarrow>\n                                insertion f\n                                 (term * Var v ^ (x - i))) \\<Longrightarrow>\n       insertion f\n        (case a of (term, x) \\<Rightarrow> term * Var v ^ (x - i)) =\n       (case a of\n        (term, x) \\<Rightarrow> insertion f (term * Var v ^ (x - i)))", "by auto"], ["proof (state)\nthis:\n  insertion f\n   (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i)) =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop\n                     (to_list v p). insertion f (term * Var v ^ (x - i)))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "also"], ["proof (state)\nthis:\n  insertion f\n   (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). term * Var v ^ (x - i)) =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop\n                     (to_list v p). insertion f (term * Var v ^ (x - i)))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "have \"... = (\\<Sum>(term, x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        x)\\<leftarrow>chop\n                       (to_list v\n                         p). insertion f (term * Var v ^ (x - i))) =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "unfolding insertion_mult insertion_pow insert_Var_Zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term,\n        x)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (x - i)) =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop\n                     (to_list v p). insertion f (term * Var v ^ (x - i))) =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "finally"], ["proof (chain)\npicking this:\n  insertion f p' =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion f p' =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))\n\ngoal (1 subgoal):\n 1. insertion f p' =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))", "by auto"], ["proof (state)\nthis:\n  insertion f p' =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion f p' =\n  (\\<Sum>(term,\n      x)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (x - i))\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "have h : \"(coef, i') # list = chop (to_list v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coef, i') # list = chop (to_list v p)", "using Cons"], ["proof (prove)\nusing this:\n  chop (to_list v p) = a # list\n\ngoal (1 subgoal):\n 1. (coef, i') # list = chop (to_list v p)", "unfolding Pair"], ["proof (prove)\nusing this:\n  chop (to_list v p) = (coef, i') # list\n\ngoal (1 subgoal):\n 1. (coef, i') # list = chop (to_list v p)", "by auto"], ["proof (state)\nthis:\n  (coef, i') # list = chop (to_list v p)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>chop (to_list v p) = a # list; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> insertion f p = insertion f p' * f v ^ i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p = insertion f p' * f v ^ i", "unfolding p'_insertion"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (x - i)) *\n    f v ^ i", "using move_exp[OF h, of f]"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i')) *\n  f v ^ i'\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (x - i)) *\n    f v ^ i", "unfolding i'_def"], ["proof (prove)\nusing this:\n  insertion f p =\n  (\\<Sum>(term,\n      d)\\<leftarrow>chop (to_list v p). insertion f term * f v ^ (d - i)) *\n  f v ^ i\n\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>(term,\n        x)\\<leftarrow>chop\n                       (to_list v p). insertion f term * f v ^ (x - i)) *\n    f v ^ i", "."], ["proof (state)\nthis:\n  insertion f p = insertion f p' * f v ^ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion f p = insertion f p' * f v ^ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unpower_eval: \"eval (unpower v \\<phi>) L = eval \\<phi> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v \\<phi>) L = eval \\<phi> L", "proof(induction \\<phi> arbitrary: v L)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>v L. eval (unpower v TrueF) L = eval TrueF L\n 2. \\<And>v L. eval (unpower v FalseF) L = eval FalseF L\n 3. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 4. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 5. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 7. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 8. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 9. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 10. \\<And>x1 \\<phi> v L.\n        (\\<And>v L.\n            eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n        eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "case TrueF"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>v L. eval (unpower v TrueF) L = eval TrueF L\n 2. \\<And>v L. eval (unpower v FalseF) L = eval FalseF L\n 3. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 4. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 5. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 7. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 8. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 9. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 10. \\<And>x1 \\<phi> v L.\n        (\\<And>v L.\n            eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n        eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v TrueF) L = eval TrueF L", "by auto"], ["proof (state)\nthis:\n  eval (unpower v TrueF) L = eval TrueF L\n\ngoal (9 subgoals):\n 1. \\<And>v L. eval (unpower v FalseF) L = eval FalseF L\n 2. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 3. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 4. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 7. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 8. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 9. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>v L. eval (unpower v FalseF) L = eval FalseF L\n 2. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 3. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 4. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 7. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 8. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 9. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "case FalseF"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<And>v L. eval (unpower v FalseF) L = eval FalseF L\n 2. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 3. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 4. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 7. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 8. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 9. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v FalseF) L = eval FalseF L", "by auto"], ["proof (state)\nthis:\n  eval (unpower v FalseF) L = eval FalseF L\n\ngoal (8 subgoals):\n 1. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 2. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 3. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 4. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 7. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 8. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 2. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 3. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 4. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 7. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 8. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "case (Atom At)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>x v L. eval (unpower v (fm.Atom x)) L = eval (fm.Atom x) L\n 2. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 3. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 4. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 6. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 7. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 8. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "obtain q i where h: \"decreasePower v p = (q, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  decreasePower v p = (q, i)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "have p : \"\\<And>f. insertion f p = insertion f q* (f v)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "using decreasePower_insertion[OF h]"], ["proof (prove)\nusing this:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "by auto"], ["proof (state)\nthis:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "proof(cases \"i=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "unfolding Less unpower.simps h"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. eval\n     (case (q, i) of (x, 0) \\<Rightarrow> fm.Atom (Less p)\n      | (x, Suc nat) \\<Rightarrow>\n          if Suc nat mod 2 = 0\n          then And (fm.Atom (Less x)) (fm.Atom (Neq (Var v)))\n          else Or (And (fm.Atom (Less x)) (fm.Atom (Less (- Var v))))\n                (And (fm.Atom (Less (- x))) (fm.Atom (Less (Var v)))))\n     L =\n    eval (fm.Atom (Less p)) L", "by auto"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "obtain x where x_def : \"Suc x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using False"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using not0_implies_Suc"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  ?n \\<noteq> 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Suc x = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "have h1 : \"i mod 2 = 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)", "assume \"i mod 2 = 0\""], ["proof (state)\nthis:\n  i mod 2 = 0\n\ngoal (1 subgoal):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)", "then"], ["proof (chain)\npicking this:\n  i mod 2 = 0", "have \"\\<forall>r. \\<not> (r::real) ^ i < 0\""], ["proof (prove)\nusing this:\n  i mod 2 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>r. \\<not> r ^ i < 0", "by presburger"], ["proof (state)\nthis:\n  \\<forall>r. \\<not> r ^ i < 0\n\ngoal (1 subgoal):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)", "then"], ["proof (chain)\npicking this:\n  \\<forall>r. \\<not> r ^ i < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r. \\<not> r ^ i < 0\n\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)", "by (metis \\<open>\\<And>thesis. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> insert_Var_Zero linorder_neqE_linordered_idom mult_less_0_iff power_0_Suc power_eq_0_iff)"], ["proof (state)\nthis:\n  (insertion (nth_default 0 L) q < 0 \\<and>\n   insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n  (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i mod 2 = 0 \\<Longrightarrow>\n  (insertion (nth_default 0 L) q < 0 \\<and>\n   insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n  (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "unfolding Less unpower.simps h x_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (case (q, Suc x) of (x, 0) \\<Rightarrow> fm.Atom (Less p)\n      | (x, Suc nat) \\<Rightarrow>\n          if Suc nat mod 2 = 0\n          then And (fm.Atom (Less x)) (fm.Atom (Neq (Var v)))\n          else Or (And (fm.Atom (Less x)) (fm.Atom (Less (- Var v))))\n                (And (fm.Atom (Less (- x))) (fm.Atom (Less (Var v)))))\n     L =\n    eval (fm.Atom (Less p)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc x mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n     (insertion (nth_default 0 L) p < 0)) \\<and>\n    (Suc x mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) < 0) =\n     (insertion (nth_default 0 L) p < 0))", "unfolding x_def p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) < 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0))", "apply(cases \"i mod 2 = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) < 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0))\n 2. i mod 2 \\<noteq> 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) < 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0))", "using h1"], ["proof (prove)\nusing this:\n  i mod 2 = 0 \\<Longrightarrow>\n  (insertion (nth_default 0 L) q < 0 \\<and>\n   insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n  (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)\n\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) < 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0))\n 2. i mod 2 \\<noteq> 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) < 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. i mod 2 = Suc 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q < 0 \\<and>\n     insertion (nth_default 0 L) (- Var v) < 0 \\<or>\n     insertion (nth_default 0 L) (- q) < 0 \\<and>\n     insertion (nth_default 0 L) (Var v) < 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i < 0)", "by (smt insert_Var_Zero insertion_neg mod_Suc mod_eq_0D mult_less_0_iff nat.inject odd_power_less_zero power_0 power_Suc0_right power_eq_0_iff x_def zero_less_Suc zero_less_power)"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "obtain q i where h: \"decreasePower v p = (q, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  decreasePower v p = (q, i)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "have p : \"\\<And>f. insertion f p = insertion f q* (f v)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "using decreasePower_insertion[OF h]"], ["proof (prove)\nusing this:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "by auto"], ["proof (state)\nthis:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "unfolding Eq unpower.simps h"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (case (q, i) of (x, 0) \\<Rightarrow> fm.Atom (Eq p)\n      | (x, Suc nat) \\<Rightarrow>\n          Or (fm.Atom (Eq x)) (fm.Atom (Eq (Var v))))\n     L =\n    eval (fm.Atom (Eq p)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (case i of 0 \\<Rightarrow> fm.Atom (Eq p)\n      | Suc nat \\<Rightarrow> Or (fm.Atom (Eq q)) (fm.Atom (Eq (Var v))))\n     L =\n    (insertion (nth_default 0 L) p = 0)", "apply(cases i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    eval\n     (case i of 0 \\<Rightarrow> fm.Atom (Eq p)\n      | Suc nat \\<Rightarrow> Or (fm.Atom (Eq q)) (fm.Atom (Eq (Var v))))\n     L =\n    (insertion (nth_default 0 L) p = 0)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       eval\n        (case i of 0 \\<Rightarrow> fm.Atom (Eq p)\n         | Suc nat \\<Rightarrow> Or (fm.Atom (Eq q)) (fm.Atom (Eq (Var v))))\n        L =\n       (insertion (nth_default 0 L) p = 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       eval\n        (case i of 0 \\<Rightarrow> fm.Atom (Eq p)\n         | Suc nat \\<Rightarrow> Or (fm.Atom (Eq q)) (fm.Atom (Eq (Var v))))\n        L =\n       (insertion (nth_default 0 L) p = 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (insertion (nth_default 0 L) q = 0 \\<or>\n        insertion (nth_default 0 L) (Var v) = 0) =\n       (insertion (nth_default 0 L) p = 0)", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (insertion (nth_default 0 L) q = 0 \\<or>\n        insertion (nth_default 0 L) (Var v) = 0) =\n       (insertion (nth_default 0 L) q * nth_default 0 L v ^ i = 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (insertion (nth_default 0 L) q = 0 \\<or>\n        insertion (nth_default 0 L) (Var v) = 0) =\n       (insertion (nth_default 0 L) q = 0 \\<or>\n        nth_default 0 L v = 0 \\<or> nth_default 0 L v = 0 \\<and> 0 < nat)", "by (metis insert_Var_Zero)"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "obtain q i where h: \"decreasePower v p = (q, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  decreasePower v p = (q, i)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "have p : \"\\<And>f. insertion f p = insertion f q* (f v)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "using decreasePower_insertion[OF h]"], ["proof (prove)\nusing this:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "by auto"], ["proof (state)\nthis:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "proof(cases \"i=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "unfolding Leq unpower.simps h"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. eval\n     (case (q, i) of (x, 0) \\<Rightarrow> fm.Atom (Leq p)\n      | (x, Suc nat) \\<Rightarrow>\n          if Suc nat mod 2 = 0\n          then Or (fm.Atom (Leq x)) (fm.Atom (Eq (Var v)))\n          else Or (fm.Atom (Eq x))\n                (Or (And (fm.Atom (Less x)) (fm.Atom (Leq (- Var v))))\n                  (And (fm.Atom (Less (- x))) (fm.Atom (Leq (Var v))))))\n     L =\n    eval (fm.Atom (Leq p)) L", "by auto"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "obtain x where x_def : \"Suc x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using False"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using not0_implies_Suc"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  ?n \\<noteq> 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>x. Suc x = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Suc x = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "define a where \"a = insertion (nth_default 0 L) q\""], ["proof (state)\nthis:\n  a = insertion (nth_default 0 L) q\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "define x' where \"x' = nth_default 0 L v\""], ["proof (state)\nthis:\n  x' = nth_default 0 L v\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "unfolding Leq unpower.simps h x_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (case (q, Suc x) of (x, 0) \\<Rightarrow> fm.Atom (Leq p)\n      | (x, Suc nat) \\<Rightarrow>\n          if Suc nat mod 2 = 0\n          then Or (fm.Atom (Leq x)) (fm.Atom (Eq (Var v)))\n          else Or (fm.Atom (Eq x))\n                (Or (And (fm.Atom (Less x)) (fm.Atom (Leq (- Var v))))\n                  (And (fm.Atom (Less (- x))) (fm.Atom (Leq (Var v))))))\n     L =\n    eval (fm.Atom (Leq p)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc x mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (Var v) = 0) =\n     (insertion (nth_default 0 L) p \\<le> 0)) \\<and>\n    (Suc x mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q = 0 \\<or>\n      insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<le> 0) =\n     (insertion (nth_default 0 L) p \\<le> 0))", "unfolding x_def p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (Var v) = 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q = 0 \\<or>\n      insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<le> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0))", "apply(cases \"i mod 2 = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (Var v) = 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q = 0 \\<or>\n      insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<le> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0))\n 2. i mod 2 \\<noteq> 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (Var v) = 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q = 0 \\<or>\n      insertion (nth_default 0 L) q < 0 \\<and>\n      insertion (nth_default 0 L) (- Var v) \\<le> 0 \\<or>\n      insertion (nth_default 0 L) (- q) < 0 \\<and>\n      insertion (nth_default 0 L) (Var v) \\<le> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0))", "unfolding insert_Var_Zero insertion_mult insertion_pow insertion_neg"], ["proof (prove)\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q \\<le> 0 \\<or> nth_default 0 L v = 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q = 0 \\<or>\n      insertion (nth_default 0 L) q < 0 \\<and>\n      - nth_default 0 L v \\<le> 0 \\<or>\n      - insertion (nth_default 0 L) q < 0 \\<and>\n      nth_default 0 L v \\<le> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0))\n 2. i mod 2 \\<noteq> 0 \\<Longrightarrow>\n    (i mod 2 = 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q \\<le> 0 \\<or> nth_default 0 L v = 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)) \\<and>\n    (i mod 2 = Suc 0 \\<longrightarrow>\n     (insertion (nth_default 0 L) q = 0 \\<or>\n      insertion (nth_default 0 L) q < 0 \\<and>\n      - nth_default 0 L v \\<le> 0 \\<or>\n      - insertion (nth_default 0 L) q < 0 \\<and>\n      nth_default 0 L v \\<le> 0) =\n     (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q \\<le> 0 \\<or> nth_default 0 L v = 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)\n 2. i mod 2 = Suc 0 \\<Longrightarrow>\n    (insertion (nth_default 0 L) q = 0 \\<or>\n     insertion (nth_default 0 L) q < 0 \\<and>\n     0 \\<le> nth_default 0 L v \\<or>\n     0 < insertion (nth_default 0 L) q \\<and> nth_default 0 L v \\<le> 0) =\n    (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<le> 0)", "unfolding a_def[symmetric] x'_def[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)\n 2. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)\n 2. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "assume \"i mod 2 = 0\""], ["proof (state)\nthis:\n  i mod 2 = 0\n\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)\n 2. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "then"], ["proof (chain)\npicking this:\n  i mod 2 = 0", "have \"x' ^ i \\<ge>0\""], ["proof (prove)\nusing this:\n  i mod 2 = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> x' ^ i", "by (simp add: \\<open>i mod 2 = 0\\<close> even_iff_mod_2_eq_zero zero_le_even_power)"], ["proof (state)\nthis:\n  0 \\<le> x' ^ i\n\ngoal (2 subgoals):\n 1. i mod 2 = 0 \\<Longrightarrow>\n    (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)\n 2. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x' ^ i", "show \"(a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)\""], ["proof (prove)\nusing this:\n  0 \\<le> x' ^ i\n\ngoal (1 subgoal):\n 1. (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)", "using Rings.ordered_semiring_0_class.mult_nonpos_nonneg[of a \"x'^i\"]"], ["proof (prove)\nusing this:\n  0 \\<le> x' ^ i\n  \\<lbrakk>a \\<le> 0; 0 \\<le> x' ^ i\\<rbrakk>\n  \\<Longrightarrow> a * x' ^ i \\<le> 0\n\ngoal (1 subgoal):\n 1. (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> 0 \\<Longrightarrow> a * 0 ^ i \\<le> 0; x' = 0\\<rbrakk>\n    \\<Longrightarrow> a * 0 ^ i \\<le> 0\n 2. \\<lbrakk>0 \\<le> x' ^ i; a * x' ^ i \\<le> 0; x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> a \\<le> 0", "unfolding Rings.linordered_ring_strict_class.mult_le_0_iff"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> 0 \\<Longrightarrow>\n             0 \\<le> a \\<and> 0 ^ i \\<le> 0 \\<or>\n             a \\<le> 0 \\<and> 0 \\<le> 0 ^ i;\n     x' = 0\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> a \\<and> 0 ^ i \\<le> 0 \\<or>\n                      a \\<le> 0 \\<and> 0 \\<le> 0 ^ i\n 2. \\<lbrakk>0 \\<le> x' ^ i;\n     0 \\<le> a \\<and> x' ^ i \\<le> 0 \\<or> a \\<le> 0 \\<and> 0 \\<le> x' ^ i;\n     x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> a \\<le> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' = 0; \\<not> a \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 ^ i \\<le> 0", "by (simp add: False power_0_left)"], ["proof (state)\nthis:\n  (a \\<le> 0 \\<or> x' = 0) = (a * x' ^ i \\<le> 0)\n\ngoal (1 subgoal):\n 1. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "assume h:  \"i mod 2 = Suc 0\""], ["proof (state)\nthis:\n  i mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. i mod 2 = Suc 0 \\<Longrightarrow>\n    (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "show \"(a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) = (a * x' ^ i \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "using h"], ["proof (prove)\nusing this:\n  i mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n    (a * x' ^ i \\<le> 0)", "by (smt even_iff_mod_2_eq_zero mult_less_cancel_right mult_neg_neg mult_nonneg_nonpos mult_pos_pos not_mod2_eq_Suc_0_eq_0 power_0_Suc x_def zero_le_power_eq zero_less_mult_pos2 zero_less_power)"], ["proof (state)\nthis:\n  (a = 0 \\<or> a < 0 \\<and> 0 \\<le> x' \\<or> 0 < a \\<and> x' \\<le> 0) =\n  (a * x' ^ i \\<le> 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "obtain q i where h: \"decreasePower v p = (q, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        decreasePower v p = (q, i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  decreasePower v p = (q, i)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "have p : \"\\<And>f. insertion f p = insertion f q* (f v)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "using decreasePower_insertion[OF h]"], ["proof (prove)\nusing this:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (1 subgoal):\n 1. \\<And>f. insertion f p = insertion f q * f v ^ i", "by auto"], ["proof (state)\nthis:\n  insertion ?f p = insertion ?f q * ?f v ^ i\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L", "unfolding Neq unpower.simps h"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (case (q, i) of (x, 0) \\<Rightarrow> fm.Atom (Neq p)\n      | (x, Suc nat) \\<Rightarrow>\n          And (fm.Atom (Neq x)) (fm.Atom (Neq (Var v))))\n     L =\n    eval (fm.Atom (Neq p)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (case i of 0 \\<Rightarrow> fm.Atom (Neq p)\n      | Suc nat \\<Rightarrow> And (fm.Atom (Neq q)) (fm.Atom (Neq (Var v))))\n     L =\n    (insertion (nth_default 0 L) p \\<noteq> 0)", "apply(cases i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    eval\n     (case i of 0 \\<Rightarrow> fm.Atom (Neq p)\n      | Suc nat \\<Rightarrow> And (fm.Atom (Neq q)) (fm.Atom (Neq (Var v))))\n     L =\n    (insertion (nth_default 0 L) p \\<noteq> 0)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       eval\n        (case i of 0 \\<Rightarrow> fm.Atom (Neq p)\n         | Suc nat \\<Rightarrow>\n             And (fm.Atom (Neq q)) (fm.Atom (Neq (Var v))))\n        L =\n       (insertion (nth_default 0 L) p \\<noteq> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       eval\n        (case i of 0 \\<Rightarrow> fm.Atom (Neq p)\n         | Suc nat \\<Rightarrow>\n             And (fm.Atom (Neq q)) (fm.Atom (Neq (Var v))))\n        L =\n       (insertion (nth_default 0 L) p \\<noteq> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (insertion (nth_default 0 L) q \\<noteq> 0 \\<and>\n        insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n       (insertion (nth_default 0 L) p \\<noteq> 0)", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (insertion (nth_default 0 L) q \\<noteq> 0 \\<and>\n        insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n       (insertion (nth_default 0 L) q * nth_default 0 L v ^ i \\<noteq> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (insertion (nth_default 0 L) q \\<noteq> 0 \\<and>\n        insertion (nth_default 0 L) (Var v) \\<noteq> 0) =\n       (insertion (nth_default 0 L) q \\<noteq> 0 \\<and>\n        nth_default 0 L v \\<noteq> 0 \\<and>\n        (nth_default 0 L v = 0 \\<longrightarrow> nat = 0))", "by (metis insert_Var_Zero)"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (unpower v (fm.Atom At)) L = eval (fm.Atom At) L\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (And \\<phi>1 \\<phi>2)) L =\n                         eval (And \\<phi>1 \\<phi>2) L\n 2. \\<And>\\<phi>1 \\<phi>2 v L.\n       \\<lbrakk>\\<And>v L. eval (unpower v \\<phi>1) L = eval \\<phi>1 L;\n        \\<And>v L. eval (unpower v \\<phi>2) L = eval \\<phi>2 L\\<rbrakk>\n       \\<Longrightarrow> eval (unpower v (Or \\<phi>1 \\<phi>2)) L =\n                         eval (Or \\<phi>1 \\<phi>2) L\n 3. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (Neg \\<phi>)) L = eval (Neg \\<phi>) L\n 4. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExQ \\<phi>)) L = eval (ExQ \\<phi>) L\n 5. \\<And>\\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllQ \\<phi>)) L = eval (AllQ \\<phi>) L\n 6. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (ExN x1 \\<phi>)) L = eval (ExN x1 \\<phi>) L\n 7. \\<And>x1 \\<phi> v L.\n       (\\<And>v L.\n           eval (unpower v \\<phi>) L = eval \\<phi> L) \\<Longrightarrow>\n       eval (unpower v (AllN x1 \\<phi>)) L = eval (AllN x1 \\<phi>) L", "qed auto"], ["", "lemma to_list_filter: \"p = sum_list [term * (Var v) ^ i. (term,i)\\<leftarrow>((filter (\\<lambda>(x,_). x\\<noteq>0) (to_list v p)))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "define L where \"L = to_list v p\""], ["proof (state)\nthis:\n  L = to_list v p\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "have \"(\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i) = (\\<Sum>(term, i)\\<leftarrow>filter (\\<lambda>(x, _). x \\<noteq> 0) (to_list v p). term * Var v ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i) =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "unfolding L_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(term, i)\\<leftarrow>L. term * Var v ^ i) =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       L. term * Var v ^ i)", "apply(induction L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>a\\<leftarrow>[]. case a of\n                            (term, i) \\<Rightarrow> term * Var v ^ i) =\n    (\\<Sum>a\\<leftarrow>filter\n                         (\\<lambda>a.\n                             case a of (x, uu_) \\<Rightarrow> x \\<noteq> 0)\n                         []. case a of\n                             (term, i) \\<Rightarrow> term * Var v ^ i)\n 2. \\<And>a L.\n       (\\<Sum>a\\<leftarrow>L. case a of\n                              (term, i) \\<Rightarrow> term * Var v ^ i) =\n       (\\<Sum>a\\<leftarrow>filter\n                            (\\<lambda>a.\n                                case a of\n                                (x, uu_) \\<Rightarrow> x \\<noteq> 0)\n                            L. case a of\n                               (term, i) \\<Rightarrow>\n                                 term * Var v ^ i) \\<Longrightarrow>\n       (\\<Sum>a\\<leftarrow>a #\n                           L. case a of\n                              (term, i) \\<Rightarrow> term * Var v ^ i) =\n       (\\<Sum>a\\<leftarrow>filter\n                            (\\<lambda>a.\n                                case a of\n                                (x, uu_) \\<Rightarrow> x \\<noteq> 0)\n                            (a #\n                             L). case a of\n                                 (term, i) \\<Rightarrow> term * Var v ^ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i) =\n  (\\<Sum>(term,\n      i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                     (to_list v p). term * Var v ^ i)\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i) =\n  (\\<Sum>(term,\n      i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                     (to_list v p). term * Var v ^ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i) =\n  (\\<Sum>(term,\n      i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                     (to_list v p). term * Var v ^ i)\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "using to_list_p[of p v]"], ["proof (prove)\nusing this:\n  (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i) =\n  (\\<Sum>(term,\n      i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                     (to_list v p). term * Var v ^ i)\n  p = (\\<Sum>(term, i)\\<leftarrow>to_list v p. term * Var v ^ i)\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>(term,\n        i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                       (to_list v p). term * Var v ^ i)", "by auto"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>(term,\n      i)\\<leftarrow>filter (\\<lambda>(x, uu_). x \\<noteq> 0)\n                     (to_list v p). term * Var v ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}