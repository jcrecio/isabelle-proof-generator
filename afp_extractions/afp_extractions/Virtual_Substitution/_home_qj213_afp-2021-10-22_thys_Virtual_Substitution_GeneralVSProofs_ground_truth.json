{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/GeneralVSProofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma separate_aEval :\n  assumes \"separateAtoms L = (a,b,c,d)\"\n  shows \"(\\<forall>l\\<in>set L. aEvalUni l x) = \n      ((\\<forall>(a,b,c)\\<in>set a. a*x^2+b*x+c=0) \\<and> (\\<forall>(a,b,c)\\<in>set b. a*x^2+b*x+c<0) \\<and>\n      (\\<forall>(a,b,c)\\<in>set c. a*x^2+b*x+c\\<le>0) \\<and> (\\<forall>(a,b,c)\\<in>set d. a*x^2+b*x+c\\<noteq>0))\"", "lemma splitAtoms_negInfinity :\n  assumes \"separateAtoms L = (a,b,c,d)\"\n  shows \"(\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) = (\n  (\\<forall>(a,b,c)\\<in>set a.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c=0))\\<and>\n  (\\<forall>(a,b,c)\\<in>set b.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c<0))\\<and>\n  (\\<forall>(a,b,c)\\<in>set c.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c\\<le>0))\\<and>\n  (\\<forall>(a,b,c)\\<in>set d.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c\\<noteq>0)))\"", "lemma set_split : \n  assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"set L = set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\"", "lemma set_split' : assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"set (map P L) = set (map (P o EqUni) eq @ map (P o LessUni) les @ map (P o LeqUni) leq @ map (P o NeqUni) neq)\"", "lemma split_elimVar :\n  assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"(\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) = \n  ((\\<exists>(a',b',c')\\<in>set eq. (evalUni (elimVarUni_atom L' (EqUni(a',b',c'))) x))\n  \\<or> (\\<exists>(a',b',c')\\<in>set les. \n    (evalUni (elimVarUni_atom L' (LessUni(a',b',c'))) x))\n\\<or> (\\<exists>(a',b',c')\\<in>set leq. \n    (evalUni (elimVarUni_atom L' (LeqUni(a',b',c'))) x))\n\\<or> (\\<exists>(a',b',c')\\<in>set neq. \n    (evalUni (elimVarUni_atom L' (NeqUni(a',b',c'))) x)))\"", "lemma split_elimvar : \n  assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"evalUni (elimVarUni_atom L At) x = evalUni (elimVarUni_atom ((map EqUni eq)@(map LessUni les) @ map LeqUni leq @ map NeqUni neq) At) x\"", "lemma less : \"\n         ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a. evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f))) x) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b. evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f))) x) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c. evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f))) x) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d. evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f))) x) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (EqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LessUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LeqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (NeqUni (d, e, f)))\n               x) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (EqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LessUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LeqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (NeqUni (d, e, f)))\n               x))) = \n\n          ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (EqUni (d, e, f)) x)) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n            (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (LessUni (d, e, f)) x))\\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (LeqUni (d, e, f)) x)) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n            (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (NeqUni (d, e, f)) x)) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (EqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LessUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LeqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (NeqUni (d,e,f)) x)) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (EqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LessUni (d,e,f)) x)) \\<and> \n          (\\<forall>(d, e, f)\\<in>set c.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LeqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (NeqUni (d,e,f)) x))))\"", "lemma eq_inf : \"(\\<forall>(a, b, c)\\<in>set (a::(real*real*real) list). \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) = (\\<forall>(a, b, c)\\<in>set a. a=0\\<and>b=0\\<and>c=0)\"", "lemma eval_generalVS'' : \"(\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n                               evalUni (generalVS_DNF L) x\"", "lemma forallx_substNegInf : \"(\\<not>evalUni (map_atomUni substNegInfinityUni F) x) = (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F) x)\"", "lemma linear_subst_map: \"evalUni (map_atomUni (linearSubstitutionUni b c) F) x = evalUni F (-c/b)\"", "lemma quadratic_subst_map : \"evalUni (map_atomUni (quadraticSubUni a b c d) F) x = evalUni F ((a+b*sqrt(c))/d)\"", "lemma convert_atom_list_change :\n  assumes \"length xs' = var\"\n  shows \"convert_atom_list var L (xs' @ x # \\<Gamma>) = convert_atom_list var L (xs' @ x' # \\<Gamma>)\"", "lemma negInf_convert :\n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"length xs' = var\"\n  shows \"(\\<forall>f\\<in>set L. eval (substNegInfinity var f) (xs' @ x # xs))\n         = (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\"", "lemma elimVar_atom_single :\n  assumes \"convert_atom var A (xs' @ x # xs) = Some A'\"\n  assumes \"convert_atom_list var L2 (xs' @ x # xs) = Some L2'\"\n  assumes \"length xs' = var\"\n  shows \"eval (elimVar var L2 [] A) (xs' @ x # xs) = evalUni (elimVarUni_atom L2' A') x\"", "lemma convert_list : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"l\\<in>set(L)\"\n  shows \"\\<exists>l'\\<in> set L'. convert_atom var l (xs' @ x # xs) = Some l'\"", "lemma convert_list2 : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"l'\\<in>set(L')\"\n  shows \"\\<exists>l\\<in> set L. convert_atom var l (xs' @ x # xs) = Some l'\"", "lemma elimVar_atom_convert : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"convert_atom_list var L2 (xs' @ x # xs) = Some L2'\"\n  assumes \"length xs' = var\"\n  shows \"(\\<exists>f\\<in>set L. eval (elimVar var L2 [] f) (xs' @ x # xs))\n         = (\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L2' f) x)\"", "lemma eval_convert : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"length xs' = var\"\n  shows \"(\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) = (\\<forall>f\\<in>set L'. aEvalUni f x)\"", "lemma all_degree_2_convert : \n  assumes \"all_degree_2 var L\"\n  shows \"\\<exists>L'. convert_atom_list var L xs = Some L'\"", "lemma gen_qe_eval :\n  assumes hlength : \"length xs = var\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval (gen_qe var L F) (xs @ (x#\\<Gamma>))))\"", "lemma freeIn_elimVar : \"freeIn var (elimVar var L F A)\"", "lemma freeInDisj: \"freeIn var (list_disj (list_conj (map (substNegInfinity var) L) # map (elimVar var L []) L))\"", "lemma gen_qe_eval' :\n  assumes \"all_degree_2 var L\"\n  assumes \"length xs' = var\"\n  shows \"(\\<exists>x. (eval (list_conj (map Atom L)) (xs'@x#\\<Gamma>))) = (\\<forall>x.(eval (gen_qe var L []) (xs'@x#\\<Gamma>)))\"\n    \"freeIn var (gen_qe var L [])\"", "lemma gen_qe_eval'' :\n  assumes \"all_degree_2 var L\"\n  assumes \"length xs' = var\"\n  shows \"(\\<exists>x. (eval (list_conj (map Atom L)) (xs'@x#\\<Gamma>))) = (\\<forall>x.(eval (list_disj\n                          (list_conj (map (substNegInfinity var) L) # map (elimVar var L []) L)) (xs'@x#\\<Gamma>)))\""], "translations": [["", "lemma separate_aEval :\n  assumes \"separateAtoms L = (a,b,c,d)\"\n  shows \"(\\<forall>l\\<in>set L. aEvalUni l x) = \n      ((\\<forall>(a,b,c)\\<in>set a. a*x^2+b*x+c=0) \\<and> (\\<forall>(a,b,c)\\<in>set b. a*x^2+b*x+c<0) \\<and>\n      (\\<forall>(a,b,c)\\<in>set c. a*x^2+b*x+c\\<le>0) \\<and> (\\<forall>(a,b,c)\\<in>set d. a*x^2+b*x+c\\<noteq>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set L. aEvalUni l x) =\n    ((\\<forall>(a, b, c)\\<in>set a. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d. a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "using assms"], ["proof (prove)\nusing this:\n  separateAtoms L = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set L. aEvalUni l x) =\n    ((\\<forall>(a, b, c)\\<in>set a. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d. a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "proof(induction L arbitrary :a b c d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       separateAtoms [] = (a, b, c, d) \\<Longrightarrow>\n       (\\<forall>l\\<in>set []. aEvalUni l x) =\n       ((\\<forall>(a, b, c)\\<in>set a. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set b. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set c.\n            a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set d.\n            a * x\\<^sup>2 + b * x + c \\<noteq> 0))\n 2. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        a * x\\<^sup>2 + b * x + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L). aEvalUni l x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  separateAtoms [] = (a, b, c, d)\n\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       separateAtoms [] = (a, b, c, d) \\<Longrightarrow>\n       (\\<forall>l\\<in>set []. aEvalUni l x) =\n       ((\\<forall>(a, b, c)\\<in>set a. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set b. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set c.\n            a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set d.\n            a * x\\<^sup>2 + b * x + c \\<noteq> 0))\n 2. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        a * x\\<^sup>2 + b * x + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L). aEvalUni l x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  separateAtoms [] = (a, b, c, d)", "show ?case"], ["proof (prove)\nusing this:\n  separateAtoms [] = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set []. aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set []. aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        a * x\\<^sup>2 + b * x + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L). aEvalUni l x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        a * x\\<^sup>2 + b * x + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L). aEvalUni l x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "case (Cons At L)"], ["proof (state)\nthis:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        a * x\\<^sup>2 + b * x + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L). aEvalUni l x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)", "have Cons1 : \"\\<And>a b c d. separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n    (\\<forall>l\\<in>set L. aEvalUni l x) =\n    ((\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\" \"\n    separateAtoms (At # L) = (a, b,c,d)\""], ["proof (prove)\nusing this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. aEvalUni l x) =\n        ((\\<forall>a\\<in>set a.\n             case a of\n             (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n         (\\<forall>a\\<in>set b.\n             case a of\n             (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n         (\\<forall>a\\<in>set c.\n             case a of\n             (a, ba, c) \\<Rightarrow>\n               a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n         (\\<forall>a\\<in>set d.\n             case a of\n             (a, ba, c) \\<Rightarrow>\n               a * x\\<^sup>2 + ba * x + c \\<noteq> 0))) &&&\n    separateAtoms (At # L) = (a, b, c, d)", "by auto"], ["proof (state)\nthis:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        a * x\\<^sup>2 + b * x + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L). aEvalUni l x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              a * x\\<^sup>2 + b * x + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              a * x\\<^sup>2 + b * x + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)", "show ?case"], ["proof (prove)\nusing this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = [] \\<Longrightarrow>\n    (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  b = []\n\ngoal (2 subgoals):\n 1. b = [] \\<Longrightarrow>\n    (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding LessUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) = (a, [], c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LessUni p # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n                (a, [], c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (LessUni p # L).\n                             aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (Cons p' b')"], ["proof (state)\nthis:\n  b = p' # b'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  b = p' # b'", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  b = p' # b'\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  b = p' # b'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding LessUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  b = p' # b'\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>b = p' # b';\n        (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a,b',c,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b', c, d)", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  b = p' # b'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b', c, d)", "unfolding LessUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  b = p' # b'\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b', c, d)", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>b = p' # b';\n        (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a, b', c, d)", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a, b', c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # b'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) = (\n          (\\<forall>a\\<in>set (b'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # b').\n        case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) =\n    ((\\<forall>a\\<in>set b'.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # b').\n      case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) =\n  ((\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (LessUni p # L). aEvalUni l x) = ((\\<forall>l\\<in>set (L). aEvalUni l x)\\<and>(case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LessUni p # L). aEvalUni l x) =\n    ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LessUni p # L). aEvalUni l x) =\n  ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n   (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       b = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding Cons LessUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set b'. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c < 0)) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set b'. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c < 0)) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "proof(cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = [] \\<Longrightarrow>\n    (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  a = []\n\ngoal (2 subgoals):\n 1. a = [] \\<Longrightarrow>\n    (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding EqUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) = ([], b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (EqUni p # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n                ([], b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (EqUni p # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (Cons p' a')"], ["proof (state)\nthis:\n  a = p' # a'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  a = p' # a'", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  a = p' # a'\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  a = p' # a'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding EqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  a = p' # a'\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = p' # a';\n        (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a',b,c,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a', b, c, d)", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  a = p' # a'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a', b, c, d)", "unfolding EqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  a = p' # a'\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a', b, c, d)", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = p' # a';\n        (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a', b, c, d)", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a', b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # a'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) = (\n          (\\<forall>a\\<in>set (a'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # a').\n        case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) =\n    ((\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # a').\n      case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) =\n  ((\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (EqUni p # L). aEvalUni l x) = ((\\<forall>l\\<in>set (L). aEvalUni l x)\\<and>(case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (EqUni p # L). aEvalUni l x) =\n    ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (EqUni p # L). aEvalUni l x) =\n  ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n   (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       a = a # list \\<Longrightarrow>\n       (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n       ((\\<forall>a\\<in>set a.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n        (\\<forall>a\\<in>set b.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n        (\\<forall>a\\<in>set c.\n            case a of\n            (a, ba, c) \\<Rightarrow>\n              a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n        (\\<forall>a\\<in>set d.\n            case a of\n            (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding Cons EqUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0)) =\n    (((\\<forall>(a, b, c)\\<in>set a'. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c = 0)) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0)) =\n    (((\\<forall>(a, b, c)\\<in>set a'. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c = 0)) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  At = LeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "proof(cases c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LeqUni p; c = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                      ((\\<forall>a\\<in>set a.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                       (\\<forall>a\\<in>set b.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                       (\\<forall>a\\<in>set c.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                       (\\<forall>a\\<in>set d.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  c = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LeqUni p; c = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                      ((\\<forall>a\\<in>set a.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                       (\\<forall>a\\<in>set b.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                       (\\<forall>a\\<in>set c.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                       (\\<forall>a\\<in>set d.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding LeqUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) = (a, b, [], d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LeqUni p # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n                (a, b, [], d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (LeqUni p # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (Cons p' a')"], ["proof (state)\nthis:\n  c = p' # a'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  c = p' # a'", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  c = p' # a'\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  c = p' # a'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding LeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  c = p' # a'\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>c = p' # a';\n        (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a,b,a',d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, a', d)", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  c = p' # a'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, a', d)", "unfolding LeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  c = p' # a'\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, a', d)", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>c = p' # a';\n        (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a, b, a', d)", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a, b, a', d)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # a'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) = (\n          (\\<forall>a\\<in>set (a'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # a').\n        case a of\n        (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) =\n    ((\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # a').\n      case a of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) =\n  ((\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (LeqUni p # L). aEvalUni l x) = ((\\<forall>l\\<in>set (L). aEvalUni l x)\\<and>(case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LeqUni p # L). aEvalUni l x) =\n    ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LeqUni p # L). aEvalUni l x) =\n  ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n   (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = LeqUni p; c = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding Cons LeqUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set a'.\n          a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<le> 0)) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set a'.\n          a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<le> 0)) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L. aEvalUni l x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          a * x\\<^sup>2 + ba * x + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  At = NeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "proof(cases d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = NeqUni p; d = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                      ((\\<forall>a\\<in>set a.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                       (\\<forall>a\\<in>set b.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                       (\\<forall>a\\<in>set c.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                       (\\<forall>a\\<in>set d.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  d = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = NeqUni p; d = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                      ((\\<forall>a\\<in>set a.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                       (\\<forall>a\\<in>set b.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                       (\\<forall>a\\<in>set c.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                       (\\<forall>a\\<in>set d.\n                           case a of\n                           (a, ba, c) \\<Rightarrow>\n                             a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n 2. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding NeqUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) = (a, b, c, [])\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (NeqUni p # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n                (a, b, c, []);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (NeqUni p # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "case (Cons p' a')"], ["proof (state)\nthis:\n  d = p' # a'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  d = p' # a'", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  d = p' # a'\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  d = p' # a'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding NeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  d = p' # a'\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>d = p' # a';\n        (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a,b,c,a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c, a')", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  d = p' # a'\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c, a')", "unfolding NeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  d = p' # a'\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c, a')", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>d = p' # a';\n        (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a, b, c, a')", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a, b, c, a')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # a'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0) = (\n          (\\<forall>a\\<in>set (a'). case a of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # a').\n        case a of\n        (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0) =\n    ((\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           a * x\\<^sup>2 + ba * x + c \\<noteq> 0) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # a').\n      case a of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0) =\n  ((\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         a * x\\<^sup>2 + ba * x + c \\<noteq> 0) \\<and>\n   (case p of\n    (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (NeqUni p # L). aEvalUni l x) = ((\\<forall>l\\<in>set (L). aEvalUni l x)\\<and>(case p of (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (NeqUni p # L). aEvalUni l x) =\n    ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (NeqUni p # L). aEvalUni l x) =\n  ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n   (case p of\n    (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>At = NeqUni p; d = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))", "unfolding Cons NeqUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set a'.\n         a * x\\<^sup>2 + b * x + c \\<noteq> 0) \\<and>\n     (case p of\n      (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((\\<forall>l\\<in>set L. aEvalUni l x) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set a'.\n         a * x\\<^sup>2 + b * x + c \\<noteq> 0) \\<and>\n     (case p of\n      (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). aEvalUni l x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow> a * x\\<^sup>2 + ba * x + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAtoms_negInfinity :\n  assumes \"separateAtoms L = (a,b,c,d)\"\n  shows \"(\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) = (\n  (\\<forall>(a,b,c)\\<in>set a.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c=0))\\<and>\n  (\\<forall>(a,b,c)\\<in>set b.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c<0))\\<and>\n  (\\<forall>(a,b,c)\\<in>set c.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c\\<le>0))\\<and>\n  (\\<forall>(a,b,c)\\<in>set d.(\\<exists>x. \\<forall>y<x. a*y^2+b*y+c\\<noteq>0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>(a, b, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "using assms"], ["proof (prove)\nusing this:\n  separateAtoms L = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>(a, b, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "proof(induction L arbitrary :a b c d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       separateAtoms [] = (a, b, c, d) \\<Longrightarrow>\n       (\\<forall>l\\<in>set []. evalUni (substNegInfinityUni l) x) =\n       ((\\<forall>(a, b, c)\\<in>set a.\n            \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set b.\n            \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set c.\n            \\<exists>x.\n               \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set d.\n            \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  separateAtoms [] = (a, b, c, d)\n\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       separateAtoms [] = (a, b, c, d) \\<Longrightarrow>\n       (\\<forall>l\\<in>set []. evalUni (substNegInfinityUni l) x) =\n       ((\\<forall>(a, b, c)\\<in>set a.\n            \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set b.\n            \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set c.\n            \\<exists>x.\n               \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n        (\\<forall>(a, b, c)\\<in>set d.\n            \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  separateAtoms [] = (a, b, c, d)", "show ?case"], ["proof (prove)\nusing this:\n  separateAtoms [] = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set []. evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set []. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case (Cons At L)"], ["proof (state)\nthis:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)", "have Cons1 : \"\\<And>a b c d. separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n    (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\" \"separateAtoms (At # L) = (a, b, c, d)\""], ["proof (prove)\nusing this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>a\\<in>set a.\n             case a of\n             (a, ba, c) \\<Rightarrow>\n               \\<exists>x.\n                  \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n         (\\<forall>a\\<in>set b.\n             case a of\n             (a, ba, c) \\<Rightarrow>\n               \\<exists>x.\n                  \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n         (\\<forall>a\\<in>set c.\n             case a of\n             (a, ba, c) \\<Rightarrow>\n               \\<exists>x.\n                  \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n         (\\<forall>a\\<in>set d.\n             case a of\n             (a, ba, c) \\<Rightarrow>\n               \\<exists>x.\n                  \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))) &&&\n    separateAtoms (At # L) = (a, b, c, d)", "by auto"], ["proof (state)\nthis:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a L aa b c d.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>(a, b, c)\\<in>set a.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set b.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set c.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                    (\\<forall>(a, b, c)\\<in>set d.\n                        \\<exists>x.\n                           \\<forall>y<x.\n                              a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (a # L) = (aa, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (a # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set aa.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)", "show ?case"], ["proof (prove)\nusing this:\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using LessUni Cons"], ["proof (prove)\nusing this:\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "proof(induction b rule : list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LessUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, [], c, d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, [], c, d)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LessUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, [], c, d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, [], c, d)", "have Nil : \"b = []\""], ["proof (prove)\nusing this:\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, [], c, d)\n\ngoal (1 subgoal):\n 1. b = []", "using Cons.prems"], ["proof (prove)\nusing this:\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, [], c, d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. b = []", "by auto"], ["proof (state)\nthis:\n  b = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LessUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, [], c, d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding LessUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) = (a, [], c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LessUni p # L).\n        evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n                (a, [], c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (LessUni p # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set [].\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case (Cons p' b')"], ["proof (state)\nthis:\n  \\<lbrakk>At = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, p' # b', c, d)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>At = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, p' # b', c, d)", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, p' # b', c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, p' # b', c, d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding LessUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>LessUni p = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n   (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (LessUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  LessUni p = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n  (a, p' # b', c, d)\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>LessUni p = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n                 (a, b', c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (LessUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        LessUni p = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n        (a, p' # b', c, d);\n        (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a,b',c,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b', c, d)", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, p' # b', c, d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b', c, d)", "unfolding LessUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>LessUni p = LessUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n   (a, b', c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (LessUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  LessUni p = LessUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n  (a, p' # b', c, d)\n  (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b', c, d)", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>LessUni p = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n                 (a, b', c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (LessUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        LessUni p = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n        (a, p' # b', c, d);\n        (let (a, b, c, d) = separateAtoms L in (a, p # b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a, b', c, d)", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a, b', c, d)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # b'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) = (\n          (\\<forall>a\\<in>set ( b'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # b').\n        case a of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) =\n    ((\\<forall>a\\<in>set b'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # b').\n      case a of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) =\n  ((\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have one: \"(\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) = (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n    (case p of\n     (a, ba, c) \\<Rightarrow>\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n       (case p of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (LessUni p) y) =\n  (case p of\n   (a, ba, c) \\<Rightarrow>\n     \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"(\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) = ((evalUni (substNegInfinityUni (LessUni p)) x)\\<and>(\\<forall>l\\<in>set ( L). evalUni (substNegInfinityUni l) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LessUni p # L).\n        evalUni (substNegInfinityUni l) x) =\n    (evalUni (substNegInfinityUni (LessUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (LessUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "also"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (LessUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"... = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n      (\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (substNegInfinityUni (LessUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding infinity_evalUni[of \"LessUni p\" x, symmetric] Cons(3)[OF h1]  LessUni one"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (evalUni (substNegInfinityUni (LessUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n      (\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) )\""], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LessUni p # L).\n        evalUni (substNegInfinityUni l) x) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LessUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LessUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, x2, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LessUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, x1 # x2, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set (p' # b').\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding Cons LessUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set b'.\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0)) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set b'.\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0)) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set (p' # b').\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using EqUni Cons"], ["proof (prove)\nusing this:\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "proof(induction a rule : list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = EqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = ([], b, c, d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = ([], b, c, d)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = EqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = ([], b, c, d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = ([], b, c, d)", "have Nil : \"a = []\""], ["proof (prove)\nusing this:\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = ([], b, c, d)\n\ngoal (1 subgoal):\n 1. a = []", "using Cons.prems"], ["proof (prove)\nusing this:\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = ([], b, c, d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. a = []", "by auto"], ["proof (state)\nthis:\n  a = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = EqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = ([], b, c, d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding EqUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) = ([], b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n                ([], b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (EqUni p # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set [].\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case (Cons p' a')"], ["proof (state)\nthis:\n  \\<lbrakk>At = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (p' # a', b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>At = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (p' # a', b, c, d)", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>At = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (p' # a', b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (p' # a', b, c, d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding EqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>EqUni p = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n   (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (EqUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  EqUni p = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n  (p' # a', b, c, d)\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>EqUni p = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n                 (a', b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (EqUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        EqUni p = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n        (p' # a', b, c, d);\n        (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a',b,c,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a', b, c, d)", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (p' # a', b, c, d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a', b, c, d)", "unfolding EqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>EqUni p = EqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n   (a', b, c, d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (EqUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  EqUni p = EqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n  (p' # a', b, c, d)\n  (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a', b, c, d)", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>EqUni p = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n                 (a', b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (EqUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        EqUni p = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n        (p' # a', b, c, d);\n        (let (a, b, c, d) = separateAtoms L in (p # a, b, c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a', b, c, d)", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a', b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # a'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) = (\n          (\\<forall>a\\<in>set ( a'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # a').\n        case a of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) =\n    ((\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # a').\n      case a of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) =\n  ((\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have one: \"(\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) = (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n    (case p of\n     (a, ba, c) \\<Rightarrow>\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n       (case p of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni p) y) =\n  (case p of\n   (a, ba, c) \\<Rightarrow>\n     \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"(\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) = ((evalUni (substNegInfinityUni (EqUni p)) x)\\<and>(\\<forall>l\\<in>set ( L). evalUni (substNegInfinityUni l) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n    (evalUni (substNegInfinityUni (EqUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (EqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "also"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (EqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"... = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)\\<and>\n      (\\<forall>a\\<in>set a'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (substNegInfinityUni (EqUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding infinity_evalUni[of \"EqUni p\" x, symmetric] Cons(3)[OF h1] EqUni one"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set a'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (evalUni (substNegInfinityUni (EqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0)\\<and>\n      (\\<forall>a\\<in>set a'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\""], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set a'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (EqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = EqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (x2, b, c, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = EqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (x1 # x2, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set (p' # a').\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding Cons EqUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    (((\\<forall>(a, b, c)\\<in>set a'.\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    (((\\<forall>(a, b, c)\\<in>set a'.\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0)) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set (p' # a').\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using LeqUni Cons"], ["proof (prove)\nusing this:\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "proof(induction c rule : list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LeqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, b, [], d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, [], d)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LeqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, b, [], d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, [], d)", "have Nil : \"c = []\""], ["proof (prove)\nusing this:\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, [], d)\n\ngoal (1 subgoal):\n 1. c = []", "using Cons.prems"], ["proof (prove)\nusing this:\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, [], d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. c = []", "by auto"], ["proof (state)\nthis:\n  c = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = LeqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, b, [], d)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set d.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding LeqUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) = (a, b, [], d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n                (a, b, [], d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (LeqUni p # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set [].\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case (Cons p' c')"], ["proof (state)\nthis:\n  \\<lbrakk>At = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, p' # c', d)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>At = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, p' # c', d)", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, p' # c', d)\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, p' # c', d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding LeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeqUni p = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n   (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (LeqUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  LeqUni p = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n  (a, b, p' # c', d)\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>LeqUni p = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n                 (a, b, c', d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (LeqUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        LeqUni p = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n        (a, b, p' # c', d);\n        (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a,b,c',d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c', d)", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, p' # c', d)\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c', d)", "unfolding LeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>LeqUni p = LeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n   (a, b, c', d)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (LeqUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  LeqUni p = LeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n  (a, b, p' # c', d)\n  (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c', d)", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>LeqUni p = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n                 (a, b, c', d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (LeqUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        LeqUni p = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n        (a, b, p' # c', d);\n        (let (a, b, c, d) = separateAtoms L in (a, b, p # c, d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a, b, c', d)", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a, b, c', d)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # c'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) = (\n          (\\<forall>a\\<in>set ( c'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # c').\n        case a of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) =\n    ((\\<forall>a\\<in>set c'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # c').\n      case a of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) =\n  ((\\<forall>a\\<in>set c'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have one: \"(\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) = (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n    (case p of\n     (a, ba, c) \\<Rightarrow>\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n       (case p of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (LeqUni p) y) =\n  (case p of\n   (a, ba, c) \\<Rightarrow>\n     \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"(\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) = ((evalUni (substNegInfinityUni (LeqUni p)) x)\\<and>(\\<forall>l\\<in>set ( L). evalUni (substNegInfinityUni l) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n    (evalUni (substNegInfinityUni (LeqUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (LeqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "also"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (LeqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"... = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n      (\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (substNegInfinityUni (LeqUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding infinity_evalUni[of \"LeqUni p\" x, symmetric] Cons(3)[OF h1]  LeqUni one"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (evalUni (substNegInfinityUni (LeqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n      (\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) )\""], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (LeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = LeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, x2, d)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set d.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = LeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, x1 # x2, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set d.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set (p' # c').\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding Cons LeqUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c'.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set c'.\n          \\<exists>x.\n             \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c'.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     ((\\<forall>(a, b, c)\\<in>set c'.\n          \\<exists>x.\n             \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n      (case p of\n       (a, b, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0)) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set (p' # c').\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>a b c d.\n                   separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                   (\\<forall>l\\<in>set L.\n                       evalUni (substNegInfinityUni l) x) =\n                   ((\\<forall>a\\<in>set a.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                    (\\<forall>a\\<in>set b.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                    (\\<forall>a\\<in>set c.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                    (\\<forall>a\\<in>set d.\n                        case a of\n                        (a, ba, c) \\<Rightarrow>\n                          \\<exists>x.\n                             \\<forall>y<x.\n                                a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, d); At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set d.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using NeqUni Cons"], ["proof (prove)\nusing this:\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "proof(induction d rule : list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = NeqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, b, c, [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case Nil"], ["proof (state)\nthis:\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = NeqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, b, c, [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, [])", "have Nil : \"d = []\""], ["proof (prove)\nusing this:\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, [])\n\ngoal (1 subgoal):\n 1. d = []", "using Cons.prems"], ["proof (prove)\nusing this:\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, [])\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. d = []", "by auto"], ["proof (state)\nthis:\n  d = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = NeqUni p;\n     \\<And>a b c d.\n        separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n        (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n        ((\\<forall>(a, b, c)\\<in>set a.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set b.\n             \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set c.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n         (\\<forall>(a, b, c)\\<in>set d.\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n     separateAtoms (At # L) = (a, b, c, [])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                          evalUni (substNegInfinityUni l) x) =\n                      ((\\<forall>(a, b, c)\\<in>set a.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set b.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set c.\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                       (\\<forall>(a, b, c)\\<in>set [].\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + b * y + c \\<noteq> 0))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding NeqUni separateAtoms.simps Nil"], ["proof (prove)\nusing this:\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) = (a, b, c, [])\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set [].\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n                (a, b, c, []);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (NeqUni p # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>a\\<in>set a.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                          (\\<forall>a\\<in>set b.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                          (\\<forall>a\\<in>set c.\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                          (\\<forall>a\\<in>set [].\n                              case a of\n                              (a, ba, c) \\<Rightarrow>\n                                \\<exists>x.\n                                   \\<forall>y<x.\na * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set [].\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "case (Cons p' d')"], ["proof (state)\nthis:\n  \\<lbrakk>At = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, p' # d')\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>At = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, p' # d')", "have p_def : \"p' = p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>At = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, p' # d')\n\ngoal (1 subgoal):\n 1. p' = p", "using Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, p' # d')\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "unfolding NeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>NeqUni p = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n   (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (NeqUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  NeqUni p = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n  (a, b, c, p' # d')\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. p' = p", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>NeqUni p = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n                 (a, b, c, d')\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (NeqUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        NeqUni p = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n        (a, b, c, p' # d');\n        (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> p' = p", "by simp"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h1 :  \"separateAtoms L = (a,b,c,d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c, d')", "using Cons Cons1(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   separateAtoms (At # L) = (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  At = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  separateAtoms (At # L) = (a, b, c, p' # d')\n  separateAtoms (At # L) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c, d')", "unfolding NeqUni separateAtoms.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>NeqUni p = NeqUni p;\n   \\<And>a b c d.\n      separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n      (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n      ((\\<forall>a\\<in>set a.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n       (\\<forall>a\\<in>set b.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n       (\\<forall>a\\<in>set c.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n       (\\<forall>a\\<in>set d.\n           case a of\n           (a, ba, c) \\<Rightarrow>\n             \\<exists>x.\n                \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n   (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n   (a, b, c, d')\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>l\\<in>set (NeqUni p # L).\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d'.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  NeqUni p = NeqUni p\n  separateAtoms L = (?a, ?b, ?c, ?d) \\<Longrightarrow>\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set ?a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set ?b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set ?c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set ?d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n  (a, b, c, p' # d')\n  (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. separateAtoms L = (a, b, c, d')", "apply(cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<lbrakk>NeqUni p = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>a\\<in>set a.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                     (\\<forall>a\\<in>set b.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                     (\\<forall>a\\<in>set c.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                     (\\<forall>a\\<in>set d.\n                         case a of\n                         (a, ba, c) \\<Rightarrow>\n                           \\<exists>x.\n                              \\<forall>y<x.\n                                 a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n                 (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n                 (a, b, c, d')\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (NeqUni p # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>a\\<in>set a.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n                                   (\\<forall>a\\<in>set b.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n                                   (\\<forall>a\\<in>set c.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n                                   (\\<forall>a\\<in>set d'.\n case a of\n (a, ba, c) \\<Rightarrow>\n   \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        NeqUni p = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>a\\<in>set a.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n            (\\<forall>a\\<in>set b.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n            (\\<forall>a\\<in>set c.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x.\n                        a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n            (\\<forall>a\\<in>set d.\n                case a of\n                (a, ba, c) \\<Rightarrow>\n                  \\<exists>x.\n                     \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0));\n        (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n        (a, b, c, p' # d');\n        (let (a, b, c, d) = separateAtoms L in (a, b, c, p # d)) =\n        (a, b, c, d);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> separateAtoms L = (a, b, c, d')", "by simp"], ["proof (state)\nthis:\n  separateAtoms L = (a, b, c, d')\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have h2 : \"(\\<forall>a\\<in>set (p # d'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) = (\n          (\\<forall>a\\<in>set ( d'). case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)\\<and> (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>set (p # d').\n        case a of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) =\n    ((\\<forall>a\\<in>set d'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set (p # d').\n      case a of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) =\n  ((\\<forall>a\\<in>set d'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n   (case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have one: \"(\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) = (case p of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n    (case p of\n     (a, ba, c) \\<Rightarrow>\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n       (case p of\n        (a, ba, c) \\<Rightarrow>\n          \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (NeqUni p) y) =\n  (case p of\n   (a, ba, c) \\<Rightarrow>\n     \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"(\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) = ((evalUni (substNegInfinityUni (NeqUni p)) x)\\<and>(\\<forall>l\\<in>set ( L). evalUni (substNegInfinityUni l) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n    (evalUni (substNegInfinityUni (NeqUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (NeqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "also"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  (evalUni (substNegInfinityUni (NeqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "have \"... = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)\\<and>\n      (\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (substNegInfinityUni (NeqUni p)) x \\<and>\n     (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x.\n           \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding infinity_evalUni[of \"NeqUni p\" x, symmetric] Cons(3)[OF h1]  NeqUni one"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x.\n           \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set c.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0)) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x.\n           \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by simp"], ["proof (state)\nthis:\n  (evalUni (substNegInfinityUni (NeqUni p)) x \\<and>\n   (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x)) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x.\n         \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x.\n         \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "have h3 : \"(\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) = (\n      (case p of (a,ba,c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)\\<and>\n      (\\<forall>a\\<in>set a. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0)\\<and>\n     (\\<forall>a\\<in>set c. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0)\\<and>\n     (\\<forall>a\\<in>set d'. case a of (a, ba, c) \\<Rightarrow> \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) )\""], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x.\n         \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n    ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x.\n           \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set d'.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (NeqUni p # L). evalUni (substNegInfinityUni l) x) =\n  ((case p of\n    (a, ba, c) \\<Rightarrow>\n      \\<exists>x.\n         \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n   (\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>At = NeqUni p;\n                 \\<And>a b c d.\n                    separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n                    (\\<forall>l\\<in>set L.\n                        evalUni (substNegInfinityUni l) x) =\n                    ((\\<forall>(a, b, c)\\<in>set a.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set b.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set c.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                     (\\<forall>(a, b, c)\\<in>set d.\n                         \\<exists>x.\n                            \\<forall>y<x.\n                               a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n                 separateAtoms (At # L) = (a, b, c, x2)\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\nevalUni (substNegInfinityUni l) x) =\n                                  ((\\<forall>(a, b, c)\\<in>set a.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set b.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set c.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n                                   (\\<forall>(a, b, c)\\<in>set x2.\n \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        At = NeqUni p;\n        \\<And>a b c d.\n           separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n           (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n           ((\\<forall>(a, b, c)\\<in>set a.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set b.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set c.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n            (\\<forall>(a, b, c)\\<in>set d.\n                \\<exists>x.\n                   \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0));\n        separateAtoms (At # L) = (a, b, c, x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>l\\<in>set (At # L).\n                             evalUni (substNegInfinityUni l) x) =\n                         ((\\<forall>(a, b, c)\\<in>set a.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c = 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set b.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c < 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set c.\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c\n                                    \\<le> 0) \\<and>\n                          (\\<forall>(a, b, c)\\<in>set (x1 # x2).\n                              \\<exists>x.\n                                 \\<forall>y<x.\n                                    a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>a\\<in>set (p' # d').\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))", "unfolding Cons NeqUni p_def h2 h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x.\n           \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d'.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<and>\n     (case p of\n      (a, b, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "using Cons1(1)[OF h1]"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L. evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d'.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. ((case p of\n      (a, ba, c) \\<Rightarrow>\n        \\<exists>x.\n           \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set a.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set b.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set c.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, ba, c)\\<in>set d'.\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0)) =\n    ((\\<forall>a\\<in>set a.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n     (\\<forall>a\\<in>set b.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n     (\\<forall>a\\<in>set c.\n         case a of\n         (a, ba, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n     (\\<forall>(a, b, c)\\<in>set d'.\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<and>\n     (case p of\n      (a, b, c) \\<Rightarrow>\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set (p' # d').\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (At # L). evalUni (substNegInfinityUni l) x) =\n  ((\\<forall>a\\<in>set a.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c = 0) \\<and>\n   (\\<forall>a\\<in>set b.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c < 0) \\<and>\n   (\\<forall>a\\<in>set c.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x.\n            \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<le> 0) \\<and>\n   (\\<forall>a\\<in>set d.\n       case a of\n       (a, ba, c) \\<Rightarrow>\n         \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + ba * y + c \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_split : \n  assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"set L = set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set L =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "using assms"], ["proof (prove)\nusing this:\n  separateAtoms L = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. set L =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "proof(induction L arbitrary :eq les leq neq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>eqa les leq neq.\n       separateAtoms [] = (eqa, les, leq, neq) \\<Longrightarrow>\n       set [] =\n       set (map EqUni eqa @\n            map LessUni les @ map LeqUni leq @ map NeqUni neq)\n 2. \\<And>a L eqa les leq neq.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (a # L) = (eqa, les, leq, neq)\\<rbrakk>\n       \\<Longrightarrow> set (a # L) =\n                         set (map EqUni eqa @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "case Nil"], ["proof (state)\nthis:\n  separateAtoms [] = (eq, les, leq, neq)\n\ngoal (2 subgoals):\n 1. \\<And>eqa les leq neq.\n       separateAtoms [] = (eqa, les, leq, neq) \\<Longrightarrow>\n       set [] =\n       set (map EqUni eqa @\n            map LessUni les @ map LeqUni leq @ map NeqUni neq)\n 2. \\<And>a L eqa les leq neq.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (a # L) = (eqa, les, leq, neq)\\<rbrakk>\n       \\<Longrightarrow> set (a # L) =\n                         set (map EqUni eqa @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "then"], ["proof (chain)\npicking this:\n  separateAtoms [] = (eq, les, leq, neq)", "show ?case"], ["proof (prove)\nusing this:\n  separateAtoms [] = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. set [] =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "by auto"], ["proof (state)\nthis:\n  set [] =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal (1 subgoal):\n 1. \\<And>a L eqa les leq neq.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (a # L) = (eqa, les, leq, neq)\\<rbrakk>\n       \\<Longrightarrow> set (a # L) =\n                         set (map EqUni eqa @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L eqa les leq neq.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (a # L) = (eqa, les, leq, neq)\\<rbrakk>\n       \\<Longrightarrow> set (a # L) =\n                         set (map EqUni eqa @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "case (Cons At L)"], ["proof (state)\nthis:\n  separateAtoms L = (?eq, ?les, ?leq, ?neq) \\<Longrightarrow>\n  set L =\n  set (map EqUni ?eq @ map LessUni ?les @ map LeqUni ?leq @ map NeqUni ?neq)\n  separateAtoms (At # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<And>a L eqa les leq neq.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (a # L) = (eqa, les, leq, neq)\\<rbrakk>\n       \\<Longrightarrow> set (a # L) =\n                         set (map EqUni eqa @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "then"], ["proof (chain)\npicking this:\n  separateAtoms L = (?eq, ?les, ?leq, ?neq) \\<Longrightarrow>\n  set L =\n  set (map EqUni ?eq @ map LessUni ?les @ map LeqUni ?leq @ map NeqUni ?neq)\n  separateAtoms (At # L) = (eq, les, leq, neq)", "show ?case"], ["proof (prove)\nusing this:\n  separateAtoms L = (?eq, ?les, ?leq, ?neq) \\<Longrightarrow>\n  set L =\n  set (map EqUni ?eq @ map LessUni ?les @ map LeqUni ?leq @ map NeqUni ?neq)\n  separateAtoms (At # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. set (At # L) =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "have \"\\<exists>les'. p#les' = les \\<and> separateAtoms L = (eq, les', leq, neq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>les'.\n       p # les' = les \\<and> separateAtoms L = (eq, les', leq, neq)", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>les'.\n       p # les' = les \\<and> separateAtoms L = (eq, les', leq, neq)", "unfolding LessUni"], ["proof (prove)\nusing this:\n  separateAtoms (LessUni p # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>les'.\n       p # les' = les \\<and> separateAtoms L = (eq, les', leq, neq)", "apply (cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>separateAtoms (LessUni p # L) = (eq, les, leq, neq);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>les'.\n                            p # les' = les \\<and>\n                            separateAtoms L = (eq, les', leq, neq)", "by auto"], ["proof (state)\nthis:\n  \\<exists>les'.\n     p # les' = les \\<and> separateAtoms L = (eq, les', leq, neq)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "then"], ["proof (chain)\npicking this:\n  \\<exists>les'.\n     p # les' = les \\<and> separateAtoms L = (eq, les', leq, neq)", "obtain les' where les' : \"p#les' = les\" \"separateAtoms L = (eq, les', leq, neq)\""], ["proof (prove)\nusing this:\n  \\<exists>les'.\n     p # les' = les \\<and> separateAtoms L = (eq, les', leq, neq)\n\ngoal (1 subgoal):\n 1. (\\<And>les'.\n        \\<lbrakk>p # les' = les;\n         separateAtoms L = (eq, les', leq, neq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p # les' = les\n  separateAtoms L = (eq, les', leq, neq)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LessUni x1\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (At # L) =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "unfolding LessUni les'(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (LessUni p # L) =\n    set (map EqUni eq @\n         map LessUni (p # les') @ map LeqUni leq @ map NeqUni neq)", "using Cons(1)[OF les'(2)]"], ["proof (prove)\nusing this:\n  set L =\n  set (map EqUni eq @ map LessUni les' @ map LeqUni leq @ map NeqUni neq)\n\ngoal (1 subgoal):\n 1. set (LessUni p # L) =\n    set (map EqUni eq @\n         map LessUni (p # les') @ map LeqUni leq @ map NeqUni neq)", "by auto"], ["proof (state)\nthis:\n  set (At # L) =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "have \"\\<exists>eq'. p#eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>eq'. p # eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>eq'. p # eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)", "unfolding EqUni"], ["proof (prove)\nusing this:\n  separateAtoms (EqUni p # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>eq'. p # eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)", "apply (cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>separateAtoms (EqUni p # L) = (eq, les, leq, neq);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eq'.\n                            p # eq' = eq \\<and>\n                            separateAtoms L = (eq', les, leq, neq)", "by auto"], ["proof (state)\nthis:\n  \\<exists>eq'. p # eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "then"], ["proof (chain)\npicking this:\n  \\<exists>eq'. p # eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)", "obtain eq' where eq' : \"p#eq' = eq\" \"separateAtoms L = (eq', les, leq, neq)\""], ["proof (prove)\nusing this:\n  \\<exists>eq'. p # eq' = eq \\<and> separateAtoms L = (eq', les, leq, neq)\n\ngoal (1 subgoal):\n 1. (\\<And>eq'.\n        \\<lbrakk>p # eq' = eq;\n         separateAtoms L = (eq', les, leq, neq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p # eq' = eq\n  separateAtoms L = (eq', les, leq, neq)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq); At = EqUni x2\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (At # L) =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "unfolding EqUni eq'(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (EqUni p # L) =\n    set (map EqUni (p # eq') @\n         map LessUni les @ map LeqUni leq @ map NeqUni neq)", "using Cons(1)[OF eq'(2)]"], ["proof (prove)\nusing this:\n  set L =\n  set (map EqUni eq' @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal (1 subgoal):\n 1. set (EqUni p # L) =\n    set (map EqUni (p # eq') @\n         map LessUni les @ map LeqUni leq @ map NeqUni neq)", "by auto"], ["proof (state)\nthis:\n  set (At # L) =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "have \"\\<exists>leq'. p#leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>leq'.\n       p # leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>leq'.\n       p # leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)", "unfolding LeqUni"], ["proof (prove)\nusing this:\n  separateAtoms (LeqUni p # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>leq'.\n       p # leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)", "apply (cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>separateAtoms (LeqUni p # L) = (eq, les, leq, neq);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>leq'.\n                            p # leq' = leq \\<and>\n                            separateAtoms L = (eq, les, leq', neq)", "by auto"], ["proof (state)\nthis:\n  \\<exists>leq'.\n     p # leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "then"], ["proof (chain)\npicking this:\n  \\<exists>leq'.\n     p # leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)", "obtain leq' where leq' : \"p#leq' = leq\" \"separateAtoms L = (eq, les, leq', neq)\""], ["proof (prove)\nusing this:\n  \\<exists>leq'.\n     p # leq' = leq \\<and> separateAtoms L = (eq, les, leq', neq)\n\ngoal (1 subgoal):\n 1. (\\<And>leq'.\n        \\<lbrakk>p # leq' = leq;\n         separateAtoms L = (eq, les, leq', neq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p # leq' = leq\n  separateAtoms L = (eq, les, leq', neq)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = LeqUni x3\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (At # L) =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "unfolding LeqUni leq'(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (LeqUni p # L) =\n    set (map EqUni eq @\n         map LessUni les @ map LeqUni (p # leq') @ map NeqUni neq)", "using Cons(1)[OF leq'(2)]"], ["proof (prove)\nusing this:\n  set L =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq' @ map NeqUni neq)\n\ngoal (1 subgoal):\n 1. set (LeqUni p # L) =\n    set (map EqUni eq @\n         map LessUni les @ map LeqUni (p # leq') @ map NeqUni neq)", "by auto"], ["proof (state)\nthis:\n  set (At # L) =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "have \"\\<exists>neq'. p#neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>neq'.\n       p # neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')", "using Cons(2)"], ["proof (prove)\nusing this:\n  separateAtoms (At # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>neq'.\n       p # neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')", "unfolding NeqUni"], ["proof (prove)\nusing this:\n  separateAtoms (NeqUni p # L) = (eq, les, leq, neq)\n\ngoal (1 subgoal):\n 1. \\<exists>neq'.\n       p # neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')", "apply (cases \"separateAtoms L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>separateAtoms (NeqUni p # L) = (eq, les, leq, neq);\n        separateAtoms L = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>neq'.\n                            p # neq' = neq \\<and>\n                            separateAtoms L = (eq, les, leq, neq')", "by auto"], ["proof (state)\nthis:\n  \\<exists>neq'.\n     p # neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "then"], ["proof (chain)\npicking this:\n  \\<exists>neq'.\n     p # neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')", "obtain neq' where neq' : \"p#neq' = neq\" \"separateAtoms L = (eq, les, leq, neq')\""], ["proof (prove)\nusing this:\n  \\<exists>neq'.\n     p # neq' = neq \\<and> separateAtoms L = (eq, les, leq, neq')\n\ngoal (1 subgoal):\n 1. (\\<And>neq'.\n        \\<lbrakk>p # neq' = neq;\n         separateAtoms L = (eq, les, leq, neq')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p # neq' = neq\n  separateAtoms L = (eq, les, leq, neq')\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>eqa les leq neq.\n                   separateAtoms L = (eqa, les, leq, neq) \\<Longrightarrow>\n                   set L =\n                   set (map EqUni eqa @\n                        map LessUni les @ map LeqUni leq @ map NeqUni neq);\n        separateAtoms (At # L) = (eq, les, leq, neq);\n        At = NeqUni x4\\<rbrakk>\n       \\<Longrightarrow> set (At # L) =\n                         set (map EqUni eq @\n                              map LessUni les @\n                              map LeqUni leq @ map NeqUni neq)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (At # L) =\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)", "unfolding NeqUni neq'(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (NeqUni p # L) =\n    set (map EqUni eq @\n         map LessUni les @ map LeqUni leq @ map NeqUni (p # neq'))", "using Cons(1)[OF neq'(2)]"], ["proof (prove)\nusing this:\n  set L =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq')\n\ngoal (1 subgoal):\n 1. set (NeqUni p # L) =\n    set (map EqUni eq @\n         map LessUni les @ map LeqUni leq @ map NeqUni (p # neq'))", "by auto"], ["proof (state)\nthis:\n  set (At # L) =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (At # L) =\n  set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_split' : assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"set (map P L) = set (map (P o EqUni) eq @ map (P o LessUni) les @ map (P o LeqUni) leq @ map (P o NeqUni) neq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map P L) =\n    set (map (P \\<circ> EqUni) eq @\n         map (P \\<circ> LessUni) les @\n         map (P \\<circ> LeqUni) leq @ map (P \\<circ> NeqUni) neq)", "unfolding image_set[symmetric] set_split[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. P `\n    set (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq) =\n    set (map (P \\<circ> EqUni) eq @\n         map (P \\<circ> LessUni) les @\n         map (P \\<circ> LeqUni) leq @ map (P \\<circ> NeqUni) neq)", "unfolding image_set map_append map_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (P \\<circ> EqUni) eq @\n         map (P \\<circ> LessUni) les @\n         map (P \\<circ> LeqUni) leq @ map (P \\<circ> NeqUni) neq) =\n    set (map (P \\<circ> EqUni) eq @\n         map (P \\<circ> LessUni) les @\n         map (P \\<circ> LeqUni) leq @ map (P \\<circ> NeqUni) neq)", "by auto"], ["", "lemma split_elimVar :\n  assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"(\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) = \n  ((\\<exists>(a',b',c')\\<in>set eq. (evalUni (elimVarUni_atom L' (EqUni(a',b',c'))) x))\n  \\<or> (\\<exists>(a',b',c')\\<in>set les. \n    (evalUni (elimVarUni_atom L' (LessUni(a',b',c'))) x))\n\\<or> (\\<exists>(a',b',c')\\<in>set leq. \n    (evalUni (elimVarUni_atom L' (LeqUni(a',b',c'))) x))\n\\<or> (\\<exists>(a',b',c')\\<in>set neq. \n    (evalUni (elimVarUni_atom L' (NeqUni(a',b',c'))) x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "have c1: \"(\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) = (\\<exists>(a', b', c')\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) =\n    (\\<exists>(a', b', c')\\<in>set eq.\n        evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x)", "by (metis (no_types, lifting) case_prodE case_prodI2)"], ["proof (state)\nthis:\n  (\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set eq.\n      evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x)\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "have c2: \"(\\<exists>l\\<in>set les. evalUni (elimVarUni_atom L' (LessUni l)) x) = (\\<exists>(a', b', c')\\<in>set les. evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set les. evalUni (elimVarUni_atom L' (LessUni l)) x) =\n    (\\<exists>(a', b', c')\\<in>set les.\n        evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x)", "by (metis (no_types, lifting) case_prodE case_prodI2)"], ["proof (state)\nthis:\n  (\\<exists>l\\<in>set les. evalUni (elimVarUni_atom L' (LessUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set les.\n      evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x)\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "have c3: \"(\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) = (\\<exists>(a', b', c')\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) =\n    (\\<exists>(a', b', c')\\<in>set leq.\n        evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x)", "by (metis (no_types, lifting) case_prodE case_prodI2)"], ["proof (state)\nthis:\n  (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set leq.\n      evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x)\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "have c4: \"(\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x) = (\\<exists>(a', b', c')\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x) =\n    (\\<exists>(a', b', c')\\<in>set neq.\n        evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x)", "by (metis (no_types, lifting) case_prodE case_prodI2)"], ["proof (state)\nthis:\n  (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set neq.\n      evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x)\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "have h :  \"((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n         (\\<exists>l\\<in>LessUni ` set les. evalUni (elimVarUni_atom L' l) x) \\<or>\n    (\\<exists>l\\<in>LeqUni ` set leq. evalUni (elimVarUni_atom L' l) x) \\<or>\n    (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)\n    ) = \n        ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n         (\\<exists>l\\<in>set les. evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n    (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n    (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>LessUni ` set les.\n         evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>LeqUni ` set leq.\n         evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n    ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n     (\\<exists>l\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n     (\\<exists>l\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n     (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x))", "by auto"], ["proof (state)\nthis:\n  ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LessUni ` set les.\n       evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LeqUni ` set leq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x))\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "then"], ["proof (chain)\npicking this:\n  ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LessUni ` set les.\n       evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LeqUni ` set leq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x))", "have \"... = ((\\<exists>(a', b', c')\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les. evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))\""], ["proof (prove)\nusing this:\n  ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LessUni ` set les.\n       evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LeqUni ` set leq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x))\n\ngoal (1 subgoal):\n 1. ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n     (\\<exists>l\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n     (\\<exists>l\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n     (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "using c1 c2 c3 c4"], ["proof (prove)\nusing this:\n  ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LessUni ` set les.\n       evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>LeqUni ` set leq. evalUni (elimVarUni_atom L' l) x) \\<or>\n   (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x))\n  (\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set eq.\n      evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x)\n  (\\<exists>l\\<in>set les. evalUni (elimVarUni_atom L' (LessUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set les.\n      evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x)\n  (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set leq.\n      evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x)\n  (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x) =\n  (\\<exists>(a', b', c')\\<in>set neq.\n      evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x)\n\ngoal (1 subgoal):\n 1. ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n     (\\<exists>l\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n     (\\<exists>l\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n     (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "by auto"], ["proof (state)\nthis:\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n  ((\\<exists>(a', b', c')\\<in>set eq.\n       evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set leq.\n       evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set neq.\n       evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "then"], ["proof (chain)\npicking this:\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n  ((\\<exists>(a', b', c')\\<in>set eq.\n       evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set leq.\n       evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set neq.\n       evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n  ((\\<exists>(a', b', c')\\<in>set eq.\n       evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set leq.\n       evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set neq.\n       evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))\n\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "unfolding set_split[OF assms] set_append bex_Un image_set[symmetric]"], ["proof (prove)\nusing this:\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n  ((\\<exists>(a', b', c')\\<in>set eq.\n       evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set leq.\n       evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set neq.\n       evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))\n\ngoal (1 subgoal):\n 1. ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>LessUni ` set les.\n         evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>LeqUni ` set leq.\n         evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "using case_prodE case_prodI2"], ["proof (prove)\nusing this:\n  ((\\<exists>l\\<in>set eq. evalUni (elimVarUni_atom L' (EqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni l)) x) \\<or>\n   (\\<exists>l\\<in>set leq. evalUni (elimVarUni_atom L' (LeqUni l)) x) \\<or>\n   (\\<exists>l\\<in>set neq. evalUni (elimVarUni_atom L' (NeqUni l)) x)) =\n  ((\\<exists>(a', b', c')\\<in>set eq.\n       evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set leq.\n       evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set neq.\n       evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))\n  \\<lbrakk>case ?p of (a, b) \\<Rightarrow> ?c a b;\n   \\<And>x y.\n      \\<lbrakk>?p = (x, y); ?c x y\\<rbrakk> \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  (\\<And>a b. ?p = (a, b) \\<Longrightarrow> ?c a b) \\<Longrightarrow>\n  case ?p of (a, b) \\<Rightarrow> ?c a b\n\ngoal (1 subgoal):\n 1. ((\\<exists>l\\<in>EqUni ` set eq. evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>LessUni ` set les.\n         evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>LeqUni ` set leq.\n         evalUni (elimVarUni_atom L' l) x) \\<or>\n     (\\<exists>l\\<in>NeqUni ` set neq. evalUni (elimVarUni_atom L' l) x)) =\n    ((\\<exists>(a', b', c')\\<in>set eq.\n         evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set les.\n         evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set leq.\n         evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set neq.\n         evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L' l) x) =\n  ((\\<exists>(a', b', c')\\<in>set eq.\n       evalUni (elimVarUni_atom L' (EqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set les.\n       evalUni (elimVarUni_atom L' (LessUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set leq.\n       evalUni (elimVarUni_atom L' (LeqUni (a', b', c'))) x) \\<or>\n   (\\<exists>(a', b', c')\\<in>set neq.\n       evalUni (elimVarUni_atom L' (NeqUni (a', b', c'))) x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_elimvar : \n  assumes \"separateAtoms L = (eq,les,leq,neq)\"\n  shows \"evalUni (elimVarUni_atom L At) x = evalUni (elimVarUni_atom ((map EqUni eq)@(map LessUni les) @ map LeqUni leq @ map NeqUni neq) At) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (elimVarUni_atom L At) x =\n    evalUni\n     (elimVarUni_atom\n       (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n       At)\n     x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. evalUni (elimVarUni_atom L At) x =\n    evalUni\n     (elimVarUni_atom\n       (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n       At)\n     x", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> evalUni (elimVarUni_atom L At) x =\n                         evalUni\n                          (elimVarUni_atom\n                            (map EqUni eq @\n                             map LessUni les @\n                             map LeqUni leq @ map NeqUni neq)\n                            At)\n                          x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (substInfinitesimalLinearUni b c) L))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x)) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (substInfinitesimalLinearUni b c \\<circ>\n                                   EqUni)\n                               eq @\n                              map (substInfinitesimalLinearUni b c \\<circ>\n                                   LessUni)\n                               les @\n                              map (substInfinitesimalLinearUni b c \\<circ>\n                                   LeqUni)\n                               leq @\n                              map (substInfinitesimalLinearUni b c \\<circ>\n                                   NeqUni)\n                               neq))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x))", "unfolding eval_list_conj_Uni set_split'[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (substInfinitesimalLinearUni b c \\<circ> EqUni) eq @\n      map (substInfinitesimalLinearUni b c \\<circ> LessUni) les @\n      map (substInfinitesimalLinearUni b c \\<circ> LeqUni) leq @\n      map (substInfinitesimalLinearUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x))) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (substInfinitesimalLinearUni b c \\<circ> EqUni) eq @\n      map (substInfinitesimalLinearUni b c \\<circ> LessUni) les @\n      map (substInfinitesimalLinearUni b c \\<circ> LeqUni) leq @\n      map (substInfinitesimalLinearUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x)))", "by simp"], ["proof (state)\nthis:\n  evalUni (elimVarUni_atom L At) x =\n  evalUni\n   (elimVarUni_atom\n     (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq) At)\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "then"], ["proof (chain)\npicking this:\n  At = EqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. evalUni (elimVarUni_atom L At) x =\n    evalUni\n     (elimVarUni_atom\n       (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n       At)\n     x", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> evalUni (elimVarUni_atom L At) x =\n                         evalUni\n                          (elimVarUni_atom\n                            (map EqUni eq @\n                             map LessUni les @\n                             map LeqUni leq @ map NeqUni neq)\n                            At)\n                          x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (linearSubstitutionUni b c) L))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x)) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (linearSubstitutionUni b c \\<circ> EqUni)\n                               eq @\n                              map (linearSubstitutionUni b c \\<circ>\n                                   LessUni)\n                               les @\n                              map (linearSubstitutionUni b c \\<circ> LeqUni)\n                               leq @\n                              map (linearSubstitutionUni b c \\<circ> NeqUni)\n                               neq))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x))", "unfolding eval_list_conj_Uni set_split'[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (linearSubstitutionUni b c \\<circ> EqUni) eq @\n      map (linearSubstitutionUni b c \\<circ> LessUni) les @\n      map (linearSubstitutionUni b c \\<circ> LeqUni) leq @\n      map (linearSubstitutionUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x))) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (linearSubstitutionUni b c \\<circ> EqUni) eq @\n      map (linearSubstitutionUni b c \\<circ> LessUni) les @\n      map (linearSubstitutionUni b c \\<circ> LeqUni) leq @\n      map (linearSubstitutionUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x)))", "by simp"], ["proof (state)\nthis:\n  evalUni (elimVarUni_atom L At) x =\n  evalUni\n   (elimVarUni_atom\n     (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq) At)\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "then"], ["proof (chain)\npicking this:\n  At = LeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. evalUni (elimVarUni_atom L At) x =\n    evalUni\n     (elimVarUni_atom\n       (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n       At)\n     x", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> evalUni (elimVarUni_atom L At) x =\n                         evalUni\n                          (elimVarUni_atom\n                            (map EqUni eq @\n                             map LessUni les @\n                             map LeqUni leq @ map NeqUni neq)\n                            At)\n                          x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (linearSubstitutionUni b c) L))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x)) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (linearSubstitutionUni b c \\<circ> EqUni)\n                               eq @\n                              map (linearSubstitutionUni b c \\<circ>\n                                   LessUni)\n                               les @\n                              map (linearSubstitutionUni b c \\<circ> LeqUni)\n                               leq @\n                              map (linearSubstitutionUni b c \\<circ> NeqUni)\n                               neq))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (quadraticSubUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (quadraticSubUni (- b) (- 1)\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x))", "unfolding eval_list_conj_Uni set_split'[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (linearSubstitutionUni b c \\<circ> EqUni) eq @\n      map (linearSubstitutionUni b c \\<circ> LessUni) les @\n      map (linearSubstitutionUni b c \\<circ> LeqUni) leq @\n      map (linearSubstitutionUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x))) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (linearSubstitutionUni b c \\<circ> EqUni) eq @\n      map (linearSubstitutionUni b c \\<circ> LessUni) les @\n      map (linearSubstitutionUni b c \\<circ> LeqUni) leq @\n      map (linearSubstitutionUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x)))", "by simp"], ["proof (state)\nthis:\n  evalUni (elimVarUni_atom L At) x =\n  evalUni\n   (elimVarUni_atom\n     (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq) At)\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       evalUni (elimVarUni_atom L At) x =\n       evalUni\n        (elimVarUni_atom\n          (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n          At)\n        x", "then"], ["proof (chain)\npicking this:\n  At = NeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. evalUni (elimVarUni_atom L At) x =\n    evalUni\n     (elimVarUni_atom\n       (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq)\n       At)\n     x", "apply(cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> evalUni (elimVarUni_atom L At) x =\n                         evalUni\n                          (elimVarUni_atom\n                            (map EqUni eq @\n                             map LessUni les @\n                             map LeqUni leq @ map NeqUni neq)\n                            At)\n                          x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (substInfinitesimalLinearUni b c) L))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a))\n                                L))\n                            x)) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          evalUni\n                           (list_conj_Uni\n                             (map (substInfinitesimalLinearUni b c \\<circ>\n                                   EqUni)\n                               eq @\n                              map (substInfinitesimalLinearUni b c \\<circ>\n                                   LessUni)\n                               les @\n                              map (substInfinitesimalLinearUni b c \\<circ>\n                                   LeqUni)\n                               leq @\n                              map (substInfinitesimalLinearUni b c \\<circ>\n                                   NeqUni)\n                               neq))\n                           x \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          (evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (substInfinitesimalQuadraticUni (- b) 1\n                                     (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x \\<or>\n                           evalUni\n                            (list_conj_Uni\n                              (map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    EqUni)\n                                eq @\n                               map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    LessUni)\n                                les @\n                               map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    LeqUni)\n                                leq @\n                               map (substInfinitesimalQuadraticUni (- b)\n                                     (- 1) (b\\<^sup>2 - 4 * a * c)\n                                     (2 * a) \\<circ>\n                                    NeqUni)\n                                neq))\n                            x))", "unfolding eval_list_conj_Uni set_split'[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni (a, b, c); p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (substInfinitesimalLinearUni b c \\<circ> EqUni) eq @\n      map (substInfinitesimalLinearUni b c \\<circ> LessUni) les @\n      map (substInfinitesimalLinearUni b c \\<circ> LeqUni) leq @\n      map (substInfinitesimalLinearUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x))) =\n                         (a = 0 \\<and>\n                          b \\<noteq> 0 \\<and>\n                          (\\<forall>l\\<in>set\n     (map (substInfinitesimalLinearUni b c \\<circ> EqUni) eq @\n      map (substInfinitesimalLinearUni b c \\<circ> LessUni) les @\n      map (substInfinitesimalLinearUni b c \\<circ> LeqUni) leq @\n      map (substInfinitesimalLinearUni b c \\<circ> NeqUni) neq).\n                              evalUni l x) \\<or>\n                          a \\<noteq> 0 \\<and>\n                          4 * a * c \\<le> b\\<^sup>2 \\<and>\n                          ((\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n             (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x) \\<or>\n                           (\\<forall>l\\<in>set\n      (map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            EqUni)\n        eq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LessUni)\n        les @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            LeqUni)\n        leq @\n       map (substInfinitesimalQuadraticUni (- b) (- 1)\n             (b\\<^sup>2 - 4 * a * c) (2 * a) \\<circ>\n            NeqUni)\n        neq).\n                               evalUni l x)))", "by simp"], ["proof (state)\nthis:\n  evalUni (elimVarUni_atom L At) x =\n  evalUni\n   (elimVarUni_atom\n     (map EqUni eq @ map LessUni les @ map LeqUni leq @ map NeqUni neq) At)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less : \"\n         ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a. evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f))) x) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b. evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f))) x) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c. evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f))) x) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d. evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f))) x) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (EqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LessUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LeqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (NeqUni (d, e, f)))\n               x) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (EqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LessUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (LeqUni (d, e, f)))\n               x) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              evalUni\n               (substInfinitesimalQuadraticUni (- b') (- 1) (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                 (NeqUni (d, e, f)))\n               x))) = \n\n          ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (EqUni (d, e, f)) x)) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n            (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (LessUni (d, e, f)) x))\\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (LeqUni (d, e, f)) x)) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n            (\\<exists>y'::real>-c'/b'. \\<forall>x::real \\<in>{-c'/b'<..y'}. aEvalUni (NeqUni (d, e, f)) x)) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (EqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LessUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LeqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              (\\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (NeqUni (d,e,f)) x)) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (EqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LessUni (d,e,f)) x)) \\<and> \n          (\\<forall>(d, e, f)\\<in>set c.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (LeqUni (d,e,f)) x)) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              (\\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n        \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n           aEvalUni (NeqUni (d,e,f)) x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "proof(cases \"a'=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a' = 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))\n 2. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "case True"], ["proof (state)\nthis:\n  a' = 0\n\ngoal (2 subgoals):\n 1. a' = 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))\n 2. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  a' = 0", "have a' :  \"a'=0\""], ["proof (prove)\nusing this:\n  a' = 0\n\ngoal (1 subgoal):\n 1. a' = 0", "by auto"], ["proof (state)\nthis:\n  a' = 0\n\ngoal (2 subgoals):\n 1. a' = 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))\n 2. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  a' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a' = 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "proof(cases \"b'=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a' = 0; b' = 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))\n 2. \\<lbrakk>a' = 0; b' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))", "case True"], ["proof (state)\nthis:\n  b' = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a' = 0; b' = 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))\n 2. \\<lbrakk>a' = 0; b' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  b' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b' = 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "using a'"], ["proof (prove)\nusing this:\n  b' = 0\n  a' = 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "by auto"], ["proof (state)\nthis:\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n        x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (NeqUni (d, e, f)))\n         x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n         x))) =\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (EqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LessUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LeqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (NeqUni (d, e, f)) x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a' = 0; b' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a' = 0; b' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))", "case False"], ["proof (state)\nthis:\n  b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a' = 0; b' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (EqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LessUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (LeqUni (d, e, f)))\n                            x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           evalUni\n                            (substInfinitesimalLinearUni b' c'\n                              (NeqUni (d, e, f)))\n                            x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') 1\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (EqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LessUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (LeqUni (d, e, f)))\n                             x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b') (- 1)\n                               (b'\\<^sup>2 - 4 * a' * c') (2 * a')\n                               (NeqUni (d, e, f)))\n                             x))) =\n                      ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set a.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (EqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set b.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LessUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set c.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                       (\\<forall>(d, e, f)\\<in>set d.\n                           \\<exists>y'>- c' / b'.\n                              \\<forall>x\\<in>{- c' / b'<..y'}.\n                                 aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                       a' \\<noteq> 0 \\<and>\n                       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n                       ((\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x) \\<or>\n                        (\\<forall>(d, e, f)\\<in>set a.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (EqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set b.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LessUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set c.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (LeqUni (d, e, f)) x) \\<and>\n                        (\\<forall>(d, e, f)\\<in>set d.\n                            \\<exists>y'>(- b' +\n   - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n  (2 * a').\n                               \\<forall>x\n  \\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}.\n                                  aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  b' \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "using True"], ["proof (prove)\nusing this:\n  b' \\<noteq> 0\n  a' = 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "unfolding infinitesimal_linear'[of b' c' _ x, symmetric, OF False]"], ["proof (prove)\nusing this:\n  b' \\<noteq> 0\n  a' = 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            Ball {- c' / b'<..y'} (aEvalUni (EqUni (d, e, f)))) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            Ball {- c' / b'<..y'} (aEvalUni (LessUni (d, e, f)))) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            Ball {- c' / b'<..y'} (aEvalUni (LeqUni (d, e, f)))) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            Ball {- c' / b'<..y'} (aEvalUni (NeqUni (d, e, f)))) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "by auto"], ["proof (state)\nthis:\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n        x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (NeqUni (d, e, f)))\n         x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n         x))) =\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (EqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LessUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LeqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (NeqUni (d, e, f)) x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n        x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (NeqUni (d, e, f)))\n         x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n         x))) =\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (EqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LessUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LeqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (NeqUni (d, e, f)) x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x)))\n\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "case False"], ["proof (state)\nthis:\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  a' \\<noteq> 0", "have a' : \"a' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  a' \\<noteq> 0", "have d : \"2 * a' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * a' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' \\<noteq> 0 \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "proof(cases \"0 \\<le> b'\\<^sup>2 - 4 * a' * c'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))\n 2. \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "case True"], ["proof (state)\nthis:\n  0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n\ngoal (2 subgoals):\n 1. 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))\n 2. \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> b'\\<^sup>2 - 4 * a' * c'", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "using False"], ["proof (prove)\nusing this:\n  0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "unfolding infinitesimal_quad[OF d True, of \"-b'\", symmetric]"], ["proof (prove)\nusing this:\n  0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}\n              (aEvalUni (EqUni (d, e, f)))) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}\n              (aEvalUni (LessUni (d, e, f)))) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}\n              (aEvalUni (LeqUni (d, e, f)))) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')<..y'}\n              (aEvalUni (NeqUni (d, e, f)))) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a')<..y'}\n              (aEvalUni (EqUni (d, e, f)))) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a')<..y'}\n              (aEvalUni (LessUni (d, e, f)))) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a')<..y'}\n              (aEvalUni (LeqUni (d, e, f)))) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             Ball\n              {(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a')<..y'}\n              (aEvalUni (NeqUni (d, e, f)))))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "by auto"], ["proof (state)\nthis:\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n        x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (NeqUni (d, e, f)))\n         x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n         x))) =\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (EqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LessUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LeqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (NeqUni (d, e, f)) x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c' \\<Longrightarrow>\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "using a'"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> b'\\<^sup>2 - 4 * a' * c'\n  a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n          x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n          x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') 1\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n           x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b') (- 1)\n             (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n           x))) =\n    ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n     (\\<forall>(d, e, f)\\<in>set a.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (EqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set b.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LessUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set c.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (LeqUni (d, e, f)) x) \\<and>\n     (\\<forall>(d, e, f)\\<in>set d.\n         \\<exists>y'>- c' / b'.\n            \\<forall>x\\<in>{- c' / b'<..y'}.\n               aEvalUni (NeqUni (d, e, f)) x) \\<or>\n     a' \\<noteq> 0 \\<and>\n     - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n     ((\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x) \\<or>\n      (\\<forall>(d, e, f)\\<in>set a.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (EqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set b.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LessUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set c.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (LeqUni (d, e, f)) x) \\<and>\n      (\\<forall>(d, e, f)\\<in>set d.\n          \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                      (2 * a').\n             \\<forall>x\\<in>{(- b' +\n                              - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                             (2 * a')<..y'}.\n                aEvalUni (NeqUni (d, e, f)) x)))", "by auto"], ["proof (state)\nthis:\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n        x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (NeqUni (d, e, f)))\n         x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n         x))) =\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (EqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LessUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LeqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (NeqUni (d, e, f)) x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       evalUni (substInfinitesimalLinearUni b' c' (EqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       evalUni (substInfinitesimalLinearUni b' c' (LessUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       evalUni (substInfinitesimalLinearUni b' c' (LeqUni (d, e, f)))\n        x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       evalUni (substInfinitesimalLinearUni b' c' (NeqUni (d, e, f)))\n        x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') 1 (b'\\<^sup>2 - 4 * a' * c')\n           (2 * a') (NeqUni (d, e, f)))\n         x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (EqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LessUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (LeqUni (d, e, f)))\n         x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b') (- 1)\n           (b'\\<^sup>2 - 4 * a' * c') (2 * a') (NeqUni (d, e, f)))\n         x))) =\n  ((a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n   (\\<forall>(d, e, f)\\<in>set a.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (EqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LessUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (LeqUni (d, e, f)) x) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d.\n       \\<exists>y'>- c' / b'.\n          \\<forall>x\\<in>{- c' / b'<..y'}.\n             aEvalUni (NeqUni (d, e, f)) x) \\<or>\n   a' \\<noteq> 0 \\<and>\n   - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n   ((\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a').\n           \\<forall>x\\<in>{(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x) \\<or>\n    (\\<forall>(d, e, f)\\<in>set a.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (EqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set b.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LessUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set c.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (LeqUni (d, e, f)) x) \\<and>\n    (\\<forall>(d, e, f)\\<in>set d.\n        \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                    (2 * a').\n           \\<forall>x\\<in>{(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                           (2 * a')<..y'}.\n              aEvalUni (NeqUni (d, e, f)) x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_inf : \"(\\<forall>(a, b, c)\\<in>set (a::(real*real*real) list). \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) = (\\<forall>(a, b, c)\\<in>set a. a=0\\<and>b=0\\<and>c=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(a, b, c)\\<in>set a.\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) =\n    (\\<forall>(a, b, c)\\<in>set a. a = 0 \\<and> b = 0 \\<and> c = 0)", "using infinity_evalUni_EqUni[of _ x]"], ["proof (prove)\nusing this:\n  (\\<exists>x. \\<forall>y<x. aEvalUni (EqUni ?p) y) =\n  evalUni (substNegInfinityUni (EqUni ?p)) x\n\ngoal (1 subgoal):\n 1. (\\<forall>(a, b, c)\\<in>set a.\n        \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) =\n    (\\<forall>(a, b, c)\\<in>set a. a = 0 \\<and> b = 0 \\<and> c = 0)", "by auto"], ["", "text \"This is the main quantifier elimination lemma, in the simplified framework. We are located directly underneath \nthe most internal existential quantifier so F is completely free in quantifier and consists only of conjunction and disjunction.\nThe variable we are evaluating on, x, is removed in the generalVS\\\\_DNF converted formula as expanding out the evalUni function\ndetermines that x doesn't play a role in the computation of it. It would be okay to replace the x in the second half with any variable,\nbut it is simplier this way\n\nThis conversion is defined as a \\\"veritcal\\\" translation as we remain within the univariate framework in both sides of the expression\""], ["", "lemma eval_generalVS'' : \"(\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n                               evalUni (generalVS_DNF L) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n    evalUni (generalVS_DNF L) x", "proof(cases \"separateAtoms L\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n       (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n       evalUni (generalVS_DNF L) x", "case (fields a b c d)"], ["proof (state)\nthis:\n  separateAtoms L = (a, b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n       (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n       evalUni (generalVS_DNF L) x", "have a : \"\\<And> P. (\\<forall>l\\<in>set (map EqUni a) \\<union> (set (map LessUni b) \\<union> (set (map LeqUni c) \\<union> set (map NeqUni d))).P l) = \n            ((\\<forall>(d,e,f)\\<in>set a. P (EqUni (d,e,f))) \\<and> (\\<forall>(d,e,f)\\<in>set b. P (LessUni (d,e,f))) \\<and> (\\<forall>(d,e,f)\\<in>set c. P (LeqUni (d,e,f))) \\<and> (\\<forall>(d,e,f)\\<in>set d. P (NeqUni (d,e,f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       (\\<forall>l\\<in>set (map EqUni a) \\<union>\n                       (set (map LessUni b) \\<union>\n                        (set (map LeqUni c) \\<union> set (map NeqUni d))).\n           P l) =\n       ((\\<forall>(d, e, f)\\<in>set a. P (EqUni (d, e, f))) \\<and>\n        (\\<forall>(d, e, f)\\<in>set b. P (LessUni (d, e, f))) \\<and>\n        (\\<forall>(d, e, f)\\<in>set c. P (LeqUni (d, e, f))) \\<and>\n        (\\<forall>(d, e, f)\\<in>set d. P (NeqUni (d, e, f))))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set (map EqUni a) \\<union>\n                  (set (map LessUni b) \\<union>\n                   (set (map LeqUni c) \\<union> set (map NeqUni d))).\n      ?P l) =\n  ((\\<forall>(d, e, f)\\<in>set a. ?P (EqUni (d, e, f))) \\<and>\n   (\\<forall>(d, e, f)\\<in>set b. ?P (LessUni (d, e, f))) \\<and>\n   (\\<forall>(d, e, f)\\<in>set c. ?P (LeqUni (d, e, f))) \\<and>\n   (\\<forall>(d, e, f)\\<in>set d. ?P (NeqUni (d, e, f))))\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       separateAtoms L = (a, b, c, d) \\<Longrightarrow>\n       (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n       evalUni (generalVS_DNF L) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n    evalUni (generalVS_DNF L) x", "apply(simp add: eval_list_conj_Uni separate_aEval[OF fields]\n        splitAtoms_negInfinity[OF fields] eval_list_disj_Uni \n        del:elimVar.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        (\\<forall>xa\\<in>set a.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c = 0) \\<and>\n        (\\<forall>xa\\<in>set b.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c < 0) \\<and>\n        (\\<forall>xa\\<in>set c.\n            case xa of\n            (a, b, c) \\<Rightarrow>\n              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n        (\\<forall>xa\\<in>set d.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<noteq> 0)) =\n    ((\\<forall>x\\<in>set a.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>x\\<in>set b.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>x\\<in>set c.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>x\\<in>set d.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<or>\n     (\\<exists>l\\<in>set L. evalUni (elimVarUni_atom L l) x))", "unfolding eval_conj_atom generalVS_DNF.simps \n      split_elimVar[OF fields ] \n\nsplit_elimvar[OF fields]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        (\\<forall>xa\\<in>set a.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c = 0) \\<and>\n        (\\<forall>xa\\<in>set b.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c < 0) \\<and>\n        (\\<forall>xa\\<in>set c.\n            case xa of\n            (a, b, c) \\<Rightarrow>\n              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n        (\\<forall>xa\\<in>set d.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<noteq> 0)) =\n    ((\\<forall>x\\<in>set a.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c = 0) \\<and>\n     (\\<forall>x\\<in>set b.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>x\\<in>set c.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>x\\<in>set d.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<or>\n     (\\<exists>(a', b', c')\\<in>set a.\n         evalUni\n          (elimVarUni_atom\n            (map EqUni a @ map LessUni b @ map LeqUni c @ map NeqUni d)\n            (EqUni (a', b', c')))\n          x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set b.\n         evalUni\n          (elimVarUni_atom\n            (map EqUni a @ map LessUni b @ map LeqUni c @ map NeqUni d)\n            (LessUni (a', b', c')))\n          x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set c.\n         evalUni\n          (elimVarUni_atom\n            (map EqUni a @ map LessUni b @ map LeqUni c @ map NeqUni d)\n            (LeqUni (a', b', c')))\n          x) \\<or>\n     (\\<exists>(a', b', c')\\<in>set d.\n         evalUni\n          (elimVarUni_atom\n            (map EqUni a @ map LessUni b @ map LeqUni c @ map NeqUni d)\n            (NeqUni (a', b', c')))\n          x))", "unfolding elimVarUni_atom.simps evalUni.simps aEvalUni.simps\n      Rings.mult_zero_class.mult_zero_left Groups.add_0 eval_list_conj_Uni Groups.group_add_class.minus_zero \n      eval_map_all linearSubstitutionUni.simps quadraticSubUni.simps evalUni_if aEvalUni.simps\n      set_append a less eq_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        (\\<forall>xa\\<in>set a.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c = 0) \\<and>\n        (\\<forall>xa\\<in>set b.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c < 0) \\<and>\n        (\\<forall>xa\\<in>set c.\n            case xa of\n            (a, b, c) \\<Rightarrow>\n              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n        (\\<forall>xa\\<in>set d.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<noteq> 0)) =\n    ((\\<forall>(a, b, c)\\<in>set a. a = 0 \\<and> b = 0 \\<and> c = 0) \\<and>\n     (\\<forall>x\\<in>set b.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>x\\<in>set c.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>x\\<in>set d.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<or>\n     (\\<exists>(a', b', c')\\<in>set a.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0))) \\<or>\n     (\\<exists>(a', b', c')\\<in>set b.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0))) \\<or>\n     (\\<exists>(a', b', c')\\<in>set c.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0))) \\<or>\n     (\\<exists>(a', b', c')\\<in>set d.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0))))", "using qe"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      (\\<forall>(a, b, c)\\<in>set ?a. a * x\\<^sup>2 + b * x + c = 0) \\<and>\n      (\\<forall>(a, b, c)\\<in>set ?b. a * x\\<^sup>2 + b * x + c < 0) \\<and>\n      (\\<forall>(a, b, c)\\<in>set ?c.\n          a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n      (\\<forall>(a, b, c)\\<in>set ?d.\n          a * x\\<^sup>2 + b * x + c \\<noteq> 0)) =\n  ((\\<forall>(a, b, c)\\<in>set ?a. a = 0 \\<and> b = 0 \\<and> c = 0) \\<and>\n   (\\<forall>(a, b, c)\\<in>set ?b.\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n   (\\<forall>(a, b, c)\\<in>set ?c.\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n   (\\<forall>(a, b, c)\\<in>set ?d.\n       \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<or>\n   (\\<exists>(a', b', c')\\<in>set ?a.\n       (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?a.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f = 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?b.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f < 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?c.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<le> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?d.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<noteq> 0) \\<or>\n       a' \\<noteq> 0 \\<and>\n       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n       ((\\<forall>(d, e, f)\\<in>set ?a.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f =\n            0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f \\<noteq>\n            0) \\<or>\n        (\\<forall>(d, e, f)\\<in>set ?a.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f =\n            0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f \\<noteq>\n            0))) \\<or>\n   (\\<exists>(a', b', c')\\<in>set ?b.\n       (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?a.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f = 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?b.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f < 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?c.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?d.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n       a' \\<noteq> 0 \\<and>\n       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n       ((\\<forall>(d, e, f)\\<in>set ?a.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f = 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n        (\\<forall>(d, e, f)\\<in>set ?a.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f = 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<noteq> 0))) \\<or>\n   (\\<exists>(a', b', c')\\<in>set ?c.\n       (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?a.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f = 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?b.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f < 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?c.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<le> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?d.\n           d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<noteq> 0) \\<or>\n       a' \\<noteq> 0 \\<and>\n       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n       ((\\<forall>(d, e, f)\\<in>set ?a.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f =\n            0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            d *\n            ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e * ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f \\<noteq>\n            0) \\<or>\n        (\\<forall>(d, e, f)\\<in>set ?a.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f =\n            0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f\n            \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            d *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n             (2 * a'))\\<^sup>2 +\n            e *\n            ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n            f \\<noteq>\n            0))) \\<or>\n   (\\<exists>(a', b', c')\\<in>set ?d.\n       (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?a.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f = 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?b.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f < 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?c.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n       (\\<forall>(d, e, f)\\<in>set ?d.\n           \\<exists>y'>- c' / b'.\n              \\<forall>x\\<in>{- c' / b'<..y'}.\n                 d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n       a' \\<noteq> 0 \\<and>\n       - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n       ((\\<forall>(d, e, f)\\<in>set ?a.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f = 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n        (\\<forall>(d, e, f)\\<in>set ?a.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f = 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?b.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f < 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?c.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n        (\\<forall>(d, e, f)\\<in>set ?d.\n            \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                        (2 * a').\n               \\<forall>x\\<in>{(- b' +\n                                - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                               (2 * a')<..y'}.\n                  d * x\\<^sup>2 + e * x + f \\<noteq> 0))))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        (\\<forall>xa\\<in>set a.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c = 0) \\<and>\n        (\\<forall>xa\\<in>set b.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c < 0) \\<and>\n        (\\<forall>xa\\<in>set c.\n            case xa of\n            (a, b, c) \\<Rightarrow>\n              a * x\\<^sup>2 + b * x + c \\<le> 0) \\<and>\n        (\\<forall>xa\\<in>set d.\n            case xa of\n            (a, b, c) \\<Rightarrow> a * x\\<^sup>2 + b * x + c \\<noteq> 0)) =\n    ((\\<forall>(a, b, c)\\<in>set a. a = 0 \\<and> b = 0 \\<and> c = 0) \\<and>\n     (\\<forall>x\\<in>set b.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x. \\<forall>y<x. a * y\\<^sup>2 + b * y + c < 0) \\<and>\n     (\\<forall>x\\<in>set c.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<le> 0) \\<and>\n     (\\<forall>x\\<in>set d.\n         case x of\n         (a, b, c) \\<Rightarrow>\n           \\<exists>x.\n              \\<forall>y<x. a * y\\<^sup>2 + b * y + c \\<noteq> 0) \\<or>\n     (\\<exists>(a', b', c')\\<in>set a.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0))) \\<or>\n     (\\<exists>(a', b', c')\\<in>set b.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0))) \\<or>\n     (\\<exists>(a', b', c')\\<in>set c.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             d * (- c' / b')\\<^sup>2 + e * (- c' / b') + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f =\n              0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f\n              \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              d *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n               (2 * a'))\\<^sup>2 +\n              e *\n              ((- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) / (2 * a')) +\n              f \\<noteq>\n              0))) \\<or>\n     (\\<exists>(a', b', c')\\<in>set d.\n         (a' = 0 \\<and> b' \\<noteq> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set a.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f = 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set b.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f < 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set c.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n         (\\<forall>(d, e, f)\\<in>set d.\n             \\<exists>y'>- c' / b'.\n                \\<forall>x\\<in>{- c' / b'<..y'}.\n                   d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n         a' \\<noteq> 0 \\<and>\n         - b'\\<^sup>2 + 4 * a' * c' \\<le> 0 \\<and>\n         ((\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0) \\<or>\n          (\\<forall>(d, e, f)\\<in>set a.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f = 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set b.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f < 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set c.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<le> 0) \\<and>\n          (\\<forall>(d, e, f)\\<in>set d.\n              \\<exists>y'>(- b' + - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                          (2 * a').\n                 \\<forall>x\\<in>{(- b' +\n                                  - 1 * sqrt (b'\\<^sup>2 - 4 * a' * c')) /\n                                 (2 * a')<..y'}.\n                    d * x\\<^sup>2 + e * x + f \\<noteq> 0))))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L)) x) =\n  evalUni (generalVS_DNF L) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma forallx_substNegInf : \"(\\<not>evalUni (map_atomUni substNegInfinityUni F) x) = (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni F) x) =\n    (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F) x)", "proof(induction F)"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x)\n 2. (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)\n 3. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 5. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "case TrueFUni"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x)\n 2. (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)\n 3. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 5. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x)", "by simp"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni TrueFUni) x)\n\ngoal (4 subgoals):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)\n 2. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)\n 2. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "case FalseFUni"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)\n 2. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)", "by simp"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni FalseFUni) x)\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "case (AtomUni At)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni xa)) x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x)", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x)\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x)\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x)\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x) =\n       (\\<forall>x.\n           \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x) =\n  (\\<forall>x.\n      \\<not> evalUni (map_atomUni substNegInfinityUni (AtomUni At)) x)\n\ngoal (2 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "case (AndUni F1 F2)"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F1) x)\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\n\ngoal (2 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (AndUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (AndUni F1 F2))\n                                     x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "then"], ["proof (chain)\npicking this:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F1) x)\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F1) x)\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\n\ngoal (1 subgoal):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni (AndUni F1 F2)) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni (AndUni F1 F2)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni (AndUni F1 F2)) x) =\n  (\\<forall>x.\n      \\<not> evalUni (map_atomUni substNegInfinityUni (AndUni F1 F2)) x)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "case (OrUni F1 F2)"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F1) x)\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2.\n       \\<lbrakk>(\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n                (\\<forall>x.\n                    \\<not> evalUni (map_atomUni substNegInfinityUni F1) x);\n        (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n        (\\<forall>x.\n            \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> evalUni\n                                  (map_atomUni substNegInfinityUni\n                                    (OrUni F1 F2))\n                                  x) =\n                         (\\<forall>x.\n                             \\<not> evalUni\n                                     (map_atomUni substNegInfinityUni\n (OrUni F1 F2))\n                                     x)", "then"], ["proof (chain)\npicking this:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F1) x)\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F1) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F1) x)\n  (\\<not> evalUni (map_atomUni substNegInfinityUni F2) x) =\n  (\\<forall>x. \\<not> evalUni (map_atomUni substNegInfinityUni F2) x)\n\ngoal (1 subgoal):\n 1. (\\<not> evalUni (map_atomUni substNegInfinityUni (OrUni F1 F2)) x) =\n    (\\<forall>x.\n        \\<not> evalUni (map_atomUni substNegInfinityUni (OrUni F1 F2)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<not> evalUni (map_atomUni substNegInfinityUni (OrUni F1 F2)) x) =\n  (\\<forall>x.\n      \\<not> evalUni (map_atomUni substNegInfinityUni (OrUni F1 F2)) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_subst_map: \"evalUni (map_atomUni (linearSubstitutionUni b c) F) x = evalUni F (-c/b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (map_atomUni (linearSubstitutionUni b c) F) x =\n    evalUni F (- c / b)", "apply(induction F)"], ["proof (prove)\ngoal (5 subgoals):\n 1. evalUni (map_atomUni (linearSubstitutionUni b c) TrueFUni) x =\n    evalUni TrueFUni (- c / b)\n 2. evalUni (map_atomUni (linearSubstitutionUni b c) FalseFUni) x =\n    evalUni FalseFUni (- c / b)\n 3. \\<And>xa.\n       evalUni (map_atomUni (linearSubstitutionUni b c) (AtomUni xa)) x =\n       evalUni (AtomUni xa) (- c / b)\n 4. \\<And>F1 F2.\n       \\<lbrakk>evalUni (map_atomUni (linearSubstitutionUni b c) F1) x =\n                evalUni F1 (- c / b);\n        evalUni (map_atomUni (linearSubstitutionUni b c) F2) x =\n        evalUni F2 (- c / b)\\<rbrakk>\n       \\<Longrightarrow> evalUni\n                          (map_atomUni (linearSubstitutionUni b c)\n                            (AndUni F1 F2))\n                          x =\n                         evalUni (AndUni F1 F2) (- c / b)\n 5. \\<And>F1 F2.\n       \\<lbrakk>evalUni (map_atomUni (linearSubstitutionUni b c) F1) x =\n                evalUni F1 (- c / b);\n        evalUni (map_atomUni (linearSubstitutionUni b c) F2) x =\n        evalUni F2 (- c / b)\\<rbrakk>\n       \\<Longrightarrow> evalUni\n                          (map_atomUni (linearSubstitutionUni b c)\n                            (OrUni F1 F2))\n                          x =\n                         evalUni (OrUni F1 F2) (- c / b)", "by auto"], ["", "lemma quadratic_subst_map : \"evalUni (map_atomUni (quadraticSubUni a b c d) F) x = evalUni F ((a+b*sqrt(c))/d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (map_atomUni (quadraticSubUni a b c d) F) x =\n    evalUni F ((a + b * sqrt c) / d)", "apply(induction F)"], ["proof (prove)\ngoal (5 subgoals):\n 1. evalUni (map_atomUni (quadraticSubUni a b c d) TrueFUni) x =\n    evalUni TrueFUni ((a + b * sqrt c) / d)\n 2. evalUni (map_atomUni (quadraticSubUni a b c d) FalseFUni) x =\n    evalUni FalseFUni ((a + b * sqrt c) / d)\n 3. \\<And>xa.\n       evalUni (map_atomUni (quadraticSubUni a b c d) (AtomUni xa)) x =\n       evalUni (AtomUni xa) ((a + b * sqrt c) / d)\n 4. \\<And>F1 F2.\n       \\<lbrakk>evalUni (map_atomUni (quadraticSubUni a b c d) F1) x =\n                evalUni F1 ((a + b * sqrt c) / d);\n        evalUni (map_atomUni (quadraticSubUni a b c d) F2) x =\n        evalUni F2 ((a + b * sqrt c) / d)\\<rbrakk>\n       \\<Longrightarrow> evalUni\n                          (map_atomUni (quadraticSubUni a b c d)\n                            (AndUni F1 F2))\n                          x =\n                         evalUni (AndUni F1 F2) ((a + b * sqrt c) / d)\n 5. \\<And>F1 F2.\n       \\<lbrakk>evalUni (map_atomUni (quadraticSubUni a b c d) F1) x =\n                evalUni F1 ((a + b * sqrt c) / d);\n        evalUni (map_atomUni (quadraticSubUni a b c d) F2) x =\n        evalUni F2 ((a + b * sqrt c) / d)\\<rbrakk>\n       \\<Longrightarrow> evalUni\n                          (map_atomUni (quadraticSubUni a b c d)\n                            (OrUni F1 F2))\n                          x =\n                         evalUni (OrUni F1 F2) ((a + b * sqrt c) / d)", "by auto"], ["", "fun convert_atom_list :: \"nat \\<Rightarrow> atom list \\<Rightarrow> real list \\<Rightarrow> (atomUni list) option\" where\n  \"convert_atom_list var [] xs = Some []\"|\n  \"convert_atom_list var (a#as) xs = (\n  case convert_atom var a xs of Some(a) \\<Rightarrow> \n  (case convert_atom_list var as xs of Some(as) \\<Rightarrow> Some(a#as) | None \\<Rightarrow> None)\n   | None \\<Rightarrow> None\n)\""], ["", "lemma convert_atom_list_change :\n  assumes \"length xs' = var\"\n  shows \"convert_atom_list var L (xs' @ x # \\<Gamma>) = convert_atom_list var L (xs' @ x' # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_atom_list var L (xs' @ x # \\<Gamma>) =\n    convert_atom_list var L (xs' @ x' # \\<Gamma>)", "apply(induction L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. convert_atom_list var [] (xs' @ x # \\<Gamma>) =\n    convert_atom_list var [] (xs' @ x' # \\<Gamma>)\n 2. \\<And>a L.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       convert_atom_list var L (xs' @ x' # \\<Gamma>) \\<Longrightarrow>\n       convert_atom_list var (a # L) (xs' @ x # \\<Gamma>) =\n       convert_atom_list var (a # L) (xs' @ x' # \\<Gamma>)", "using convert_atom_change[OF assms]"], ["proof (prove)\nusing this:\n  convert_atom var ?At (xs' @ ?x # ?\\<Gamma>) =\n  convert_atom var ?At (xs' @ ?x' # ?\\<Gamma>)\n\ngoal (2 subgoals):\n 1. convert_atom_list var [] (xs' @ x # \\<Gamma>) =\n    convert_atom_list var [] (xs' @ x' # \\<Gamma>)\n 2. \\<And>a L.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       convert_atom_list var L (xs' @ x' # \\<Gamma>) \\<Longrightarrow>\n       convert_atom_list var (a # L) (xs' @ x # \\<Gamma>) =\n       convert_atom_list var (a # L) (xs' @ x' # \\<Gamma>)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>convert_atom_list var L (xs' @ x # \\<Gamma>) =\n                convert_atom_list var L (xs' @ x' # \\<Gamma>);\n        \\<And>At x \\<Gamma> x'.\n           convert_atom var At (xs' @ x # \\<Gamma>) =\n           convert_atom var At (xs' @ x' # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> (case convert_atom var a (xs' @ x # \\<Gamma>) of\n                          None \\<Rightarrow> None\n                          | Some a \\<Rightarrow>\n                              case convert_atom_list var L\n                                    (xs' @ x # \\<Gamma>) of\n                              None \\<Rightarrow> None\n                              | Some as \\<Rightarrow> Some (a # as)) =\n                         (case convert_atom var a (xs' @ x' # \\<Gamma>) of\n                          None \\<Rightarrow> None\n                          | Some a \\<Rightarrow>\n                              case convert_atom_list var L\n                                    (xs' @ x' # \\<Gamma>) of\n                              None \\<Rightarrow> None\n                              | Some as \\<Rightarrow> Some (a # as))", "by (metis)"], ["", "lemma negInf_convert :\n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"length xs' = var\"\n  shows \"(\\<forall>f\\<in>set L. eval (substNegInfinity var f) (xs' @ x # xs))\n         = (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set L. eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set L. eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "proof(induction L arbitrary : L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "case Nil"], ["proof (state)\nthis:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set []. eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set []. eval (substNegInfinity var f) (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "case (Cons a L)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "have h:  \"MPoly_Type.degree p var < 3 \\<Longrightarrow>\n          eval (substNegInfinity var (Less p)) (xs' @ x # xs) = evalUni\n           (substNegInfinityUni\n             (LessUni\n               (insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))))\n           x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Less p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "using convert_substNegInfinity[of var \"Less p\" xs' x xs, OF _ assms(2)]"], ["proof (prove)\nusing this:\n  convert_atom var (Less p) (xs' @ x # xs) = Some ?A' \\<Longrightarrow>\n  eval (substNegInfinity var (Less p)) (xs' @ x # xs) =\n  evalUni (substNegInfinityUni ?A') x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Less p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3 \\<Longrightarrow>\n  eval (substNegInfinity var (Less p)) (xs' @ x # xs) =\n  evalUni\n   (substNegInfinityUni\n     (LessUni\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 2),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 0))))\n   x\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "using Cons(2)[symmetric] Cons(1)"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (a # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "unfolding Less"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Less p # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<And>a.\n       \\<lbrakk>Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                                 eval (substNegInfinity var f)\n                                  (xs' @ x # xs)) =\n                             (\\<forall>f\\<in>set L'.\n                                 evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "apply (simp_all del: substNegInfinity.simps substNegInfinityUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        length xs' = var \\<Longrightarrow>\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (eval (substNegInfinity var (Less p))\n                           (xs' @ x # xs) \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (evalUni\n                           (substNegInfinityUni\n                             (LessUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set a.\n                              evalUni (substNegInfinityUni f) x))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        length xs' = var \\<Longrightarrow>\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (LessUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (evalUni\n                           (substNegInfinityUni\n                             (LessUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set a.\n                              evalUni (substNegInfinityUni f) x))", "using assms(2)"], ["proof (prove)\nusing this:\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        length xs' = var \\<Longrightarrow>\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (LessUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (evalUni\n                           (substNegInfinityUni\n                             (LessUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set a.\n                              evalUni (substNegInfinityUni f) x))", "by presburger"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L).\n      eval (substNegInfinity var f) (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "have h:  \"MPoly_Type.degree p var < 3 \\<Longrightarrow>\n          eval (substNegInfinity var (Eq p)) (xs' @ x # xs) = evalUni\n           (substNegInfinityUni\n             (EqUni\n               (insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))))\n           x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Eq p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (EqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "using convert_substNegInfinity[of var \"Eq p\", OF _ assms(2)]"], ["proof (prove)\nusing this:\n  convert_atom var (Eq p) (xs' @ ?x # ?xs) = Some ?A' \\<Longrightarrow>\n  eval (substNegInfinity var (Eq p)) (xs' @ ?x # ?xs) =\n  evalUni (substNegInfinityUni ?A') ?x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Eq p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (EqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3 \\<Longrightarrow>\n  eval (substNegInfinity var (Eq p)) (xs' @ x # xs) =\n  evalUni\n   (substNegInfinityUni\n     (EqUni\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 2),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 0))))\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "using Cons(2)[symmetric] Cons(1)"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (a # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Eq p # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'.\n                              evalUni (substNegInfinityUni f) x);\n     MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<And>a.\n       \\<lbrakk>Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                                 eval (substNegInfinity var f)\n                                  (xs' @ x # xs)) =\n                             (\\<forall>f\\<in>set L'.\n                                 evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "apply (simp_all del: substNegInfinity.simps substNegInfinityUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        length xs' = var \\<Longrightarrow>\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (eval (substNegInfinity var (Eq p))\n                           (xs' @ x # xs) \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (evalUni\n                           (substNegInfinityUni\n                             (EqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set a.\n                              evalUni (substNegInfinityUni f) x))", "unfolding h assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        var = var \\<Longrightarrow>\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) x);\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (EqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (evalUni\n                           (substNegInfinityUni\n                             (EqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set a.\n                              evalUni (substNegInfinityUni f) x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L).\n      eval (substNegInfinity var f) (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "have h:  \"MPoly_Type.degree p var < 3 \\<Longrightarrow>\n          eval (substNegInfinity var (Leq p)) (xs' @ x # xs) = evalUni\n           (substNegInfinityUni\n             (LeqUni\n               (insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))))\n           x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Leq p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (LeqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "using convert_substNegInfinity[of var \"Leq p\", OF _ assms(2)]"], ["proof (prove)\nusing this:\n  convert_atom var (Leq p) (xs' @ ?x # ?xs) = Some ?A' \\<Longrightarrow>\n  eval (substNegInfinity var (Leq p)) (xs' @ ?x # ?xs) =\n  evalUni (substNegInfinityUni ?A') ?x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Leq p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (LeqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3 \\<Longrightarrow>\n  eval (substNegInfinity var (Leq p)) (xs' @ x # xs) =\n  evalUni\n   (substNegInfinityUni\n     (LeqUni\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 2),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 0))))\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "using Cons(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "unfolding Leq"], ["proof (prove)\nusing this:\n  convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Leq p # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (Leq p # L) (xs' @ x # xs) = Some L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "apply (simp_all del: substNegInfinity.simps substNegInfinityUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a =\n                L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (eval (substNegInfinity var (Leq p))\n                           (xs' @ x # xs) \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a =\n                L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (LeqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "using Cons.IH assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a =\n                L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (LeqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L).\n      eval (substNegInfinity var f) (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "have h:  \"MPoly_Type.degree p var < 3 \\<Longrightarrow>\n          eval (substNegInfinity var (Neq p)) (xs' @ x # xs) = evalUni\n           (substNegInfinityUni\n             (NeqUni\n               (insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)),\n                insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))))\n           x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Neq p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (NeqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "using convert_substNegInfinity[of var \"Neq p\", OF _ assms(2)]"], ["proof (prove)\nusing this:\n  convert_atom var (Neq p) (xs' @ ?x # ?xs) = Some ?A' \\<Longrightarrow>\n  eval (substNegInfinity var (Neq p)) (xs' @ ?x # ?xs) =\n  evalUni (substNegInfinityUni ?A') ?x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3 \\<Longrightarrow>\n    eval (substNegInfinity var (Neq p)) (xs' @ x # xs) =\n    evalUni\n     (substNegInfinityUni\n       (NeqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0))))\n     x", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3 \\<Longrightarrow>\n  eval (substNegInfinity var (Neq p)) (xs' @ x # xs) =\n  evalUni\n   (substNegInfinityUni\n     (NeqUni\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 2),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)),\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var 0))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   eval (substNegInfinity var f) (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'.\n   evalUni (substNegInfinityUni f) x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "using Cons(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "unfolding Neq"], ["proof (prove)\nusing this:\n  convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Neq p # L).\n        eval (substNegInfinity var f) (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n     MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          eval (substNegInfinity var f) (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'.\n                          evalUni (substNegInfinityUni f) x)\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (Neq p # L) (xs' @ x # xs) = Some L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                             eval (substNegInfinity var f) (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "apply (simp_all del: substNegInfinity.simps substNegInfinityUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a =\n                L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (eval (substNegInfinity var (Neq p))\n                           (xs' @ x # xs) \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a =\n                L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (NeqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "using Cons.IH assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L.\n                        eval (substNegInfinity var f) (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'.\n                        evalUni (substNegInfinityUni f) x)\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a =\n                L';\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (evalUni\n                           (substNegInfinityUni\n                             (NeqUni\n                               (insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 2),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var (Suc 0)),\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 (isolate_variable_sparse p var 0))))\n                           x \\<and>\n                          (\\<forall>f\\<in>set L.\n                              eval (substNegInfinity var f)\n                               (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'.\n                             evalUni (substNegInfinityUni f) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L).\n      eval (substNegInfinity var f) (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L).\n      eval (substNegInfinity var f) (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elimVar_atom_single :\n  assumes \"convert_atom var A (xs' @ x # xs) = Some A'\"\n  assumes \"convert_atom_list var L2 (xs' @ x # xs) = Some L2'\"\n  assumes \"length xs' = var\"\n  shows \"eval (elimVar var L2 [] A) (xs' @ x # xs) = evalUni (elimVarUni_atom L2' A') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "proof(cases A)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "case (Less p)"], ["proof (state)\nthis:\n  A = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define a where \"a = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\""], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have a_def' : \"a = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using insertion_isovarspars_free[of \"(xs' @ x # xs)\" var x p 2 0] assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "by auto"], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define b where \"b = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have b_def' : \"b = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using insertion_isovarspars_free[of \"(xs' @ x # xs)\" var x p \"(Suc 0)\" 0] assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ 0 # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define c where \"c = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\""], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have c_def' : \"c = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using insertion_isovarspars_free[of \"(xs' @ x # xs)\" var x p 0 0] assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 0)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have linear : \"b\\<noteq>0 \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n         eval\n          (substInfinitesimalLinear var (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (\\<forall>f\\<in>set L2.\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (\\<forall>f\\<in>set L2.\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "proof(induction L2 arbitrary : L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)\n 2. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "case Nil"], ["proof (state)\nthis:\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)\n 2. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<noteq> 0;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalLinear var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni (substInfinitesimalLinearUni b c l) x)\n  b \\<noteq> 0\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(3) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(3) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have h : \"eval\n         (substInfinitesimalLinear var (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0))\n            At)\n         (xs' @ x # xs) = evalUni (substInfinitesimalLinearUni b c At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x", "by simp_all"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Some a)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "have h1 : \"var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "have h2 : \"var \\<notin> vars (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "have h :  \"evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Less p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some a = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x", "by simp_all"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Eq p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some a = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x", "by simp_all"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At' Some"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At' Some"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "unfolding convert_substInfinitesimalLinear[OF Some b_def[symmetric] c_def[symmetric] Cons(2) h1 h2 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using h"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "."], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (substInfinitesimalLinearUni b c l) x)", "using h Cons(1)[OF Cons(2) L2's]"], ["proof (prove)\nusing this:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n  (\\<forall>f\\<in>set L2.\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2's. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (substInfinitesimalLinearUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<noteq> 0 \\<Longrightarrow>\n  (\\<forall>f\\<in>set L2.\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_1 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n          eval\n           (substInfinitesimalQuadratic var\n             (- isolate_variable_sparse p var (Suc 0)) 1\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n           x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) 1\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) 1\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_lowerPoly1 list_update_length not_in_isovarspar)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 1", "by (metis h9 not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n      (substInfinitesimalQuadratic var (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) =  evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "proof (cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "by auto"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h1 : \"insertion (nth_default 0 (xs' @ x # xs)) (- isolate_variable_sparse p var (Suc 0)) = (-b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (- isolate_variable_sparse p var (Suc 0)) =\n    - b", "unfolding b_def insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)) =\n    - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (- isolate_variable_sparse p var (Suc 0)) =\n  - b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h2 : \"insertion (nth_default 0 (xs' @ x # xs)) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) 1 = 1", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h3 : \"insertion (nth_default 0 (xs' @ x # xs)) (((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)) = (b\\<^sup>2 - 4 * a * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 *\n      isolate_variable_sparse p var 0) =\n    b\\<^sup>2 - 4 * a * c", "unfolding insertion_mult insertion_pow insertion_four insertion_neg insertion_sub a_def b_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n    4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n  b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h4 : \"insertion (nth_default 0 (xs' @ x # xs)) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (2 * isolate_variable_sparse p var 2) =\n    2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) 2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2)", "by (metis insertion_add insertion_mult mult_2)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (2 * isolate_variable_sparse p var 2) =\n  2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h5 : \"2 * a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h6 : \"0 \\<le> b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h7 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h8 : \"var\\<notin>vars(1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 1", "by (metis h9 not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars 1\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h9 : \"var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h10 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h : \"evalUni (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n     x =\n    evalUni (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n     x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Less p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Eq p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using Some"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using Some"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "unfolding convert_substInfinitesimalQuadratic[OF Some h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using h"], ["proof (prove)\nusing this:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "."], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "apply(simp del : substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (substInfinitesimalQuadratic var\n            (- isolate_variable_sparse p var (Suc 0)) 1\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_2 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n          eval\n           (substInfinitesimalQuadratic var\n             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a)\n             l)\n           x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (-1) = (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1", "unfolding insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = - 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis (no_types, hide_lams) MPoly_Type.insertion_one add.inverse_inverse add_uminus_conv_diff arith_special(3) insertion_isovarspars_free insertion_neg insertion_sub list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(- 1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (metis h9 not_in_neg not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n      (substInfinitesimalQuadratic var (- isolate_variable_sparse p var (Suc 0)) (-1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) =  evalUni\n      (substInfinitesimalQuadraticUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "proof (cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "by auto"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h1 : \"insertion (nth_default 0 (xs' @ x # xs)) (- isolate_variable_sparse p var (Suc 0)) = (-b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (- isolate_variable_sparse p var (Suc 0)) =\n    - b", "unfolding b_def insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)) =\n    - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (- isolate_variable_sparse p var (Suc 0)) =\n  - b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h2 : \"insertion (nth_default 0 (xs' @ x # xs)) (-1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (- 1) = - 1", "unfolding insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. - insertion (nth_default 0 (xs' @ x # xs)) 1 = - 1", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) (- 1) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h3 : \"insertion (nth_default 0 (xs' @ x # xs)) (((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)) = (b\\<^sup>2 - 4 * a * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 *\n      isolate_variable_sparse p var 0) =\n    b\\<^sup>2 - 4 * a * c", "unfolding insertion_mult insertion_pow insertion_four insertion_neg insertion_sub a_def b_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n    4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n  b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h4 : \"insertion (nth_default 0 (xs' @ x # xs)) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (2 * isolate_variable_sparse p var 2) =\n    2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) 2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2)", "by (metis insertion_add insertion_mult mult_2)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (2 * isolate_variable_sparse p var 2) =\n  2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h5 : \"2 * a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h6 : \"0 \\<le> b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h7 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h8 : \"var\\<notin>vars(- 1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (simp add: h10 not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h9 : \"var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h10 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h : \"evalUni (substInfinitesimalQuadraticUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n     x =\n    evalUni (substInfinitesimalQuadraticUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n     x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Less p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Eq p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using Some option.inject"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n  (Some ?x2.0 = Some ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using Some"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "unfolding convert_substInfinitesimalQuadratic[OF Some h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using h"], ["proof (prove)\nusing this:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "."], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "apply(simp del : substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (substInfinitesimalQuadratic var\n            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "using assms(1)[symmetric]"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var A (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "unfolding Less"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var (Less p) (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] (Less p)) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some A' = convert_atom var (Less p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Less p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x\n 2. \\<lbrakk>Some A' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Less p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' =\n             LessUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 0));\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       eval\n                        (list_conj\n                          (map (substInfinitesimalLinear var\n                                 (- isolate_variable_sparse p var 0)\n                                 (isolate_variable_sparse p var (Suc 0)))\n                            L2))\n                        (xs' @ x # xs) \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (4 * isolate_variable_sparse p var 2 *\n                         isolate_variable_sparse p var 0 -\n                         (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\n                       \\<le> 0 \\<and>\n                       (eval\n                         (list_conj\n                           (map (substInfinitesimalQuadratic var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  1 ((isolate_variable_sparse p var\n (Suc 0))\\<^sup>2 -\n                                     4 * isolate_variable_sparse p var 2 *\n                                     isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs) \\<or>\n                        eval\n                         (list_conj\n                           (map (substInfinitesimalQuadratic var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  (- 1)\n                                  ((isolate_variable_sparse p var\n                                     (Suc 0))\\<^sup>2 -\n                                   4 * isolate_variable_sparse p var 2 *\n                                   isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs))) =\n                      (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       evalUni\n                        (list_conj_Uni\n                          (map (substInfinitesimalLinearUni\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var (Suc 0)))\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var 0)))\n                            L2'))\n                        x \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       4 *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 0)\n                       \\<le> (insertion (nth_default 0 (xs' @ x # xs))\n                               (isolate_variable_sparse p var\n                                 (Suc 0)))\\<^sup>2 \\<and>\n                       (evalUni\n                         (list_conj_Uni\n                           (map (substInfinitesimalQuadraticUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  1 ((insertion\n (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n                                     4 *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2) *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x \\<or>\n                        evalUni\n                         (list_conj_Uni\n                           (map (substInfinitesimalQuadraticUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  (- 1)\n                                  ((insertion (nth_default 0 (xs' @ x # xs))\n                                     (isolate_variable_sparse p var\n (Suc 0)))\\<^sup>2 -\n                                   4 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2) *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x))", "apply(simp del : substInfinitesimalLinear.simps substInfinitesimalLinearUni.simps substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps\n        add: insertion_neg insertion_mult insertion_add insertion_pow insertion_sub insertion_four\n        a_def[symmetric] b_def[symmetric] c_def[symmetric] a_def'[symmetric] b_def'[symmetric] c_def'[symmetric] eval_list_conj\n        eval_list_conj_Uni\n        )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = LessUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           eval\n                            (substInfinitesimalLinear var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (substInfinitesimalLinearUni b c l)\n                            x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "using linear quadratic_1 quadratic_2"], ["proof (prove)\nusing this:\n  b \\<noteq> 0 \\<Longrightarrow>\n  (\\<forall>f\\<in>set L2.\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = LessUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           eval\n                            (substInfinitesimalLinear var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (substInfinitesimalLinearUni b c l)\n                            x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "by smt"], ["proof (state)\nthis:\n  eval (elimVar var L2 [] A) (xs' @ x # xs) =\n  evalUni (elimVarUni_atom L2' A') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "case (Eq p)"], ["proof (state)\nthis:\n  A = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define a where \"a = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\""], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have a_def' : \"a = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using insertion_isovarspars_free[of \"xs' @x#xs\" var x p 2 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "by auto"], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define b where \"b = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have b_def' : \"b = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using insertion_isovarspars_free[of \"xs' @x#xs\" var x p \"(Suc 0)\" 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ 0 # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define c where \"c = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\""], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have c_def' : \"c = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using insertion_isovarspars_free[of \"xs' @x#xs\" var x p 0 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 0)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have linear : \"a=0 \\<Longrightarrow> b\\<noteq>0 \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n         aEval\n          (linear_substitution var \n            (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          aEval\n                           (linear_substitution var\n                             (- isolate_variable_sparse p var 0)\n                             (isolate_variable_sparse p var (Suc 0)) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni (linearSubstitutionUni b c l) x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          aEval\n                           (linear_substitution var\n                             (- isolate_variable_sparse p var 0)\n                             (isolate_variable_sparse p var (Suc 0)) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni (linearSubstitutionUni b c l) x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a = 0; b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "case Nil"], ["proof (state)\nthis:\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a = 0; b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a = 0; b \\<noteq> 0;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have h1 : \"var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have h2 : \"var \\<notin> vars (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have h : \"aEval\n         (linear_substitution var\n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) At)\n         (xs' @ x # xs) = evalUni (linearSubstitutionUni b c At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x", "by auto"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "case (Some a)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "have h : \"a=At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = At'", "using At' Some"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. a = At'", "by auto"], ["proof (state)\nthis:\n  a = At'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "unfolding convert_linearSubstitutionUni[OF Some b_def[symmetric] c_def[symmetric] Cons(3) h1 h2 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (linearSubstitutionUni b c a) x =\n    evalUni (linearSubstitutionUni b c At') x", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (linearSubstitutionUni b c At') x =\n    evalUni (linearSubstitutionUni b c At') x", "by auto"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni b c At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"(\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var\n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) = (aEval\n         (linear_substitution var \n           (-isolate_variable_sparse p var 0)(isolate_variable_sparse p var (Suc 0)) At)\n         (xs' @ x # xs)\\<and> (\\<forall>f\\<in>set (L2).\n        aEval\n         (linear_substitution var\n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (aEval\n      (linear_substitution var (- isolate_variable_sparse p var 0)\n        (isolate_variable_sparse p var (Suc 0)) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         aEval\n          (linear_substitution var (- isolate_variable_sparse p var 0)\n            (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs)))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) At)\n    (xs' @ x # xs) \\<and>\n   (\\<forall>f\\<in>set L2.\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) f)\n        (xs' @ x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "also"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) At)\n    (xs' @ x # xs) \\<and>\n   (\\<forall>f\\<in>set L2.\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) f)\n        (xs' @ x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"... = (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aEval\n      (linear_substitution var (- isolate_variable_sparse p var 0)\n        (isolate_variable_sparse p var (Suc 0)) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         aEval\n          (linear_substitution var (- isolate_variable_sparse p var 0)\n            (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs))) =\n    (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))", "unfolding h Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x)) =\n    (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))", "by auto"], ["proof (state)\nthis:\n  (aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) At)\n    (xs' @ x # xs) \\<and>\n   (\\<forall>f\\<in>set L2.\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) f)\n        (xs' @ x # xs))) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)", "unfolding L2'"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (linearSubstitutionUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_1 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow>(\\<forall>f\\<in>set L2.\n          eval\n           (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                             (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                             (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n         x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_add insertion_isovarspars_free insertion_mult list_update_length mult_2)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 1", "by (metis h9 not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =  aEval At (xs' @ (((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "using quadratic_sub[OF h1 h2 h3 h4 h5 h6 h7 h8, symmetric, of At]\n        free_in_quad[OF h9 h10 h4 h11]"], ["proof (prove)\nusing this:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   ((xs' @ x # xs)[var := sqrt (b\\<^sup>2 - 4 * a * c)]) =\n  aEval At\n   ((xs' @ x # xs)\n    [var := (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)])\n  freeIn var\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) ?A)\n\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "by (metis assms(3) list_update_length var_not_in_eval3)"], ["proof (state)\nthis:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) = evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Less"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Less p) (xs' @ x # xs)\n  Some aT = convert_atom var (Less p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Eq p) (xs' @ x # xs)\n  Some aT = convert_atom var (Eq p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Leq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Leq x3) (xs' @ x # xs)\n  Some aT = convert_atom var (Leq x3) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Neq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Neq x4) (xs' @ x # xs)\n  Some aT = convert_atom var (Neq x4) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n         x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n         x)", "apply(simp del : quadratic_sub.simps quadraticSubUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding h h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_2 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n          eval\n           (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (-1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1", "unfolding insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = - 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_lowerPoly1 list_update_length not_in_isovarspar)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(-1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (metis h9 not_in_neg not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (-1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =  aEval At (xs' @ (((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "using quadratic_sub[OF h1 h2 h3 h4 h5 h6 h7 h8, symmetric, of At]\n        var_not_in_eval3 free_in_quad[OF h9 h10 h4 h11]"], ["proof (prove)\nusing this:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   ((xs' @ x # xs)[var := sqrt (b\\<^sup>2 - 4 * a * c)]) =\n  aEval At\n   ((xs' @ x # xs)\n    [var := (- b + - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)])\n  \\<lbrakk>freeIn ?var ?\\<phi>; length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x. eval ?\\<phi> (?xs' @ x # ?L)) =\n                    (\\<forall>x. eval ?\\<phi> (?xs' @ x # ?L))\n  freeIn var\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) ?A)\n\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "using assms(3)"], ["proof (prove)\nusing this:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   ((xs' @ x # xs)[var := sqrt (b\\<^sup>2 - 4 * a * c)]) =\n  aEval At\n   ((xs' @ x # xs)\n    [var := (- b + - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)])\n  \\<lbrakk>freeIn ?var ?\\<phi>; length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x. eval ?\\<phi> (?xs' @ x # ?L)) =\n                    (\\<forall>x. eval ?\\<phi> (?xs' @ x # ?L))\n  freeIn var\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) ?A)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "by fastforce"], ["proof (state)\nthis:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"aEval At (xs'  @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) = evalUni (quadraticSubUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Less"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Less p) (xs' @ x # xs)\n  Some aT = convert_atom var (Less p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Eq p) (xs' @ x # xs)\n  Some aT = convert_atom var (Eq p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Leq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Leq x3) (xs' @ x # xs)\n  Some aT = convert_atom var (Leq x3) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Neq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Neq x4) (xs' @ x # xs)\n  Some aT = convert_atom var (Neq x4) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni\n         (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)", "apply(simp del : quadratic_sub.simps quadraticSubUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding h h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "using assms(1)[symmetric]"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var A (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var (Eq p) (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] (Eq p)) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some A' = convert_atom var (Eq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Eq p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x\n 2. \\<lbrakk>Some A' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Eq p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' =\n             EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 0));\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       eval\n                        (list_conj\n                          (map (\\<lambda>a.\n                                   fm.Atom\n                                    (linear_substitution var\n(- isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0))\na))\n                            L2))\n                        (xs' @ x # xs) \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (4 * isolate_variable_sparse p var 2 *\n                         isolate_variable_sparse p var 0 -\n                         (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\n                       \\<le> 0 \\<and>\n                       (eval\n                         (list_conj\n                           (map (quadratic_sub var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  1 ((isolate_variable_sparse p var\n (Suc 0))\\<^sup>2 -\n                                     4 * isolate_variable_sparse p var 2 *\n                                     isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs) \\<or>\n                        eval\n                         (list_conj\n                           (map (quadratic_sub var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  (- 1)\n                                  ((isolate_variable_sparse p var\n                                     (Suc 0))\\<^sup>2 -\n                                   4 * isolate_variable_sparse p var 2 *\n                                   isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs))) =\n                      (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       evalUni\n                        (list_conj_Uni\n                          (map (linearSubstitutionUni\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var (Suc 0)))\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var 0)))\n                            L2'))\n                        x \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       4 *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 0)\n                       \\<le> (insertion (nth_default 0 (xs' @ x # xs))\n                               (isolate_variable_sparse p var\n                                 (Suc 0)))\\<^sup>2 \\<and>\n                       (evalUni\n                         (list_conj_Uni\n                           (map (quadraticSubUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  1 ((insertion\n (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n                                     4 *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2) *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x \\<or>\n                        evalUni\n                         (list_conj_Uni\n                           (map (quadraticSubUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  (- 1)\n                                  ((insertion (nth_default 0 (xs' @ x # xs))\n                                     (isolate_variable_sparse p var\n (Suc 0)))\\<^sup>2 -\n                                   4 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2) *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x))", "apply(simp del : linearSubstitutionUni.simps quadraticSubUni.simps\n        add: insertion_neg insertion_mult insertion_add insertion_pow insertion_sub insertion_four\n        a_def[symmetric] b_def[symmetric] c_def[symmetric] a_def'[symmetric] b_def'[symmetric] c_def'[symmetric] eval_list_conj\n        eval_list_conj_Uni )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = EqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           aEval\n                            (linear_substitution var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (linearSubstitutionUni b c l) x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "using linear"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = EqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           aEval\n                            (linear_substitution var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (linearSubstitutionUni b c l) x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "using quadratic_1 quadratic_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = EqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           aEval\n                            (linear_substitution var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (linearSubstitutionUni b c l) x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "by smt"], ["proof (state)\nthis:\n  eval (elimVar var L2 [] A) (xs' @ x # xs) =\n  evalUni (elimVarUni_atom L2' A') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "case (Leq p)"], ["proof (state)\nthis:\n  A = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define a where \"a = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\""], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have a_def' : \"a = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using insertion_isovarspars_free[of \"xs'@ x#xs\" var x p 2 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "by auto"], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define b where \"b = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have b_def' : \"b = insertion (nth_default 0 (xs'@ 0 # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using insertion_isovarspars_free[of \"xs'@x#xs\" var x p \"(Suc 0)\" 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ 0 # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define c where \"c = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\""], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have c_def' : \"c = insertion (nth_default 0 (xs'@ 0 # xs)) (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using insertion_isovarspars_free[of \"xs'@ x#xs\" var x p 0 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 0)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have linear : \"a=0 \\<Longrightarrow> b\\<noteq>0 \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n         aEval\n          (linear_substitution var \n            (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          aEval\n                           (linear_substitution var\n                             (- isolate_variable_sparse p var 0)\n                             (isolate_variable_sparse p var (Suc 0)) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni (linearSubstitutionUni b c l) x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          aEval\n                           (linear_substitution var\n                             (- isolate_variable_sparse p var 0)\n                             (isolate_variable_sparse p var (Suc 0)) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni (linearSubstitutionUni b c l) x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a = 0; b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "case Nil"], ["proof (state)\nthis:\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a = 0; b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a = 0; b \\<noteq> 0;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n  a = 0\n  b \\<noteq> 0\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have h1 : \"var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have h2 : \"var \\<notin> vars (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have h : \"aEval\n         (linear_substitution var \n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) At)\n         (xs' @ x # xs) = evalUni (linearSubstitutionUni b c At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval\n                          (linear_substitution var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (linearSubstitutionUni b c At') x", "by auto"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "case (Some a)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "have h : \"a=At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = At'", "using At' Some"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. a = At'", "by auto"], ["proof (state)\nthis:\n  a = At'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (linearSubstitutionUni b c At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni b c At') x", "unfolding convert_linearSubstitutionUni[OF Some b_def[symmetric] c_def[symmetric] Cons(3) h1 h2 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (linearSubstitutionUni b c a) x =\n    evalUni (linearSubstitutionUni b c At') x", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (linearSubstitutionUni b c At') x =\n    evalUni (linearSubstitutionUni b c At') x", "by auto"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni b c At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"(\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var \n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) = (aEval\n         (linear_substitution var \n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) At)\n         (xs' @ x # xs)\\<and> (\\<forall>f\\<in>set (L2).\n        aEval\n         (linear_substitution var \n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (aEval\n      (linear_substitution var (- isolate_variable_sparse p var 0)\n        (isolate_variable_sparse p var (Suc 0)) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         aEval\n          (linear_substitution var (- isolate_variable_sparse p var 0)\n            (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs)))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) At)\n    (xs' @ x # xs) \\<and>\n   (\\<forall>f\\<in>set L2.\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) f)\n        (xs' @ x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "also"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) At)\n    (xs' @ x # xs) \\<and>\n   (\\<forall>f\\<in>set L2.\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) f)\n        (xs' @ x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "have \"... = (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aEval\n      (linear_substitution var (- isolate_variable_sparse p var 0)\n        (isolate_variable_sparse p var (Suc 0)) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         aEval\n          (linear_substitution var (- isolate_variable_sparse p var 0)\n            (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs))) =\n    (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))", "unfolding h Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x)) =\n    (evalUni (linearSubstitutionUni b c At') x \\<and>\n     (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))", "by auto"], ["proof (state)\nthis:\n  (aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) At)\n    (xs' @ x # xs) \\<and>\n   (\\<forall>f\\<in>set L2.\n       aEval\n        (linear_substitution var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) f)\n        (xs' @ x # xs))) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a = 0; b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   aEval\n    (linear_substitution var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (linearSubstitutionUni b c l) x);\n        a = 0; b \\<noteq> 0;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             aEval\n                              (linear_substitution var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (linearSubstitutionUni b c l) x)", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)", "unfolding L2'"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (evalUni (linearSubstitutionUni b c At') x \\<and>\n   (\\<forall>l\\<in>set L2's. evalUni (linearSubstitutionUni b c l) x))\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        aEval\n         (linear_substitution var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (linearSubstitutionUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      aEval\n       (linear_substitution var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (linearSubstitutionUni b c l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_1 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow>(\\<forall>f\\<in>set L2.\n          eval\n           (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                             (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                             (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n         x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_lowerPoly1 list_update_length not_in_isovarspar)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 1", "by (metis h9 not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =  aEval At (xs' @ (((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "using quadratic_sub[OF h1 h2 h3 h4 h5 h6 h7 h8, symmetric, of At]\n        var_not_in_eval3 free_in_quad[OF h9 h10 h4 h11]"], ["proof (prove)\nusing this:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   ((xs' @ x # xs)[var := sqrt (b\\<^sup>2 - 4 * a * c)]) =\n  aEval At\n   ((xs' @ x # xs)\n    [var := (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)])\n  \\<lbrakk>freeIn ?var ?\\<phi>; length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x. eval ?\\<phi> (?xs' @ x # ?L)) =\n                    (\\<forall>x. eval ?\\<phi> (?xs' @ x # ?L))\n  freeIn var\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) ?A)\n\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "by (metis assms(3) list_update_length)"], ["proof (state)\nthis:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) = evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Less"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Less p) (xs' @ x # xs)\n  Some aT = convert_atom var (Less p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Eq p) (xs' @ x # xs)\n  Some aT = convert_atom var (Eq p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Leq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Leq x3) (xs' @ x # xs)\n  Some aT = convert_atom var (Leq x3) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                            (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Neq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Neq x4) (xs' @ x # xs)\n  Some aT = convert_atom var (Neq x4) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b + 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n         x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n         x)", "apply(simp del : quadratic_sub.simps quadraticSubUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding h h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_2 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n          eval\n           (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (quadratic_sub var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (quadraticSubUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (-1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1", "unfolding insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = - 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_lowerPoly1 list_update_length not_in_isovarspar)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(-1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (metis h9 not_in_neg not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (-1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =  aEval At (xs' @(((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "using quadratic_sub[OF h1 h2 h3 h4 h5 h6 h7 h8, symmetric, of At]\n        var_not_in_eval3 free_in_quad[OF h9 h10 h4 h11]"], ["proof (prove)\nusing this:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   ((xs' @ x # xs)[var := sqrt (b\\<^sup>2 - 4 * a * c)]) =\n  aEval At\n   ((xs' @ x # xs)\n    [var := (- b + - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)])\n  \\<lbrakk>freeIn ?var ?\\<phi>; length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x. eval ?\\<phi> (?xs' @ x # ?L)) =\n                    (\\<forall>x. eval ?\\<phi> (?xs' @ x # ?L))\n  freeIn var\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) ?A)\n\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "using assms(3)"], ["proof (prove)\nusing this:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   ((xs' @ x # xs)[var := sqrt (b\\<^sup>2 - 4 * a * c)]) =\n  aEval At\n   ((xs' @ x # xs)\n    [var := (- b + - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)])\n  \\<lbrakk>freeIn ?var ?\\<phi>; length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x. eval ?\\<phi> (?xs' @ x # ?L)) =\n                    (\\<forall>x. eval ?\\<phi> (?xs' @ x # ?L))\n  freeIn var\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) ?A)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval\n     (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)", "by fastforce"], ["proof (state)\nthis:\n  eval\n   (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"aEval At (xs'  @(- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) = evalUni (quadraticSubUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Less p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Less"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Less p) (xs' @ x # xs)\n  Some aT = convert_atom var (Less p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Less p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Less p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Eq p;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Eq p) (xs' @ x # xs)\n  Some aT = convert_atom var (Eq p) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Eq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq x3; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Leq x3;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Leq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Leq x3) (xs' @ x # xs)\n  Some aT = convert_atom var (Leq x3) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Leq x3) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by (auto)"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       aEval At\n        (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n       evalUni\n        (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq x4; convert_atom var At (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric]"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  Some At' = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n     Some At' = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval At\n                       (xs' @\n                        (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) #\n                        xs) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by simp_all"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = Some aT", "have Some : \"\\<And>x. convert_atom var At (xs' @ x # xs) = Some aT\""], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom var At (xs' @ x # xs) = Some aT", "by (metis assms(3) convert_atom_change)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ ?x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>At = Neq x4;\n        convert_atom var At (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> aEval At\n                          (xs' @\n                           (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                           (2 * a) #\n                           xs) =\n                         evalUni\n                          (quadraticSubUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval At\n     (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding aEval_aEvalUni[OF Some assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "unfolding Neq"], ["proof (prove)\nusing this:\n  Some At' = convert_atom var (Neq x4) (xs' @ x # xs)\n  Some aT = convert_atom var (Neq x4) (xs' @ ?x # xs)\n\ngoal (1 subgoal):\n 1. aEvalUni aT ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a)) =\n    evalUni\n     (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x\n 2. \\<lbrakk>Some At' = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<And>x. Some aT = convert_atom var (Neq x4) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> aEvalUni aT\n                       ((- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) /\n                        (2 * a)) =\n                      evalUni\n                       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n                         (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval At (xs' @ (- b - 1 * sqrt (b\\<^sup>2 - 4 * a * c)) / (2 * a) # xs) =\n  evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (quadratic_sub var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (quadraticSubUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni\n         (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)", "apply(simp del : quadratic_sub.simps quadraticSubUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding h h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (quadratic_sub var (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (quadraticSubUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a) l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "using assms(1)[symmetric]"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var A (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "unfolding Leq"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var (Leq p) (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] (Leq p)) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some A' = convert_atom var (Leq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Leq p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x\n 2. \\<lbrakk>Some A' = convert_atom var (Leq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Leq p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' =\n             LeqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 0));\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       eval\n                        (list_conj\n                          (map (\\<lambda>a.\n                                   fm.Atom\n                                    (linear_substitution var\n(- isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0))\na))\n                            L2))\n                        (xs' @ x # xs) \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (4 * isolate_variable_sparse p var 2 *\n                         isolate_variable_sparse p var 0 -\n                         (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\n                       \\<le> 0 \\<and>\n                       (eval\n                         (list_conj\n                           (map (quadratic_sub var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  1 ((isolate_variable_sparse p var\n (Suc 0))\\<^sup>2 -\n                                     4 * isolate_variable_sparse p var 2 *\n                                     isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs) \\<or>\n                        eval\n                         (list_conj\n                           (map (quadratic_sub var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  (- 1)\n                                  ((isolate_variable_sparse p var\n                                     (Suc 0))\\<^sup>2 -\n                                   4 * isolate_variable_sparse p var 2 *\n                                   isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs))) =\n                      (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       evalUni\n                        (list_conj_Uni\n                          (map (linearSubstitutionUni\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var (Suc 0)))\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var 0)))\n                            L2'))\n                        x \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       4 *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 0)\n                       \\<le> (insertion (nth_default 0 (xs' @ x # xs))\n                               (isolate_variable_sparse p var\n                                 (Suc 0)))\\<^sup>2 \\<and>\n                       (evalUni\n                         (list_conj_Uni\n                           (map (quadraticSubUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  1 ((insertion\n (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n                                     4 *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2) *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x \\<or>\n                        evalUni\n                         (list_conj_Uni\n                           (map (quadraticSubUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  (- 1)\n                                  ((insertion (nth_default 0 (xs' @ x # xs))\n                                     (isolate_variable_sparse p var\n (Suc 0)))\\<^sup>2 -\n                                   4 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2) *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x))", "apply(simp del : linearSubstitutionUni.simps quadraticSubUni.simps\n        add: insertion_neg insertion_mult insertion_add insertion_pow insertion_sub insertion_four\n        a_def[symmetric] b_def[symmetric] c_def[symmetric] a_def'[symmetric] b_def'[symmetric] c_def'[symmetric] eval_list_conj\n        eval_list_conj_Uni )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = LeqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           aEval\n                            (linear_substitution var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (linearSubstitutionUni b c l) x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "using linear"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = LeqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           aEval\n                            (linear_substitution var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (linearSubstitutionUni b c l) x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "using quadratic_1 quadratic_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = 0; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        aEval\n                         (linear_substitution var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni (linearSubstitutionUni b c l) x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n                           (2 * a) l)\n                         x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (quadratic_sub var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (quadraticSubUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = LeqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           aEval\n                            (linear_substitution var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (quadratic_sub var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (linearSubstitutionUni b c l) x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (quadraticSubUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "by smt"], ["proof (state)\nthis:\n  eval (elimVar var L2 [] A) (xs' @ x # xs) =\n  evalUni (elimVarUni_atom L2' A') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "case (Neq p)"], ["proof (state)\nthis:\n  A = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define a where \"a = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\""], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have a_def' : \"a = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using insertion_isovarspars_free[of \"xs'  @x#xs\" var x p 2 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 2) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 2)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 2)", "by auto"], ["proof (state)\nthis:\n  a =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define b where \"b = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have b_def' : \"b = insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using insertion_isovarspars_free[of \"xs'@x#xs\" var x p \"(Suc 0)\" 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var (Suc 0)) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var (Suc 0))\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  b =\n  insertion (nth_default 0 (xs' @ 0 # xs))\n   (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "define c where \"c = insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\""], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have c_def' : \"c = insertion (nth_default 0 (xs'@0 # xs)) (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using insertion_isovarspars_free[of \"xs'@x#xs\" var x p 0 0]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "using assms"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n   (isolate_variable_sparse p var 0) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := 0]))\n   (isolate_variable_sparse p var 0)\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    insertion (nth_default 0 (xs' @ 0 # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  c =\n  insertion (nth_default 0 (xs' @ 0 # xs)) (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have linear : \"b\\<noteq>0 \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n         eval\n          (substInfinitesimalLinear var \n            (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) f)\n          (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (\\<forall>f\\<in>set L2.\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    (\\<forall>f\\<in>set L2.\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "proof(induction L2 arbitrary : L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)\n 2. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "case Nil"], ["proof (state)\nthis:\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>b \\<noteq> 0;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)\n 2. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<noteq> 0;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalLinear var\n                           (- isolate_variable_sparse p var 0)\n                           (isolate_variable_sparse p var (Suc 0)) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni (substInfinitesimalLinearUni b c l) x)\n  b \\<noteq> 0\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(3)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(3) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(3) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "have h : \"eval\n         (substInfinitesimalLinear var \n           (-isolate_variable_sparse p var 0) (isolate_variable_sparse p var (Suc 0)) At)\n         (xs' @ x # xs) = evalUni (substInfinitesimalLinearUni b c At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "proof(cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) At)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni b c At') x", "by simp_all"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Some a)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "have h1 : \"var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "have h2 : \"var \\<notin> vars (isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "have h :  \"evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Less p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some a = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x", "by simp_all"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Eq p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some a = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some a = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni (substInfinitesimalLinearUni b c a) x =\n                      evalUni (substInfinitesimalLinearUni b c At') x", "by simp_all"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At' Some"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni (substInfinitesimalLinearUni b c a) x =\n       evalUni (substInfinitesimalLinearUni b c At') x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using At' Some"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some a\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom var At (xs' @ x # xs) = Some a \\<Longrightarrow>\n       eval\n        (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n          (isolate_variable_sparse p var (Suc 0)) At)\n        (xs' @ x # xs) =\n       evalUni (substInfinitesimalLinearUni b c At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n       (isolate_variable_sparse p var (Suc 0)) At)\n     (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni b c At') x", "unfolding convert_substInfinitesimalLinear[OF Some b_def[symmetric] c_def[symmetric] Cons(2) h1 h2 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "using h"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalLinearUni b c a) x =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni b c a) x =\n    evalUni (substInfinitesimalLinearUni b c At') x", "."], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n\ngoal (1 subgoal):\n 1. \\<And>a L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>b \\<noteq> 0;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n      (isolate_variable_sparse p var (Suc 0)) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni (substInfinitesimalLinearUni b c l) x);\n        b \\<noteq> 0;\n        convert_atom_list var (a # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L2).\n                             eval\n                              (substInfinitesimalLinear var\n                                (- isolate_variable_sparse p var 0)\n                                (isolate_variable_sparse p var (Suc 0)) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni (substInfinitesimalLinearUni b c l) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (substInfinitesimalLinearUni b c l) x)", "using h Cons(1)[OF Cons(2) L2's]"], ["proof (prove)\nusing this:\n  eval\n   (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n     (isolate_variable_sparse p var (Suc 0)) At)\n   (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni b c At') x\n  (\\<forall>f\\<in>set L2.\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2's. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n           (isolate_variable_sparse p var (Suc 0)) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni (substInfinitesimalLinearUni b c l) x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<noteq> 0 \\<Longrightarrow>\n  (\\<forall>f\\<in>set L2.\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_1 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n          eval\n           (substInfinitesimalQuadratic var\n             (- isolate_variable_sparse p var (Suc 0)) 1\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n           x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) 1\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) 1\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) 1\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_lowerPoly1 list_update_length not_in_isovarspar)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 1", "by (metis h9 not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n      (substInfinitesimalQuadratic var (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) =  evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "proof (cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) 1\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "by auto"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h1 : \"insertion (nth_default 0 (xs' @ x # xs)) (- isolate_variable_sparse p var (Suc 0)) = (-b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (- isolate_variable_sparse p var (Suc 0)) =\n    - b", "unfolding b_def insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)) =\n    - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (- isolate_variable_sparse p var (Suc 0)) =\n  - b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h2 : \"insertion (nth_default 0 (xs' @ x # xs)) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) 1 = 1", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h3 : \"insertion (nth_default 0 (xs' @ x # xs)) (((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)) = (b\\<^sup>2 - 4 * a * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 *\n      isolate_variable_sparse p var 0) =\n    b\\<^sup>2 - 4 * a * c", "unfolding insertion_mult insertion_pow insertion_four insertion_neg insertion_sub a_def b_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n    4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n  b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h4 : \"insertion (nth_default 0 (xs' @ x # xs)) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (2 * isolate_variable_sparse p var 2) =\n    2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) 2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2)", "by (metis insertion_add insertion_mult mult_2)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (2 * isolate_variable_sparse p var 2) =\n  2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h5 : \"2 * a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h6 : \"0 \\<le> b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h7 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h8 : \"var\\<notin>vars(1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 1", "by (metis h9 not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars 1\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h9 : \"var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h10 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h : \"evalUni (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n     x =\n    evalUni (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n     x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Less p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Eq p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) 1\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using Some"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using Some"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) 1\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) 1\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "unfolding convert_substInfinitesimalQuadratic[OF Some h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "using h"], ["proof (prove)\nusing this:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n       At')\n     x", "."], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) 1\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n     At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) 1\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c) (2 * a)\n      l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0)) 1\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) 1\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) 1\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "apply(simp del : substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (substInfinitesimalQuadratic var\n            (- isolate_variable_sparse p var (Suc 0)) 1\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) 1\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n            (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) 1\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) 1 (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "have quadratic_2 : \"(a \\<noteq> 0) \\<Longrightarrow>\n     (4 * a * c \\<le> b\\<^sup>2) \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n          eval\n           (substInfinitesimalQuadratic var\n             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n             (2 * isolate_variable_sparse p var 2) f)\n           (xs' @ x # xs)) = (\\<forall>l\\<in>set L2'.\n          evalUni\n           (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c) (2 * a)\n             l)\n           x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "using assms(2)"], ["proof (prove)\nusing this:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                          eval\n                           (substInfinitesimalQuadratic var\n                             (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                             ((isolate_variable_sparse p var\n                                (Suc 0))\\<^sup>2 -\n                              4 * isolate_variable_sparse p var 2 *\n                              isolate_variable_sparse p var 0)\n                             (2 * isolate_variable_sparse p var 2) f)\n                           (xs' @ x # xs)) =\n                      (\\<forall>l\\<in>set L2'.\n                          evalUni\n                           (substInfinitesimalQuadraticUni (- b) (- 1)\n                             (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                           x)", "proof(induction L2 arbitrary: L2')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case Nil"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (2 subgoals):\n 1. \\<And>L2'.\n       \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var [] (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set [].\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)\n 2. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var [] (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set [].\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set [].\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "case (Cons At L2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Less p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Less p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LessUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Eq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Eq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           EqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Leq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           LeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "using Cons(4)"], ["proof (prove)\nusing this:\n  At = Neq p\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2'\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>At = Neq p;\n     (case if MPoly_Type.degree p var < 3\n           then let (A, B, C) = get_coeffs var p\n                in Some\n                    (insertion (nth_default 0 (xs' @ x # xs)) A,\n                     insertion (nth_default 0 (xs' @ x # xs)) B,\n                     insertion (nth_default 0 (xs' @ x # xs)) C)\n           else None of\n      None \\<Rightarrow> None\n      | Some xa \\<Rightarrow>\n          ((\\<lambda>a.\n               case convert_atom_list var L2 (xs' @ x # xs) of\n               None \\<Rightarrow> None\n               | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n           NeqUni)\n           xa) =\n     Some L2';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'", "obtain At' where At' : \"convert_atom var At (xs' @ x # xs) = Some At'\""], ["proof (prove)\nusing this:\n  \\<exists>At'. convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. (\\<And>At'.\n        convert_atom var At (xs' @ x # xs) = Some At' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "apply(cases \"convert_atom_list var L2 (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n     convert_atom var At (xs' @ x # xs) = Some At';\n     convert_atom_list var L2 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L2's.\n                         convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n 2. \\<And>a.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At';\n        convert_atom_list var L2 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L2's.\n                            convert_atom_list var L2 (xs' @ x # xs) =\n                            Some L2's", "by auto"], ["proof (state)\nthis:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's", "obtain L2's where L2's : \"convert_atom_list var L2 (xs' @ x # xs) = Some L2's\""], ["proof (prove)\nusing this:\n  \\<exists>L2's. convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. (\\<And>L2's.\n        convert_atom_list var L2 (xs' @ x # xs) =\n        Some L2's \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have L2' : \"L2' = At' # L2's\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "using Cons(4) At'"], ["proof (prove)\nusing this:\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. L2' = At' # L2's", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2';\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> L2' = At' # L2's", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LessUni (a, aa, b) # as)) =\n                Some L2';\n        At = Less x1;\n        (if MPoly_Type.degree x1 var < 3\n         then let (A, B, C) = get_coeffs var x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LessUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LessUni (a, aa, b) # L2's\n 2. \\<And>x2 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (EqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Eq x2;\n        (if MPoly_Type.degree x2 var < 3\n         then let (A, B, C) = get_coeffs var x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = EqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = EqUni (a, aa, b) # L2's\n 3. \\<And>x3 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (LeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Leq x3;\n        (if MPoly_Type.degree x3 var < 3\n         then let (A, B, C) = get_coeffs var x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = LeqUni (a, aa, b) # L2's\n 4. \\<And>x4 a aa b.\n       \\<lbrakk>(case convert_atom_list var L2 (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow> Some (NeqUni (a, aa, b) # as)) =\n                Some L2';\n        At = Neq x4;\n        (if MPoly_Type.degree x4 var < 3\n         then let (A, B, C) = get_coeffs var x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (a, aa, b);\n        At' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> L2' = NeqUni (a, aa, b) # L2's", "by (simp_all add: L2's)"], ["proof (state)\nthis:\n  L2' = At' # L2's\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h1 :  \"var < length ((xs' @ x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h2 : \"2*a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h3 : \"0\\<le>b^2-4*a*c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons(3)"], ["proof (prove)\nusing this:\n  4 * a * c \\<le> b\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h4 : \"var\\<notin>vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h5 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- isolate_variable_sparse p var (Suc 0)) = -b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (- isolate_variable_sparse p var (Suc 0)) =\n       - b", "unfolding insertion_neg b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n          (isolate_variable_sparse p var (Suc 0)) =\n       - insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0))", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (- isolate_variable_sparse p var (Suc 0)) =\n     - b\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h6 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (-1) = (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1", "unfolding insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       - insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 1 = - 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (- 1) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h7 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0) =\n       b\\<^sup>2 - 4 * a * c", "apply(simp add: insertion_four insertion_mult insertion_sub insertion_pow b_def a_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       (insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 0) =\n       (insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n       4 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)", "by (metis insertion_isovarspars_free list_update_id)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0) =\n     b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have \"\\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) (2::real mpoly)  = (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 (xs' @ xa # xs)) 2 = 2", "by (metis MPoly_Type.insertion_one insertion_add one_add_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2", "have h8 : \"\\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (2 * isolate_variable_sparse p var 2) =\n       2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?xa # xs)) 2 = 2\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xa.\n           insertion (nth_default 0 (xs' @ xa # xs)) 2 =\n           2) \\<Longrightarrow>\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) 2 *\n       insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n        (isolate_variable_sparse p var 2) =\n       2 *\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2)", "by (metis assms(3) insertion_lowerPoly1 list_update_length not_in_isovarspar)"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 ((xs' @ x # xs)[var := xa]))\n      (2 * isolate_variable_sparse p var 2) =\n     2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h9 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h10 : \"var\\<notin>vars(- 1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (metis h9 not_in_neg not_in_pow power.simps(1))"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h11 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "have h :  \"eval\n      (substInfinitesimalQuadratic var (- isolate_variable_sparse p var (Suc 0)) (-1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) =  evalUni\n      (substInfinitesimalQuadraticUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "proof (cases \"convert_atom var At (xs' @ x # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case None"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (2 subgoals):\n 1. convert_atom var At (xs' @ x # xs) = None \\<Longrightarrow>\n    eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x\n 2. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  convert_atom var At (xs' @ x # xs) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = None\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = None;\n        convert_atom var At (xs' @ x # xs) = Some At'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni (- b) (- 1)\n                            (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                          x", "by auto"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Some aT)"], ["proof (state)\nthis:\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h1 : \"insertion (nth_default 0 (xs' @ x # xs)) (- isolate_variable_sparse p var (Suc 0)) = (-b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (- isolate_variable_sparse p var (Suc 0)) =\n    - b", "unfolding b_def insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)) =\n    - insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0))", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (- isolate_variable_sparse p var (Suc 0)) =\n  - b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h2 : \"insertion (nth_default 0 (xs' @ x # xs)) (-1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (- 1) = - 1", "unfolding insertion_neg"], ["proof (prove)\ngoal (1 subgoal):\n 1. - insertion (nth_default 0 (xs' @ x # xs)) 1 = - 1", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) (- 1) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h3 : \"insertion (nth_default 0 (xs' @ x # xs)) (((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)) = (b\\<^sup>2 - 4 * a * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 *\n      isolate_variable_sparse p var 0) =\n    b\\<^sup>2 - 4 * a * c", "unfolding insertion_mult insertion_pow insertion_four insertion_neg insertion_sub a_def b_def c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n    4 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n    4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) =\n  b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h4 : \"insertion (nth_default 0 (xs' @ x # xs)) (2 * isolate_variable_sparse p var 2) = 2 * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (2 * isolate_variable_sparse p var 2) =\n    2 * a", "unfolding insertion_mult a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) 2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    2 *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2)", "by (metis insertion_add insertion_mult mult_2)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (2 * isolate_variable_sparse p var 2) =\n  2 * a\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h5 : \"2 * a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 2 * a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h6 : \"0 \\<le> b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n   convert_atom_list var L2 (xs' @ x # xs) = Some ?L2'\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set ?L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  a \\<noteq> 0\n  4 * a * c \\<le> b\\<^sup>2\n  convert_atom_list var (At # L2) (xs' @ x # xs) = Some L2'\n\ngoal (1 subgoal):\n 1. 0 \\<le> b\\<^sup>2 - 4 * a * c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h7 : \"var\\<notin>vars(- isolate_variable_sparse p var (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))", "by (simp add: not_in_isovarspar not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h8 : \"var\\<notin>vars(- 1::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (simp add: h10 not_in_neg)"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h9 : \"var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)", "by (metis add_uminus_conv_diff not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow num_double numeral_times_numeral one_add_one power_0)"], ["proof (state)\nthis:\n  var\n  \\<notin> vars\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h10 : \"var\\<notin>vars(2 * isolate_variable_sparse p var 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (2 * isolate_variable_sparse p var 2)", "by (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (2 * isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "have h : \"evalUni (substInfinitesimalQuadraticUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n     x =\n    evalUni (substInfinitesimalQuadraticUni (- b) (-1) (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n     x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Less p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Less p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'[symmetric] Some[symmetric]"], ["proof (prove)\nusing this:\n  At = Eq p\n  Some At' = convert_atom var At (xs' @ x # xs)\n  Some aT = convert_atom var At (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x\n 2. \\<lbrakk>At = Eq p; Some At' = convert_atom var At (xs' @ x # xs);\n     Some aT = convert_atom var At (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) aT)\n                       x =\n                      evalUni\n                       (substInfinitesimalQuadraticUni (- b) (- 1)\n                         (b\\<^sup>2 - 4 * a * c) (2 * a) At')\n                       x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Leq x3)"], ["proof (state)\nthis:\n  At = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq x3\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using Some option.inject"], ["proof (prove)\nusing this:\n  At = Leq x3\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n  (Some ?x2.0 = Some ?y2.0) = (?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "case (Neq x4)"], ["proof (state)\nthis:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) aT)\n        x =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "then"], ["proof (chain)\npicking this:\n  At = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq x4\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using At'"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using Some"], ["proof (prove)\nusing this:\n  At = Neq x4\n  convert_atom var At (xs' @ x # xs) = Some At'\n  convert_atom var At (xs' @ x # xs) = Some aT\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "by auto"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       convert_atom var At (xs' @ x # xs) = Some aa \\<Longrightarrow>\n       eval\n        (substInfinitesimalQuadratic var\n          (- isolate_variable_sparse p var (Suc 0)) (- 1)\n          ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n           4 * isolate_variable_sparse p var 2 *\n           isolate_variable_sparse p var 0)\n          (2 * isolate_variable_sparse p var 2) At)\n        (xs' @ x # xs) =\n       evalUni\n        (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n          (2 * a) At')\n        x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (substInfinitesimalQuadratic var\n       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n        4 * isolate_variable_sparse p var 2 *\n        isolate_variable_sparse p var 0)\n       (2 * isolate_variable_sparse p var 2) At)\n     (xs' @ x # xs) =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "unfolding convert_substInfinitesimalQuadratic[OF Some h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "using h"], ["proof (prove)\nusing this:\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) aT)\n   x =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) aT)\n     x =\n    evalUni\n     (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n       (2 * a) At')\n     x", "."], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (substInfinitesimalQuadratic var\n     (- isolate_variable_sparse p var (Suc 0)) (- 1)\n     ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\n     (2 * isolate_variable_sparse p var 2) At)\n   (xs' @ x # xs) =\n  evalUni\n   (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n     (2 * a) At')\n   x\n\ngoal (1 subgoal):\n 1. \\<And>aa L2 L2'.\n       \\<lbrakk>\\<And>L2'.\n                   \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n                    convert_atom_list var L2 (xs' @ x # xs) =\n                    Some L2'\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n   eval\n    (substInfinitesimalQuadratic var\n      (- isolate_variable_sparse p var (Suc 0)) (- 1)\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n       4 * isolate_variable_sparse p var 2 *\n       isolate_variable_sparse p var 0)\n      (2 * isolate_variable_sparse p var 2) f)\n    (xs' @ x # xs)) =\n                                     (\\<forall>l\\<in>set L2'.\n   evalUni\n    (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n      (2 * a) l)\n    x);\n        a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2;\n        convert_atom_list var (aa # L2) (xs' @ x # xs) = Some L2'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (aa # L2).\n                             eval\n                              (substInfinitesimalQuadratic var\n                                (- isolate_variable_sparse p var (Suc 0))\n                                (- 1)\n                                ((isolate_variable_sparse p var\n                                   (Suc 0))\\<^sup>2 -\n                                 4 * isolate_variable_sparse p var 2 *\n                                 isolate_variable_sparse p var 0)\n                                (2 * isolate_variable_sparse p var 2) f)\n                              (xs' @ x # xs)) =\n                         (\\<forall>l\\<in>set L2'.\n                             evalUni\n                              (substInfinitesimalQuadraticUni (- b) (- 1)\n                                (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set L2'.\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "unfolding L2'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (At # L2).\n        eval\n         (substInfinitesimalQuadratic var\n           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n           ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n            4 * isolate_variable_sparse p var 2 *\n            isolate_variable_sparse p var 0)\n           (2 * isolate_variable_sparse p var 2) f)\n         (xs' @ x # xs)) =\n    (\\<forall>l\\<in>set (At' # L2's).\n        evalUni\n         (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n           (2 * a) l)\n         x)", "apply(simp del : substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>f\\<in>set L2.\n         eval\n          (substInfinitesimalQuadratic var\n            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n            ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n             4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0)\n            (2 * isolate_variable_sparse p var 2) f)\n          (xs' @ x # xs))) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding \n        Cons(1)[OF Cons(2) Cons(3) L2's]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (substInfinitesimalQuadratic var\n        (- isolate_variable_sparse p var (Suc 0)) (- 1)\n        ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n         4 * isolate_variable_sparse p var 2 *\n         isolate_variable_sparse p var 0)\n        (2 * isolate_variable_sparse p var 2) At)\n      (xs' @ x # xs) \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x)) =\n    (evalUni\n      (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n        (2 * a) At')\n      x \\<and>\n     (\\<forall>l\\<in>set L2's.\n         evalUni\n          (substInfinitesimalQuadraticUni (- b) (- 1)\n            (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n          x))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (At # L2).\n      eval\n       (substInfinitesimalQuadratic var\n         (- isolate_variable_sparse p var (Suc 0)) (- 1)\n         ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n          4 * isolate_variable_sparse p var 2 *\n          isolate_variable_sparse p var 0)\n         (2 * isolate_variable_sparse p var 2) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'.\n      evalUni\n       (substInfinitesimalQuadraticUni (- b) (- 1) (b\\<^sup>2 - 4 * a * c)\n         (2 * a) l)\n       x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       eval (elimVar var L2 [] A) (xs' @ x # xs) =\n       evalUni (elimVarUni_atom L2' A') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "using assms(1)[symmetric]"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var A (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] A) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "unfolding Neq"], ["proof (prove)\nusing this:\n  Some A' = convert_atom var (Neq p) (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. eval (elimVar var L2 [] (Neq p)) (xs' @ x # xs) =\n    evalUni (elimVarUni_atom L2' A') x", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some A' = convert_atom var (Neq p) (xs' @ x # xs);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Neq p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x\n 2. \\<lbrakk>Some A' = convert_atom var (Neq p) (xs' @ x # xs);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> eval (elimVar var L2 [] (Neq p)) (xs' @ x # xs) =\n                      evalUni (elimVarUni_atom L2' A') x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' =\n             NeqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse p var 0));\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       eval\n                        (list_conj\n                          (map (substInfinitesimalLinear var\n                                 (- isolate_variable_sparse p var 0)\n                                 (isolate_variable_sparse p var (Suc 0)))\n                            L2))\n                        (xs' @ x # xs) \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (4 * isolate_variable_sparse p var 2 *\n                         isolate_variable_sparse p var 0 -\n                         (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\n                       \\<le> 0 \\<and>\n                       (eval\n                         (list_conj\n                           (map (substInfinitesimalQuadratic var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  1 ((isolate_variable_sparse p var\n (Suc 0))\\<^sup>2 -\n                                     4 * isolate_variable_sparse p var 2 *\n                                     isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs) \\<or>\n                        eval\n                         (list_conj\n                           (map (substInfinitesimalQuadratic var\n                                  (- isolate_variable_sparse p var (Suc 0))\n                                  (- 1)\n                                  ((isolate_variable_sparse p var\n                                     (Suc 0))\\<^sup>2 -\n                                   4 * isolate_variable_sparse p var 2 *\n                                   isolate_variable_sparse p var 0)\n                                  (2 * isolate_variable_sparse p var 2))\n                             L2))\n                         (xs' @ x # xs))) =\n                      (insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) =\n                       0 \\<and>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var (Suc 0)) \\<noteq>\n                       0 \\<and>\n                       evalUni\n                        (list_conj_Uni\n                          (map (substInfinitesimalLinearUni\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var (Suc 0)))\n                                 (insertion (nth_default 0 (xs' @ x # xs))\n                                   (isolate_variable_sparse p var 0)))\n                            L2'))\n                        x \\<or>\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) \\<noteq>\n                       0 \\<and>\n                       4 *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 2) *\n                       insertion (nth_default 0 (xs' @ x # xs))\n                        (isolate_variable_sparse p var 0)\n                       \\<le> (insertion (nth_default 0 (xs' @ x # xs))\n                               (isolate_variable_sparse p var\n                                 (Suc 0)))\\<^sup>2 \\<and>\n                       (evalUni\n                         (list_conj_Uni\n                           (map (substInfinitesimalQuadraticUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  1 ((insertion\n (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 -\n                                     4 *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2) *\n                                     insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x \\<or>\n                        evalUni\n                         (list_conj_Uni\n                           (map (substInfinitesimalQuadraticUni\n                                  (- insertion\n(nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)))\n                                  (- 1)\n                                  ((insertion (nth_default 0 (xs' @ x # xs))\n                                     (isolate_variable_sparse p var\n (Suc 0)))\\<^sup>2 -\n                                   4 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2) *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 0))\n                                  (2 *\n                                   insertion (nth_default 0 (xs' @ x # xs))\n                                    (isolate_variable_sparse p var 2)))\n                             L2'))\n                         x))", "apply(simp del : substInfinitesimalLinear.simps substInfinitesimalLinearUni.simps substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps\n        add: insertion_neg insertion_mult insertion_add insertion_pow insertion_sub insertion_four\n        a_def[symmetric] b_def[symmetric] c_def[symmetric] a_def'[symmetric] b_def'[symmetric] c_def'[symmetric] eval_list_conj\n        eval_list_conj_Uni\n        )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = NeqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           eval\n                            (substInfinitesimalLinear var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (substInfinitesimalLinearUni b c l)\n                            x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "using linear quadratic_1 quadratic_2"], ["proof (prove)\nusing this:\n  b \\<noteq> 0 \\<Longrightarrow>\n  (\\<forall>f\\<in>set L2.\n      eval\n       (substInfinitesimalLinear var (- isolate_variable_sparse p var 0)\n         (isolate_variable_sparse p var (Suc 0)) f)\n       (xs' @ x # xs)) =\n  (\\<forall>l\\<in>set L2'. evalUni (substInfinitesimalLinearUni b c l) x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) 1\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) 1\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n  \\<lbrakk>a \\<noteq> 0; 4 * a * c \\<le> b\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L2.\n                        eval\n                         (substInfinitesimalQuadratic var\n                           (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                           ((isolate_variable_sparse p var\n                              (Suc 0))\\<^sup>2 -\n                            4 * isolate_variable_sparse p var 2 *\n                            isolate_variable_sparse p var 0)\n                           (2 * isolate_variable_sparse p var 2) f)\n                         (xs' @ x # xs)) =\n                    (\\<forall>l\\<in>set L2'.\n                        evalUni\n                         (substInfinitesimalQuadraticUni (- b) (- 1)\n                           (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                         x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A' = NeqUni (a, b, c); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>f\\<in>set L2.\n                           eval\n                            (substInfinitesimalLinear var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)) f)\n                            (xs' @ x # xs)) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0)) 1\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)) \\<or>\n                        (\\<forall>f\\<in>set L2.\n                            eval\n                             (substInfinitesimalQuadratic var\n                               (- isolate_variable_sparse p var (Suc 0))\n                               (- 1)\n                               ((isolate_variable_sparse p var\n                                  (Suc 0))\\<^sup>2 -\n                                4 * isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0)\n                               (2 * isolate_variable_sparse p var 2) f)\n                             (xs' @ x # xs)))) =\n                      (a = 0 \\<and>\n                       b \\<noteq> 0 \\<and>\n                       (\\<forall>l\\<in>set L2'.\n                           evalUni (substInfinitesimalLinearUni b c l)\n                            x) \\<or>\n                       a \\<noteq> 0 \\<and>\n                       4 * a * c \\<le> b\\<^sup>2 \\<and>\n                       ((\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) 1\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x) \\<or>\n                        (\\<forall>l\\<in>set L2'.\n                            evalUni\n                             (substInfinitesimalQuadraticUni (- b) (- 1)\n                               (b\\<^sup>2 - 4 * a * c) (2 * a) l)\n                             x)))", "by smt"], ["proof (state)\nthis:\n  eval (elimVar var L2 [] A) (xs' @ x # xs) =\n  evalUni (elimVarUni_atom L2' A') x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_list : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"l\\<in>set(L)\"\n  shows \"\\<exists>l'\\<in> set L'. convert_atom var l (xs' @ x # xs) = Some l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "using assms"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  l \\<in> set L\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "proof(induction L arbitrary : L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        l \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case Nil"], ["proof (state)\nthis:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  l \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        l \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  l \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  l \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "by auto"], ["proof (state)\nthis:\n  \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Cons At L)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  convert_atom_list var (At # L) (xs' @ x # xs) = Some L'\n  l \\<in> set (At # L)\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  convert_atom_list var (At # L) (xs' @ x # xs) = Some L'\n  l \\<in> set (At # L)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  convert_atom_list var (At # L) (xs' @ x # xs) = Some L'\n  l \\<in> set (At # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  At = Less p\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (At # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Less"], ["proof (prove)\nusing this:\n  Less p = Less p\n  Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (Less p # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LessUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Less p \\<or> l \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LessUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LessUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Less p \\<or> l \\<in> set L;\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LessUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LessUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (LessUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l \\<in> set L\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (LessUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"l = Less p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a; l = Less p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (LessUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Less p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a;\n        l \\<noteq> Less p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (LessUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (At # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (Eq p # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   EqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Eq p \\<or> l \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   EqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   EqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Eq p \\<or> l \\<in> set L;\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (EqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (EqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l \\<in> set L\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (EqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"l = Eq p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a; l = Eq p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (EqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Eq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a;\n        l \\<noteq> Eq p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (EqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  At = Leq p\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (At # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Leq"], ["proof (prove)\nusing this:\n  Leq p = Leq p\n  Some L' = convert_atom_list var (Leq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (Leq p # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Leq p \\<or> l \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Leq p \\<or> l \\<in> set L;\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (LeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l \\<in> set L\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (LeqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"l = Leq p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a; l = Leq p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (LeqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>L' =\n                LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Leq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a;\n        l \\<noteq> Leq p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (LeqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l \\<in> set L\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l \\<in> set (At # L); At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  At = Neq p\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (At # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Neq"], ["proof (prove)\nusing this:\n  Neq p = Neq p\n  Some L' = convert_atom_list var (Neq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l \\<in> set L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l \\<in> set (Neq p # L)\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   NeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Neq p \\<or> l \\<in> set L\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   NeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   NeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Neq p \\<or> l \\<in> set L;\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (NeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (NeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l \\<in> set L\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                         convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (NeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l \\<in> set L\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'\\<in>set L'.\n                            convert_atom var l (xs' @ x # xs) = Some l'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (NeqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"l = Neq p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a; l = Neq p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (NeqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>L' =\n                NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l \\<in> set L \\<Longrightarrow>\n        \\<exists>l'\\<in>set a. convert_atom var l (xs' @ x # xs) = Some l';\n        l = Neq p \\<or> l \\<in> set L; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a;\n        l \\<noteq> Neq p\\<rbrakk>\n       \\<Longrightarrow> convert_atom var l (xs' @ x # xs) =\n                         Some\n                          (NeqUni\n                            (insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 2),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var (Suc 0)),\n                             insertion (nth_default 0 (xs' @ x # xs))\n                              (isolate_variable_sparse p var 0))) \\<or>\n                         (\\<exists>l'\\<in>set a.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l'\\<in>set L'. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_list2 : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"l'\\<in>set(L')\"\n  shows \"\\<exists>l\\<in> set L. convert_atom var l (xs' @ x # xs) = Some l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set L. convert_atom var l (xs' @ x # xs) = Some l'", "using assms"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set L. convert_atom var l (xs' @ x # xs) = Some l'", "proof(induction L arbitrary : L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set [].\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (a # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case Nil"], ["proof (state)\nthis:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  l' \\<in> set L'\n\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set [].\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (a # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  l' \\<in> set L'", "show ?case"], ["proof (prove)\nusing this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set []. convert_atom var l (xs' @ x # xs) = Some l'", "by auto"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set []. convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (a # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (a # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Cons At L)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  convert_atom_list var (At # L) (xs' @ x # xs) = Some L'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (a # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  convert_atom_list var (At # L) (xs' @ x # xs) = Some L'\n  l' \\<in> set L'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  convert_atom_list var (At # L) (xs' @ x # xs) = Some L'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  At = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Less p\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  At = Less p\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Less"], ["proof (prove)\nusing this:\n  Less p = Less p\n  Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (Less p # L).\n       convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LessUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       LessUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LessUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       LessUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LessUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       LessUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LessUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> LessUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LessUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> LessUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (LessUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l' \\<in> set L'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l\\<in>set L.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l' \\<in> set L'; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> LessUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l' \\<in> set a \\<Longrightarrow>\n        \\<exists>l\\<in>set L. convert_atom var l (xs' @ x # xs) = Some l';\n        l' =\n        LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0)) \\<or>\n        l' \\<in> set a;\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> LessUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by blast"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Eq"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (Eq p # L).\n       convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   EqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   EqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   EqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (EqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> EqUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (EqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> EqUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l' \\<in> set L'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l\\<in>set L.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l' \\<in> set L'; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> EqUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l' \\<in> set a \\<Longrightarrow>\n        \\<exists>l\\<in>set L. convert_atom var l (xs' @ x # xs) = Some l';\n        l' =\n        EqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0)) \\<or>\n        l' \\<in> set a;\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> EqUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by blast"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  At = Leq p\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Leq"], ["proof (prove)\nusing this:\n  Leq p = Leq p\n  Some L' = convert_atom_list var (Leq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (Leq p # L).\n       convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       LeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       LeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   LeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       LeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> LeqUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> LeqUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (LeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l' \\<in> set L'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l\\<in>set L.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l' \\<in> set L'; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> LeqUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l' \\<in> set a \\<Longrightarrow>\n        \\<exists>l\\<in>set L. convert_atom var l (xs' @ x # xs) = Some l';\n        l' =\n        LeqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0)) \\<or>\n        l' \\<in> set a;\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> LeqUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by blast"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    l' \\<in> set L'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<in>set L.\n  convert_atom var l (xs' @ x # xs) = Some l';\n        convert_atom_list var (At # L) (xs' @ x # xs) = Some L';\n        l' \\<in> set L'; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>set (At # L).\n                            convert_atom var l (xs' @ x # xs) = Some l'", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  At = Neq p\n  Some L' = convert_atom_list var (At # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'", "unfolding Neq"], ["proof (prove)\nusing this:\n  Neq p = Neq p\n  Some L' = convert_atom_list var (Neq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set L.\n                       convert_atom var l (xs' @ x # xs) = Some l'\n  l' \\<in> set L'\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>set (Neq p # L).\n       convert_atom var l (xs' @ x # xs) = Some l'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   NeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       NeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   NeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       NeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))\n 2. \\<lbrakk>Some L' =\n             (case if MPoly_Type.degree p var < 3\n                   then let (A, B, C) = get_coeffs var p\n                        in Some\n                            (insertion (nth_default 0 (xs' @ x # xs)) A,\n                             insertion (nth_default 0 (xs' @ x # xs)) B,\n                             insertion (nth_default 0 (xs' @ x # xs)) C)\n                   else None of\n              None \\<Rightarrow> None\n              | Some xa \\<Rightarrow>\n                  ((\\<lambda>a.\n                       case convert_atom_list var L (xs' @ x # xs) of\n                       None \\<Rightarrow> None\n                       | Some as \\<Rightarrow> Some (a # as)) \\<circ>\n                   NeqUni)\n                   xa);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       NeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) =\n                       l' \\<or>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) =\n                           Some l')) \\<and>\n                      (\\<not> MPoly_Type.degree p var < 3 \\<longrightarrow>\n                       (\\<exists>l\\<in>set L.\n                           convert_atom var l (xs' @ x # xs) = Some l'))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (NeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> NeqUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (NeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         l' \\<in> set L'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l';\n     l' \\<in> set L'; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> NeqUni\n                       (insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 2),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var (Suc 0)),\n                        insertion (nth_default 0 (xs' @ x # xs))\n                         (isolate_variable_sparse p var 0)) =\n                      l' \\<or>\n                      (\\<exists>l\\<in>set L.\n                          convert_atom var l (xs' @ x # xs) = Some l')\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (NeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n            l' \\<in> set L'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>l\\<in>set L.\n                                convert_atom var l (xs' @ x # xs) = Some l';\n        l' \\<in> set L'; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> NeqUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        l' \\<in> set a \\<Longrightarrow>\n        \\<exists>l\\<in>set L. convert_atom var l (xs' @ x # xs) = Some l';\n        l' =\n        NeqUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var 0)) \\<or>\n        l' \\<in> set a;\n        MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> NeqUni\n                          (insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 2),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var (Suc 0)),\n                           insertion (nth_default 0 (xs' @ x # xs))\n                            (isolate_variable_sparse p var 0)) =\n                         l' \\<or>\n                         (\\<exists>l\\<in>set L.\n                             convert_atom var l (xs' @ x # xs) = Some l')", "by blast"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l\\<in>set (At # L). convert_atom var l (xs' @ x # xs) = Some l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elimVar_atom_convert : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"convert_atom_list var L2 (xs' @ x # xs) = Some L2'\"\n  assumes \"length xs' = var\"\n  shows \"(\\<exists>f\\<in>set L. eval (elimVar var L2 [] f) (xs' @ x # xs))\n         = (\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L2' f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set L. eval (elimVar var L2 [] f) (xs' @ x # xs)) =\n    (\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L2' f) x)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L;\n        eval (elimVar var L2 [] f) (xs' @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L'.\n                            evalUni (elimVarUni_atom L2' f) x\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L;\n        eval (elimVar var L2 [] f) (xs' @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L'.\n                            evalUni (elimVarUni_atom L2' f) x\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "assume h : \"f \\<in> set L\"\n    \"eval (elimVar var L2 [] f) (xs' @ x # xs)\""], ["proof (state)\nthis:\n  f \\<in> set L\n  eval (elimVar var L2 [] f) (xs' @ x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L;\n        eval (elimVar var L2 [] f) (xs' @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L'.\n                            evalUni (elimVarUni_atom L2' f) x\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "have \"\\<exists>f'\\<in>set L'. convert_atom var f (xs' @ x # xs) = Some f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'\\<in>set L'. convert_atom var f (xs' @ x # xs) = Some f'", "using convert_list h assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list ?var ?L (?xs' @ ?x # ?xs) = Some ?L';\n   ?l \\<in> set ?L\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l'\\<in>set ?L'.\n                       convert_atom ?var ?l (?xs' @ ?x # ?xs) = Some l'\n  f \\<in> set L\n  eval (elimVar var L2 [] f) (xs' @ x # xs)\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<exists>f'\\<in>set L'. convert_atom var f (xs' @ x # xs) = Some f'", "by auto"], ["proof (state)\nthis:\n  \\<exists>f'\\<in>set L'. convert_atom var f (xs' @ x # xs) = Some f'\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L;\n        eval (elimVar var L2 [] f) (xs' @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L'.\n                            evalUni (elimVarUni_atom L2' f) x\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f'\\<in>set L'. convert_atom var f (xs' @ x # xs) = Some f'", "obtain f' where f' : \"f'\\<in>set L'\" \"convert_atom var f (xs' @ x # xs) = Some f'\""], ["proof (prove)\nusing this:\n  \\<exists>f'\\<in>set L'. convert_atom var f (xs' @ x # xs) = Some f'\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set L';\n         convert_atom var f (xs' @ x # xs) = Some f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  f' \\<in> set L'\n  convert_atom var f (xs' @ x # xs) = Some f'\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L;\n        eval (elimVar var L2 [] f) (xs' @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L'.\n                            evalUni (elimVarUni_atom L2' f) x\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "show \"\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L2' f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L2' f) x", "apply(rule bexI[where x=f'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. evalUni (elimVarUni_atom L2' f') x\n 2. f' \\<in> set L'", "using f' elimVar_atom_single[OF f'(2) assms(2) assms(3)] h"], ["proof (prove)\nusing this:\n  f' \\<in> set L'\n  convert_atom var f (xs' @ x # xs) = Some f'\n  eval (elimVar var L2 [] f) (xs' @ x # xs) =\n  evalUni (elimVarUni_atom L2' f') x\n  f \\<in> set L\n  eval (elimVar var L2 [] f) (xs' @ x # xs)\n\ngoal (2 subgoals):\n 1. evalUni (elimVarUni_atom L2' f') x\n 2. f' \\<in> set L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L2' f) x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "assume h : \"f' \\<in> set L'\"\n    \"evalUni (elimVarUni_atom L2' f') x\""], ["proof (state)\nthis:\n  f' \\<in> set L'\n  evalUni (elimVarUni_atom L2' f') x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "have \"\\<exists>f\\<in>set L. convert_atom var f (xs' @ x # xs) = Some f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set L. convert_atom var f (xs' @ x # xs) = Some f'", "using convert_list2 h assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list ?var ?L (?xs' @ ?x # ?xs) = Some ?L';\n   ?l' \\<in> set ?L'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<in>set ?L.\n                       convert_atom ?var l (?xs' @ ?x # ?xs) = Some ?l'\n  f' \\<in> set L'\n  evalUni (elimVarUni_atom L2' f') x\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  convert_atom_list var L2 (xs' @ x # xs) = Some L2'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set L. convert_atom var f (xs' @ x # xs) = Some f'", "by auto"], ["proof (state)\nthis:\n  \\<exists>f\\<in>set L. convert_atom var f (xs' @ x # xs) = Some f'\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>set L. convert_atom var f (xs' @ x # xs) = Some f'", "obtain f where f : \"f\\<in>set L\" \"convert_atom var f (xs' @ x # xs) = Some f'\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set L. convert_atom var f (xs' @ x # xs) = Some f'\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set L;\n         convert_atom var f (xs' @ x # xs) = Some f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  f \\<in> set L\n  convert_atom var f (xs' @ x # xs) = Some f'\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set L'; evalUni (elimVarUni_atom L2' f) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set L.\n                            eval (elimVar var L2 [] f) (xs' @ x # xs)", "show \"\\<exists>f\\<in>set L. eval (elimVar var L2 [] f) (xs' @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set L. eval (elimVar var L2 [] f) (xs' @ x # xs)", "apply(rule bexI[where x=f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. eval (elimVar var L2 [] f) (xs' @ x # xs)\n 2. f \\<in> set L", "using f elimVar_atom_single[OF f(2) assms(2) assms(3)] h"], ["proof (prove)\nusing this:\n  f \\<in> set L\n  convert_atom var f (xs' @ x # xs) = Some f'\n  eval (elimVar var L2 [] f) (xs' @ x # xs) =\n  evalUni (elimVarUni_atom L2' f') x\n  f' \\<in> set L'\n  evalUni (elimVarUni_atom L2' f') x\n\ngoal (2 subgoals):\n 1. eval (elimVar var L2 [] f) (xs' @ x # xs)\n 2. f \\<in> set L", "by auto"], ["proof (state)\nthis:\n  \\<exists>f\\<in>set L. eval (elimVar var L2 [] f) (xs' @ x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_convert : \n  assumes \"convert_atom_list var L (xs' @ x # xs) = Some L'\"\n  assumes \"length xs' = var\"\n  shows \"(\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) = (\\<forall>f\\<in>set L'. aEvalUni f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "proof(induction L arbitrary : L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set []. aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "case Nil"], ["proof (state)\nthis:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (2 subgoals):\n 1. \\<And>L'.\n       \\<lbrakk>convert_atom_list var [] (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set []. aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_atom_list var [] (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set []. aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set []. aEval f (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f x)\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "case (Cons a L)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a L L'.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  convert_atom_list var (a # L) (xs' @ x # xs) = Some L'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "then"], ["proof (chain)\npicking this:\n  a = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Less p\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  a = Less p\n  Some L' = convert_atom_list var (a # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "unfolding Less"], ["proof (prove)\nusing this:\n  Less p = Less p\n  Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Less p # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Less p = Less p;\n     Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<lbrakk>Less p = Less p;\n     Some L' = convert_atom_list var (Less p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Less p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LessUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LessUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (LessUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           convert_atom_list var L (xs' @ x # xs) =\n           Some L' \\<Longrightarrow>\n           (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n           (\\<forall>f\\<in>set L'. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p\n                          < 0 \\<and>\n                          (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LessUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p\n                          < 0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x)) =\n                         (insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 2) *\n                          x\\<^sup>2 +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var (Suc 0)) *\n                          x +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 0)\n                          < 0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x))", "by (simp add: poly_to_univar)"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f x)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "then"], ["proof (chain)\npicking this:\n  a = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Eq p\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  a = Eq p\n  Some L' = convert_atom_list var (a # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "unfolding Eq"], ["proof (prove)\nusing this:\n  Eq p = Eq p\n  Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Eq p # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Eq p = Eq p;\n     Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<lbrakk>Eq p = Eq p;\n     Some L' = convert_atom_list var (Eq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Eq p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (EqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p = 0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (EqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p = 0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           convert_atom_list var L (xs' @ x # xs) =\n           Some L' \\<Longrightarrow>\n           (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n           (\\<forall>f\\<in>set L'. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p =\n                          0 \\<and>\n                          (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                EqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p =\n                          0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x)) =\n                         (insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 2) *\n                          x\\<^sup>2 +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var (Suc 0)) *\n                          x +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 0) =\n                          0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x))", "by (simp add: poly_to_univar)"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f x)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (a # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "unfolding Leq"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (Leq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Leq p # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Leq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<lbrakk>Some L' = convert_atom_list var (Leq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Leq p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p\n                       \\<le> 0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (LeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p\n                       \\<le> 0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (LeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           convert_atom_list var L (xs' @ x # xs) =\n           Some L' \\<Longrightarrow>\n           (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n           (\\<forall>f\\<in>set L'. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p\n                          \\<le> 0 \\<and>\n                          (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                LeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p\n                          \\<le> 0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x)) =\n                         (insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 2) *\n                          x\\<^sup>2 +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var (Suc 0)) *\n                          x +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 0)\n                          \\<le> 0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x))", "by (simp add: poly_to_univar)"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f x)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>L'.\n                   \\<lbrakk>convert_atom_list var L (xs' @ x # xs) =\n                            Some L';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>f\\<in>set L.\n   aEval f (xs' @ x # xs)) =\n                                     (\\<forall>f\\<in>set L'. aEvalUni f x);\n        convert_atom_list var (a # L) (xs' @ x # xs) = Some L';\n        length xs' = var; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>f\\<in>set (a # L).\n                             aEval f (xs' @ x # xs)) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "using Cons(2)[symmetric] Cons(1) Cons(3)"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (a # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "unfolding Neq"], ["proof (prove)\nusing this:\n  Some L' = convert_atom_list var (Neq p # L) (xs' @ x # xs)\n  \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some ?L';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                    (\\<forall>f\\<in>set ?L'. aEvalUni f x)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (Neq p # L). aEval f (xs' @ x # xs)) =\n    (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \" MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' = convert_atom_list var (Neq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<lbrakk>Some L' = convert_atom_list var (Neq p # L) (xs' @ x # xs);\n     \\<And>L'.\n        \\<lbrakk>convert_atom_list var L (xs' @ x # xs) = Some L';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n                          (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>f\\<in>set (Neq p # L).\n                          aEval f (xs' @ x # xs)) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (NeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p \\<noteq>\n                       0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply(cases \"convert_atom_list var L (xs' @ x # xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some L' =\n             (case convert_atom_list var L (xs' @ x # xs) of\n              None \\<Rightarrow> None\n              | Some as \\<Rightarrow>\n                  Some\n                   (NeqUni\n                     (insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)),\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0)) #\n                    as));\n     \\<And>L'.\n        convert_atom_list var L (xs' @ x # xs) = Some L' \\<Longrightarrow>\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set L'. aEvalUni f x);\n     length xs' = var; MPoly_Type.degree p var < 3;\n     convert_atom_list var L (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p \\<noteq>\n                       0 \\<and>\n                       (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                      (\\<forall>f\\<in>set L'. aEvalUni f x)\n 2. \\<And>a.\n       \\<lbrakk>Some L' =\n                (case convert_atom_list var L (xs' @ x # xs) of\n                 None \\<Rightarrow> None\n                 | Some as \\<Rightarrow>\n                     Some\n                      (NeqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)) #\n                       as));\n        \\<And>L'.\n           convert_atom_list var L (xs' @ x # xs) =\n           Some L' \\<Longrightarrow>\n           (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n           (\\<forall>f\\<in>set L'. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs))\n                           p \\<noteq>\n                          0 \\<and>\n                          (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs))) =\n                         (\\<forall>f\\<in>set L'. aEvalUni f x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>L' =\n                NeqUni\n                 (insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 2),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var (Suc 0)),\n                  insertion (nth_default 0 (xs' @ x # xs))\n                   (isolate_variable_sparse p var 0)) #\n                a;\n        (\\<forall>f\\<in>set L. aEval f (xs' @ x # xs)) =\n        (\\<forall>f\\<in>set a. aEvalUni f x);\n        length xs' = var; MPoly_Type.degree p var < 3;\n        convert_atom_list var L (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs))\n                           p \\<noteq>\n                          0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x)) =\n                         (insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 2) *\n                          x\\<^sup>2 +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var (Suc 0)) *\n                          x +\n                          insertion (nth_default 0 (xs' @ x # xs))\n                           (isolate_variable_sparse p var 0) \\<noteq>\n                          0 \\<and>\n                          (\\<forall>f\\<in>set a. aEvalUni f x))", "by (simp add: poly_to_univar)"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (a # L). aEval f (xs' @ x # xs)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_degree_2_convert : \n  assumes \"all_degree_2 var L\"\n  shows \"\\<exists>L'. convert_atom_list var L xs = Some L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var L xs = Some L'", "using assms"], ["proof (prove)\nusing this:\n  all_degree_2 var L\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var L xs = Some L'", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. all_degree_2 var [] \\<Longrightarrow>\n    \\<exists>L'. convert_atom_list var [] xs = Some L'\n 2. \\<And>a L.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "case Nil"], ["proof (state)\nthis:\n  all_degree_2 var []\n\ngoal (2 subgoals):\n 1. all_degree_2 var [] \\<Longrightarrow>\n    \\<exists>L'. convert_atom_list var [] xs = Some L'\n 2. \\<And>a L.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "then"], ["proof (chain)\npicking this:\n  all_degree_2 var []", "show ?case"], ["proof (prove)\nusing this:\n  all_degree_2 var []\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var [] xs = Some L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var [] xs = Some L'\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "case (Cons a L)"], ["proof (state)\nthis:\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "then"], ["proof (chain)\npicking this:\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)", "show ?case"], ["proof (prove)\nusing this:\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x2.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 3. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 4. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x2.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 3. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 4. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "using Cons"], ["proof (prove)\nusing this:\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "unfolding Less all_degree_2.simps convert_atom_list.simps convert_atom.simps"], ["proof (prove)\nusing this:\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  MPoly_Type.degree p var \\<le> 2 \\<and> all_degree_2 var L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       (case map_option LessUni (convert_poly var p xs) of\n        None \\<Rightarrow> None\n        | Some a \\<Rightarrow>\n            case convert_atom_list var L xs of None \\<Rightarrow> None\n            | Some as \\<Rightarrow> Some (a # as)) =\n       Some L'", "using degree_convert_eq[of var p xs]"], ["proof (prove)\nusing this:\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  MPoly_Type.degree p var \\<le> 2 \\<and> all_degree_2 var L\n  convert_poly var p xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       (case map_option LessUni (convert_poly var p xs) of\n        None \\<Rightarrow> None\n        | Some a \\<Rightarrow>\n            case convert_atom_list var L xs of None \\<Rightarrow> None\n            | Some as \\<Rightarrow> Some (a # as)) =\n       Some L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var (a # L) xs = Some L'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 3. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 3. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 3. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "then"], ["proof (chain)\npicking this:\n  a = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Eq p\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "using Cons"], ["proof (prove)\nusing this:\n  a = Eq p\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "unfolding Eq all_degree_2.simps convert_atom_list.simps convert_atom.simps"], ["proof (prove)\nusing this:\n  Eq p = Eq p\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  MPoly_Type.degree p var \\<le> 2 \\<and> all_degree_2 var L\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       (case map_option EqUni (convert_poly var p xs) of\n        None \\<Rightarrow> None\n        | Some a \\<Rightarrow>\n            case convert_atom_list var L xs of None \\<Rightarrow> None\n            | Some as \\<Rightarrow> Some (a # as)) =\n       Some L'", "using degree_convert_eq[of var p xs]"], ["proof (prove)\nusing this:\n  Eq p = Eq p\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  MPoly_Type.degree p var \\<le> 2 \\<and> all_degree_2 var L\n  convert_poly var p xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. \\<exists>L'.\n       (case map_option EqUni (convert_poly var p xs) of\n        None \\<Rightarrow> None\n        | Some a \\<Rightarrow>\n            case convert_atom_list var L xs of None \\<Rightarrow> None\n            | Some as \\<Rightarrow> Some (a # as)) =\n       Some L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var (a # L) xs = Some L'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "case (Leq x3)"], ["proof (state)\nthis:\n  a = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'\n 2. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "then"], ["proof (chain)\npicking this:\n  a = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Leq x3\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "using Cons"], ["proof (prove)\nusing this:\n  a = Leq x3\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var (a # L) xs = Some L'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "case (Neq x4)"], ["proof (state)\nthis:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>all_degree_2 var L \\<Longrightarrow>\n                \\<exists>L'. convert_atom_list var L xs = Some L';\n        all_degree_2 var (a # L); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L'.\n                            convert_atom_list var (a # L) xs = Some L'", "then"], ["proof (chain)\npicking this:\n  a = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "using Cons"], ["proof (prove)\nusing this:\n  a = Neq x4\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L xs = Some L'\n  all_degree_2 var (a # L)\n\ngoal (1 subgoal):\n 1. \\<exists>L'. convert_atom_list var (a # L) xs = Some L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var (a # L) xs = Some L'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var (a # L) xs = Some L'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_qe_eval :\n  assumes hlength : \"length xs = var\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval (gen_qe var L F) (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "proof(cases \"luckyFind var L []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. luckyFind var L [] = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       luckyFind var L [] = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "case None"], ["proof (state)\nthis:\n  luckyFind var L [] = None\n\ngoal (2 subgoals):\n 1. luckyFind var L [] = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       luckyFind var L [] = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  luckyFind var L [] = None", "have notLucky : \"luckyFind var L [] = None\""], ["proof (prove)\nusing this:\n  luckyFind var L [] = None\n\ngoal (1 subgoal):\n 1. luckyFind var L [] = None", "by auto"], ["proof (state)\nthis:\n  luckyFind var L [] = None\n\ngoal (2 subgoals):\n 1. luckyFind var L [] = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       luckyFind var L [] = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  luckyFind var L [] = None", "show ?thesis"], ["proof (prove)\nusing this:\n  luckyFind var L [] = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "proof(cases F)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>luckyFind var L [] = None; F = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a list.\n       \\<lbrakk>luckyFind var L [] = None; F = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "case Nil"], ["proof (state)\nthis:\n  F = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>luckyFind var L [] = None; F = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a list.\n       \\<lbrakk>luckyFind var L [] = None; F = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  F = []", "show ?thesis"], ["proof (prove)\nusing this:\n  F = []\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "proof(cases \"all_degree_2 var L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>F = []; all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "case True"], ["proof (state)\nthis:\n  all_degree_2 var L\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F = []; all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  all_degree_2 var L", "have \"\\<And>x.\\<exists>L'. convert_atom_list var L (xs@x#\\<Gamma>) = Some L'\""], ["proof (prove)\nusing this:\n  all_degree_2 var L\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>L'. convert_atom_list var L (xs @ x # \\<Gamma>) = Some L'", "using all_degree_2_convert[of var L \"xs@_#\\<Gamma>\"]"], ["proof (prove)\nusing this:\n  all_degree_2 var L\n  all_degree_2 var L \\<Longrightarrow>\n  \\<exists>L'. convert_atom_list var L (xs @ ?uu3 # \\<Gamma>) = Some L'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>L'. convert_atom_list var L (xs @ x # \\<Gamma>) = Some L'", "by auto"], ["proof (state)\nthis:\n  \\<exists>L'. convert_atom_list var L (xs @ ?x # \\<Gamma>) = Some L'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F = []; all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>L'. convert_atom_list var L (xs @ ?x # \\<Gamma>) = Some L'", "obtain L' where L' : \"convert_atom_list var L (xs@x#\\<Gamma>) = Some L'\""], ["proof (prove)\nusing this:\n  \\<exists>L'. convert_atom_list var L (xs @ ?x # \\<Gamma>) = Some L'\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        convert_atom_list var L (xs @ x # \\<Gamma>) =\n        Some L' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  convert_atom_list var L (xs @ x # \\<Gamma>) = Some L'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F = []; all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var L (xs @ x # \\<Gamma>) = Some L'", "have L' : \"\\<And>x. convert_atom_list var L (xs@x#\\<Gamma>) = Some L'\""], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs @ x # \\<Gamma>) = Some L'\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom_list var L (xs @ x # \\<Gamma>) = Some L'", "by (metis convert_atom_list_change hlength)"], ["proof (state)\nthis:\n  convert_atom_list var L (xs @ ?x # \\<Gamma>) = Some L'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>F = []; all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "unfolding Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map fm.Atom L @ [])) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L []) (xs @ x # \\<Gamma>))", "apply (simp add:eval_list_conj eval_list_disj True del:luckyFind.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval\n         (case luckyFind var L [] of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs @ x # \\<Gamma>))", "unfolding notLucky"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval\n         (case None of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs @ x # \\<Gamma>))", "apply (simp add:eval_list_conj eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs @ x # \\<Gamma>)))", "using negInf_convert[OF L' assms] elimVar_atom_convert[OF L' L' assms] eval_convert[OF L' assms]"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set L.\n      eval (substNegInfinity var f) (xs @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) ?x)\n  (\\<exists>f\\<in>set L. eval (elimVar var L [] f) (xs @ ?x # \\<Gamma>)) =\n  (\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L' f) ?x)\n  (\\<forall>f\\<in>set L. aEval f (xs @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f ?x)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs @ x # \\<Gamma>)))", "using eval_generalVS''[of L']"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set L.\n      eval (substNegInfinity var f) (xs @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) ?x)\n  (\\<exists>f\\<in>set L. eval (elimVar var L [] f) (xs @ ?x # \\<Gamma>)) =\n  (\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L' f) ?x)\n  (\\<forall>f\\<in>set L. aEval f (xs @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f ?x)\n  (\\<exists>x. evalUni (list_conj_Uni (map AtomUni L')) x) =\n  evalUni (generalVS_DNF L') ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs @ x # \\<Gamma>)))", "unfolding eval_list_conj_Uni generalVS_DNF.simps eval_list_conj_Uni eval_list_disj_Uni eval_append eval_map eval_map_all\n          evalUni.simps"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set L.\n      eval (substNegInfinity var f) (xs @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set L'. evalUni (substNegInfinityUni f) ?x)\n  (\\<exists>f\\<in>set L. eval (elimVar var L [] f) (xs @ ?x # \\<Gamma>)) =\n  (\\<exists>f\\<in>set L'. evalUni (elimVarUni_atom L' f) ?x)\n  (\\<forall>f\\<in>set L. aEval f (xs @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set L'. aEvalUni f ?x)\n  (\\<exists>x. \\<forall>l\\<in>set L'. aEvalUni l x) =\n  ((\\<forall>l\\<in>set L'. evalUni (substNegInfinityUni l) ?x) \\<or>\n   (\\<exists>l\\<in>set L'. evalUni (elimVarUni_atom L' l) ?x))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs @ x # \\<Gamma>)))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "case False"], ["proof (state)\nthis:\n  \\<not> all_degree_2 var L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F = []; \\<not> all_degree_2 var L\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  \\<not> all_degree_2 var L", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> all_degree_2 var L\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "using notLucky"], ["proof (prove)\nusing this:\n  \\<not> all_degree_2 var L\n  luckyFind var L [] = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "unfolding Nil  False"], ["proof (prove)\nusing this:\n  \\<not> all_degree_2 var L\n  luckyFind var L [] = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map fm.Atom L @ [])) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L []) (xs @ x # \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> all_degree_2 var L;\n     (case find_lucky_eq var L of None \\<Rightarrow> None\n      | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p))) =\n     None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval\n                           (case find_eq var L of\n                            (A, L') \\<Rightarrow>\n                              qe_eq_repeat_helper var A L' [])\n                           (xs @ x # \\<Gamma>))", "by (metis append_Nil2 hlength notLucky option.simps(4) qe_eq_repeat.simps qe_eq_repeat_eval)"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>luckyFind var L [] = None; F = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>luckyFind var L [] = None; F = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "case (Cons a list)"], ["proof (state)\nthis:\n  F = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>luckyFind var L [] = None; F = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "apply(simp add:Cons del:qe_eq_repeat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map fm.Atom L @ a # list)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L (a # list)) (xs @ x # \\<Gamma>))", "apply(rule qe_eq_repeat_eval[of xs var L \"a # list\" \\<Gamma>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = var", "using assms"], ["proof (prove)\nusing this:\n  length xs = var\n\ngoal (1 subgoal):\n 1. length xs = var", "."], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       luckyFind var L [] = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       luckyFind var L [] = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "case (Some a)"], ["proof (state)\nthis:\n  luckyFind var L [] = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       luckyFind var L [] = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  luckyFind var L [] = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  luckyFind var L [] = Some a\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "using luckyFind_eval[OF Some assms]"], ["proof (prove)\nusing this:\n  luckyFind var L [] = Some a\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ [])) (xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval a (xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "apply(cases F)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>luckyFind var L [] = Some a;\n     \\<And>\\<Gamma>.\n        (\\<exists>x.\n            eval (list_conj (map fm.Atom L @ [])) (xs @ x # \\<Gamma>)) =\n        (\\<exists>x. eval a (xs @ x # \\<Gamma>));\n     F = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>aa list.\n       \\<lbrakk>luckyFind var L [] = Some a;\n        \\<And>\\<Gamma>.\n           (\\<exists>x.\n               eval (list_conj (map fm.Atom L @ [])) (xs @ x # \\<Gamma>)) =\n           (\\<exists>x. eval a (xs @ x # \\<Gamma>));\n        F = aa # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>luckyFind var L [] = Some a;\n        \\<And>\\<Gamma>.\n           (\\<exists>x.\n               eval (list_conj (map fm.Atom L @ [])) (xs @ x # \\<Gamma>)) =\n           (\\<exists>x. eval a (xs @ x # \\<Gamma>));\n        F = aa # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "apply(simp add:Cons del:qe_eq_repeat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>(case find_lucky_eq var L of None \\<Rightarrow> None\n                 | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p))) =\n                Some a;\n        \\<And>\\<Gamma>.\n           (\\<exists>x.\n               eval (list_conj (map fm.Atom L)) (xs @ x # \\<Gamma>)) =\n           (\\<exists>x. eval a (xs @ x # \\<Gamma>));\n        F = aa # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ aa # list))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L (aa # list))\n                              (xs @ x # \\<Gamma>))", "using qe_eq_repeat_eval[of xs var L _ \\<Gamma>]"], ["proof (prove)\nusing this:\n  length xs = var \\<Longrightarrow>\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ ?F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L ?F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>(case find_lucky_eq var L of None \\<Rightarrow> None\n                 | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p))) =\n                Some a;\n        \\<And>\\<Gamma>.\n           (\\<exists>x.\n               eval (list_conj (map fm.Atom L)) (xs @ x # \\<Gamma>)) =\n           (\\<exists>x. eval a (xs @ x # \\<Gamma>));\n        F = aa # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ aa # list))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L (aa # list))\n                              (xs @ x # \\<Gamma>))", "using assms"], ["proof (prove)\nusing this:\n  length xs = var \\<Longrightarrow>\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ ?F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L ?F) (xs @ x # \\<Gamma>))\n  length xs = var\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>(case find_lucky_eq var L of None \\<Rightarrow> None\n                 | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p))) =\n                Some a;\n        \\<And>\\<Gamma>.\n           (\\<exists>x.\n               eval (list_conj (map fm.Atom L)) (xs @ x # \\<Gamma>)) =\n           (\\<exists>x. eval a (xs @ x # \\<Gamma>));\n        F = aa # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ aa # list))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L (aa # list))\n                              (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeIn_elimVar : \"freeIn var (elimVar var L F A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "proof(cases A)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1. A = Less x1 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 4. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "case (Less p)"], ["proof (state)\nthis:\n  A = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1. A = Less x1 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 4. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "have two: \"2 = Suc(Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by auto"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (4 subgoals):\n 1. \\<And>x1. A = Less x1 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 4. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "have notIn4: \"var \\<notin> vars (4::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 4", "by (metis isolate_var_one not_in_add not_in_isovarspar numeral_plus_numeral one_add_one semiring_norm(2) semiring_norm(6))"], ["proof (state)\nthis:\n  var \\<notin> vars 4\n\ngoal (4 subgoals):\n 1. \\<And>x1. A = Less x1 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 4. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "using Less"], ["proof (prove)\nusing this:\n  A = Less p\n\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalLinear var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         L @\n        map (substInfinitesimalLinear_fm var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         F))\n 4. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 6. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 7. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (7 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalLinear var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         L @\n        map (substInfinitesimalLinear_fm var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         F))\n 4. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 6. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 7. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "apply force+"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalLinear var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         L @\n        map (substInfinitesimalLinear_fm var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         F))\n 2. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "apply (rule freeIn_list_conj)"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Less p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (substInfinitesimalLinear var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)))\n                         L @\n                        map (substInfinitesimalLinear_fm var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)))\n                         F).\n       freeIn var f\n 2. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 3. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 6. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "defer"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)", "defer"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (6 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply force+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "using not_in_sub[OF not_in_mult[of var 4, OF _ not_in_mult[of var \"isolate_variable_sparse p var 2\" \"isolate_variable_sparse p var 0\"]], of \"(isolate_variable_sparse p var (Suc 0))\\<^sup>2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars 4;\n   var \\<notin> vars (isolate_variable_sparse p var 2);\n   var \\<notin> vars (isolate_variable_sparse p var 0);\n   var\n   \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n  \\<Longrightarrow> var\n                    \\<notin> vars\n                              (4 *\n                               (isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0) -\n                               (isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply (simp add:not_in_isovarspar two)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var (Suc (Suc 0)) *\n             isolate_variable_sparse p var 0 -\n             isolate_variable_sparse p var (Suc 0) *\n             isolate_variable_sparse p var (Suc 0));\n     \\<lbrakk>var \\<notin> vars 4;\n      var\n      \\<notin> vars\n                (isolate_variable_sparse p var (Suc 0) *\n                 isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n     \\<Longrightarrow> var\n                       \\<notin> vars\n                                 (4 *\n                                  (isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   isolate_variable_sparse p var 0) -\n                                  isolate_variable_sparse p var (Suc 0) *\n                                  isolate_variable_sparse p var\n                                   (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "using not_in_mult[of var \"isolate_variable_sparse p var (Suc 0)\" \"isolate_variable_sparse p var (Suc 0)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars (isolate_variable_sparse p var (Suc 0));\n   var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n  \\<Longrightarrow> var\n                    \\<notin> vars\n                              (isolate_variable_sparse p var (Suc 0) *\n                               isolate_variable_sparse p var (Suc 0))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var (Suc (Suc 0)) *\n             isolate_variable_sparse p var 0 -\n             isolate_variable_sparse p var (Suc 0) *\n             isolate_variable_sparse p var (Suc 0));\n     \\<lbrakk>var \\<notin> vars 4;\n      var\n      \\<notin> vars\n                (isolate_variable_sparse p var (Suc 0) *\n                 isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n     \\<Longrightarrow> var\n                       \\<notin> vars\n                                 (4 *\n                                  (isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   isolate_variable_sparse p var 0) -\n                                  isolate_variable_sparse p var (Suc 0) *\n                                  isolate_variable_sparse p var\n                                   (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply (simp add:not_in_isovarspar notIn4)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Less p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var (Suc (Suc 0)) *\n             isolate_variable_sparse p var 0 -\n             isolate_variable_sparse p var (Suc 0) *\n             isolate_variable_sparse p var (Suc 0));\n     var\n     \\<notin> vars\n               (4 *\n                (isolate_variable_sparse p var (Suc (Suc 0)) *\n                 isolate_variable_sparse p var 0) -\n                isolate_variable_sparse p var (Suc 0) *\n                isolate_variable_sparse p var (Suc 0));\n     var\n     \\<notin> vars\n               (isolate_variable_sparse p var (Suc 0) *\n                isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply (simp add: ideal.scale_scale)"], ["proof (prove)\ngoal (4 subgoals):\n 1. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (4 subgoals):\n 1. A = Less p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (substInfinitesimalQuadratic var\n                              (- isolate_variable_sparse p var (Suc 0)) 1\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         L @\n                        map (substInfinitesimalQuadratic_fm var\n                              (- isolate_variable_sparse p var (Suc 0)) 1\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         F).\n       freeIn var f\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 3. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Less p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Less p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (substInfinitesimalQuadratic var\n                              (- isolate_variable_sparse p var (Suc 0))\n                              (- 1)\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         L @\n                        map (substInfinitesimalQuadratic_fm var\n                              (- isolate_variable_sparse p var (Suc 0))\n                              (- 1)\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         F).\n       freeIn var f\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply(rule freeIn_substInfinitesimalQuadratic)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   (- isolate_variable_sparse p var (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (- 1)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars (2 * isolate_variable_sparse p var 2)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 8. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 9. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (- isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L; var \\<in> vars (- 1)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 8. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 9. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using not_in_isovarspar not_in_neg"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (- isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L; var \\<in> vars (- 1)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 8. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 9. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply blast"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L; var \\<in> vars (- 1)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 7. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 8. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis not_in_isovarspar not_in_neg not_in_pow power_0)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using notIn4 not_in_isovarspar not_in_mult not_in_pow not_in_sub"], ["proof (prove)\nusing this:\n  var \\<notin> vars 4\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  ?var \\<notin> vars ?p \\<Longrightarrow> ?var \\<notin> vars (?p ^ ?i)\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p - ?q)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using freeIn_substInfinitesimalQuadratic_fm[of var \"(- isolate_variable_sparse p var (Suc 0))\" \"-1\" \"((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\" \"(2 * isolate_variable_sparse p var 2)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n   var \\<notin> vars (- 1);\n   var\n   \\<notin> vars\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 *\n              isolate_variable_sparse p var 0);\n   var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n  \\<Longrightarrow> freeIn var\n                     (substInfinitesimalQuadratic_fm var\n                       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                        4 * isolate_variable_sparse p var 2 *\n                        isolate_variable_sparse p var 0)\n                       (2 * isolate_variable_sparse p var 2) ?F)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F;\n        \\<And>F.\n           \\<lbrakk>var\n                    \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n            var \\<notin> vars (- 1);\n            var\n            \\<notin> vars\n                      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                       4 * isolate_variable_sparse p var 2 *\n                       isolate_variable_sparse p var 0);\n            var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n           \\<Longrightarrow> freeIn var\n                              (liftmap\n                                (\\<lambda>x.\n                                    substInfinitesimalQuadratic (var + x)\n                                     (liftPoly 0 x\n (- isolate_variable_sparse p var (Suc 0)))\n                                     (liftPoly 0 x (- 1))\n                                     (liftPoly 0 x\n ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n  4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0))\n                                     (liftPoly 0 x\n (2 * isolate_variable_sparse p var 2)))\n                                F 0)\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis (no_types, lifting) mult_2 notIn4 not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow not_in_sub power_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply(rule freeIn_substInfinitesimalLinear)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars (- isolate_variable_sparse p var 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   (isolate_variable_sparse p var (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (meson not_in_isovarspar not_in_neg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   (isolate_variable_sparse p var (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (simp add: not_in_isovarspar)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using freeIn_substInfinitesimalLinear_fm"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?a; ?var \\<notin> vars ?b\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var (substInfinitesimalLinear_fm ?var ?a ?b ?F)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using not_in_isovarspar not_in_neg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?a; ?var \\<notin> vars ?b\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var (substInfinitesimalLinear_fm ?var ?a ?b ?F)\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis (no_types, lifting) \\<open>\\<lbrakk>var \\<notin> vars 4; var \\<notin> vars (isolate_variable_sparse p var 2); var \\<notin> vars (isolate_variable_sparse p var 0); var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk> \\<Longrightarrow> var \\<notin> vars (4 * (isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) - (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<close> freeIn_substInfinitesimalQuadratic minus_diff_eq mult.assoc mult_2 notIn4 not_in_add not_in_isovarspar not_in_neg not_in_pow power_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using freeIn_substInfinitesimalQuadratic_fm[of var \"(- isolate_variable_sparse p var (Suc 0))\" 1 \"((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\" \"(2 * isolate_variable_sparse p var 2)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n   var \\<notin> vars 1;\n   var\n   \\<notin> vars\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 *\n              isolate_variable_sparse p var 0);\n   var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n  \\<Longrightarrow> freeIn var\n                     (substInfinitesimalQuadratic_fm var\n                       (- isolate_variable_sparse p var (Suc 0)) 1\n                       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                        4 * isolate_variable_sparse p var 2 *\n                        isolate_variable_sparse p var 0)\n                       (2 * isolate_variable_sparse p var 2) ?F)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = Less p; x \\<in> set F;\n        \\<And>F.\n           \\<lbrakk>var\n                    \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n            var \\<notin> vars 1;\n            var\n            \\<notin> vars\n                      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                       4 * isolate_variable_sparse p var 2 *\n                       isolate_variable_sparse p var 0);\n            var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n           \\<Longrightarrow> freeIn var\n                              (liftmap\n                                (\\<lambda>x.\n                                    substInfinitesimalQuadratic (var + x)\n                                     (liftPoly 0 x\n (- isolate_variable_sparse p var (Suc 0)))\n                                     (liftPoly 0 x 1)\n                                     (liftPoly 0 x\n ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n  4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0))\n                                     (liftPoly 0 x\n (2 * isolate_variable_sparse p var 2)))\n                                F 0)\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "by (metis (no_types, lifting) \\<open>\\<lbrakk>var \\<notin> vars 4; var \\<notin> vars (isolate_variable_sparse p var 2); var \\<notin> vars (isolate_variable_sparse p var 0); var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk> \\<Longrightarrow> var \\<notin> vars (4 * (isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) - (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<close> ideal.scale_scale minus_diff_eq mult_2 notIn4 not_in_add not_in_isovarspar not_in_neg not_in_pow power_0)"], ["proof (state)\nthis:\n  freeIn var (elimVar var L F A)\n\ngoal (3 subgoals):\n 1. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "case (Eq p)"], ["proof (state)\nthis:\n  A = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2. A = Eq x2 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 3. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "then"], ["proof (chain)\npicking this:\n  A = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  A = Eq p\n\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "using freeIn_elimVar_eq"], ["proof (prove)\nusing this:\n  A = Eq p\n  freeIn ?var (elimVar ?var ?L ?F (Eq ?p))\n\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "by auto"], ["proof (state)\nthis:\n  freeIn var (elimVar var L F A)\n\ngoal (2 subgoals):\n 1. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "case (Leq p)"], ["proof (state)\nthis:\n  A = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3. A = Leq x3 \\<Longrightarrow> freeIn var (elimVar var L F A)\n 2. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "then"], ["proof (chain)\npicking this:\n  A = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  A = Leq p\n\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "using freeIn_elimVar_eq"], ["proof (prove)\nusing this:\n  A = Leq p\n  freeIn ?var (elimVar ?var ?L ?F (Eq ?p))\n\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "by auto"], ["proof (state)\nthis:\n  freeIn var (elimVar var L F A)\n\ngoal (1 subgoal):\n 1. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "case (Neq p)"], ["proof (state)\nthis:\n  A = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "have two: \"2 = Suc(Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by auto"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "have notIn4: \"var \\<notin> vars (4::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars 4", "by (metis isolate_var_one not_in_add not_in_isovarspar numeral_plus_numeral one_add_one semiring_norm(2) semiring_norm(6))"], ["proof (state)\nthis:\n  var \\<notin> vars 4\n\ngoal (1 subgoal):\n 1. \\<And>x4. A = Neq x4 \\<Longrightarrow> freeIn var (elimVar var L F A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "using Neq"], ["proof (prove)\nusing this:\n  A = Neq p\n\ngoal (1 subgoal):\n 1. freeIn var (elimVar var L F A)", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalLinear var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         L @\n        map (substInfinitesimalLinear_fm var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         F))\n 4. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 6. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 7. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (7 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalLinear var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         L @\n        map (substInfinitesimalLinear_fm var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         F))\n 4. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 6. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 7. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "apply force+"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalLinear var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         L @\n        map (substInfinitesimalLinear_fm var\n              (- isolate_variable_sparse p var 0)\n              (isolate_variable_sparse p var (Suc 0)))\n         F))\n 2. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "apply (rule freeIn_list_conj)"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Neq p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (substInfinitesimalLinear var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)))\n                         L @\n                        map (substInfinitesimalLinear_fm var\n                              (- isolate_variable_sparse p var 0)\n                              (isolate_variable_sparse p var (Suc 0)))\n                         F).\n       freeIn var f\n 2. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 3. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 6. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))", "defer"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)", "defer"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (6 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var \\<in> vars (isolate_variable_sparse p var 2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply force+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "using not_in_sub[OF not_in_mult[of var 4, OF _ not_in_mult[of var \"isolate_variable_sparse p var 2\" \"isolate_variable_sparse p var 0\"]], of \"(isolate_variable_sparse p var (Suc 0))\\<^sup>2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars 4;\n   var \\<notin> vars (isolate_variable_sparse p var 2);\n   var \\<notin> vars (isolate_variable_sparse p var 0);\n   var\n   \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n  \\<Longrightarrow> var\n                    \\<notin> vars\n                              (4 *\n                               (isolate_variable_sparse p var 2 *\n                                isolate_variable_sparse p var 0) -\n                               (isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var 2 *\n             isolate_variable_sparse p var 0 -\n             (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply (simp add:not_in_isovarspar two)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var (Suc (Suc 0)) *\n             isolate_variable_sparse p var 0 -\n             isolate_variable_sparse p var (Suc 0) *\n             isolate_variable_sparse p var (Suc 0));\n     \\<lbrakk>var \\<notin> vars 4;\n      var\n      \\<notin> vars\n                (isolate_variable_sparse p var (Suc 0) *\n                 isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n     \\<Longrightarrow> var\n                       \\<notin> vars\n                                 (4 *\n                                  (isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   isolate_variable_sparse p var 0) -\n                                  isolate_variable_sparse p var (Suc 0) *\n                                  isolate_variable_sparse p var\n                                   (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "using not_in_mult[of var \"isolate_variable_sparse p var (Suc 0)\" \"isolate_variable_sparse p var (Suc 0)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars (isolate_variable_sparse p var (Suc 0));\n   var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n  \\<Longrightarrow> var\n                    \\<notin> vars\n                              (isolate_variable_sparse p var (Suc 0) *\n                               isolate_variable_sparse p var (Suc 0))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var (Suc (Suc 0)) *\n             isolate_variable_sparse p var 0 -\n             isolate_variable_sparse p var (Suc 0) *\n             isolate_variable_sparse p var (Suc 0));\n     \\<lbrakk>var \\<notin> vars 4;\n      var\n      \\<notin> vars\n                (isolate_variable_sparse p var (Suc 0) *\n                 isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n     \\<Longrightarrow> var\n                       \\<notin> vars\n                                 (4 *\n                                  (isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   isolate_variable_sparse p var 0) -\n                                  isolate_variable_sparse p var (Suc 0) *\n                                  isolate_variable_sparse p var\n                                   (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply (simp add:not_in_isovarspar notIn4)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>A = Neq p;\n     var\n     \\<in> vars\n            (4 * isolate_variable_sparse p var (Suc (Suc 0)) *\n             isolate_variable_sparse p var 0 -\n             isolate_variable_sparse p var (Suc 0) *\n             isolate_variable_sparse p var (Suc 0));\n     var\n     \\<notin> vars\n               (4 *\n                (isolate_variable_sparse p var (Suc (Suc 0)) *\n                 isolate_variable_sparse p var 0) -\n                isolate_variable_sparse p var (Suc 0) *\n                isolate_variable_sparse p var (Suc 0));\n     var\n     \\<notin> vars\n               (isolate_variable_sparse p var (Suc 0) *\n                isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply (simp add: ideal.scale_scale)"], ["proof (prove)\ngoal (4 subgoals):\n 1. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) 1\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (4 subgoals):\n 1. A = Neq p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (substInfinitesimalQuadratic var\n                              (- isolate_variable_sparse p var (Suc 0)) 1\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         L @\n                        map (substInfinitesimalQuadratic_fm var\n                              (- isolate_variable_sparse p var (Suc 0)) 1\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         F).\n       freeIn var f\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 3. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Neq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (substInfinitesimalQuadratic var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         L @\n        map (substInfinitesimalQuadratic_fm var\n              (- isolate_variable_sparse p var (Suc 0)) (- 1)\n              ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n               4 * isolate_variable_sparse p var 2 *\n               isolate_variable_sparse p var 0)\n              (2 * isolate_variable_sparse p var 2))\n         F))\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (5 subgoals):\n 1. A = Neq p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (substInfinitesimalQuadratic var\n                              (- isolate_variable_sparse p var (Suc 0))\n                              (- 1)\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         L @\n                        map (substInfinitesimalQuadratic_fm var\n                              (- isolate_variable_sparse p var (Suc 0))\n                              (- 1)\n                              ((isolate_variable_sparse p var\n                                 (Suc 0))\\<^sup>2 -\n                               4 * isolate_variable_sparse p var 2 *\n                               isolate_variable_sparse p var 0)\n                              (2 * isolate_variable_sparse p var 2))\n                         F).\n       freeIn var f\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply(rule freeIn_substInfinitesimalQuadratic)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   (- isolate_variable_sparse p var (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (- 1)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars (2 * isolate_variable_sparse p var 2)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 8. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 9. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (- isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L; var \\<in> vars (- 1)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 8. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 9. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using not_in_isovarspar not_in_neg"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (- isolate_variable_sparse p var (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L; var \\<in> vars (- 1)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 8. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 9. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply blast"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L; var \\<in> vars (- 1)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 7. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 8. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis not_in_isovarspar not_in_neg not_in_pow power_0)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using notIn4 not_in_isovarspar not_in_mult not_in_pow not_in_sub"], ["proof (prove)\nusing this:\n  var \\<notin> vars 4\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  ?var \\<notin> vars ?p \\<Longrightarrow> ?var \\<notin> vars (?p ^ ?i)\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p - ?q)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var\n        \\<in> vars\n               ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                4 * isolate_variable_sparse p var 2 *\n                isolate_variable_sparse p var 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 7. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L;\n        var \\<in> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 6. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis isovarspar_sum mult_2 not_in_isovarspar)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using freeIn_substInfinitesimalQuadratic_fm[of var \"(- isolate_variable_sparse p var (Suc 0))\" \"-1\" \"((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\" \"(2 * isolate_variable_sparse p var 2)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n   var \\<notin> vars (- 1);\n   var\n   \\<notin> vars\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 *\n              isolate_variable_sparse p var 0);\n   var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n  \\<Longrightarrow> freeIn var\n                     (substInfinitesimalQuadratic_fm var\n                       (- isolate_variable_sparse p var (Suc 0)) (- 1)\n                       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                        4 * isolate_variable_sparse p var 2 *\n                        isolate_variable_sparse p var 0)\n                       (2 * isolate_variable_sparse p var 2) ?F)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F;\n        \\<And>F.\n           \\<lbrakk>var\n                    \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n            var \\<notin> vars (- 1);\n            var\n            \\<notin> vars\n                      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                       4 * isolate_variable_sparse p var 2 *\n                       isolate_variable_sparse p var 0);\n            var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n           \\<Longrightarrow> freeIn var\n                              (liftmap\n                                (\\<lambda>x.\n                                    substInfinitesimalQuadratic (var + x)\n                                     (liftPoly 0 x\n (- isolate_variable_sparse p var (Suc 0)))\n                                     (liftPoly 0 x (- 1))\n                                     (liftPoly 0 x\n ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n  4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0))\n                                     (liftPoly 0 x\n (2 * isolate_variable_sparse p var 2)))\n                                F 0)\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x (- 1))\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis (no_types, lifting) mult_2 notIn4 not_in_add not_in_isovarspar not_in_mult not_in_neg not_in_pow not_in_sub power_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalLinear var\n                            (- isolate_variable_sparse p var 0)\n                            (isolate_variable_sparse p var (Suc 0)) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply(rule freeIn_substInfinitesimalLinear)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars (- isolate_variable_sparse p var 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   (isolate_variable_sparse p var (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 5. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (meson not_in_isovarspar not_in_neg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> var\n                         \\<notin> vars\n                                   (isolate_variable_sparse p var (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 4. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (simp add: not_in_isovarspar)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using freeIn_substInfinitesimalLinear_fm"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?a; ?var \\<notin> vars ?b\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var (substInfinitesimalLinear_fm ?var ?a ?b ?F)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using not_in_isovarspar not_in_neg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?a; ?var \\<notin> vars ?b\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var (substInfinitesimalLinear_fm ?var ?a ?b ?F)\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (isolate_variable_sparse p var (Suc 0))))\n                            x 0)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 3. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (substInfinitesimalQuadratic var\n                            (- isolate_variable_sparse p var (Suc 0)) 1\n                            ((isolate_variable_sparse p var\n                               (Suc 0))\\<^sup>2 -\n                             4 * isolate_variable_sparse p var 2 *\n                             isolate_variable_sparse p var 0)\n                            (2 * isolate_variable_sparse p var 2) x)\n 2. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply (metis (no_types, lifting) \\<open>\\<lbrakk>var \\<notin> vars 4; var \\<notin> vars (isolate_variable_sparse p var 2); var \\<notin> vars (isolate_variable_sparse p var 0); var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk> \\<Longrightarrow> var \\<notin> vars (4 * (isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) - (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<close> freeIn_substInfinitesimalQuadratic minus_diff_eq mult.assoc mult_2 notIn4 not_in_add not_in_isovarspar not_in_neg not_in_pow power_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "using freeIn_substInfinitesimalQuadratic_fm[of var \"(- isolate_variable_sparse p var (Suc 0))\" 1 \"((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                      4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0)\" \"(2 * isolate_variable_sparse p var 2)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>var \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n   var \\<notin> vars 1;\n   var\n   \\<notin> vars\n             ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n              4 * isolate_variable_sparse p var 2 *\n              isolate_variable_sparse p var 0);\n   var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n  \\<Longrightarrow> freeIn var\n                     (substInfinitesimalQuadratic_fm var\n                       (- isolate_variable_sparse p var (Suc 0)) 1\n                       ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                        4 * isolate_variable_sparse p var 2 *\n                        isolate_variable_sparse p var 0)\n                       (2 * isolate_variable_sparse p var 2) ?F)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = Neq p; x \\<in> set F;\n        \\<And>F.\n           \\<lbrakk>var\n                    \\<notin> vars (- isolate_variable_sparse p var (Suc 0));\n            var \\<notin> vars 1;\n            var\n            \\<notin> vars\n                      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n                       4 * isolate_variable_sparse p var 2 *\n                       isolate_variable_sparse p var 0);\n            var \\<notin> vars (2 * isolate_variable_sparse p var 2)\\<rbrakk>\n           \\<Longrightarrow> freeIn var\n                              (liftmap\n                                (\\<lambda>x.\n                                    substInfinitesimalQuadratic (var + x)\n                                     (liftPoly 0 x\n (- isolate_variable_sparse p var (Suc 0)))\n                                     (liftPoly 0 x 1)\n                                     (liftPoly 0 x\n ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 -\n  4 * isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0))\n                                     (liftPoly 0 x\n (2 * isolate_variable_sparse p var 2)))\n                                F 0)\\<rbrakk>\n       \\<Longrightarrow> freeIn var\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x\n                                   (- isolate_variable_sparse p var\n (Suc 0)))\n                                 (liftPoly 0 x 1)\n                                 (liftPoly 0 x\n                                   ((isolate_variable_sparse p var\n(Suc 0))\\<^sup>2 -\n                                    4 * isolate_variable_sparse p var 2 *\n                                    isolate_variable_sparse p var 0))\n                                 (liftPoly 0 x\n                                   (2 * isolate_variable_sparse p var 2)))\n                            x 0)", "by (metis (no_types, lifting) \\<open>\\<lbrakk>var \\<notin> vars 4; var \\<notin> vars (isolate_variable_sparse p var 2); var \\<notin> vars (isolate_variable_sparse p var 0); var \\<notin> vars ((isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<rbrakk> \\<Longrightarrow> var \\<notin> vars (4 * (isolate_variable_sparse p var 2 * isolate_variable_sparse p var 0) - (isolate_variable_sparse p var (Suc 0))\\<^sup>2)\\<close> ideal.scale_scale minus_diff_eq mult_2 notIn4 not_in_add not_in_isovarspar not_in_neg not_in_pow power_0)"], ["proof (state)\nthis:\n  freeIn var (elimVar var L F A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeInDisj: \"freeIn var (list_disj (list_conj (map (substNegInfinity var) L) # map (elimVar var L []) L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (list_disj\n       (list_conj (map (substNegInfinity var) L) #\n        map (elimVar var L []) L))", "apply(rule freeIn_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (list_conj (map (substNegInfinity var) L) #\n                        map (elimVar var L []) L).\n       freeIn var f", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. freeIn var (list_conj (map (substNegInfinity var) L))\n 2. \\<And>x. x \\<in> set L \\<Longrightarrow> freeIn var (elimVar var L [] x)", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>f\\<in>set (map (substNegInfinity var) L). freeIn var f\n 2. \\<And>x. x \\<in> set L \\<Longrightarrow> freeIn var (elimVar var L [] x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set L. freeIn var (substNegInfinity var x)\n 2. \\<And>x. x \\<in> set L \\<Longrightarrow> freeIn var (elimVar var L [] x)", "using freeIn_substNegInfinity[of var]"], ["proof (prove)\nusing this:\n  freeIn var (substNegInfinity var ?A)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set L. freeIn var (substNegInfinity var x)\n 2. \\<And>x. x \\<in> set L \\<Longrightarrow> freeIn var (elimVar var L [] x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set L \\<Longrightarrow> freeIn var (elimVar var L [] x)", "using freeIn_elimVar"], ["proof (prove)\nusing this:\n  freeIn ?var (elimVar ?var ?L ?F ?A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set L \\<Longrightarrow> freeIn var (elimVar var L [] x)", "by simp"], ["", "lemma gen_qe_eval' :\n  assumes \"all_degree_2 var L\"\n  assumes \"length xs' = var\"\n  shows \"(\\<exists>x. (eval (list_conj (map Atom L)) (xs'@x#\\<Gamma>))) = (\\<forall>x.(eval (gen_qe var L []) (xs'@x#\\<Gamma>)))\"\n    \"freeIn var (gen_qe var L [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>)) &&&\n    freeIn var (gen_qe var L [])", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))\n 2. freeIn var (gen_qe var L [])", "have h : \"(\\<exists>x. (eval (list_conj (map Atom L)) (xs'@x#\\<Gamma>))) = (\\<exists>x. eval (gen_qe var L []) (xs'@x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))", "using gen_qe_eval[OF assms(2), of L \"[]\" \\<Gamma>]"], ["proof (prove)\nusing this:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ [])) (xs' @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))", "unfolding List.append.left_neutral"], ["proof (prove)\nusing this:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ [])) (xs' @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))\n 2. freeIn var (gen_qe var L [])", "show \"(\\<exists>x. (eval (list_conj (map Atom L)) (xs'@x#\\<Gamma>))) = (\\<forall>x.(eval (gen_qe var L []) (xs'@x#\\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))", "apply (simp add:assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>))", "apply(cases \"find_lucky_eq var L\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    (\\<exists>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    (\\<exists>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>))", "using freeInDisj[of var L]"], ["proof (prove)\nusing this:\n  freeIn var\n   (list_disj\n     (list_conj (map (substNegInfinity var) L) # map (elimVar var L []) L))\n\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    (\\<exists>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>))", "using var_not_in_eval3[OF _ assms(2)]"], ["proof (prove)\nusing this:\n  freeIn var\n   (list_disj\n     (list_conj (map (substNegInfinity var) L) # map (elimVar var L []) L))\n  freeIn var ?\\<phi> \\<Longrightarrow>\n  (\\<exists>x. eval ?\\<phi> (xs' @ x # ?L)) =\n  (\\<forall>x. eval ?\\<phi> (xs' @ x # ?L))\n\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    (\\<exists>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (case case find_lucky_eq var L of None \\<Rightarrow> None\n                  | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n             None \\<Rightarrow>\n               list_disj\n                (list_conj (map (substNegInfinity var) L) #\n                 map (elimVar var L []) L)\n             | Some F \\<Rightarrow> F)\n            (xs' @ x # \\<Gamma>))", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_lucky_eq var L = Some a \\<Longrightarrow>\n    (\\<exists>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>))", "using freeIn_elimVar_eq[of var L \"[]\" a]"], ["proof (prove)\nusing this:\n  freeIn var (elimVar var L [] (Eq a))\n\ngoal (1 subgoal):\n 1. find_lucky_eq var L = Some a \\<Longrightarrow>\n    (\\<exists>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (case case find_lucky_eq var L of None \\<Rightarrow> None\n               | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n          None \\<Rightarrow>\n            list_disj\n             (list_conj (map (substNegInfinity var) L) #\n              map (elimVar var L []) L)\n          | Some F \\<Rightarrow> F)\n         (xs' @ x # \\<Gamma>))", "apply(simp del:elimVar.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq var L = Some a;\n     freeIn var (elimVar var L [] (Eq a))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (elimVar var L [] (Eq a))\n                           (xs' @ x # \\<Gamma>)) =\n                      (\\<forall>x.\n                          eval (elimVar var L [] (Eq a))\n                           (xs' @ x # \\<Gamma>))", "using var_not_in_eval3[OF _ assms(2)]"], ["proof (prove)\nusing this:\n  freeIn var ?\\<phi> \\<Longrightarrow>\n  (\\<exists>x. eval ?\\<phi> (xs' @ x # ?L)) =\n  (\\<forall>x. eval ?\\<phi> (xs' @ x # ?L))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq var L = Some a;\n     freeIn var (elimVar var L [] (Eq a))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (elimVar var L [] (Eq a))\n                           (xs' @ x # \\<Gamma>)) =\n                      (\\<forall>x.\n                          eval (elimVar var L [] (Eq a))\n                           (xs' @ x # \\<Gamma>))", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n  (\\<forall>x. eval (gen_qe var L []) (xs' @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. freeIn var (gen_qe var L [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (gen_qe var L [])", "show \"freeIn var (gen_qe var L []) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (gen_qe var L [])", "apply(simp add:assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (case case find_lucky_eq var L of None \\<Rightarrow> None\n           | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n      None \\<Rightarrow>\n        list_disj\n         (list_conj (map (substNegInfinity var) L) #\n          map (elimVar var L []) L)\n      | Some F \\<Rightarrow> F)", "apply(cases \"find_lucky_eq var L\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    freeIn var\n     (case case find_lucky_eq var L of None \\<Rightarrow> None\n           | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n      None \\<Rightarrow>\n        list_disj\n         (list_conj (map (substNegInfinity var) L) #\n          map (elimVar var L []) L)\n      | Some F \\<Rightarrow> F)\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       freeIn var\n        (case case find_lucky_eq var L of None \\<Rightarrow> None\n              | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n         None \\<Rightarrow>\n           list_disj\n            (list_conj (map (substNegInfinity var) L) #\n             map (elimVar var L []) L)\n         | Some F \\<Rightarrow> F)", "apply (simp add:freeInDisj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       freeIn var\n        (case case find_lucky_eq var L of None \\<Rightarrow> None\n              | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n         None \\<Rightarrow>\n           list_disj\n            (list_conj (map (substNegInfinity var) L) #\n             map (elimVar var L []) L)\n         | Some F \\<Rightarrow> F)", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_lucky_eq var L = Some a \\<Longrightarrow>\n    freeIn var\n     (case case find_lucky_eq var L of None \\<Rightarrow> None\n           | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n      None \\<Rightarrow>\n        list_disj\n         (list_conj (map (substNegInfinity var) L) #\n          map (elimVar var L []) L)\n      | Some F \\<Rightarrow> F)", "using freeIn_elimVar_eq[of var L \"[]\" a]"], ["proof (prove)\nusing this:\n  freeIn var (elimVar var L [] (Eq a))\n\ngoal (1 subgoal):\n 1. find_lucky_eq var L = Some a \\<Longrightarrow>\n    freeIn var\n     (case case find_lucky_eq var L of None \\<Rightarrow> None\n           | Some p \\<Rightarrow> Some (elimVar var L [] (Eq p)) of\n      None \\<Rightarrow>\n        list_disj\n         (list_conj (map (substNegInfinity var) L) #\n          map (elimVar var L []) L)\n      | Some F \\<Rightarrow> F)", "by(simp del:elimVar.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  freeIn var (gen_qe var L [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_qe_eval'' :\n  assumes \"all_degree_2 var L\"\n  assumes \"length xs' = var\"\n  shows \"(\\<exists>x. (eval (list_conj (map Atom L)) (xs'@x#\\<Gamma>))) = (\\<forall>x.(eval (list_disj\n                          (list_conj (map (substNegInfinity var) L) # map (elimVar var L []) L)) (xs'@x#\\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))", "proof(cases \"convert_atom_list var L (xs'@x#\\<Gamma>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. convert_atom_list var L (xs' @ x # \\<Gamma>) = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))\n 2. \\<And>a.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       Some a \\<Longrightarrow>\n       (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (list_disj\n              (list_conj (map (substNegInfinity var) L) #\n               map (elimVar var L []) L))\n            (xs' @ x # \\<Gamma>))", "case None"], ["proof (state)\nthis:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = None\n\ngoal (2 subgoals):\n 1. convert_atom_list var L (xs' @ x # \\<Gamma>) = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))\n 2. \\<And>a.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       Some a \\<Longrightarrow>\n       (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (list_disj\n              (list_conj (map (substNegInfinity var) L) #\n               map (elimVar var L []) L))\n            (xs' @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))", "using all_degree_2_convert[OF assms(1), of \"(xs' @ x # \\<Gamma>)\"]"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = None\n  \\<exists>L'. convert_atom_list var L (xs' @ x # \\<Gamma>) = Some L'\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n  (\\<forall>x.\n      eval\n       (list_disj\n         (list_conj (map (substNegInfinity var) L) #\n          map (elimVar var L []) L))\n       (xs' @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       Some a \\<Longrightarrow>\n       (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (list_disj\n              (list_conj (map (substNegInfinity var) L) #\n               map (elimVar var L []) L))\n            (xs' @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       Some a \\<Longrightarrow>\n       (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (list_disj\n              (list_conj (map (substNegInfinity var) L) #\n               map (elimVar var L []) L))\n            (xs' @ x # \\<Gamma>))", "case (Some a)"], ["proof (state)\nthis:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       Some a \\<Longrightarrow>\n       (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (list_disj\n              (list_conj (map (substNegInfinity var) L) #\n               map (elimVar var L []) L))\n            (xs' @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = Some a", "have Some : \"\\<And>x. convert_atom_list var L (xs'@x#\\<Gamma>) = Some a\""], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom_list var L (xs' @ x # \\<Gamma>) = Some a", "using convert_atom_list_change[OF assms(2), of L x \\<Gamma>]"], ["proof (prove)\nusing this:\n  convert_atom_list var L (xs' @ x # \\<Gamma>) = Some a\n  convert_atom_list var L (xs' @ x # \\<Gamma>) =\n  convert_atom_list var L (xs' @ ?x' # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x. convert_atom_list var L (xs' @ x # \\<Gamma>) = Some a", "by fastforce"], ["proof (state)\nthis:\n  convert_atom_list var L (xs' @ ?x # \\<Gamma>) = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       convert_atom_list var L (xs' @ x # \\<Gamma>) =\n       Some a \\<Longrightarrow>\n       (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n       (\\<forall>x.\n           eval\n            (list_disj\n              (list_conj (map (substNegInfinity var) L) #\n               map (elimVar var L []) L))\n            (xs' @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        eval\n         (list_disj\n           (list_conj (map (substNegInfinity var) L) #\n            map (elimVar var L []) L))\n         (xs' @ x # \\<Gamma>))", "apply (simp add: eval_list_conj eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs' @ x # \\<Gamma>)))", "using negInf_convert[OF Some assms(2)] elimVar_atom_convert[OF Some Some assms(2)] eval_convert[OF Some assms(2)]"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set L.\n      eval (substNegInfinity var f) (xs' @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) ?x)\n  (\\<exists>f\\<in>set L. eval (elimVar var L [] f) (xs' @ ?x # \\<Gamma>)) =\n  (\\<exists>f\\<in>set a. evalUni (elimVarUni_atom a f) ?x)\n  (\\<forall>f\\<in>set L. aEval f (xs' @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set a. aEvalUni f ?x)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs' @ x # \\<Gamma>)))", "using eval_generalVS''[of a]"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set L.\n      eval (substNegInfinity var f) (xs' @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) ?x)\n  (\\<exists>f\\<in>set L. eval (elimVar var L [] f) (xs' @ ?x # \\<Gamma>)) =\n  (\\<exists>f\\<in>set a. evalUni (elimVarUni_atom a f) ?x)\n  (\\<forall>f\\<in>set L. aEval f (xs' @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set a. aEvalUni f ?x)\n  (\\<exists>x. evalUni (list_conj_Uni (map AtomUni a)) x) =\n  evalUni (generalVS_DNF a) ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs' @ x # \\<Gamma>)))", "unfolding eval_list_conj_Uni generalVS_DNF.simps eval_list_conj_Uni eval_list_disj_Uni eval_append eval_map eval_map_all\n      evalUni.simps"], ["proof (prove)\nusing this:\n  (\\<forall>f\\<in>set L.\n      eval (substNegInfinity var f) (xs' @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set a. evalUni (substNegInfinityUni f) ?x)\n  (\\<exists>f\\<in>set L. eval (elimVar var L [] f) (xs' @ ?x # \\<Gamma>)) =\n  (\\<exists>f\\<in>set a. evalUni (elimVarUni_atom a f) ?x)\n  (\\<forall>f\\<in>set L. aEval f (xs' @ ?x # \\<Gamma>)) =\n  (\\<forall>f\\<in>set a. aEvalUni f ?x)\n  (\\<exists>x. \\<forall>l\\<in>set a. aEvalUni l x) =\n  ((\\<forall>l\\<in>set a. evalUni (substNegInfinityUni l) ?x) \\<or>\n   (\\<exists>l\\<in>set a. evalUni (elimVarUni_atom a l) ?x))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>f\\<in>set L. aEval f (xs' @ x # \\<Gamma>)) =\n    (\\<forall>x.\n        (\\<forall>f\\<in>set L.\n            eval (substNegInfinity var f) (xs' @ x # \\<Gamma>)) \\<or>\n        (\\<exists>f\\<in>set L.\n            eval (elimVar var L [] f) (xs' @ x # \\<Gamma>)))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L)) (xs' @ x # \\<Gamma>)) =\n  (\\<forall>x.\n      eval\n       (list_disj\n         (list_conj (map (substNegInfinity var) L) #\n          map (elimVar var L []) L))\n       (xs' @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}