{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/ExecutiblePolyProps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma of_nat_monomial: \"of_nat p = monomial p 0\"", "lemma of_nat_times_monomial: \"of_nat p * monomial c i = monomial (p*c) i\"", "lemma monomial_adds_nat_iff: \"monomial p i adds c \\<longleftrightarrow> lookup c i \\<ge> p\" for p::\"nat\"", "lemma update_minus_monomial: \"Poly_Mapping.update k i (m - monomial i k) = Poly_Mapping.update k i m\"", "lemma monomials_Var: \"monomials (Var x::'a::zero_neq_one mpoly) = {Poly_Mapping.single x 1}\"", "lemma monomials_Const: \"monomials (Const x) = (if x = 0 then {} else {0})\"", "lemma coeff_eq_zero_iff: \"MPoly_Type.coeff c p = 0 \\<longleftrightarrow> p \\<notin> monomials c\"", "lemma monomials_1[simp]: \"monomials 1 = {0}\"", "lemma monomials_and_monoms: \n  shows \"(k \\<in> monomials m) = (\\<exists> (a::nat). a \\<noteq> 0 \\<and> (monomials (MPoly_Type.monom k a)) \\<subseteq> monomials m)\"", "lemma mult_monomials_dir_one:\n  shows \"monomials (p*q) \\<subseteq> {a+b | a b . a \\<in> monomials p \\<and> b \\<in> monomials q}\"", "lemma monom_eq_zero_iff[simp]: \"MPoly_Type.monom a b = 0 \\<longleftrightarrow> b = 0\"", "lemma update_eq_plus_monomial:\n  \"v \\<ge> lookup m k \\<Longrightarrow> Poly_Mapping.update k v m = m + monomial (v - lookup m k) k\"\n  for v n::nat", "lemma coeff_monom_mult':\n  \"MPoly_Type.coeff ((MPoly_Type.monom m' a) * q) (m'm)  = a * MPoly_Type.coeff q (m'm - m')\"\n  if *: \"m'm = m' + (m'm - m')\"", "lemma monomials_zero[simp]: \"monomials 0 = {}\"", "lemma in_monomials_iff: \"x \\<in> monomials m \\<longleftrightarrow> MPoly_Type.coeff m x \\<noteq> 0\"", "lemma monomials_monom_mult: \"monomials (MPoly_Type.monom mon a * q) = (if a = 0 then {} else (+) mon ` monomials q)\"\n  for q::\"'a::semiring_no_zero_divisors mpoly\"", "lemma add_zero : \"P + Const 0 = P\"", "lemma add_zero_example : \"((Var 0)^2 - (Const 1)) + Const 0 = ((Var 0)^2 - (Const 1))\"", "lemma mult_zero_left : \"Const 0 * P = Const 0\"", "lemma mult_zero_right : \"P * Const 0 = Const 0\"", "lemma mult_one_left : \"Const 1 * (P :: real mpoly) = P\"", "lemma mult_one_right : \"(P::real mpoly) * Const 1 = P\"", "lemma coeff_zero[simp]: \"MPoly_Type.coeff 0 x = 0\"", "lemma coeff_sum: \"MPoly_Type.coeff (sum f S) x = sum (\\<lambda>i. MPoly_Type.coeff (f i) x) S\"", "lemma coeff_mult_Var: \"MPoly_Type.coeff (x * Var i ^ p) c = (MPoly_Type.coeff x (c - monomial p i) when lookup c i \\<ge> p)\"", "lemma lookup_update_self[simp]: \"Poly_Mapping.update i (lookup m i) m = m\"", "lemma coeff_Const: \"MPoly_Type.coeff (Const p) m = (p when m = 0)\"", "lemma coeff_Var: \"MPoly_Type.coeff (Var p) m = (1 when m = monomial 1 p)\"", "lemma update_0_0[simp]: \"Poly_Mapping.update x 0 0 = 0\"", "lemma mpoly_eq_iff: \"p = q \\<longleftrightarrow> (\\<forall>m. MPoly_Type.coeff p m = MPoly_Type.coeff q m)\"", "lemma power_both_sides :\n  assumes Ah : \"(A::real) \\<ge>0\"\n  assumes Bh : \"(B::real) \\<ge>0\"\n  shows \"(A\\<le>B) = (A^2\\<le>B^2)\"", "lemma in_list_induct_helper: \n  assumes \"set(xs)\\<subseteq>X\"\n  assumes  \"P []\"\n  assumes \"(\\<And>x. x\\<in>X \\<Longrightarrow> ( \\<And>xs. P xs \\<Longrightarrow> P (x # xs)))\"\n  shows \"P xs\"", "theorem in_list_induct [case_names Nil Cons]: \n  assumes  \"P []\"\n  assumes \"(\\<And>x. x\\<in>set(xs) \\<Longrightarrow> ( \\<And>xs. P xs \\<Longrightarrow> P (x # xs)))\"\n  shows \"P xs\"", "lemma inKeys_inVars : \"a\\<noteq>0 \\<Longrightarrow> x \\<in> keys m \\<Longrightarrow> x \\<in> vars(MPoly_Type.monom m a)\"", "lemma notInKeys_notInVars : \"x \\<notin> keys m \\<Longrightarrow> x \\<notin> vars(MPoly_Type.monom m a)\"", "lemma lookupNotIn : \"x \\<notin> keys m \\<Longrightarrow> lookup m x = 0\"", "lemma degree_le_iff: \"MPoly_Type.degree p x \\<le> k \\<longleftrightarrow> (\\<forall>m\\<in>monomials p. lookup m x \\<le> k)\"", "lemma degree_less_iff: \"MPoly_Type.degree p x < k \\<longleftrightarrow> (k>0 \\<and> (\\<forall>m\\<in>monomials p. lookup m x < k))\"", "lemma degree_ge_iff: \"k > 0 \\<Longrightarrow> MPoly_Type.degree p x \\<ge> k \\<longleftrightarrow> (\\<exists>m\\<in>monomials p. lookup m x \\<ge> k)\"", "lemma degree_greater_iff: \"MPoly_Type.degree p x > k \\<longleftrightarrow> (\\<exists>m\\<in>monomials p. lookup m x > k)\"", "lemma degree_eq_iff:\n  \"MPoly_Type.degree p x = k \\<longleftrightarrow> (if k = 0\n    then (\\<forall>m\\<in>monomials p. lookup m x = 0)\n    else (\\<exists>m\\<in>monomials p. lookup m x = k) \\<and> (\\<forall>m\\<in>monomials p. lookup m x \\<le> k))\"", "lemma lookup_eq_and_update_lemma: \"lookup m var = deg \\<and> Poly_Mapping.update var 0 m = x \\<longleftrightarrow>\n  m = Poly_Mapping.update var deg x \\<and> lookup x var = 0\"", "lemma degree_const : \"MPoly_Type.degree (Const (z::real)) (x::nat) = 0\"", "lemma degree_one : \"MPoly_Type.degree (Var x :: real mpoly) x = 1\"", "lemma coeff_isolate_variable_sparse:\n  \"MPoly_Type.coeff (isolate_variable_sparse p var deg) x =\n  (if lookup x var = 0\n  then MPoly_Type.coeff p (Poly_Mapping.update var deg x)\n  else 0)\"", "lemma isovarspar_sum: \n  \"isolate_variable_sparse (p+q) var deg = \n  isolate_variable_sparse (p) var deg\n  + isolate_variable_sparse (q) var deg\"", "lemma isolate_zero[simp]: \"isolate_variable_sparse 0 var n = 0\"", "lemma coeff_isolate_variable_sparse_minus_monomial:\n  \"MPoly_Type.coeff (isolate_variable_sparse mp var i) (m - monomial i var) =\n  (if lookup m var \\<le> i then MPoly_Type.coeff mp (Poly_Mapping.update var i m) else 0)\"", "lemma sum_over_zero: \"(mp::real mpoly) = (\\<Sum>i::nat \\<le>MPoly_Type.degree mp x. isolate_variable_sparse mp x i * Var x^i)\"", "lemma const_lookup_zero : \"isolate_variable_sparse (Const p ::real mpoly) (x::nat) (0::nat) = Const p\"", "lemma const_lookup_suc : \"isolate_variable_sparse (Const p :: real mpoly) x (Suc i) = 0\"", "lemma isovar_greater_degree : \"\\<forall>i > MPoly_Type.degree p var. isolate_variable_sparse p var i = 0\"", "lemma isolate_var_0 : \"isolate_variable_sparse (Var x::real mpoly) x 0 = 0\"", "lemma isolate_var_one : \"isolate_variable_sparse (Var x :: real mpoly) x 1 = 1\"", "lemma isovarspase_monom :\n  assumes notInKeys : \"x \\<notin> keys m\"\n  assumes notZero : \"a \\<noteq> 0\"\n  shows \"isolate_variable_sparse (MPoly_Type.monom m a) x 0 = (MPoly_Type.monom m a :: real mpoly)\"", "lemma isolate_variable_spase_zero : \"lookup m x = 0 \\<Longrightarrow>\n    insertion (nth L) ((MPoly_Type.monom m a)::real mpoly) = 0 \\<Longrightarrow>\n    a \\<noteq> 0 \\<Longrightarrow> insertion (nth L) (isolate_variable_sparse (MPoly_Type.monom m a) x 0) = 0\"", "lemma isovarsparNotIn : \"x \\<notin> vars (p::real mpoly) \\<Longrightarrow> isolate_variable_sparse p x 0 = p\"", "lemma degree0isovarspar :\n  assumes deg0 : \"MPoly_Type.degree (p::real mpoly) x = 0\"\n  shows \"isolate_variable_sparse p x 0 = p\"", "lemma summation_normalized :\n  assumes nonzero : \"(B ::real) \\<noteq>0\"\n  shows \"(\\<Sum>i = 0..<((n::nat)+1). (f i :: real) * B ^ (n - i)) = (\\<Sum>i = 0..<(n+1). (f i) / (B ^ i)) * (B^n)\"", "lemma normalize_summation :\n  assumes nonzero : \"(B::real)\\<noteq>0\"\n  shows \"(\\<Sum>i = 0..<n+1. f i * B ^ (n - i))= 0\n          \\<longleftrightarrow>\n  (\\<Sum>i = 0..<(n::nat)+1. (f i::real) / (B ^ i)) = 0\"", "lemma normalize_summation_less :\n  assumes nonzero : \"(B::real)\\<noteq>0\"\n  shows \"(\\<Sum>i = 0..<(n+1). (f i) * B ^ (n - i)) * B ^ (n mod 2) < 0\n          \\<longleftrightarrow>\n  (\\<Sum>i = 0..<((n::nat)+1). (f i::real) / (B ^ i)) < 0\"", "lemma not_in_isovarspar : \"isolate_variable_sparse (p::real mpoly) var x = (q::real mpoly) \\<Longrightarrow> var\\<notin>(vars q)\"", "lemma not_in_add : \"var\\<notin>(vars (p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (q::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (p+q))\"", "lemma not_in_mult : \"var\\<notin>(vars (p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (q::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (p*q))\"", "lemma not_in_neg : \"var\\<notin>(vars(p::real mpoly)) \\<longleftrightarrow> var\\<notin>(vars(-p))\"", "lemma not_in_sub : \"var\\<notin>(vars (p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (q::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (p-q))\"", "lemma not_in_pow : \"var\\<notin>(vars(p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars(p^i))\"", "lemma not_in_sum_var: \"(\\<forall>i. var\\<notin>(vars(f(i)::real mpoly))) \\<Longrightarrow> var\\<notin>(vars(\\<Sum>i\\<in>{0..<(n::nat)}.f(i)))\"", "lemma not_in_sum : \"(\\<forall>i. var\\<notin>(vars(f(i)::real mpoly))) \\<Longrightarrow> \\<forall>(n::nat). var\\<notin>(vars(\\<Sum>i\\<in>{0..<n}.f(i)))\"", "lemma not_contains_insertion_helper : \n  \"\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x \\<Longrightarrow>\n         (\\<And>k f. (k \\<notin> keys f) = (lookup f k = 0)) \\<Longrightarrow>\n         lookup (mapping_of p) a = 0 \\<or>\n         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa else 0) ^ lookup a aa) =\n         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa else 0) ^ lookup a aa)\"", "lemma not_contains_insertion : \n  assumes notIn : \"var \\<notin> vars (p:: real mpoly)\"\n  assumes exists : \"insertion (nth_default 0 (list_update L var x)) p = val\"\n  shows \"insertion (nth_default 0 (list_update L var y)) p = val\"", "lemma insertion_sum_var : \"((insertion f (\\<Sum>i\\<in>{0..<(n::nat)}.g(i))) = (\\<Sum>i\\<in>{0..<n}. insertion f (g i)))\"", "lemma insertion_sum : \"\\<forall>(n::nat). ((insertion f (\\<Sum>i\\<in>{0..<n}.g(i))) = (\\<Sum>i\\<in>{0..<n}. insertion f (g i)))\"", "lemma insertion_sum' : \"\\<And>(n::nat). ((insertion f (\\<Sum>i\\<le>n. g(i))) = (\\<Sum>i\\<le>n. insertion f (g i)))\"", "lemma insertion_pow : \"insertion f (p^i) = (insertion f p)^i\"", "lemma insertion_neg : \"insertion f (-p) = -insertion f p\"", "lemma insertion_var : \n  \"length L > var \\<Longrightarrow> insertion (nth_default 0 (list_update L var x)) (Var var) = x\"", "lemma insertion_var_zero : \"insertion (nth_default 0 (x#xs)) (Var 0) = x\"", "lemma notIn_insertion_sub : \"x\\<notin>vars(p::real mpoly) \\<Longrightarrow> x\\<notin>vars(q::real mpoly)\n                             \\<Longrightarrow> insertion f (p-q) = insertion f p - insertion f q\"", "lemma insertion_sub : \"insertion f (A-B :: real mpoly) = insertion f A - insertion f B\"", "lemma insertion_four : \"insertion ((nth_default 0) xs) 4 = 4\"", "lemma insertion_add_ind_basecase:\n  \"insertion (nth (list_update L var x)) ((\\<Sum>i::nat \\<le> 0. isolate_variable_sparse p var i * (Var var)^i))\n  = (\\<Sum>i = 0..<(0+1).  insertion (nth (list_update L var x)) (isolate_variable_sparse p var i * (Var var)^i))\"", "lemma insertion_add_ind:\n  \"insertion (nth_default 0 (list_update L var x)) ((\\<Sum>i::nat \\<le> d. isolate_variable_sparse p var i * (Var var)^i))\n  = (\\<Sum>i = 0..<(d+1).  insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse p var i * (Var var)^i))\"", "lemma sum_over_degree_insertion :\n  assumes lLength : \"length L > var\"\n  assumes deg : \"MPoly_Type.degree (p::real mpoly) var = d\"\n  shows \"(\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse p var i) * (x^i))\n          = insertion (nth_default 0 (list_update L var x)) p\"", "lemma insertion_isovarspars_free :\n  \"insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse (p::real mpoly) var (i::nat))\n  =insertion (nth_default 0 (list_update L var y)) (isolate_variable_sparse (p::real mpoly) var (i::nat))\"", "lemma insertion_zero : \"insertion f (Const 0 ::real mpoly) = 0\"", "lemma insertion_one : \"insertion f (Const 1 ::real mpoly) = 1\"", "lemma insertion_const : \"insertion f (Const c::real mpoly) = (c::real)\"", "lemma degree_add_leq : \n  assumes h1 : \"MPoly_Type.degree a var \\<le> x\"\n  assumes h2 : \"MPoly_Type.degree b var \\<le> x\"\n  shows \"MPoly_Type.degree (a+b) var \\<le> x\"", "lemma degree_add_less : \n  assumes h1 : \"MPoly_Type.degree a var < x\"\n  assumes h2 : \"MPoly_Type.degree b var < x\"\n  shows \"MPoly_Type.degree (a+b) var < x\"", "lemma degree_sum : \"(\\<forall>i\\<in>{0..n::nat}. MPoly_Type.degree (f i :: real mpoly) var \\<le> x) \\<Longrightarrow> (MPoly_Type.degree (\\<Sum>x\\<in>{0..n}. f x) var) \\<le> x\"", "lemma degree_sum_less : \"(\\<forall>i\\<in>{0..n::nat}. MPoly_Type.degree (f i :: real mpoly) var < x) \\<Longrightarrow> (MPoly_Type.degree (\\<Sum>x\\<in>{0..n}. f x) var) < x\"", "lemma varNotIn_degree : \n  assumes \"var \\<notin> vars p\"\n  shows \"MPoly_Type.degree p var = 0\"", "lemma degree_mult_leq : \n  assumes pnonzero: \"(p::real mpoly)\\<noteq>0\"\n  assumes qnonzero: \"(q::real mpoly)\\<noteq>0\"\n  shows \"MPoly_Type.degree ((p::real mpoly) * (q::real mpoly)) var \\<le> (MPoly_Type.degree p var) + (MPoly_Type.degree q var)\"", "lemma degree_exists_monom: \n  assumes \"p\\<noteq>0\"\n  shows  \"\\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\"", "lemma degree_not_exists_monom: \n  assumes \"p\\<noteq>0\"\n  shows  \"\\<not> (\\<exists> m\\<in>monomials p. lookup m var > MPoly_Type.degree p var)\"", "lemma degree_monom: \"MPoly_Type.degree (MPoly_Type.monom x y) v = (if y = 0 then 0 else lookup x v)\"", "lemma degree_plus_disjoint:\n  \"MPoly_Type.degree (p + MPoly_Type.monom m c) v = max (MPoly_Type.degree p v) (MPoly_Type.degree (MPoly_Type.monom m c) v)\"\n  if \"m \\<notin> monomials p\"\n  for p::\"real mpoly\"", "lemma isolate_variable_sparse_ne_zeroD:\n  \"isolate_variable_sparse mp v x \\<noteq> 0 \\<Longrightarrow> x \\<le> MPoly_Type.degree mp v\"", "lemma degree_eq_0_mpoly_to_nested_polyI:\n  \"mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> MPoly_Type.degree mp v = 0\"", "lemma coeff_eq_zero_mpoly_to_nested_polyD: \"mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> MPoly_Type.coeff mp 0 = 0\"", "lemma mpoly_to_nested_poly_eq_zero_iff[simp]:\n  \"mpoly_to_nested_poly mp v = 0 \\<longleftrightarrow> mp = 0\"", "lemma isolate_variable_sparse_degree_eq_zero_iff: \"isolate_variable_sparse p v (MPoly_Type.degree p v) = 0 \\<longleftrightarrow> p = 0\"", "lemma degree_eq_univariate_degree: \"MPoly_Type.degree p v =\n    (if p = 0 then 0 else Polynomial.degree (mpoly_to_nested_poly p v))\"", "lemma compute_mpoly_to_nested_poly[code]:\n  \"coeffs (mpoly_to_nested_poly mp v) =\n    (if mp = 0 then []\n    else map (isolate_variable_sparse mp v) [0..<Suc(MPoly_Type.degree mp v)])\"", "lemma isolate_variable_sparse_monom: \"isolate_variable_sparse (MPoly_Type.monom m a) v i =\n  (if a = 0 \\<or> lookup m v \\<noteq> i then 0 else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)\"", "lemma isolate_variable_sparse_monom_mult:\n  \"isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n    (if n \\<ge> lookup m v\n    then MPoly_Type.monom (Poly_Mapping.update v 0 m) a * isolate_variable_sparse q v (n - lookup m v)\n    else 0)\"\n  for q::\"'a::semiring_no_zero_divisors mpoly\"", "lemma isolate_variable_sparse_mult:\n  \"isolate_variable_sparse (p * q) v n = (\\<Sum>i\\<le>n. isolate_variable_sparse p v i * isolate_variable_sparse q v (n - i))\"\n  for p q::\"'a::semiring_no_zero_divisors mpoly\"", "lemma var_not_in_Const : \"var\\<notin>vars (Const x :: real mpoly)\"", "lemma mpoly_to_nested_poly_mult:\n  \"mpoly_to_nested_poly (p * q) v = mpoly_to_nested_poly p v * mpoly_to_nested_poly q v\"\n  for p q::\"'a::{comm_semiring_0, semiring_no_zero_divisors} mpoly\"", "lemma get_if_const_insertion : \n  assumes \"get_if_const (p::real mpoly) = Some r\"\n  shows \"insertion f p = r\"", "lemma degree_mult:\n  fixes p q::\"'a::{comm_semiring_0, ring_1_no_zero_divisors} mpoly\"\n  assumes \"p \\<noteq> 0\"\n  assumes \"q \\<noteq> 0\"\n  shows \"MPoly_Type.degree (p * q) v = MPoly_Type.degree p v + MPoly_Type.degree q v\"", "lemma degree_eq:\n  assumes \"(p::real mpoly) = (q:: real mpoly)\"\n  shows \"MPoly_Type.degree p x = MPoly_Type.degree q x\"", "lemma degree_var_i : \"MPoly_Type.degree (((Var x)^i:: real mpoly)) x = i\"", "lemma degree_less_sum: \n  assumes \"MPoly_Type.degree (p::real mpoly) var = n\"\n  assumes \"MPoly_Type.degree (q::real mpoly) var = m\"\n  assumes \"m < n\"\n  shows \"MPoly_Type.degree (p + q) var = n\"", "lemma degree_less_sum': \n  assumes \"MPoly_Type.degree (p::real mpoly) var = n\"\n  assumes \"MPoly_Type.degree (q::real mpoly) var = m\"\n  assumes \"n < m\"\n  shows \"MPoly_Type.degree (p + q) var = m\"", "lemma nonzero_const_is_nonzero: \n  assumes \"(k::real) \\<noteq> 0\"\n  shows \"((Const k)::real mpoly) \\<noteq> 0\"", "lemma degree_derivative : \n  assumes \"MPoly_Type.degree p x > 0\"\n  shows \"MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1\"", "lemma express_poly :\n  assumes h : \"MPoly_Type.degree (p::real mpoly) var = 1 \\<or> MPoly_Type.degree p var = 2\"\n  shows \"p =\n     (isolate_variable_sparse p var 2)*(Var var)^2\n    +(isolate_variable_sparse p var 1)*(Var var)\n    +(isolate_variable_sparse p var 0)\"", "lemma degree_isovarspar : \"MPoly_Type.degree (isolate_variable_sparse (p::real mpoly) x i) x = 0\""], "translations": [["", "lemma of_nat_monomial: \"of_nat p = monomial p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p = monomial p (0::'a)", "by (auto simp: poly_mapping_eq_iff lookup_of_nat fun_eq_iff lookup_single)"], ["", "lemma of_nat_times_monomial: \"of_nat p * monomial c i = monomial (p*c) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p * monomial c i = monomial (p * c) i", "by (auto simp: poly_mapping_eq_iff prod_fun_def fun_eq_iff of_nat_monomial\n      lookup_single mult_single)"], ["", "lemma monomial_adds_nat_iff: \"monomial p i adds c \\<longleftrightarrow> lookup c i \\<ge> p\" for p::\"nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial p i adds c) = (p \\<le> lookup c i)", "apply (auto simp: adds_def lookup_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> lookup c i \\<Longrightarrow> \\<exists>k. c = monomial p i + k", "by (metis add.left_commute nat_le_iff_add remove_key_sum single_add)"], ["", "lemma update_minus_monomial: \"Poly_Mapping.update k i (m - monomial i k) = Poly_Mapping.update k i m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.update k i (m - monomial i k) = Poly_Mapping.update k i m", "by (auto simp: poly_mapping_eq_iff lookup_update update.rep_eq fun_eq_iff lookup_minus\n      lookup_single)"], ["", "lemma monomials_Var: \"monomials (Var x::'a::zero_neq_one mpoly) = {Poly_Mapping.single x 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (Var x) = {monomial 1 x}", "by transfer (auto simp: Var\\<^sub>0_def)"], ["", "lemma monomials_Const: \"monomials (Const x) = (if x = 0 then {} else {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (Const x) = (if x = (0::'a) then {} else {0})", "by transfer' (auto simp: Const\\<^sub>0_def)"], ["", "lemma coeff_eq_zero_iff: \"MPoly_Type.coeff c p = 0 \\<longleftrightarrow> p \\<notin> monomials c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MPoly_Type.coeff c p = (0::'a)) = (p \\<notin> monomials c)", "by transfer (simp add: not_in_keys_iff_lookup_eq_zero)"], ["", "lemma monomials_1[simp]: \"monomials 1 = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials 1 = {0}", "by transfer auto"], ["", "lemma monomials_and_monoms: \n  shows \"(k \\<in> monomials m) = (\\<exists> (a::nat). a \\<noteq> 0 \\<and> (monomials (MPoly_Type.monom k a)) \\<subseteq> monomials m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> monomials m) =\n    (\\<exists>a.\n        a \\<noteq> 0 \\<and>\n        monomials (MPoly_Type.monom k a) \\<subseteq> monomials m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (k \\<in> monomials m) =\n    (\\<exists>a.\n        a \\<noteq> 0 \\<and>\n        monomials (MPoly_Type.monom k a) \\<subseteq> monomials m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> monomials m) =\n    (\\<exists>a.\n        a \\<noteq> 0 \\<and>\n        monomials (MPoly_Type.monom k a) \\<subseteq> monomials m)", "using monomials_monom"], ["proof (prove)\nusing this:\n  monomials (MPoly_Type.monom ?m ?a) = (if ?a = (0::?'a) then {} else {?m})\n\ngoal (1 subgoal):\n 1. (k \\<in> monomials m) =\n    (\\<exists>a.\n        a \\<noteq> 0 \\<and>\n        monomials (MPoly_Type.monom k a) \\<subseteq> monomials m)", "by auto"], ["proof (state)\nthis:\n  (k \\<in> monomials m) =\n  (\\<exists>a.\n      a \\<noteq> 0 \\<and>\n      monomials (MPoly_Type.monom k a) \\<subseteq> monomials m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_monomials_dir_one:\n  shows \"monomials (p*q) \\<subseteq> {a+b | a b . a \\<in> monomials p \\<and> b \\<in> monomials q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (p * q)\n    \\<subseteq> {a + b |a b. a \\<in> monomials p \\<and> b \\<in> monomials q}", "using monomials_and_monoms mult_monom"], ["proof (prove)\nusing this:\n  (?k \\<in> monomials ?m) =\n  (\\<exists>a.\n      a \\<noteq> 0 \\<and>\n      monomials (MPoly_Type.monom ?k a) \\<subseteq> monomials ?m)\n  Polynomial.monom ?a ?m * Polynomial.monom ?b ?n =\n  Polynomial.monom (?a * ?b) (?m + ?n)\n\ngoal (1 subgoal):\n 1. monomials (p * q)\n    \\<subseteq> {a + b |a b. a \\<in> monomials p \\<and> b \\<in> monomials q}", "by (simp add: keys_mult monomials.rep_eq times_mpoly.rep_eq)"], ["", "lemma monom_eq_zero_iff[simp]: \"MPoly_Type.monom a b = 0 \\<longleftrightarrow> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MPoly_Type.monom a b = 0) = (b = (0::'a))", "by (metis MPolyExtension.coeff_monom MPolyExtension.monom_zero)"], ["", "lemma update_eq_plus_monomial:\n  \"v \\<ge> lookup m k \\<Longrightarrow> Poly_Mapping.update k v m = m + monomial (v - lookup m k) k\"\n  for v n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m k \\<le> v \\<Longrightarrow>\n    Poly_Mapping.update k v m = m + monomial (v - lookup m k) k", "by transfer auto"], ["", "lemma coeff_monom_mult':\n  \"MPoly_Type.coeff ((MPoly_Type.monom m' a) * q) (m'm)  = a * MPoly_Type.coeff q (m'm - m')\"\n  if *: \"m'm = m' + (m'm - m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom m' a * q) m'm =\n    a * MPoly_Type.coeff q (m'm - m')", "by (subst *) (rule More_MPoly_Type.coeff_monom_mult)"], ["", "lemma monomials_zero[simp]: \"monomials 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials 0 = {}", "by transfer auto"], ["", "lemma in_monomials_iff: \"x \\<in> monomials m \\<longleftrightarrow> MPoly_Type.coeff m x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> monomials m) = (MPoly_Type.coeff m x \\<noteq> (0::'a))", "using coeff_eq_zero_iff[of m x]"], ["proof (prove)\nusing this:\n  (MPoly_Type.coeff m x = (0::'a)) = (x \\<notin> monomials m)\n\ngoal (1 subgoal):\n 1. (x \\<in> monomials m) = (MPoly_Type.coeff m x \\<noteq> (0::'a))", "by auto"], ["", "lemma monomials_monom_mult: \"monomials (MPoly_Type.monom mon a * q) = (if a = 0 then {} else (+) mon ` monomials q)\"\n  for q::\"'a::semiring_no_zero_divisors mpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (MPoly_Type.monom mon a * q) =\n    (if a = (0::'a) then {} else (+) mon ` monomials q)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a \\<noteq> (0::'a);\n        x \\<in> monomials (MPoly_Type.monom mon a * q)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (+) mon ` monomials q\n 2. \\<And>xa.\n       \\<lbrakk>a \\<noteq> (0::'a); xa \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> mon + xa\n                         \\<in> monomials (MPoly_Type.monom mon a * q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a);\n     x_ \\<in> monomials (MPoly_Type.monom mon a * q)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> (+) mon ` monomials q", "by transfer' (auto elim!: in_keys_timesE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>a \\<noteq> (0::'a); xa \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> mon + xa\n                         \\<in> monomials (MPoly_Type.monom mon a * q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a); xa_ \\<in> monomials q\\<rbrakk>\n    \\<Longrightarrow> mon + xa_ \\<in> monomials (MPoly_Type.monom mon a * q)", "by (simp add: in_monomials_iff More_MPoly_Type.coeff_monom_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Simplification Lemmas for Const 0 and Const 1\""], ["", "lemma add_zero : \"P + Const 0 = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P + Const (0::'a) = P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P + Const (0::'a) = P", "have h:\"P + 0 = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P + 0 = P", "using add_0_right"], ["proof (prove)\nusing this:\n  ?a + (0::?'a) = ?a\n\ngoal (1 subgoal):\n 1. P + 0 = P", "by auto"], ["proof (state)\nthis:\n  P + 0 = P\n\ngoal (1 subgoal):\n 1. P + Const (0::'a) = P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P + Const (0::'a) = P", "unfolding Const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P + map_fun id MPoly Const\\<^sub>0 (0::'a) = P", "using h"], ["proof (prove)\nusing this:\n  P + 0 = P\n\ngoal (1 subgoal):\n 1. P + map_fun id MPoly Const\\<^sub>0 (0::'a) = P", "by (simp add: Const\\<^sub>0_zero zero_mpoly.abs_eq)"], ["proof (state)\nthis:\n  P + Const (0::'a) = P\n\ngoal:\nNo subgoals!", "qed"], ["", "(* example *)"], ["", "lemma add_zero_example : \"((Var 0)^2 - (Const 1)) + Const 0 = ((Var 0)^2 - (Const 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var 0)\\<^sup>2 - Const (1::'a) + Const (0::'a) =\n    (Var 0)\\<^sup>2 - Const (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Var 0)\\<^sup>2 - Const (1::'a) + Const (0::'a) =\n    (Var 0)\\<^sup>2 - Const (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Var 0)\\<^sup>2 - Const (1::'a) + Const (0::'a) =\n    (Var 0)\\<^sup>2 - Const (1::'a)", "by (simp add : add_zero)"], ["proof (state)\nthis:\n  (Var 0)\\<^sup>2 - Const (1::'a) + Const (0::'a) =\n  (Var 0)\\<^sup>2 - Const (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_zero_left : \"Const 0 * P = Const 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (0::'a) * P = Const (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Const (0::'a) * P = Const (0::'a)", "have h:\"0*P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * P = 0", "by simp"], ["proof (state)\nthis:\n  0 * P = 0\n\ngoal (1 subgoal):\n 1. Const (0::'a) * P = Const (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (0::'a) * P = Const (0::'a)", "unfolding Const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id MPoly Const\\<^sub>0 (0::'a) * P =\n    map_fun id MPoly Const\\<^sub>0 (0::'a)", "using h"], ["proof (prove)\nusing this:\n  0 * P = 0\n\ngoal (1 subgoal):\n 1. map_fun id MPoly Const\\<^sub>0 (0::'a) * P =\n    map_fun id MPoly Const\\<^sub>0 (0::'a)", "by (simp add: Const\\<^sub>0_zero zero_mpoly_def)"], ["proof (state)\nthis:\n  Const (0::'a) * P = Const (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_zero_right : \"P * Const 0 = Const 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Const (0::'a) = Const (0::'a)", "by (metis mult_zero_left mult_zero_right)"], ["", "lemma mult_one_left : \"Const 1 * (P :: real mpoly) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const 1 * P = P", "by (simp add: Const.abs_eq Const\\<^sub>0_one one_mpoly_def)"], ["", "lemma mult_one_right : \"(P::real mpoly) * Const 1 = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Const 1 = P", "by (simp add: Const.abs_eq Const\\<^sub>0_one one_mpoly_def)"], ["", "subsection \"Coefficient Lemmas\""], ["", "lemma coeff_zero[simp]: \"MPoly_Type.coeff 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff 0 x = (0::'a)", "by transfer auto"], ["", "lemma coeff_sum: \"MPoly_Type.coeff (sum f S) x = sum (\\<lambda>i. MPoly_Type.coeff (f i) x) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sum f S) x = (\\<Sum>i\\<in>S. MPoly_Type.coeff (f i) x)", "apply (induction S rule: infinite_finite_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       MPoly_Type.coeff (sum f A) x =\n       (\\<Sum>i\\<in>A. MPoly_Type.coeff (f i) x)\n 2. MPoly_Type.coeff (sum f {}) x =\n    (\\<Sum>i\\<in>{}. MPoly_Type.coeff (f i) x)\n 3. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        MPoly_Type.coeff (sum f F) x =\n        (\\<Sum>i\\<in>F. MPoly_Type.coeff (f i) x)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff (sum f (insert xa F)) x =\n                         (\\<Sum>i\\<in>insert xa F. MPoly_Type.coeff (f i) x)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        MPoly_Type.coeff (sum f F) x =\n        (\\<Sum>i\\<in>F. MPoly_Type.coeff (f i) x)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff (f xa + sum f F) x =\n                         MPoly_Type.coeff (f xa) x +\n                         (\\<Sum>i\\<in>F. MPoly_Type.coeff (f i) x)", "by (metis More_MPoly_Type.coeff_add)"], ["", "lemma coeff_mult_Var: \"MPoly_Type.coeff (x * Var i ^ p) c = (MPoly_Type.coeff x (c - monomial p i) when lookup c i \\<ge> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (x * Var i ^ p) c =\n    (MPoly_Type.coeff x (c - monomial p i) when p \\<le> lookup c i)", "by transfer'\n    (auto simp: Var\\<^sub>0_def pprod.monomial_power lookup_times_monomial_right\n      of_nat_times_monomial monomial_adds_nat_iff)"], ["", "lemma lookup_update_self[simp]: \"Poly_Mapping.update i (lookup m i) m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.update i (lookup m i) m = m", "by (auto simp: lookup_update intro!: poly_mapping_eqI)"], ["", "lemma coeff_Const: \"MPoly_Type.coeff (Const p) m = (p when m = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Const p) m = (p when m = 0)", "by transfer' (auto simp: Const\\<^sub>0_def lookup_single)"], ["", "lemma coeff_Var: \"MPoly_Type.coeff (Var p) m = (1 when m = monomial 1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var p) m = ((1::'a) when m = monomial 1 p)", "by transfer' (auto simp: Var\\<^sub>0_def lookup_single when_def)"], ["", "subsection \"Miscellaneous\""], ["", "lemma update_0_0[simp]: \"Poly_Mapping.update x 0 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.update x (0::'b) 0 = 0", "by (metis lookup_update_self lookup_zero)"], ["", "lemma mpoly_eq_iff: \"p = q \\<longleftrightarrow> (\\<forall>m. MPoly_Type.coeff p m = MPoly_Type.coeff q m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = q) = (\\<forall>m. MPoly_Type.coeff p m = MPoly_Type.coeff q m)", "by transfer (auto simp: poly_mapping_eqI)"], ["", "lemma power_both_sides :\n  assumes Ah : \"(A::real) \\<ge>0\"\n  assumes Bh : \"(B::real) \\<ge>0\"\n  shows \"(A\\<le>B) = (A^2\\<le>B^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<le> B) = (A\\<^sup>2 \\<le> B\\<^sup>2)", "using Ah Bh"], ["proof (prove)\nusing this:\n  0 \\<le> A\n  0 \\<le> B\n\ngoal (1 subgoal):\n 1. (A \\<le> B) = (A\\<^sup>2 \\<le> B\\<^sup>2)", "by (meson power2_le_imp_le power_mono)"], ["", "lemma in_list_induct_helper: \n  assumes \"set(xs)\\<subseteq>X\"\n  assumes  \"P []\"\n  assumes \"(\\<And>x. x\\<in>X \\<Longrightarrow> ( \\<And>xs. P xs \\<Longrightarrow> P (x # xs)))\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms(1)"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X\n\ngoal (1 subgoal):\n 1. P xs", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> X \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>set xs \\<subseteq> X \\<Longrightarrow> P xs;\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> X\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> X \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>set xs \\<subseteq> X \\<Longrightarrow> P xs;\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> X\n\ngoal (1 subgoal):\n 1. P []", "using assms"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> X\n  set xs \\<subseteq> X\n  P []\n  \\<lbrakk>?x \\<in> X; P ?xs\\<rbrakk> \\<Longrightarrow> P (?x # ?xs)\n\ngoal (1 subgoal):\n 1. P []", "by auto"], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set xs \\<subseteq> X \\<Longrightarrow> P xs;\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set xs \\<subseteq> X \\<Longrightarrow> P xs;\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  set xs \\<subseteq> X \\<Longrightarrow> P xs\n  set (a # xs) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set xs \\<subseteq> X \\<Longrightarrow> P xs;\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "then"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> X \\<Longrightarrow> P xs\n  set (a # xs) \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X \\<Longrightarrow> P xs\n  set (a # xs) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. P (a # xs)", "using assms(3)"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X \\<Longrightarrow> P xs\n  set (a # xs) \\<subseteq> X\n  \\<lbrakk>?x \\<in> X; P ?xs\\<rbrakk> \\<Longrightarrow> P (?x # ?xs)\n\ngoal (1 subgoal):\n 1. P (a # xs)", "by auto"], ["proof (state)\nthis:\n  P (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem in_list_induct [case_names Nil Cons]: \n  assumes  \"P []\"\n  assumes \"(\\<And>x. x\\<in>set(xs) \\<Longrightarrow> ( \\<And>xs. P xs \\<Longrightarrow> P (x # xs)))\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using in_list_induct_helper[of xs \"set(xs)\" P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> set xs; P [];\n   \\<And>x xsa.\n      \\<lbrakk>x \\<in> set xs; P xsa\\<rbrakk>\n      \\<Longrightarrow> P (x # xsa)\\<rbrakk>\n  \\<Longrightarrow> P xs\n\ngoal (1 subgoal):\n 1. P xs", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> set xs; P [];\n   \\<And>x xsa.\n      \\<lbrakk>x \\<in> set xs; P xsa\\<rbrakk>\n      \\<Longrightarrow> P (x # xsa)\\<rbrakk>\n  \\<Longrightarrow> P xs\n  P []\n  \\<lbrakk>?x \\<in> set xs; P ?xs\\<rbrakk> \\<Longrightarrow> P (?x # ?xs)\n\ngoal (1 subgoal):\n 1. P xs", "by auto"], ["", "subsubsection \"Keys and vars\""], ["", "lemma inKeys_inVars : \"a\\<noteq>0 \\<Longrightarrow> x \\<in> keys m \\<Longrightarrow> x \\<in> vars(MPoly_Type.monom m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a); x \\<in> keys m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> vars (MPoly_Type.monom m a)", "by(simp add: vars_def)"], ["", "lemma notInKeys_notInVars : \"x \\<notin> keys m \\<Longrightarrow> x \\<notin> vars(MPoly_Type.monom m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> keys m \\<Longrightarrow>\n    x \\<notin> vars (MPoly_Type.monom m a)", "by(simp add: vars_def)"], ["", "lemma lookupNotIn : \"x \\<notin> keys m \\<Longrightarrow> lookup m x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> keys m \\<Longrightarrow> lookup m x = (0::'b)", "by (simp add: in_keys_iff)"], ["", "subsection \"Degree Lemmas\""], ["", "lemma degree_le_iff: \"MPoly_Type.degree p x \\<le> k \\<longleftrightarrow> (\\<forall>m\\<in>monomials p. lookup m x \\<le> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MPoly_Type.degree p x \\<le> k) =\n    (\\<forall>m\\<in>monomials p. lookup m x \\<le> k)", "by transfer simp"], ["", "lemma degree_less_iff: \"MPoly_Type.degree p x < k \\<longleftrightarrow> (k>0 \\<and> (\\<forall>m\\<in>monomials p. lookup m x < k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MPoly_Type.degree p x < k) =\n    (0 < k \\<and> (\\<forall>m\\<in>monomials p. lookup m x < k))", "by (transfer fixing: k) (cases \"k = 0\"; simp)"], ["", "lemma degree_ge_iff: \"k > 0 \\<Longrightarrow> MPoly_Type.degree p x \\<ge> k \\<longleftrightarrow> (\\<exists>m\\<in>monomials p. lookup m x \\<ge> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (k \\<le> MPoly_Type.degree p x) =\n    (\\<exists>m\\<in>monomials p. k \\<le> lookup m x)", "using Max_ge_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> (?x \\<le> Max ?A) = (\\<exists>a\\<in>?A. ?x \\<le> a)\n\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    (k \\<le> MPoly_Type.degree p x) =\n    (\\<exists>m\\<in>monomials p. k \\<le> lookup m x)", "by (meson degree_less_iff not_less)"], ["", "lemma degree_greater_iff: \"MPoly_Type.degree p x > k \\<longleftrightarrow> (\\<exists>m\\<in>monomials p. lookup m x > k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k < MPoly_Type.degree p x) =\n    (\\<exists>m\\<in>monomials p. k < lookup m x)", "by transfer' (auto simp: Max_gr_iff)"], ["", "lemma degree_eq_iff:\n  \"MPoly_Type.degree p x = k \\<longleftrightarrow> (if k = 0\n    then (\\<forall>m\\<in>monomials p. lookup m x = 0)\n    else (\\<exists>m\\<in>monomials p. lookup m x = k) \\<and> (\\<forall>m\\<in>monomials p. lookup m x \\<le> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MPoly_Type.degree p x = k) =\n    (if k = 0 then \\<forall>m\\<in>monomials p. lookup m x = 0\n     else (\\<exists>m\\<in>monomials p. lookup m x = k) \\<and>\n          (\\<forall>m\\<in>monomials p. lookup m x \\<le> k))", "by (subst eq_iff) (force simp: degree_le_iff degree_ge_iff intro!: antisym)"], ["", "declare poly_mapping.lookup_inject[simp del]"], ["", "lemma lookup_eq_and_update_lemma: \"lookup m var = deg \\<and> Poly_Mapping.update var 0 m = x \\<longleftrightarrow>\n  m = Poly_Mapping.update var deg x \\<and> lookup x var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup m var = deg \\<and> Poly_Mapping.update var (0::'a) m = x) =\n    (m = Poly_Mapping.update var deg x \\<and> lookup x var = (0::'a))", "unfolding poly_mapping_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup m var = deg \\<and>\n     lookup (Poly_Mapping.update var (0::'a) m) = lookup x) =\n    (lookup m = lookup (Poly_Mapping.update var deg x) \\<and>\n     lookup x var = (0::'a))", "by (force simp: update.rep_eq fun_eq_iff)"], ["", "lemma degree_const : \"MPoly_Type.degree (Const (z::real)) (x::nat) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Const z) x = 0", "by (simp add: degree_eq_iff monomials_Const)"], ["", "lemma degree_one : \"MPoly_Type.degree (Var x :: real mpoly) x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x) x = 1", "by(simp add: degree_eq_iff monomials_Var)"], ["", "subsection \"Lemmas on treating a multivariate polynomial as univariate \""], ["", "lemma coeff_isolate_variable_sparse:\n  \"MPoly_Type.coeff (isolate_variable_sparse p var deg) x =\n  (if lookup x var = 0\n  then MPoly_Type.coeff p (Poly_Mapping.update var deg x)\n  else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (isolate_variable_sparse p var deg) x =\n    (if lookup x var = 0\n     then MPoly_Type.coeff p (Poly_Mapping.update var deg x) else (0::'a))", "apply (transfer fixing: x var deg p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = deg.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m))\n     x =\n    (if lookup x var = 0\n     then MPoly_Type.coeff p (Poly_Mapping.update var deg x) else (0::'a))", "unfolding lookup_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       lookup\n        (monomial (MPoly_Type.coeff p xa) (Poly_Mapping.update var 0 xa))\n        x) =\n    (if lookup x var = 0\n     then MPoly_Type.coeff p (Poly_Mapping.update var deg x) else (0::'a))", "unfolding lookup_single"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       MPoly_Type.coeff p xa when Poly_Mapping.update var 0 xa = x) =\n    (if lookup x var = 0\n     then MPoly_Type.coeff p (Poly_Mapping.update var deg x) else (0::'a))", "apply (auto simp: when_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lookup x var = 0 \\<Longrightarrow>\n    (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       if Poly_Mapping.update var 0 xa = x then MPoly_Type.coeff p xa\n       else (0::'a)) =\n    MPoly_Type.coeff p (Poly_Mapping.update var deg x)\n 2. 0 < lookup x var \\<Longrightarrow>\n    (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       if Poly_Mapping.update var 0 xa = x then MPoly_Type.coeff p xa\n       else (0::'a)) =\n    (0::'a)", "apply (subst sum.inter_filter[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. lookup x var = 0 \\<Longrightarrow>\n    finite {m \\<in> monomials p. lookup m var = deg}\n 2. lookup x var = 0 \\<Longrightarrow>\n    sum (MPoly_Type.coeff p)\n     {xa \\<in> {m \\<in> monomials p. lookup m var = deg}.\n      Poly_Mapping.update var 0 xa = x} =\n    MPoly_Type.coeff p (Poly_Mapping.update var deg x)\n 3. 0 < lookup x var \\<Longrightarrow>\n    (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       if Poly_Mapping.update var 0 xa = x then MPoly_Type.coeff p xa\n       else (0::'a)) =\n    (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup x var = 0 \\<Longrightarrow>\n    finite {m \\<in> monomials p. lookup m var = deg}", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. lookup x var = 0 \\<Longrightarrow>\n    sum (MPoly_Type.coeff p)\n     {xa \\<in> {m \\<in> monomials p. lookup m var = deg}.\n      Poly_Mapping.update var 0 xa = x} =\n    MPoly_Type.coeff p (Poly_Mapping.update var deg x)\n 2. 0 < lookup x var \\<Longrightarrow>\n    (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       if Poly_Mapping.update var 0 xa = x then MPoly_Type.coeff p xa\n       else (0::'a)) =\n    (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup x var = 0 \\<Longrightarrow>\n    sum (MPoly_Type.coeff p)\n     {xa \\<in> {m \\<in> monomials p. lookup m var = deg}.\n      Poly_Mapping.update var 0 xa = x} =\n    MPoly_Type.coeff p (Poly_Mapping.update var deg x)", "by (simp add: lookup_eq_and_update_lemma Collect_conv_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lookup x var \\<Longrightarrow>\n    (\\<Sum>xa\\<in>{m \\<in> monomials p. lookup m var = deg}.\n       if Poly_Mapping.update var 0 xa = x then MPoly_Type.coeff p xa\n       else (0::'a)) =\n    (0::'a)", "by (auto intro!: sum.neutral simp add: lookup_update)"], ["", "lemma isovarspar_sum: \n  \"isolate_variable_sparse (p+q) var deg = \n  isolate_variable_sparse (p) var deg\n  + isolate_variable_sparse (q) var deg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (p + q) var deg =\n    isolate_variable_sparse p var deg + isolate_variable_sparse q var deg", "apply (auto simp add: mpoly_eq_iff coeff_isolate_variable_sparse )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       lookup m var = 0 \\<Longrightarrow>\n       MPoly_Type.coeff (p + q) (Poly_Mapping.update var deg m) =\n       MPoly_Type.coeff\n        (isolate_variable_sparse p var deg +\n         isolate_variable_sparse q var deg)\n        m\n 2. \\<And>m.\n       0 < lookup m var \\<Longrightarrow>\n       MPoly_Type.coeff\n        (isolate_variable_sparse p var deg +\n         isolate_variable_sparse q var deg)\n        m =\n       (0::'a)", "apply (metis More_MPoly_Type.coeff_add coeff_isolate_variable_sparse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       0 < lookup m var \\<Longrightarrow>\n       MPoly_Type.coeff\n        (isolate_variable_sparse p var deg +\n         isolate_variable_sparse q var deg)\n        m =\n       (0::'a)", "by (metis More_MPoly_Type.coeff_add add.comm_neutral coeff_isolate_variable_sparse less_numeral_extra(3))"], ["", "lemma isolate_zero[simp]: \"isolate_variable_sparse 0 var n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse 0 var n = 0", "by transfer' (auto simp: mpoly_eq_iff)"], ["", "lemma coeff_isolate_variable_sparse_minus_monomial:\n  \"MPoly_Type.coeff (isolate_variable_sparse mp var i) (m - monomial i var) =\n  (if lookup m var \\<le> i then MPoly_Type.coeff mp (Poly_Mapping.update var i m) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (isolate_variable_sparse mp var i)\n     (m - monomial i var) =\n    (if lookup m var \\<le> i\n     then MPoly_Type.coeff mp (Poly_Mapping.update var i m) else (0::'a))", "by (simp add: coeff_isolate_variable_sparse lookup_minus update_minus_monomial)"], ["", "lemma sum_over_zero: \"(mp::real mpoly) = (\\<Sum>i::nat \\<le>MPoly_Type.degree mp x. isolate_variable_sparse mp x i * Var x^i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mp =\n    (\\<Sum>i\\<le>MPoly_Type.degree mp x.\n        isolate_variable_sparse mp x i * Var x ^ i)", "by (auto simp add: mpoly_eq_iff coeff_sum coeff_mult_Var if_if_eq_conj not_le\n      coeff_isolate_variable_sparse_minus_monomial when_def lookup_update degree_less_iff\n      simp flip: eq_iff\n      intro!: coeff_not_in_monomials)"], ["", "lemma const_lookup_zero : \"isolate_variable_sparse (Const p ::real mpoly) (x::nat) (0::nat) = Const p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (Const p) x 0 = Const p", "by (auto simp: mpoly_eq_iff coeff_isolate_variable_sparse coeff_Const when_def)\n    (metis lookup_update_self)"], ["", "lemma const_lookup_suc : \"isolate_variable_sparse (Const p :: real mpoly) x (Suc i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (Const p) x (Suc i) = 0", "apply(auto simp add: mpoly_eq_iff coeff_isolate_variable_sparse coeff_Const when_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>Poly_Mapping.update x (Suc i) m = 0; lookup m x = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "by (metis lookup_update lookup_zero nat.distinct(1))"], ["", "lemma isovar_greater_degree : \"\\<forall>i > MPoly_Type.degree p var. isolate_variable_sparse p var i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i>MPoly_Type.degree p var. isolate_variable_sparse p var i = 0", "apply(auto simp add: mpoly_eq_iff coeff_isolate_variable_sparse degree_less_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m.\n       \\<lbrakk>0 < i; \\<forall>m\\<in>monomials p. lookup m var < i;\n        lookup m var = 0\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff p (Poly_Mapping.update var i m) =\n                         (0::'a)", "by (metis coeff_not_in_monomials less_irrefl_nat lookup_update)"], ["", "lemma isolate_var_0 : \"isolate_variable_sparse (Var x::real mpoly) x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (Var x) x 0 = 0", "apply(auto simp add: mpoly_eq_iff coeff_isolate_variable_sparse coeff_Var when_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       Poly_Mapping.update x 0 m = monomial (Suc 0) x \\<Longrightarrow>\n       0 < lookup m x", "by (metis gr0I lookup_single_eq lookup_update_self n_not_Suc_n)"], ["", "lemma isolate_var_one : \"isolate_variable_sparse (Var x :: real mpoly) x 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (Var x) x 1 = 1", "by (auto simp add: mpoly_eq_iff coeff_isolate_variable_sparse coeff_Var coeff_eq_zero_iff)\n    (smt More_MPoly_Type.coeff_monom One_nat_def add_diff_cancel_left' lookup_eq_and_update_lemma\n      lookup_single_eq lookup_update_self monom_one plus_1_eq_Suc single_diff single_zero update_minus_monomial)"], ["", "lemma isovarspase_monom :\n  assumes notInKeys : \"x \\<notin> keys m\"\n  assumes notZero : \"a \\<noteq> 0\"\n  shows \"isolate_variable_sparse (MPoly_Type.monom m a) x 0 = (MPoly_Type.monom m a :: real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n    MPoly_Type.monom m a", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> keys m\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n    MPoly_Type.monom m a", "by (auto simp add: mpoly_eq_iff coeff_isolate_variable_sparse coeff_eq_zero_iff in_keys_iff)\n    (metis lookup_update_self)"], ["", "lemma isolate_variable_spase_zero : \"lookup m x = 0 \\<Longrightarrow>\n    insertion (nth L) ((MPoly_Type.monom m a)::real mpoly) = 0 \\<Longrightarrow>\n    a \\<noteq> 0 \\<Longrightarrow> insertion (nth L) (isolate_variable_sparse (MPoly_Type.monom m a) x 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup m x = 0; insertion ((!) L) (MPoly_Type.monom m a) = 0;\n     a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> insertion ((!) L)\n                       (isolate_variable_sparse (MPoly_Type.monom m a) x\n                         0) =\n                      0", "by (simp add: isovarspase_monom lookup_eq_zero_in_keys_contradict notInKeys_notInVars)"], ["", "lemma isovarsparNotIn : \"x \\<notin> vars (p::real mpoly) \\<Longrightarrow> isolate_variable_sparse p x 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars p \\<Longrightarrow> isolate_variable_sparse p x 0 = p", "proof(induction p rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       x \\<notin> vars (MPoly_Type.monom m a) \\<Longrightarrow>\n       isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n       MPoly_Type.monom m a\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>x \\<notin> vars p1 \\<Longrightarrow>\n                isolate_variable_sparse p1 x 0 = p1;\n        x \\<notin> vars p2 \\<Longrightarrow>\n        isolate_variable_sparse p2 x 0 = p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        x \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse (p1 + p2) x 0 = p1 + p2", "case (monom m a)"], ["proof (state)\nthis:\n  x \\<notin> vars (MPoly_Type.monom m a)\n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       x \\<notin> vars (MPoly_Type.monom m a) \\<Longrightarrow>\n       isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n       MPoly_Type.monom m a\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>x \\<notin> vars p1 \\<Longrightarrow>\n                isolate_variable_sparse p1 x 0 = p1;\n        x \\<notin> vars p2 \\<Longrightarrow>\n        isolate_variable_sparse p2 x 0 = p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        x \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse (p1 + p2) x 0 = p1 + p2", "then"], ["proof (chain)\npicking this:\n  x \\<notin> vars (MPoly_Type.monom m a)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<notin> vars (MPoly_Type.monom m a)\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n    MPoly_Type.monom m a", "apply(cases \"a=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> vars (MPoly_Type.monom m a); a = 0\\<rbrakk>\n    \\<Longrightarrow> isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n                      MPoly_Type.monom m a\n 2. \\<lbrakk>x \\<notin> vars (MPoly_Type.monom m a); a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> isolate_variable_sparse (MPoly_Type.monom m a) x 0 =\n                      MPoly_Type.monom m a", "by (simp_all add: isovarspase_monom vars_monom_keys)"], ["proof (state)\nthis:\n  isolate_variable_sparse (MPoly_Type.monom m a) x 0 = MPoly_Type.monom m a\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>x \\<notin> vars p1 \\<Longrightarrow>\n                isolate_variable_sparse p1 x 0 = p1;\n        x \\<notin> vars p2 \\<Longrightarrow>\n        isolate_variable_sparse p2 x 0 = p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        x \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse (p1 + p2) x 0 = p1 + p2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>x \\<notin> vars p1 \\<Longrightarrow>\n                isolate_variable_sparse p1 x 0 = p1;\n        x \\<notin> vars p2 \\<Longrightarrow>\n        isolate_variable_sparse p2 x 0 = p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        x \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse (p1 + p2) x 0 = p1 + p2", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  x \\<notin> vars p1 \\<Longrightarrow> isolate_variable_sparse p1 x 0 = p1\n  x \\<notin> vars p2 \\<Longrightarrow> isolate_variable_sparse p2 x 0 = p2\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  x \\<notin> vars (p1 + p2)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>x \\<notin> vars p1 \\<Longrightarrow>\n                isolate_variable_sparse p1 x 0 = p1;\n        x \\<notin> vars p2 \\<Longrightarrow>\n        isolate_variable_sparse p2 x 0 = p2;\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        x \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse (p1 + p2) x 0 = p1 + p2", "then"], ["proof (chain)\npicking this:\n  x \\<notin> vars p1 \\<Longrightarrow> isolate_variable_sparse p1 x 0 = p1\n  x \\<notin> vars p2 \\<Longrightarrow> isolate_variable_sparse p2 x 0 = p2\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  x \\<notin> vars (p1 + p2)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<notin> vars p1 \\<Longrightarrow> isolate_variable_sparse p1 x 0 = p1\n  x \\<notin> vars p2 \\<Longrightarrow> isolate_variable_sparse p2 x 0 = p2\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  x \\<notin> vars (p1 + p2)\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse (p1 + p2) x 0 = p1 + p2", "by (simp add: monomials.rep_eq vars_add_monom isovarspar_sum)"], ["proof (state)\nthis:\n  isolate_variable_sparse (p1 + p2) x 0 = p1 + p2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree0isovarspar :\n  assumes deg0 : \"MPoly_Type.degree (p::real mpoly) x = 0\"\n  shows \"isolate_variable_sparse p x 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "have h1 : \"p = (\\<Sum>i::nat \\<le>MPoly_Type.degree p x. isolate_variable_sparse p x i * Var x ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>MPoly_Type.degree p x.\n        isolate_variable_sparse p x i * Var x ^ i)", "using sum_over_zero"], ["proof (prove)\nusing this:\n  ?mp =\n  (\\<Sum>i\\<le>MPoly_Type.degree ?mp ?x.\n      isolate_variable_sparse ?mp ?x i * Var ?x ^ i)\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>MPoly_Type.degree p x.\n        isolate_variable_sparse p x i * Var x ^ i)", "by auto"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p x.\n      isolate_variable_sparse p x i * Var x ^ i)\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "have h2a : \"\\<forall>f. (\\<Sum>i::nat \\<le>0. f i) = f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. sum f {..0} = f 0", "apply(simp add: sum_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. comm_monoid_set.F (+) (0::'a) f {0} = f 0", "by (metis add.right_neutral comm_monoid_add_class.sum_def finite.emptyI insert_absorb insert_not_empty sum.empty sum.insert)"], ["proof (state)\nthis:\n  \\<forall>f. sum f {..0} = f 0\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "have h2 : \"p = isolate_variable_sparse p x 0 * Var x ^ 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = isolate_variable_sparse p x 0 * Var x ^ 0", "using deg0 h1 h2a"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p x = 0\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p x.\n      isolate_variable_sparse p x i * Var x ^ i)\n  \\<forall>f. sum f {..0} = f 0\n\ngoal (1 subgoal):\n 1. p = isolate_variable_sparse p x 0 * Var x ^ 0", "by auto"], ["proof (state)\nthis:\n  p = isolate_variable_sparse p x 0 * Var x ^ 0\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "using h2"], ["proof (prove)\nusing this:\n  p = isolate_variable_sparse p x 0 * Var x ^ 0\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x 0 = p", "by auto"], ["proof (state)\nthis:\n  isolate_variable_sparse p x 0 = p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Summation Lemmas\""], ["", "lemma summation_normalized :\n  assumes nonzero : \"(B ::real) \\<noteq>0\"\n  shows \"(\\<Sum>i = 0..<((n::nat)+1). (f i :: real) * B ^ (n - i)) = (\\<Sum>i = 0..<(n+1). (f i) / (B ^ i)) * (B^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "have h1a : \"\\<forall>x::real. ((\\<Sum>i = 0..<(n+1). (f i) / (B ^ i)) * x = (\\<Sum>i = 0..<(n+1). ((f i) / (B ^ i)) * x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<Sum>i = 0..<n + 1. f i / B ^ i) * x =\n       (\\<Sum>i = 0..<n + 1. f i / B ^ i * x)", "apply(induction n )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       (\\<Sum>i = 0..<0 + 1. f i / B ^ i) * x =\n       (\\<Sum>i = 0..<0 + 1. f i / B ^ i * x)\n 2. \\<And>n.\n       \\<forall>x.\n          (\\<Sum>i = 0..<n + 1. f i / B ^ i) * x =\n          (\\<Sum>i = 0..<n + 1. f i / B ^ i * x) \\<Longrightarrow>\n       \\<forall>x.\n          (\\<Sum>i = 0..<Suc n + 1. f i / B ^ i) * x =\n          (\\<Sum>i = 0..<Suc n + 1. f i / B ^ i * x)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<forall>x.\n          ((\\<Sum>i = 0..<n. f i / B ^ i) + f n / B ^ n) * x =\n          (\\<Sum>i = 0..<n. f i * x / B ^ i) +\n          f n * x / B ^ n \\<Longrightarrow>\n       ((\\<Sum>i = 0..<n. f i / B ^ i) + f n / B ^ n +\n        f (Suc n) / (B * B ^ n)) *\n       x =\n       (\\<Sum>i = 0..<n. f i * x / B ^ i) + f n * x / B ^ n +\n       f (Suc n) * x / (B * B ^ n)", "by (simp add: distrib_right)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<Sum>i = 0..<n + 1. f i / B ^ i) * x =\n     (\\<Sum>i = 0..<n + 1. f i / B ^ i * x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "have h1 : \"(\\<Sum>i = 0..<(n+1). (f i) / (B ^ i)) * (B^n) = (\\<Sum>i = 0..<(n+1). ((f i) / (B ^ i)) * (B^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n)", "using h1a"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (\\<Sum>i = 0..<n + 1. f i / B ^ i) * x =\n     (\\<Sum>i = 0..<n + 1. f i / B ^ i * x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "have h2 : \"(\\<Sum>i = 0..<(n+1). ((f i) / (B ^ i)) * (B^n)) = (\\<Sum>i = 0..<(n+1). (f i) * ((B^n) / (B ^ i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n) =\n    (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n) =\n  (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "have h3 : \"(\\<Sum>i = 0..<(n+1). (f i) * ((B^n) / (B ^ i))) = (\\<Sum>i = 0..<(n+1). (f i) * B ^ (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i)) =\n    (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))", "using add.right_neutral nonzero power_diff"], ["proof (prove)\nusing this:\n  ?a + (0::?'a) = ?a\n  B \\<noteq> 0\n  \\<lbrakk>?a \\<noteq> (0::?'a); ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ?a ^ (?m - ?n) = ?a ^ ?m div ?a ^ ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i)) =\n    (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i)) =\n  (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "using h1 h2 h3"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n)\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i * B ^ n) =\n  (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i))\n  (\\<Sum>i = 0..<n + 1. f i * (B ^ n / B ^ i)) =\n  (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n    (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) =\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_summation :\n  assumes nonzero : \"(B::real)\\<noteq>0\"\n  shows \"(\\<Sum>i = 0..<n+1. f i * B ^ (n - i))= 0\n          \\<longleftrightarrow>\n  (\\<Sum>i = 0..<(n::nat)+1. (f i::real) / (B ^ i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "have pow_zero : \"\\<forall>i. B^(i :: nat)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. B ^ i \\<noteq> 0", "using nonzero"], ["proof (prove)\nusing this:\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. B ^ i \\<noteq> 0", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>i. B ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "have single_division_zero : \"\\<forall>X. B*(X::real)=0 \\<longleftrightarrow> X=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X. (B * X = 0) = (X = 0)", "using nonzero"], ["proof (prove)\nusing this:\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>X. (B * X = 0) = (X = 0)", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>X. (B * X = 0) = (X = 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "have h1: \"(\\<Sum>i = 0..<n+1. (f i) / (B ^ i)) = 0 \\<longleftrightarrow> ((\\<Sum>i = 0..<n+1. (f i) / (B ^ i)))*B^n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n = 0)", "using nonzero single_division_zero"], ["proof (prove)\nusing this:\n  B \\<noteq> 0\n  \\<forall>X. (B * X = 0) = (X = 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n = 0)", "by(auto)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0) =\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n = 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "have h2: \"((\\<Sum>i = 0..<n+1. (f i) / (B ^ i))*(B^n)) = ((\\<Sum>i = 0..<n+1. (f i) * (B ^ (n- i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n    (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))", "using summation_normalized nonzero"], ["proof (prove)\nusing this:\n  ?B \\<noteq> 0 \\<Longrightarrow>\n  (\\<Sum>i = 0..<?n + 1. ?f i * ?B ^ (?n - i)) =\n  (\\<Sum>i = 0..<?n + 1. ?f i / ?B ^ i) * ?B ^ ?n\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n    (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n  (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "using h1 h2"], ["proof (prove)\nusing this:\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0) =\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n = 0)\n  (\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n =\n  (\\<Sum>i = 0..<n + 1. f i * B ^ (n - i))\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) = 0) =\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_summation_less :\n  assumes nonzero : \"(B::real)\\<noteq>0\"\n  shows \"(\\<Sum>i = 0..<(n+1). (f i) * B ^ (n - i)) * B ^ (n mod 2) < 0\n          \\<longleftrightarrow>\n  (\\<Sum>i = 0..<((n::nat)+1). (f i::real) / (B ^ i)) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "have h1 : \"(\\<Sum>i = 0..<(n+1). (f i) * B ^ (n - i)) * B ^ (n mod 2) < 0\n        \\<longleftrightarrow>  (\\<Sum>i = 0..<(n+1). (f i) / (B ^ i)) * (B^n) * B ^ (n mod 2) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n * B ^ (n mod 2) < 0)", "using summation_normalized nonzero"], ["proof (prove)\nusing this:\n  ?B \\<noteq> 0 \\<Longrightarrow>\n  (\\<Sum>i = 0..<?n + 1. ?f i * ?B ^ (?n - i)) =\n  (\\<Sum>i = 0..<?n + 1. ?f i / ?B ^ i) * ?B ^ ?n\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n * B ^ (n mod 2) < 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n * B ^ (n mod 2) < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "have h2a : \"n mod 2 = 0 \\<or> n mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod 2 = 0 \\<or> n mod 2 = 1", "by auto"], ["proof (state)\nthis:\n  n mod 2 = 0 \\<or> n mod 2 = 1\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "have h2b : \"n mod 2 = 1 \\<Longrightarrow> odd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod 2 = 1 \\<Longrightarrow> odd n", "by auto"], ["proof (state)\nthis:\n  n mod 2 = 1 \\<Longrightarrow> odd n\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "have h2c : \"(B^n) * B ^ (n mod 2) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < B ^ n * B ^ (n mod 2)", "using h2a h2b"], ["proof (prove)\nusing this:\n  n mod 2 = 0 \\<or> n mod 2 = 1\n  n mod 2 = 1 \\<Longrightarrow> odd n\n\ngoal (1 subgoal):\n 1. 0 < B ^ n * B ^ (n mod 2)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> 0 < B ^ n\n 2. \\<lbrakk>odd n; n mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> 0 < B ^ n * B", "using nonzero"], ["proof (prove)\nusing this:\n  B \\<noteq> 0\n\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> 0 < B ^ n\n 2. \\<lbrakk>odd n; n mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> 0 < B ^ n * B", "apply presburger"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odd n; n mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> 0 < B ^ n * B", "by (metis even_Suc mult.commute nonzero power_Suc zero_less_power_eq)"], ["proof (state)\nthis:\n  0 < B ^ n * B ^ (n mod 2)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "have h2 : \"\\<forall>x. ((x * (B^n) * B ^ (n mod 2) < 0) = (x<0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (x * B ^ n * B ^ (n mod 2) < 0) = (x < 0)", "using h2c"], ["proof (prove)\nusing this:\n  0 < B ^ n * B ^ (n mod 2)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x * B ^ n * B ^ (n mod 2) < 0) = (x < 0)", "using mult.assoc"], ["proof (prove)\nusing this:\n  0 < B ^ n * B ^ (n mod 2)\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x * B ^ n * B ^ (n mod 2) < 0) = (x < 0)", "by (metis mult_less_0_iff not_square_less_zero)"], ["proof (state)\nthis:\n  \\<forall>x. (x * B ^ n * B ^ (n mod 2) < 0) = (x < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "using h1 h2"], ["proof (prove)\nusing this:\n  ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) * B ^ n * B ^ (n mod 2) < 0)\n  \\<forall>x. (x * B ^ n * B ^ (n mod 2) < 0) = (x < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n    ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<n + 1. f i * B ^ (n - i)) * B ^ (n mod 2) < 0) =\n  ((\\<Sum>i = 0..<n + 1. f i / B ^ i) < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Additional Lemmas with Vars\""], ["", "lemma not_in_isovarspar : \"isolate_variable_sparse (p::real mpoly) var x = (q::real mpoly) \\<Longrightarrow> var\\<notin>(vars q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var x = q \\<Longrightarrow>\n    var \\<notin> vars q", "apply(simp add: isolate_variable_sparse_def vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "assume a1: \"MPoly (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x. monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) = q\""], ["proof (state)\nthis:\n  MPoly\n   (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n      monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n  q\n\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "{"], ["proof (state)\nthis:\n  MPoly\n   (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n      monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n  q\n\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "fix pp :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "have \"isolate_variable_sparse p var x = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var x = q", "using a1 isolate_variable_sparse.abs_eq"], ["proof (prove)\nusing this:\n  MPoly\n   (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n      monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n  q\n  isolate_variable_sparse ?xb ?xa ?x =\n  MPoly\n   (\\<Sum>m | m \\<in> monomials ?xb \\<and> lookup m ?xa = ?x.\n      monomial (MPoly_Type.coeff ?xb m) (Poly_Mapping.update ?xa 0 m))\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var x = q", "by blast"], ["proof (state)\nthis:\n  isolate_variable_sparse p var x = q\n\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "then"], ["proof (chain)\npicking this:\n  isolate_variable_sparse p var x = q", "have \"var \\<notin> keys pp \\<or> pp \\<notin> keys (mapping_of q)\""], ["proof (prove)\nusing this:\n  isolate_variable_sparse p var x = q\n\ngoal (1 subgoal):\n 1. var \\<notin> keys pp \\<or> pp \\<notin> keys (mapping_of q)", "by (metis (no_types) coeff_def coeff_isolate_variable_sparse in_keys_iff)"], ["proof (state)\nthis:\n  var \\<notin> keys pp \\<or> pp \\<notin> keys (mapping_of q)\n\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "}"], ["proof (state)\nthis:\n  var \\<notin> keys ?pp2 \\<or> ?pp2 \\<notin> keys (mapping_of q)\n\ngoal (1 subgoal):\n 1. MPoly\n     (\\<Sum>m | m \\<in> monomials p \\<and> lookup m var = x.\n        monomial (MPoly_Type.coeff p m) (Poly_Mapping.update var 0 m)) =\n    q \\<Longrightarrow>\n    \\<forall>x\\<in>keys (mapping_of q). var \\<notin> keys x", "then"], ["proof (chain)\npicking this:\n  var \\<notin> keys ?pp2 \\<or> ?pp2 \\<notin> keys (mapping_of q)", "show \"\\<forall>p\\<in>keys (mapping_of q). var \\<notin> keys p\""], ["proof (prove)\nusing this:\n  var \\<notin> keys ?pp2 \\<or> ?pp2 \\<notin> keys (mapping_of q)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>keys (mapping_of q). var \\<notin> keys p", "by meson"], ["proof (state)\nthis:\n  \\<forall>p\\<in>keys (mapping_of q). var \\<notin> keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_in_add : \"var\\<notin>(vars (p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (q::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (p+q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> vars p; var \\<notin> vars q\\<rbrakk>\n    \\<Longrightarrow> var \\<notin> vars (p + q)", "by (meson UnE in_mono vars_add)"], ["", "lemma not_in_mult : \"var\\<notin>(vars (p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (q::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (p*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> vars p; var \\<notin> vars q\\<rbrakk>\n    \\<Longrightarrow> var \\<notin> vars (p * q)", "by (meson UnE in_mono vars_mult)"], ["", "lemma not_in_neg : \"var\\<notin>(vars(p::real mpoly)) \\<longleftrightarrow> var\\<notin>(vars(-p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (var \\<notin> vars p) = (var \\<notin> vars (- p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (var \\<notin> vars p) = (var \\<notin> vars (- p))", "have h: \"var \\<notin> (vars (-1::real mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- 1)", "by (metis add_diff_cancel_right' add_neg_numeral_special(8) isolate_var_one isolate_zero isovarsparNotIn isovarspar_sum not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. (var \\<notin> vars p) = (var \\<notin> vars (- p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (var \\<notin> vars p) = (var \\<notin> vars (- p))", "using not_in_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n\ngoal (1 subgoal):\n 1. (var \\<notin> vars p) = (var \\<notin> vars (- p))", "using h"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  var \\<notin> vars (- 1)\n\ngoal (1 subgoal):\n 1. (var \\<notin> vars p) = (var \\<notin> vars (- p))", "by fastforce"], ["proof (state)\nthis:\n  (var \\<notin> vars p) = (var \\<notin> vars (- p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_in_sub : \"var\\<notin>(vars (p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (q::real mpoly)) \\<Longrightarrow> var\\<notin>(vars (p-q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> vars p; var \\<notin> vars q\\<rbrakk>\n    \\<Longrightarrow> var \\<notin> vars (p - q)", "using not_in_add not_in_neg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p + ?q)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> vars p; var \\<notin> vars q\\<rbrakk>\n    \\<Longrightarrow> var \\<notin> vars (p - q)", "by fastforce"], ["", "lemma not_in_pow : \"var\\<notin>(vars(p::real mpoly)) \\<Longrightarrow> var\\<notin>(vars(p^i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ i)", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ 0)\n 2. \\<And>i.\n       \\<lbrakk>var \\<notin> vars p \\<Longrightarrow>\n                var \\<notin> vars (p ^ i);\n        var \\<notin> vars p\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (p ^ Suc i)", "case 0"], ["proof (state)\nthis:\n  var \\<notin> vars p\n\ngoal (2 subgoals):\n 1. var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ 0)\n 2. \\<And>i.\n       \\<lbrakk>var \\<notin> vars p \\<Longrightarrow>\n                var \\<notin> vars (p ^ i);\n        var \\<notin> vars p\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (p ^ Suc i)", "then"], ["proof (chain)\npicking this:\n  var \\<notin> vars p", "show ?case"], ["proof (prove)\nusing this:\n  var \\<notin> vars p\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (p ^ 0)", "using isolate_var_one not_in_isovarspar"], ["proof (prove)\nusing this:\n  var \\<notin> vars p\n  isolate_variable_sparse (Var ?x) ?x 1 = 1\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (p ^ 0)", "by (metis power_0)"], ["proof (state)\nthis:\n  var \\<notin> vars (p ^ 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>var \\<notin> vars p \\<Longrightarrow>\n                var \\<notin> vars (p ^ i);\n        var \\<notin> vars p\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (p ^ Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>var \\<notin> vars p \\<Longrightarrow>\n                var \\<notin> vars (p ^ i);\n        var \\<notin> vars p\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (p ^ Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ i)\n  var \\<notin> vars p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>var \\<notin> vars p \\<Longrightarrow>\n                var \\<notin> vars (p ^ i);\n        var \\<notin> vars p\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (p ^ Suc i)", "then"], ["proof (chain)\npicking this:\n  var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ i)\n  var \\<notin> vars p", "show ?case"], ["proof (prove)\nusing this:\n  var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ i)\n  var \\<notin> vars p\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (p ^ Suc i)", "using not_in_mult"], ["proof (prove)\nusing this:\n  var \\<notin> vars p \\<Longrightarrow> var \\<notin> vars (p ^ i)\n  var \\<notin> vars p\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (p ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  var \\<notin> vars (p ^ Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_in_sum_var: \"(\\<forall>i. var\\<notin>(vars(f(i)::real mpoly))) \\<Longrightarrow> var\\<notin>(vars(\\<Sum>i\\<in>{0..<(n::nat)}.f(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n    var \\<notin> vars (sum f {0..<n})", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n    var \\<notin> vars (sum f {0..<0})\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "case 0"], ["proof (state)\nthis:\n  \\<forall>i. var \\<notin> vars (f i)\n\ngoal (2 subgoals):\n 1. \\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n    var \\<notin> vars (sum f {0..<0})\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. var \\<notin> vars (f i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i. var \\<notin> vars (f i)\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (sum f {0..<0})", "using isolate_zero not_in_isovarspar"], ["proof (prove)\nusing this:\n  \\<forall>i. var \\<notin> vars (f i)\n  isolate_variable_sparse 0 ?var ?n = 0\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (sum f {0..<0})", "by fastforce"], ["proof (state)\nthis:\n  var \\<notin> vars (sum f {0..<0})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n  var \\<notin> vars (sum f {0..<n})\n  \\<forall>i. var \\<notin> vars (f i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "have h1: \"(sum f {0..<Suc n}) = (sum f {0..< n}) + (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {0..<Suc n} = sum f {0..<n} + f n", "using sum.atLeast0_lessThan_Suc"], ["proof (prove)\nusing this:\n  sum ?g {0..<Suc ?n} = sum ?g {0..<?n} + ?g ?n\n\ngoal (1 subgoal):\n 1. sum f {0..<Suc n} = sum f {0..<n} + f n", "by blast"], ["proof (state)\nthis:\n  sum f {0..<Suc n} = sum f {0..<n} + f n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "have h2: \"var \\<notin> vars (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (f n)", "by (simp add: Suc.prems)"], ["proof (state)\nthis:\n  var \\<notin> vars (f n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n                var \\<notin> vars (sum f {0..<n});\n        \\<forall>i. var \\<notin> vars (f i)\\<rbrakk>\n       \\<Longrightarrow> var \\<notin> vars (sum f {0..<Suc n})", "then"], ["proof (chain)\npicking this:\n  var \\<notin> vars (f n)", "show ?case"], ["proof (prove)\nusing this:\n  var \\<notin> vars (f n)\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (sum f {0..<Suc n})", "using h1 vars_add"], ["proof (prove)\nusing this:\n  var \\<notin> vars (f n)\n  sum f {0..<Suc n} = sum f {0..<n} + f n\n  vars (?p1.0 + ?p2.0) \\<subseteq> vars ?p1.0 \\<union> vars ?p2.0\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (sum f {0..<Suc n})", "by (simp add: Suc.IH Suc.prems not_in_add)"], ["proof (state)\nthis:\n  var \\<notin> vars (sum f {0..<Suc n})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_in_sum : \"(\\<forall>i. var\\<notin>(vars(f(i)::real mpoly))) \\<Longrightarrow> \\<forall>(n::nat). var\\<notin>(vars(\\<Sum>i\\<in>{0..<n}.f(i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n    \\<forall>n. var \\<notin> vars (sum f {0..<n})", "using not_in_sum_var"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  ?var \\<notin> vars (sum ?f {0..<?n})\n\ngoal (1 subgoal):\n 1. \\<forall>i. var \\<notin> vars (f i) \\<Longrightarrow>\n    \\<forall>n. var \\<notin> vars (sum f {0..<n})", "by blast"], ["", "lemma not_contains_insertion_helper : \n  \"\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x \\<Longrightarrow>\n         (\\<And>k f. (k \\<notin> keys f) = (lookup f k = 0)) \\<Longrightarrow>\n         lookup (mapping_of p) a = 0 \\<or>\n         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa else 0) ^ lookup a aa) =\n         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa else 0) ^ lookup a aa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n     \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c))\\<rbrakk>\n    \\<Longrightarrow> lookup (mapping_of p) a = (0::'a) \\<or>\n                      (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa) =\n                      (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa)", "apply(cases \"lookup (mapping_of p) a = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n     \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c));\n     lookup (mapping_of p) a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> lookup (mapping_of p) a = (0::'a) \\<or>\n                      (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa) =\n                      (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa)\n 2. \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n     \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c));\n     lookup (mapping_of p) a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> lookup (mapping_of p) a = (0::'a) \\<or>\n                      (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa) =\n                      (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n     \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c));\n     lookup (mapping_of p) a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa) =\n                      (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                                   else (0::'d)) ^\n                                  lookup a aa)", "apply(rule Prod_any.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c));\n        lookup (mapping_of p) a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (if aa < length L then L[var := y] ! aa\n                          else (0::'d)) ^\n                         lookup a aa =\n                         (if aa < length L then L[var := x] ! aa\n                          else (0::'d)) ^\n                         lookup a aa", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c));\n        lookup (mapping_of p) a \\<noteq> (0::'a); aa < length L\\<rbrakk>\n       \\<Longrightarrow> L[var := y] ! aa ^ lookup a aa =\n                         L[var := x] ! aa ^ lookup a aa", "using lookupNotIn nth_list_update_neq power_0"], ["proof (prove)\nusing this:\n  ?x \\<notin> keys ?m \\<Longrightarrow> lookup ?m ?x = (0::?'b)\n  ?i \\<noteq> ?j \\<Longrightarrow> ?xs[?i := ?x] ! ?j = ?xs ! ?j\n  ?a ^ 0 = (1::?'a)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::'c));\n        lookup (mapping_of p) a \\<noteq> (0::'a); aa < length L\\<rbrakk>\n       \\<Longrightarrow> L[var := y] ! aa ^ lookup a aa =\n                         L[var := x] ! aa ^ lookup a aa", "by smt"], ["", "lemma not_contains_insertion : \n  assumes notIn : \"var \\<notin> vars (p:: real mpoly)\"\n  assumes exists : \"insertion (nth_default 0 (list_update L var x)) p = val\"\n  shows \"insertion (nth_default 0 (list_update L var y)) p = val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := y])) p = val", "using notIn exists"], ["proof (prove)\nusing this:\n  var \\<notin> vars p\n  insertion (nth_default 0 (L[var := x])) p = val\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := y])) p = val", "apply(simp add: insertion_def insertion_aux_def insertion_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> vars p;\n     (\\<Sum>m. lookup (mapping_of p) m *\n               (\\<Prod>v. nth_default 0 (L[var := x]) v ^ lookup m v)) =\n     val\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>m. lookup (mapping_of p) m *\n                                (\\<Prod>v. nth_default 0 (L[var := y]) v ^\n     lookup m v)) =\n                      val", "unfolding vars_def nth_default_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> \\<Union> (keys ` keys (mapping_of p));\n     (\\<Sum>m. lookup (mapping_of p) m *\n               (\\<Prod>v. (if v < length (L[var := x]) then L[var := x] ! v\n                           else 0) ^\n                          lookup m v)) =\n     val\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>m. lookup (mapping_of p) m *\n                                (\\<Prod>v. (if v < length (L[var := y])\n      then L[var := y] ! v else 0) ^\n     lookup m v)) =\n                      val", "using not_in_keys_iff_lookup_eq_zero"], ["proof (prove)\nusing this:\n  (?k \\<notin> keys ?f) = (lookup ?f ?k = (0::?'b))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var \\<notin> \\<Union> (keys ` keys (mapping_of p));\n     (\\<Sum>m. lookup (mapping_of p) m *\n               (\\<Prod>v. (if v < length (L[var := x]) then L[var := x] ! v\n                           else 0) ^\n                          lookup m v)) =\n     val\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>m. lookup (mapping_of p) m *\n                                (\\<Prod>v. (if v < length (L[var := y])\n      then L[var := y] ! v else 0) ^\n     lookup m v)) =\n                      val", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n     \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n     val =\n     (\\<Sum>a. lookup (mapping_of p) a *\n               (\\<Prod>aa. (if aa < length L then L[var := x] ! aa else 0) ^\n                           lookup a aa))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a. lookup (mapping_of p) a *\n                                (\\<Prod>aa. (if aa < length L\n       then L[var := y] ! aa else 0) ^\n      lookup a aa)) =\n                      (\\<Sum>a. lookup (mapping_of p) a *\n                                (\\<Prod>aa. (if aa < length L\n       then L[var := x] ! aa else 0) ^\n      lookup a aa))", "apply(rule Sum_any.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa))\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a *\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         lookup (mapping_of p) a *\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa))\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "using not_contains_insertion_helper[of p var _ L y x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n   \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'c))\\<rbrakk>\n  \\<Longrightarrow> lookup (mapping_of p) ?a = 0 \\<or>\n                    (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\n                                 else 0) ^\n                                lookup ?a aa) =\n                    (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                                 else 0) ^\n                                lookup ?a aa)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa))\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa));\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n            \\<And>k f.\n               (k \\<notin> keys f) = (lookup f k = (0::?'c19))\\<rbrakk>\n           \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := y] ! aa else 0) ^\n   lookup a aa) =\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := x] ! aa else 0) ^\n   lookup a aa)\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "fix a :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa));\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n            \\<And>k f.\n               (k \\<notin> keys f) = (lookup f k = (0::?'c19))\\<rbrakk>\n           \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := y] ! aa else 0) ^\n   lookup a aa) =\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := x] ! aa else 0) ^\n   lookup a aa)\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "assume a1: \"\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa));\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n            \\<And>k f.\n               (k \\<notin> keys f) = (lookup f k = (0::?'c19))\\<rbrakk>\n           \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := y] ! aa else 0) ^\n   lookup a aa) =\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := x] ! aa else 0) ^\n   lookup a aa)\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "assume \"\\<And>k f. ((k::'a) \\<notin> keys f) = (lookup f k = 0)\""], ["proof (state)\nthis:\n  (?k1 \\<notin> keys ?f1) = (lookup ?f1 ?k1 = (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n        \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'b2));\n        val =\n        (\\<Sum>a. lookup (mapping_of p) a *\n                  (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                               else 0) ^\n                              lookup a aa));\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n            \\<And>k f.\n               (k \\<notin> keys f) = (lookup f k = (0::?'c19))\\<rbrakk>\n           \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := y] ! aa else 0) ^\n   lookup a aa) =\n                             (\\<Prod>aa. (if aa < length L\n    then L[var := x] ! aa else 0) ^\n   lookup a aa)\\<rbrakk>\n       \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or>\n                         (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\nelse 0) ^\n                                     lookup a aa) =\n                         (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\nelse 0) ^\n                                     lookup a aa)", "then"], ["proof (chain)\npicking this:\n  (?k1 \\<notin> keys ?f1) = (lookup ?f1 ?k1 = (0::'b))", "show \"lookup (mapping_of p) a = 0 \\<or> (\\<Prod>n. (if n < length L then L[var := y] ! n else 0) ^ lookup a n) = (\\<Prod>n. (if n < length L then L[var := x] ! n else 0) ^ lookup a n)\""], ["proof (prove)\nusing this:\n  (?k1 \\<notin> keys ?f1) = (lookup ?f1 ?k1 = (0::'b))\n\ngoal (1 subgoal):\n 1. lookup (mapping_of p) a = 0 \\<or>\n    (\\<Prod>n. (if n < length L then L[var := y] ! n else 0) ^ lookup a n) =\n    (\\<Prod>n. (if n < length L then L[var := x] ! n else 0) ^ lookup a n)", "using a1 \\<open>\\<And>a. \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x; \\<And>k f. (k \\<notin> keys f) = (lookup f k = 0)\\<rbrakk> \\<Longrightarrow> lookup (mapping_of p) a = 0 \\<or> (\\<Prod>aa. (if aa < length L then L[var := y] ! aa else 0) ^ lookup a aa) = (\\<Prod>aa. (if aa < length L then L[var := x] ! aa else 0) ^ lookup a aa)\\<close>"], ["proof (prove)\nusing this:\n  (?k1 \\<notin> keys ?f1) = (lookup ?f1 ?k1 = (0::'b))\n  \\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x\n  \\<lbrakk>\\<forall>x\\<in>keys (mapping_of p). var \\<notin> keys x;\n   \\<And>k f. (k \\<notin> keys f) = (lookup f k = (0::?'d))\\<rbrakk>\n  \\<Longrightarrow> lookup (mapping_of p) ?a = 0 \\<or>\n                    (\\<Prod>aa. (if aa < length L then L[var := y] ! aa\n                                 else 0) ^\n                                lookup ?a aa) =\n                    (\\<Prod>aa. (if aa < length L then L[var := x] ! aa\n                                 else 0) ^\n                                lookup ?a aa)\n\ngoal (1 subgoal):\n 1. lookup (mapping_of p) a = 0 \\<or>\n    (\\<Prod>n. (if n < length L then L[var := y] ! n else 0) ^ lookup a n) =\n    (\\<Prod>n. (if n < length L then L[var := x] ! n else 0) ^ lookup a n)", "by blast"], ["proof (state)\nthis:\n  lookup (mapping_of p) a = 0 \\<or>\n  (\\<Prod>n. (if n < length L then L[var := y] ! n else 0) ^ lookup a n) =\n  (\\<Prod>n. (if n < length L then L[var := x] ! n else 0) ^ lookup a n)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Insertion Lemmas\""], ["", "lemma insertion_sum_var : \"((insertion f (\\<Sum>i\\<in>{0..<(n::nat)}.g(i))) = (\\<Sum>i\\<in>{0..<n}. insertion f (g i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (sum g {0..<n}) = (\\<Sum>i = 0..<n. insertion f (g i))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. insertion f (sum g {0..<0}) = (\\<Sum>i = 0..<0. insertion f (g i))\n 2. \\<And>n.\n       insertion f (sum g {0..<n}) =\n       (\\<Sum>i = 0..<n. insertion f (g i)) \\<Longrightarrow>\n       insertion f (sum g {0..<Suc n}) =\n       (\\<Sum>i = 0..<Suc n. insertion f (g i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. insertion f (sum g {0..<0}) = (\\<Sum>i = 0..<0. insertion f (g i))\n 2. \\<And>n.\n       insertion f (sum g {0..<n}) =\n       (\\<Sum>i = 0..<n. insertion f (g i)) \\<Longrightarrow>\n       insertion f (sum g {0..<Suc n}) =\n       (\\<Sum>i = 0..<Suc n. insertion f (g i))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (sum g {0..<0}) = (\\<Sum>i = 0..<0. insertion f (g i))", "by auto"], ["proof (state)\nthis:\n  insertion f (sum g {0..<0}) = (\\<Sum>i = 0..<0. insertion f (g i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       insertion f (sum g {0..<n}) =\n       (\\<Sum>i = 0..<n. insertion f (g i)) \\<Longrightarrow>\n       insertion f (sum g {0..<Suc n}) =\n       (\\<Sum>i = 0..<Suc n. insertion f (g i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       insertion f (sum g {0..<n}) =\n       (\\<Sum>i = 0..<n. insertion f (g i)) \\<Longrightarrow>\n       insertion f (sum g {0..<Suc n}) =\n       (\\<Sum>i = 0..<Suc n. insertion f (g i))", "case (Suc n)"], ["proof (state)\nthis:\n  insertion f (sum g {0..<n}) = (\\<Sum>i = 0..<n. insertion f (g i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       insertion f (sum g {0..<n}) =\n       (\\<Sum>i = 0..<n. insertion f (g i)) \\<Longrightarrow>\n       insertion f (sum g {0..<Suc n}) =\n       (\\<Sum>i = 0..<Suc n. insertion f (g i))", "then"], ["proof (chain)\npicking this:\n  insertion f (sum g {0..<n}) = (\\<Sum>i = 0..<n. insertion f (g i))", "show ?case"], ["proof (prove)\nusing this:\n  insertion f (sum g {0..<n}) = (\\<Sum>i = 0..<n. insertion f (g i))\n\ngoal (1 subgoal):\n 1. insertion f (sum g {0..<Suc n}) =\n    (\\<Sum>i = 0..<Suc n. insertion f (g i))", "by (simp add: insertion_add)"], ["proof (state)\nthis:\n  insertion f (sum g {0..<Suc n}) = (\\<Sum>i = 0..<Suc n. insertion f (g i))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* changed to explicitly typecast n as a nat *)"], ["", "lemma insertion_sum : \"\\<forall>(n::nat). ((insertion f (\\<Sum>i\\<in>{0..<n}.g(i))) = (\\<Sum>i\\<in>{0..<n}. insertion f (g i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       insertion f (sum g {0..<n}) = (\\<Sum>i = 0..<n. insertion f (g i))", "using insertion_sum_var"], ["proof (prove)\nusing this:\n  insertion ?f (sum ?g {0..<?n}) = (\\<Sum>i = 0..<?n. insertion ?f (?g i))\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       insertion f (sum g {0..<n}) = (\\<Sum>i = 0..<n. insertion f (g i))", "by blast"], ["", "lemma insertion_sum' : \"\\<And>(n::nat). ((insertion f (\\<Sum>i\\<le>n. g(i))) = (\\<Sum>i\\<le>n. insertion f (g i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. insertion f (sum g {..n}) = (\\<Sum>i\\<le>n. insertion f (g i))", "by (metis (no_types, lifting) fun_sum_commute insertion_add insertion_zero sum.cong)"], ["", "lemma insertion_pow : \"insertion f (p^i) = (insertion f p)^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (p ^ i) = insertion f p ^ i", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. insertion f (p ^ 0) = insertion f p ^ 0\n 2. \\<And>i.\n       insertion f (p ^ i) = insertion f p ^ i \\<Longrightarrow>\n       insertion f (p ^ Suc i) = insertion f p ^ Suc i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. insertion f (p ^ 0) = insertion f p ^ 0\n 2. \\<And>i.\n       insertion f (p ^ i) = insertion f p ^ i \\<Longrightarrow>\n       insertion f (p ^ Suc i) = insertion f p ^ Suc i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (p ^ 0) = insertion f p ^ 0", "by auto"], ["proof (state)\nthis:\n  insertion f (p ^ 0) = insertion f p ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       insertion f (p ^ i) = insertion f p ^ i \\<Longrightarrow>\n       insertion f (p ^ Suc i) = insertion f p ^ Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       insertion f (p ^ i) = insertion f p ^ i \\<Longrightarrow>\n       insertion f (p ^ Suc i) = insertion f p ^ Suc i", "case (Suc n)"], ["proof (state)\nthis:\n  insertion f (p ^ n) = insertion f p ^ n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       insertion f (p ^ i) = insertion f p ^ i \\<Longrightarrow>\n       insertion f (p ^ Suc i) = insertion f p ^ Suc i", "then"], ["proof (chain)\npicking this:\n  insertion f (p ^ n) = insertion f p ^ n", "show ?case"], ["proof (prove)\nusing this:\n  insertion f (p ^ n) = insertion f p ^ n\n\ngoal (1 subgoal):\n 1. insertion f (p ^ Suc n) = insertion f p ^ Suc n", "by (simp add: insertion_mult)"], ["proof (state)\nthis:\n  insertion f (p ^ Suc n) = insertion f p ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_neg : \"insertion f (-p) = -insertion f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (- p) = - insertion f p", "by (metis add.inverse_inverse insertionNegative)"], ["", "lemma insertion_var : \n  \"length L > var \\<Longrightarrow> insertion (nth_default 0 (list_update L var x)) (Var var) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length L \\<Longrightarrow>\n    insertion (nth_default (0::'a) (L[var := x])) (Var var) = x", "by (auto simp: monomials_Var coeff_Var insertion_code nth_default_def)"], ["", "lemma insertion_var_zero : \"insertion (nth_default 0 (x#xs)) (Var 0) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (x # xs)) (Var 0) = x", "using insertion_var"], ["proof (prove)\nusing this:\n  ?var < length ?L \\<Longrightarrow>\n  insertion (nth_default (0::?'a) (?L[?var := ?x])) (Var ?var) = ?x\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (x # xs)) (Var 0) = x", "by fastforce"], ["", "lemma notIn_insertion_sub : \"x\\<notin>vars(p::real mpoly) \\<Longrightarrow> x\\<notin>vars(q::real mpoly)\n                             \\<Longrightarrow> insertion f (p-q) = insertion f p - insertion f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> vars p; x \\<notin> vars q\\<rbrakk>\n    \\<Longrightarrow> insertion f (p - q) = insertion f p - insertion f q", "by (metis ab_group_add_class.ab_diff_conv_add_uminus insertion_add insertion_neg)"], ["", "lemma insertion_sub : \"insertion f (A-B :: real mpoly) = insertion f A - insertion f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (A - B) = insertion f A - insertion f B", "using insertion_neg insertion_add"], ["proof (prove)\nusing this:\n  insertion ?f (- ?p) = - insertion ?f ?p\n  insertion ?f (?p + ?q) = insertion ?f ?p + insertion ?f ?q\n\ngoal (1 subgoal):\n 1. insertion f (A - B) = insertion f A - insertion f B", "by (metis uminus_add_conv_diff)"], ["", "lemma insertion_four : \"insertion ((nth_default 0) xs) 4 = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) xs) 4 = (4::'a)", "by (metis (no_types, lifting) insertion_add insertion_one numeral_plus_numeral one_add_one semiring_norm(2) semiring_norm(6))"], ["", "lemma insertion_add_ind_basecase:\n  \"insertion (nth (list_update L var x)) ((\\<Sum>i::nat \\<le> 0. isolate_variable_sparse p var i * (Var var)^i))\n  = (\\<Sum>i = 0..<(0+1).  insertion (nth (list_update L var x)) (isolate_variable_sparse p var i * (Var var)^i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion ((!) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion ((!) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion ((!) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion ((!) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "have h1: \"((\\<Sum>i::nat \\<le> 0. isolate_variable_sparse p var i * (Var var)^i))\n   = (isolate_variable_sparse p var 0 * (Var var)^0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    isolate_variable_sparse p var 0 * Var var ^ 0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n  isolate_variable_sparse p var 0 * Var var ^ 0\n\ngoal (1 subgoal):\n 1. insertion ((!) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion ((!) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion ((!) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion ((!) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "using h1"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n  isolate_variable_sparse p var 0 * Var var ^ 0\n\ngoal (1 subgoal):\n 1. insertion ((!) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion ((!) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "by auto"], ["proof (state)\nthis:\n  insertion ((!) (L[var := x]))\n   (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<0 + 1.\n      insertion ((!) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_add_ind:\n  \"insertion (nth_default 0 (list_update L var x)) ((\\<Sum>i::nat \\<le> d. isolate_variable_sparse p var i * (Var var)^i))\n  = (\\<Sum>i = 0..<(d+1).  insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse p var i * (Var var)^i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "proof (induction d)"], ["proof (state)\ngoal (2 subgoals):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))\n 2. \\<And>d.\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i *\n             Var var ^ i)) \\<Longrightarrow>\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>Suc d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<Suc d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i * Var var ^ i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))\n 2. \\<And>d.\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i *\n             Var var ^ i)) \\<Longrightarrow>\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>Suc d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<Suc d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i * Var var ^ i))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "using insertion_add_ind_basecase nth_default_def"], ["proof (prove)\nusing this:\n  insertion ((!) (?L[?var := ?x]))\n   (\\<Sum>i\\<le>0. isolate_variable_sparse ?p ?var i * Var ?var ^ i) =\n  (\\<Sum>i = 0..<0 + 1.\n      insertion ((!) (?L[?var := ?x]))\n       (isolate_variable_sparse ?p ?var i * Var ?var ^ i))\n  nth_default ?dflt ?xs ?n = (if ?n < length ?xs then ?xs ! ?n else ?dflt)\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<0 + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default (0::'a) (L[var := x]))\n   (\\<Sum>i\\<le>0. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<0 + 1.\n      insertion (nth_default (0::'a) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i *\n             Var var ^ i)) \\<Longrightarrow>\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>Suc d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<Suc d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i * Var var ^ i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i *\n             Var var ^ i)) \\<Longrightarrow>\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>Suc d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<Suc d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i * Var var ^ i))", "case (Suc n)"], ["proof (state)\nthis:\n  insertion (nth_default (0::'a) (L[var := x]))\n   (\\<Sum>i\\<le>n. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<n + 1.\n      insertion (nth_default (0::'a) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i *\n             Var var ^ i)) \\<Longrightarrow>\n       insertion (nth_default (0::'a) (L[var := x]))\n        (\\<Sum>i\\<le>Suc d. isolate_variable_sparse p var i * Var var ^ i) =\n       (\\<Sum>i = 0..<Suc d + 1.\n           insertion (nth_default (0::'a) (L[var := x]))\n            (isolate_variable_sparse p var i * Var var ^ i))", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default (0::'a) (L[var := x]))\n   (\\<Sum>i\\<le>n. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<n + 1.\n      insertion (nth_default (0::'a) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))", "show ?case"], ["proof (prove)\nusing this:\n  insertion (nth_default (0::'a) (L[var := x]))\n   (\\<Sum>i\\<le>n. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<n + 1.\n      insertion (nth_default (0::'a) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>Suc n. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<Suc n + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "using insertion_add"], ["proof (prove)\nusing this:\n  insertion (nth_default (0::'a) (L[var := x]))\n   (\\<Sum>i\\<le>n. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<n + 1.\n      insertion (nth_default (0::'a) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n  insertion ?f (?p + ?q) = insertion ?f ?p + insertion ?f ?q\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (L[var := x]))\n     (\\<Sum>i\\<le>Suc n. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i = 0..<Suc n + 1.\n        insertion (nth_default (0::'a) (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default (0::'a) (L[var := x]))\n              (\\<Sum>i\\<le>n.\n                  isolate_variable_sparse p var i * Var var ^ i) =\n             (\\<Sum>i = 0..<n.\n                 insertion (nth_default (0::'a) (L[var := x]))\n                  (isolate_variable_sparse p var i * Var var ^ i)) +\n             insertion (nth_default (0::'a) (L[var := x]))\n              (isolate_variable_sparse p var n * Var var ^ n);\n     \\<And>f p q.\n        insertion f (p + q) = insertion f p + insertion f q\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default (0::'a) (L[var := x]))\n                       ((\\<Sum>i\\<le>n.\n                            isolate_variable_sparse p var i * Var var ^ i) +\n                        isolate_variable_sparse p var (Suc n) *\n                        (Var var * Var var ^ n)) =\n                      (\\<Sum>i = 0..<n.\n                          insertion (nth_default (0::'a) (L[var := x]))\n                           (isolate_variable_sparse p var i *\n                            Var var ^ i)) +\n                      insertion (nth_default (0::'a) (L[var := x]))\n                       (isolate_variable_sparse p var n * Var var ^ n) +\n                      insertion (nth_default (0::'a) (L[var := x]))\n                       (isolate_variable_sparse p var (Suc n) *\n                        (Var var * Var var ^ n))", "by (simp add: insertion_add)"], ["proof (state)\nthis:\n  insertion (nth_default (0::'a) (L[var := x]))\n   (\\<Sum>i\\<le>Suc n. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i = 0..<Suc n + 1.\n      insertion (nth_default (0::'a) (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_over_degree_insertion :\n  assumes lLength : \"length L > var\"\n  assumes deg : \"MPoly_Type.degree (p::real mpoly) var = d\"\n  shows \"(\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse p var i) * (x^i))\n          = insertion (nth_default 0 (list_update L var x)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "have h1: \"(p::real mpoly) = (\\<Sum>i::nat \\<le>(MPoly_Type.degree p var). isolate_variable_sparse p var i * (Var var)^i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>MPoly_Type.degree p var.\n        isolate_variable_sparse p var i * Var var ^ i)", "using sum_over_zero"], ["proof (prove)\nusing this:\n  ?mp =\n  (\\<Sum>i\\<le>MPoly_Type.degree ?mp ?x.\n      isolate_variable_sparse ?mp ?x i * Var ?x ^ i)\n\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>MPoly_Type.degree p var.\n        isolate_variable_sparse p var i * Var var ^ i)", "by auto"], ["proof (state)\nthis:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "have h2: \"insertion (nth_default 0 (list_update L var x)) p = \n    insertion (nth_default 0 (list_update L var x)) ((\\<Sum>i::nat \\<le> d. isolate_variable_sparse p var i * (Var var)^i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x])) p =\n    insertion (nth_default 0 (L[var := x]))\n     (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i)", "using h1 deg"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n  MPoly_Type.degree p var = d\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x])) p =\n    insertion (nth_default 0 (L[var := x]))\n     (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i)", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L[var := x])) p =\n  insertion (nth_default 0 (L[var := x]))\n   (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "have h3:  \"insertion (nth_default 0 (list_update L var x)) p = (\\<Sum>i = 0..<(d+1).  insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse p var i * (Var var)^i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x])) p =\n    (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "using h2 insertion_add_ind nth_default_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L[var := x])) p =\n  insertion (nth_default 0 (L[var := x]))\n   (\\<Sum>i\\<le>d. isolate_variable_sparse p var i * Var var ^ i)\n  insertion (nth_default (0::?'a) (?L[?var := ?x]))\n   (\\<Sum>i\\<le>?d. isolate_variable_sparse ?p ?var i * Var ?var ^ i) =\n  (\\<Sum>i = 0..<?d + 1.\n      insertion (nth_default (0::?'a) (?L[?var := ?x]))\n       (isolate_variable_sparse ?p ?var i * Var ?var ^ i))\n  nth_default ?dflt ?xs ?n = (if ?n < length ?xs then ?xs ! ?n else ?dflt)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x])) p =\n    (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i * Var var ^ i))", "by (simp add: )"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L[var := x])) p =\n  (\\<Sum>i = 0..<d + 1.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "using h3 insertion_var insertion_pow"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L[var := x])) p =\n  (\\<Sum>i = 0..<d + 1.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i * Var var ^ i))\n  ?var < length ?L \\<Longrightarrow>\n  insertion (nth_default (0::?'a) (?L[?var := ?x])) (Var ?var) = ?x\n  insertion ?f (?p ^ ?i) = insertion ?f ?p ^ ?i\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<d + 1.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (L[var := x])) p", "by (metis (no_types, lifting) insertion_mult lLength sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<d + 1.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  insertion (nth_default 0 (L[var := x])) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_isovarspars_free :\n  \"insertion (nth_default 0 (list_update L var x)) (isolate_variable_sparse (p::real mpoly) var (i::nat))\n  =insertion (nth_default 0 (list_update L var y)) (isolate_variable_sparse (p::real mpoly) var (i::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x]))\n     (isolate_variable_sparse p var i) =\n    insertion (nth_default 0 (L[var := y]))\n     (isolate_variable_sparse p var i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x]))\n     (isolate_variable_sparse p var i) =\n    insertion (nth_default 0 (L[var := y]))\n     (isolate_variable_sparse p var i)", "have h : \"var \\<notin> vars(isolate_variable_sparse (p::real mpoly) var (i::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var i)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars (isolate_variable_sparse p var i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x]))\n     (isolate_variable_sparse p var i) =\n    insertion (nth_default 0 (L[var := y]))\n     (isolate_variable_sparse p var i)", "then"], ["proof (chain)\npicking this:\n  var \\<notin> vars (isolate_variable_sparse p var i)", "show ?thesis"], ["proof (prove)\nusing this:\n  var \\<notin> vars (isolate_variable_sparse p var i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x]))\n     (isolate_variable_sparse p var i) =\n    insertion (nth_default 0 (L[var := y]))\n     (isolate_variable_sparse p var i)", "using not_contains_insertion"], ["proof (prove)\nusing this:\n  var \\<notin> vars (isolate_variable_sparse p var i)\n  \\<lbrakk>?var \\<notin> vars ?p;\n   insertion (nth_default 0 (?L[?var := ?x])) ?p = ?val\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?L[?var := ?y])) ?p = ?val\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var := x]))\n     (isolate_variable_sparse p var i) =\n    insertion (nth_default 0 (L[var := y]))\n     (isolate_variable_sparse p var i)", "by blast"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L[var := x]))\n   (isolate_variable_sparse p var i) =\n  insertion (nth_default 0 (L[var := y])) (isolate_variable_sparse p var i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_zero : \"insertion f (Const 0 ::real mpoly) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Const 0) = 0", "by (metis add_cancel_right_right add_zero insertion_zero)"], ["", "lemma insertion_one : \"insertion f (Const 1 ::real mpoly) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Const 1) = 1", "by (metis insertion_one mult.right_neutral mult_one_left)"], ["", "lemma insertion_const : \"insertion f (Const c::real mpoly) = (c::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Const c) = c", "by (auto simp: monomials_Const coeff_Const insertion_code)"], ["", "subsection \"Putting Things Together\""], ["", "subsubsection \"More Degree Lemmas\""], ["", "lemma degree_add_leq : \n  assumes h1 : \"MPoly_Type.degree a var \\<le> x\"\n  assumes h2 : \"MPoly_Type.degree b var \\<le> x\"\n  shows \"MPoly_Type.degree (a+b) var \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var \\<le> x", "using degree_eq_iff coeff_add coeff_not_in_monomials"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n  MPoly_Type.coeff (?p + ?q) ?m =\n  MPoly_Type.coeff ?p ?m + MPoly_Type.coeff ?q ?m\n  ?x \\<notin> monomials ?m \\<Longrightarrow>\n  MPoly_Type.coeff ?m ?x = (0::?'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var \\<le> x", "by (smt (z3) More_MPoly_Type.coeff_add add.left_neutral coeff_eq_zero_iff degree_le_iff h1 h2)"], ["", "lemma degree_add_less : \n  assumes h1 : \"MPoly_Type.degree a var < x\"\n  assumes h2 : \"MPoly_Type.degree b var < x\"\n  shows \"MPoly_Type.degree (a+b) var < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "obtain pp :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a mpoly \\<Rightarrow> nat \\<Rightarrow>\\<^sub>0 nat\" where\n    \"\\<forall>x0 x1 x2. (\\<exists>v3. v3 \\<in> monomials x2 \\<and> \\<not> lookup v3 x1 < x0) = (pp x0 x1 x2 \\<in> monomials x2 \\<and> \\<not> lookup (pp x0 x1 x2) x1 < x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<forall>x0 x1 x2.\n           (\\<exists>v3.\n               v3 \\<in> monomials x2 \\<and> \\<not> lookup v3 x1 < x0) =\n           (pp x0 x1 x2 \\<in> monomials x2 \\<and>\n            \\<not> lookup (pp x0 x1 x2) x1 < x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> monomials x2 \\<and> \\<not> lookup v3 x1 < x0) =\n     (pp x0 x1 x2 \\<in> monomials x2 \\<and>\n      \\<not> lookup (pp x0 x1 x2) x1 < x0)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> monomials x2 \\<and> \\<not> lookup v3 x1 < x0) =\n     (pp x0 x1 x2 \\<in> monomials x2 \\<and>\n      \\<not> lookup (pp x0 x1 x2) x1 < x0)", "have f1: \"\\<forall>m n na. (\\<not> MPoly_Type.degree m n < na \\<or> 0 < na \\<and> (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and> (MPoly_Type.degree m n < na \\<or> \\<not> 0 < na \\<or> pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> monomials x2 \\<and> \\<not> lookup v3 x1 < x0) =\n     (pp x0 x1 x2 \\<in> monomials x2 \\<and>\n      \\<not> lookup (pp x0 x1 x2) x1 < x0)\n\ngoal (1 subgoal):\n 1. \\<forall>m n na.\n       (\\<not> MPoly_Type.degree m n < na \\<or>\n        0 < na \\<and>\n        (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and>\n       (MPoly_Type.degree m n < na \\<or>\n        \\<not> 0 < na \\<or>\n        pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)", "by (metis (no_types) degree_less_iff)"], ["proof (state)\nthis:\n  \\<forall>m n na.\n     (\\<not> MPoly_Type.degree m n < na \\<or>\n      0 < na \\<and>\n      (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and>\n     (MPoly_Type.degree m n < na \\<or>\n      \\<not> 0 < na \\<or>\n      pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "then"], ["proof (chain)\npicking this:\n  \\<forall>m n na.\n     (\\<not> MPoly_Type.degree m n < na \\<or>\n      0 < na \\<and>\n      (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and>\n     (MPoly_Type.degree m n < na \\<or>\n      \\<not> 0 < na \\<or>\n      pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)", "have \"0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)\""], ["proof (prove)\nusing this:\n  \\<forall>m n na.\n     (\\<not> MPoly_Type.degree m n < na \\<or>\n      0 < na \\<and>\n      (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and>\n     (MPoly_Type.degree m n < na \\<or>\n      \\<not> 0 < na \\<or>\n      pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>m n na.\n     (\\<not> MPoly_Type.degree m n < na \\<or>\n      0 < na \\<and>\n      (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and>\n     (MPoly_Type.degree m n < na \\<or>\n      \\<not> 0 < na \\<or>\n      pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)\n  MPoly_Type.degree a var < x\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)", "by presburger"], ["proof (state)\nthis:\n  0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "then"], ["proof (chain)\npicking this:\n  0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "using f1"], ["proof (prove)\nusing this:\n  0 < x \\<and> (\\<forall>p. p \\<notin> monomials a \\<or> lookup p var < x)\n  \\<forall>m n na.\n     (\\<not> MPoly_Type.degree m n < na \\<or>\n      0 < na \\<and>\n      (\\<forall>p. p \\<notin> monomials m \\<or> lookup p n < na)) \\<and>\n     (MPoly_Type.degree m n < na \\<or>\n      \\<not> 0 < na \\<or>\n      pp na n m \\<in> monomials m \\<and> \\<not> lookup (pp na n m) n < na)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (a + b) var < x", "by (metis MPolyExtension.coeff_add add.left_neutral assms(2) coeff_eq_zero_iff)"], ["proof (state)\nthis:\n  MPoly_Type.degree (a + b) var < x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_sum : \"(\\<forall>i\\<in>{0..n::nat}. MPoly_Type.degree (f i :: real mpoly) var \\<le> x) \\<Longrightarrow> (MPoly_Type.degree (\\<Sum>x\\<in>{0..n}. f x) var) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..n}.\n       MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n    MPoly_Type.degree (sum f {0..n}) var \\<le> x", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{0..0}.\n       MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n    MPoly_Type.degree (sum f {0..0}) var \\<le> x\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var \\<le> x;\n        \\<forall>i\\<in>{0..Suc n}.\n           MPoly_Type.degree (f i) var \\<le> x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x", "case 0"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var \\<le> x\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{0..0}.\n       MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n    MPoly_Type.degree (sum f {0..0}) var \\<le> x\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var \\<le> x;\n        \\<forall>i\\<in>{0..Suc n}.\n           MPoly_Type.degree (f i) var \\<le> x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var \\<le> x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var \\<le> x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (sum f {0..0}) var \\<le> x", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree (sum f {0..0}) var \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var \\<le> x;\n        \\<forall>i\\<in>{0..Suc n}.\n           MPoly_Type.degree (f i) var \\<le> x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var \\<le> x;\n        \\<forall>i\\<in>{0..Suc n}.\n           MPoly_Type.degree (f i) var \\<le> x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..n}.\n     MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) var \\<le> x\n  \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var \\<le> x;\n        \\<forall>i\\<in>{0..Suc n}.\n           MPoly_Type.degree (f i) var \\<le> x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{0..n}.\n     MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) var \\<le> x\n  \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var \\<le> x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..n}.\n     MPoly_Type.degree (f i) var \\<le> x \\<Longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) var \\<le> x\n  \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var \\<le> x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x", "by(simp add: degree_add_leq)"], ["proof (state)\nthis:\n  MPoly_Type.degree (sum f {0..Suc n}) var \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_sum_less : \"(\\<forall>i\\<in>{0..n::nat}. MPoly_Type.degree (f i :: real mpoly) var < x) \\<Longrightarrow> (MPoly_Type.degree (\\<Sum>x\\<in>{0..n}. f x) var) < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..n}. MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n    MPoly_Type.degree (sum f {0..n}) var < x", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n    MPoly_Type.degree (sum f {0..0}) var < x\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var < x;\n        \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var < x", "case 0"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var < x\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n    MPoly_Type.degree (sum f {0..0}) var < x\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var < x;\n        \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var < x", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var < x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..0}. MPoly_Type.degree (f i) var < x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (sum f {0..0}) var < x", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree (sum f {0..0}) var < x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var < x;\n        \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var < x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var < x;\n        \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var < x", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..n}. MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) var < x\n  \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<in>{0..n}.\n                   MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n                MPoly_Type.degree (sum f {0..n}) var < x;\n        \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree (sum f {0..Suc n}) var < x", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{0..n}. MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) var < x\n  \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..n}. MPoly_Type.degree (f i) var < x \\<Longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) var < x\n  \\<forall>i\\<in>{0..Suc n}. MPoly_Type.degree (f i) var < x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (sum f {0..Suc n}) var < x", "by(simp add: degree_add_less)"], ["proof (state)\nthis:\n  MPoly_Type.degree (sum f {0..Suc n}) var < x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma varNotIn_degree : \n  assumes \"var \\<notin> vars p\"\n  shows \"MPoly_Type.degree p var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 0", "have \"\\<forall>m\\<in>monomials p. lookup m var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials p. lookup m var = 0", "using assms"], ["proof (prove)\nusing this:\n  var \\<notin> vars p\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials p. lookup m var = 0", "unfolding vars_def keys_def"], ["proof (prove)\nusing this:\n  var\n  \\<notin> \\<Union>\n            (map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0}) `\n             map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n              (mapping_of p))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials p. lookup m var = 0", "using monomials.rep_eq"], ["proof (prove)\nusing this:\n  var\n  \\<notin> \\<Union>\n            (map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0}) `\n             map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> (0::'a)})\n              (mapping_of p))\n  monomials ?x = keys (mapping_of ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials p. lookup m var = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>m\\<in>monomials p. lookup m var = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>monomials p. lookup m var = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>monomials p. lookup m var = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 0", "using degree_less_iff"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>monomials p. lookup m var = 0\n  (MPoly_Type.degree ?p ?x < ?k) =\n  (0 < ?k \\<and> (\\<forall>m\\<in>monomials ?p. lookup m ?x < ?k))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 0", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_mult_leq : \n  assumes pnonzero: \"(p::real mpoly)\\<noteq>0\"\n  assumes qnonzero: \"(q::real mpoly)\\<noteq>0\"\n  shows \"MPoly_Type.degree ((p::real mpoly) * (q::real mpoly)) var \\<le> (MPoly_Type.degree p var) + (MPoly_Type.degree q var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "proof(cases \"MPoly_Type.degree (p*q) var =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree (p * q) var = 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n 2. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree (p * q) var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree (p * q) var = 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n 2. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree (p * q) var = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (p * q) var = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree (p * q) var\n  \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree (p * q) var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "have hp: \"\\<forall>m\\<in>monomials p. lookup m var \\<le> MPoly_Type.degree p var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials p. lookup m var \\<le> MPoly_Type.degree p var", "using degree_eq_iff"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials p. lookup m var \\<le> MPoly_Type.degree p var", "by (metis zero_le)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>monomials p. lookup m var \\<le> MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "have hq: \"\\<forall>m\\<in>monomials q. lookup m var \\<le> MPoly_Type.degree q var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials q. lookup m var \\<le> MPoly_Type.degree q var", "using degree_eq_iff"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials q. lookup m var \\<le> MPoly_Type.degree q var", "by (metis zero_le)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>monomials q. lookup m var \\<le> MPoly_Type.degree q var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "have hpq: \"\\<forall>m\\<in>{a+b | a b . a \\<in> monomials p \\<and> b \\<in> monomials q}.\n      lookup m var \\<le> (MPoly_Type.degree p var) + (MPoly_Type.degree q var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>{a + b |a b.\n                    a \\<in> monomials p \\<and> b \\<in> monomials q}.\n       lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "by (smt add_le_mono hp hq mem_Collect_eq plus_poly_mapping.rep_eq)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>{a + b |a b.\n                  a \\<in> monomials p \\<and> b \\<in> monomials q}.\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "have h1: \"(\\<forall>m\\<in>monomials (p*q). lookup m var \\<le> (MPoly_Type.degree p var) + (MPoly_Type.degree q var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials (p * q).\n       lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "using mult_monomials_dir_one hpq"], ["proof (prove)\nusing this:\n  monomials (?p * ?q)\n  \\<subseteq> {a + b |a b. a \\<in> monomials ?p \\<and> b \\<in> monomials ?q}\n  \\<forall>m\\<in>{a + b |a b.\n                  a \\<in> monomials p \\<and> b \\<in> monomials q}.\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials (p * q).\n       lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<in>monomials (p * q).\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>monomials (p * q).\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>monomials (p * q).\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "using h1 degree_eq_iff False"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>monomials (p * q).\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n  \\<forall>m\\<in>monomials (p * q).\n     lookup m var \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n  MPoly_Type.degree (p * q) var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) var\n    \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var", "by (simp add: degree_le_iff)"], ["proof (state)\nthis:\n  MPoly_Type.degree (p * q) var\n  \\<le> MPoly_Type.degree p var + MPoly_Type.degree q var\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_exists_monom: \n  assumes \"p\\<noteq>0\"\n  shows  \"\\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "proof(cases \"MPoly_Type.degree p var =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "have h1: \"\\<exists>m\\<in>monomials p. lookup m var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = 0", "unfolding monomials_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>map_fun mapping_of id keys p. lookup m var = 0", "by (metis True assms(1) aux degree_eq_iff in_keys_iff mapping_of_inject monomials.rep_eq monomials_def zero_mpoly.rep_eq)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>monomials p. lookup m var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>monomials p. lookup m var = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>monomials p. lookup m var = 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "using h1"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>monomials p. lookup m var = 0\n  \\<exists>m\\<in>monomials p. lookup m var = 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "using True"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>monomials p. lookup m var = 0\n  \\<exists>m\\<in>monomials p. lookup m var = 0\n  MPoly_Type.degree p var = 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "by simp"], ["proof (state)\nthis:\n  \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "using degree_eq_iff assms(1)"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < MPoly_Type.degree p var;\n     \\<And>p x k.\n        (MPoly_Type.degree p x = k) =\n        (if k = 0 then \\<forall>m\\<in>monomials p. lookup m x = 0\n         else (\\<exists>m\\<in>monomials p. lookup m x = k) \\<and>\n              (\\<forall>m\\<in>monomials p. lookup m x \\<le> k));\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>monomials p.\n                         lookup m var = MPoly_Type.degree p var", "by (metis degree_eq_iff dual_order.strict_iff_order)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>monomials p. lookup m var = MPoly_Type.degree p var\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_not_exists_monom: \n  assumes \"p\\<noteq>0\"\n  shows  \"\\<not> (\\<exists> m\\<in>monomials p. lookup m var > MPoly_Type.degree p var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>m\\<in>monomials p.\n               MPoly_Type.degree p var < lookup m var)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>m\\<in>monomials p.\n               MPoly_Type.degree p var < lookup m var)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>m\\<in>monomials p.\n               MPoly_Type.degree p var < lookup m var)", "using degree_less_iff"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x < ?k) =\n  (0 < ?k \\<and> (\\<forall>m\\<in>monomials ?p. lookup m ?x < ?k))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>m\\<in>monomials p.\n               MPoly_Type.degree p var < lookup m var)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>m\\<in>monomials p.\n             MPoly_Type.degree p var < lookup m var)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_monom: \"MPoly_Type.degree (MPoly_Type.monom x y) v = (if y = 0 then 0 else lookup x v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (MPoly_Type.monom x y) v =\n    (if y = (0::'a) then 0 else lookup x v)", "by (auto simp: degree_eq_iff)"], ["", "lemma degree_plus_disjoint:\n  \"MPoly_Type.degree (p + MPoly_Type.monom m c) v = max (MPoly_Type.degree p v) (MPoly_Type.degree (MPoly_Type.monom m c) v)\"\n  if \"m \\<notin> monomials p\"\n  for p::\"real mpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + MPoly_Type.monom m c) v =\n    max (MPoly_Type.degree p v) (MPoly_Type.degree (MPoly_Type.monom m c) v)", "using that"], ["proof (prove)\nusing this:\n  m \\<notin> monomials p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + MPoly_Type.monom m c) v =\n    max (MPoly_Type.degree p v) (MPoly_Type.degree (MPoly_Type.monom m c) v)", "apply (subst degree_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<notin> monomials p \\<Longrightarrow>\n    if max (MPoly_Type.degree p v)\n        (MPoly_Type.degree (MPoly_Type.monom m c) v) =\n       0\n    then \\<forall>m\\<in>monomials (p + MPoly_Type.monom m c). lookup m v = 0\n    else (\\<exists>ma\\<in>monomials (p + MPoly_Type.monom m c).\n             lookup ma v =\n             max (MPoly_Type.degree p v)\n              (MPoly_Type.degree (MPoly_Type.monom m c) v)) \\<and>\n         (\\<forall>ma\\<in>monomials (p + MPoly_Type.monom m c).\n             lookup ma v\n             \\<le> max (MPoly_Type.degree p v)\n                    (MPoly_Type.degree (MPoly_Type.monom m c) v))", "apply (auto simp: monomials_add_disjoint)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c = 0; MPoly_Type.degree p v = 0;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v = 0\n 2. \\<lbrakk>m \\<notin> monomials p; c = 0;\n     0 < MPoly_Type.degree p v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>monomials p.\n                         lookup m v = MPoly_Type.degree p v\n 3. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c = 0; 0 < MPoly_Type.degree p v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v \\<le> MPoly_Type.degree p v\n 4. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     MPoly_Type.degree p v = 0;\n     MPoly_Type.degree (MPoly_Type.monom m c) v = 0\\<rbrakk>\n    \\<Longrightarrow> lookup m v = 0\n 5. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        MPoly_Type.degree p v = 0;\n        MPoly_Type.degree (MPoly_Type.monom m c) v = 0;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v = 0\n 6. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v)\n         (MPoly_Type.degree (MPoly_Type.monom m c) v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v =\n                      max (MPoly_Type.degree p v)\n                       (MPoly_Type.degree (MPoly_Type.monom m c) v)\n 7. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v\\<rbrakk>\n    \\<Longrightarrow> lookup m v\n                      \\<le> max (MPoly_Type.degree p v)\n                             (MPoly_Type.degree (MPoly_Type.monom m c) v)\n 8. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v)\n                                (MPoly_Type.degree (MPoly_Type.monom m c) v)\n 9. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree (MPoly_Type.monom m c) v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v)\n         (MPoly_Type.degree (MPoly_Type.monom m c) v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v =\n                      max (MPoly_Type.degree p v)\n                       (MPoly_Type.degree (MPoly_Type.monom m c) v)\n 10. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n      0 < MPoly_Type.degree (MPoly_Type.monom m c) v\\<rbrakk>\n     \\<Longrightarrow> lookup m v\n                       \\<le> max (MPoly_Type.degree p v)\n                              (MPoly_Type.degree (MPoly_Type.monom m c) v)\nA total of 11 subgoals...", "apply (auto simp: degree_eq_iff degree_monom)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>m \\<notin> monomials p; c = 0;\n     0 < MPoly_Type.degree p v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>monomials p.\n                         lookup m v = MPoly_Type.degree p v\n 2. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c = 0; 0 < MPoly_Type.degree p v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v \\<le> MPoly_Type.degree p v\n 3. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 4. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)\n 5. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 6. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "apply (metis MPoly_Type.degree_zero degree_exists_monom less_numeral_extra(3))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c = 0; 0 < MPoly_Type.degree p v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v \\<le> MPoly_Type.degree p v\n 2. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 3. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)\n 4. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 5. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "using degree_le_iff"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x \\<le> ?k) =\n  (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k)\n\ngoal (5 subgoals):\n 1. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c = 0; 0 < MPoly_Type.degree p v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v \\<le> MPoly_Type.degree p v\n 2. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 3. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)\n 4. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 5. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 2. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)\n 3. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 4. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "using degree_eq_iff"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n     0 < MPoly_Type.degree p v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 2. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)\n 3. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 4. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "apply (metis max_def neq0_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0;\n        0 < MPoly_Type.degree p v; ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)\n 2. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 3. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "apply (metis degree_eq_iff max.coboundedI1 neq0_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n     \\<forall>ma\\<in>monomials p.\n        lookup ma v \\<noteq>\n        max (MPoly_Type.degree p v) (lookup m v)\\<rbrakk>\n    \\<Longrightarrow> lookup m v = max (MPoly_Type.degree p v) (lookup m v)\n 2. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "apply (metis MPoly_Type.degree_zero degree_exists_monom max_def zero_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "using degree_le_iff max.cobounded1"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x \\<le> ?k) =\n  (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k)\n  ?a \\<le> max ?a ?b\n\ngoal (1 subgoal):\n 1. \\<And>ma.\n       \\<lbrakk>m \\<notin> monomials p; c \\<noteq> 0; 0 < lookup m v;\n        ma \\<in> monomials p\\<rbrakk>\n       \\<Longrightarrow> lookup ma v\n                         \\<le> max (MPoly_Type.degree p v) (lookup m v)", "by blast"], ["", "subsubsection \"More isolate\\\\_variable\\\\_sparse lemmas\""], ["", "lemma isolate_variable_sparse_ne_zeroD:\n  \"isolate_variable_sparse mp v x \\<noteq> 0 \\<Longrightarrow> x \\<le> MPoly_Type.degree mp v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse mp v x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> MPoly_Type.degree mp v", "using isovar_greater_degree leI"], ["proof (prove)\nusing this:\n  \\<forall>i>MPoly_Type.degree ?p ?var.\n     isolate_variable_sparse ?p ?var i = 0\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse mp v x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> MPoly_Type.degree mp v", "by blast"], ["", "context includes poly.lifting begin"], ["", "lift_definition mpoly_to_nested_poly::\"'a::comm_monoid_add mpoly \\<Rightarrow> nat \\<Rightarrow> 'a mpoly Polynomial.poly\" is\n  \"\\<lambda>(mp::'a mpoly) (v::nat) (p::nat). isolate_variable_sparse mp v p\"\n  \\<comment> \\<open>note \\<^const>\\<open>extract_var\\<close> nests the other way around\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       \\<forall>\\<^sub>\\<infinity>n. isolate_variable_sparse mpoly nat n = 0", "unfolding MOST_iff_cofinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       finite {x. isolate_variable_sparse mpoly nat x \\<noteq> 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       finite {x. isolate_variable_sparse mpoly nat x \\<noteq> 0}", "fix mp::\"'a mpoly\" and v::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       finite {x. isolate_variable_sparse mpoly nat x \\<noteq> 0}", "have \"{p. isolate_variable_sparse mp v p \\<noteq> 0} \\<subseteq> {0..MPoly_Type.degree mp v}\"\n    (is \"?s \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. isolate_variable_sparse mp v p \\<noteq> 0}\n    \\<subseteq> {0..MPoly_Type.degree mp v}", "by (auto dest!: isolate_variable_sparse_ne_zeroD)"], ["proof (state)\nthis:\n  {p. isolate_variable_sparse mp v p \\<noteq> 0}\n  \\<subseteq> {0..MPoly_Type.degree mp v}\n\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       finite {x. isolate_variable_sparse mpoly nat x \\<noteq> 0}", "also"], ["proof (state)\nthis:\n  {p. isolate_variable_sparse mp v p \\<noteq> 0}\n  \\<subseteq> {0..MPoly_Type.degree mp v}\n\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       finite {x. isolate_variable_sparse mpoly nat x \\<noteq> 0}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..MPoly_Type.degree mp v}", "by simp"], ["proof (state)\nthis:\n  finite {0..MPoly_Type.degree mp v}\n\ngoal (1 subgoal):\n 1. \\<And>mpoly nat.\n       finite {x. isolate_variable_sparse mpoly nat x \\<noteq> 0}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite {p. isolate_variable_sparse mp v p \\<noteq> 0}", "show \"finite ?s\""], ["proof (prove)\nusing this:\n  finite {p. isolate_variable_sparse mp v p \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite {p. isolate_variable_sparse mp v p \\<noteq> 0}", "."], ["proof (state)\nthis:\n  finite {p. isolate_variable_sparse mp v p \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_eq_0_mpoly_to_nested_polyI:\n  \"mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> MPoly_Type.degree mp v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_nested_poly mp v = 0 \\<Longrightarrow>\n    MPoly_Type.degree mp v = 0", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       isolate_variable_sparse mp v = (\\<lambda>_. 0) \\<Longrightarrow>\n       MPoly_Type.degree mp v = 0", "apply (simp add: degree_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       isolate_variable_sparse mp v = (\\<lambda>_. 0) \\<Longrightarrow>\n       \\<forall>m\\<in>monomials mp. lookup m v = 0", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       (\\<lambda>d.\n           \\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = d.\n             monomial (MPoly_Type.coeff mp m) (Poly_Mapping.update v 0 m)) =\n       (\\<lambda>_. 0) \\<Longrightarrow>\n       \\<forall>m\\<in>monomials mp. lookup m v = 0", "apply (auto simp: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "fix mpa :: \"'a mpoly\" and va :: nat and m :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "assume a1: \"\\<forall>x. (\\<Sum>m | m \\<in> monomials mpa \\<and> lookup m va = x. monomial (MPoly_Type.coeff mpa m) (Poly_Mapping.update va 0 m)) = 0\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<Sum>m | m \\<in> monomials mpa \\<and> lookup m va = x.\n        monomial (MPoly_Type.coeff mpa m) (Poly_Mapping.update va 0 m)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "assume a2: \"m \\<in> monomials mpa\""], ["proof (state)\nthis:\n  m \\<in> monomials mpa\n\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "have f3: \"\\<forall>m p. lookup (mapping_of m) p \\<noteq> (0::'a) \\<or> p \\<notin> monomials m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m p.\n       lookup (mapping_of m) p \\<noteq> (0::'a) \\<or> p \\<notin> monomials m", "by (metis (full_types) coeff_def coeff_eq_zero_iff)"], ["proof (state)\nthis:\n  \\<forall>m p.\n     lookup (mapping_of m) p \\<noteq> (0::'a) \\<or> p \\<notin> monomials m\n\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "have f4: \"\\<forall>n. mapping_of (isolate_variable_sparse mpa va n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. mapping_of (isolate_variable_sparse mpa va n) = 0", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (\\<Sum>m | m \\<in> monomials mpa \\<and> lookup m va = x.\n        monomial (MPoly_Type.coeff mpa m) (Poly_Mapping.update va 0 m)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<forall>n. mapping_of (isolate_variable_sparse mpa va n) = 0", "by (simp add: isolate_variable_sparse.rep_eq)"], ["proof (state)\nthis:\n  \\<forall>n. mapping_of (isolate_variable_sparse mpa va n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "have \"\\<forall>p n. lookup 0 (p::nat \\<Rightarrow>\\<^sub>0 nat) = (0::'a) \\<or> (0::nat) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p n. lookup 0 p = (0::'a) \\<or> 0 = n", "by simp"], ["proof (state)\nthis:\n  \\<forall>p n. lookup 0 p = (0::'a) \\<or> 0 = n\n\ngoal (1 subgoal):\n 1. \\<And>mp v m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        m \\<in> monomials mp\\<rbrakk>\n       \\<Longrightarrow> lookup m v = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>p n. lookup 0 p = (0::'a) \\<or> 0 = n", "show \"lookup m va = 0\""], ["proof (prove)\nusing this:\n  \\<forall>p n. lookup 0 p = (0::'a) \\<or> 0 = n\n\ngoal (1 subgoal):\n 1. lookup m va = 0", "using f4 f3 a2"], ["proof (prove)\nusing this:\n  \\<forall>p n. lookup 0 p = (0::'a) \\<or> 0 = n\n  \\<forall>n. mapping_of (isolate_variable_sparse mpa va n) = 0\n  \\<forall>m p.\n     lookup (mapping_of m) p \\<noteq> (0::'a) \\<or> p \\<notin> monomials m\n  m \\<in> monomials mpa\n\ngoal (1 subgoal):\n 1. lookup m va = 0", "by (metis coeff_def coeff_isolate_variable_sparse lookup_eq_and_update_lemma)"], ["proof (state)\nthis:\n  lookup m va = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_eq_zero_mpoly_to_nested_polyD: \"mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> MPoly_Type.coeff mp 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_nested_poly mp v = 0 \\<Longrightarrow>\n    MPoly_Type.coeff mp 0 = (0::'a)", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       isolate_variable_sparse mp v = (\\<lambda>_. 0) \\<Longrightarrow>\n       MPoly_Type.coeff mp 0 = (0::'a)", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       (\\<lambda>d.\n           \\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = d.\n             monomial (MPoly_Type.coeff mp m) (Poly_Mapping.update v 0 m)) =\n       (\\<lambda>_. 0) \\<Longrightarrow>\n       MPoly_Type.coeff mp 0 = (0::'a)", "by (metis (no_types) coeff_def coeff_isolate_variable_sparse isolate_variable_sparse.rep_eq lookup_zero update_0_0)"], ["", "lemma mpoly_to_nested_poly_eq_zero_iff[simp]:\n  \"mpoly_to_nested_poly mp v = 0 \\<longleftrightarrow> mp = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mpoly_to_nested_poly mp v = 0) = (mp = 0)", "apply (auto simp: coeff_eq_zero_mpoly_to_nested_polyD degree_eq_0_mpoly_to_nested_polyI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> mp = 0\n 2. mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> mp = 0\n 2. mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0", "show \"mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> mp = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> mp = 0", "apply (frule degree_eq_0_mpoly_to_nested_polyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mpoly_to_nested_poly mp v = 0;\n     MPoly_Type.degree mp v = 0\\<rbrakk>\n    \\<Longrightarrow> mp = 0", "apply (frule coeff_eq_zero_mpoly_to_nested_polyD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mpoly_to_nested_poly mp v = 0; MPoly_Type.degree mp v = 0;\n     MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mp = 0", "apply (transfer' fixing: mp v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isolate_variable_sparse mp v = (\\<lambda>_. 0);\n     MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mp = 0", "apply (transfer' fixing: mp v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>d.\n                 \\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = d.\n                   monomial (MPoly_Type.coeff mp m)\n                    (Poly_Mapping.update v 0 m)) =\n             (\\<lambda>_. 0);\n     MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mp = 0", "apply (auto simp: fun_eq_iff mpoly_eq_iff intro!: sum.neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "fix m :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "assume a1: \"\\<forall>x. (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x. monomial (MPoly_Type.coeff mp m) (Poly_Mapping.update v 0 m)) = 0\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n        monomial (MPoly_Type.coeff mp m) (Poly_Mapping.update v 0 m)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "assume a2: \"MPoly_Type.degree mp v = 0\""], ["proof (state)\nthis:\n  MPoly_Type.degree mp v = 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "have \"\\<forall>n. isolate_variable_sparse mp v n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. isolate_variable_sparse mp v n = 0", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n        monomial (MPoly_Type.coeff mp m) (Poly_Mapping.update v 0 m)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<forall>n. isolate_variable_sparse mp v n = 0", "by (simp add: isolate_variable_sparse.abs_eq zero_mpoly.abs_eq)"], ["proof (state)\nthis:\n  \\<forall>n. isolate_variable_sparse mp v n = 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. isolate_variable_sparse mp v n = 0", "have f3: \"\\<forall>p. MPoly_Type.coeff mp p = MPoly_Type.coeff 0 p \\<or> lookup p v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>n. isolate_variable_sparse mp v n = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       MPoly_Type.coeff mp p = MPoly_Type.coeff 0 p \\<or>\n       lookup p v \\<noteq> 0", "by (metis (no_types) coeff_isolate_variable_sparse lookup_update_self)"], ["proof (state)\nthis:\n  \\<forall>p.\n     MPoly_Type.coeff mp p = MPoly_Type.coeff 0 p \\<or>\n     lookup p v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>x.\n                   (\\<Sum>m | m \\<in> monomials mp \\<and> lookup m v = x.\n                      monomial (MPoly_Type.coeff mp m)\n                       (Poly_Mapping.update v 0 m)) =\n                   0;\n        MPoly_Type.degree mp v = 0; MPoly_Type.coeff mp 0 = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff mp m = (0::'a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     MPoly_Type.coeff mp p = MPoly_Type.coeff 0 p \\<or>\n     lookup p v \\<noteq> 0", "show \"MPoly_Type.coeff mp m = 0\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     MPoly_Type.coeff mp p = MPoly_Type.coeff 0 p \\<or>\n     lookup p v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff mp m = (0::'a)", "using a2 coeff_zero"], ["proof (prove)\nusing this:\n  \\<forall>p.\n     MPoly_Type.coeff mp p = MPoly_Type.coeff 0 p \\<or>\n     lookup p v \\<noteq> 0\n  MPoly_Type.degree mp v = 0\n  MPoly_Type.coeff 0 ?x = (0::?'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff mp m = (0::'a)", "by (metis coeff_not_in_monomials degree_eq_iff)"], ["proof (state)\nthis:\n  MPoly_Type.coeff mp m = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mpoly_to_nested_poly mp v = 0 \\<Longrightarrow> mp = 0\n\ngoal (1 subgoal):\n 1. mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0", "show \"mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       mp = 0 \\<Longrightarrow>\n       isolate_variable_sparse 0 v = (\\<lambda>_. 0)", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mp v.\n       mp = (\\<lambda>k. 0::'a) \\<Longrightarrow>\n       (\\<lambda>d.\n           \\<Sum>m | m \\<in> monomials 0 \\<and> lookup m v = d.\n             monomial (MPoly_Type.coeff 0 m) (Poly_Mapping.update v 0 m)) =\n       (\\<lambda>_. 0)", "by (auto simp: fun_eq_iff intro!: sum.neutral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mp = 0 \\<Longrightarrow> mpoly_to_nested_poly 0 v = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isolate_variable_sparse_degree_eq_zero_iff: \"isolate_variable_sparse p v (MPoly_Type.degree p v) = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (isolate_variable_sparse p v (MPoly_Type.degree p v) = 0) = (p = 0)", "apply (transfer')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       ((\\<Sum>m | m \\<in> monomials p \\<and>\n                   lookup m v = MPoly_Type.degree p v.\n           monomial (MPoly_Type.coeff p m) (Poly_Mapping.update v 0 m)) =\n        0) =\n       (p = 0)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       (\\<Sum>m | m \\<in> monomials p \\<and>\n                  lookup m v = MPoly_Type.degree p v.\n          monomial (MPoly_Type.coeff p m) (Poly_Mapping.update v 0 m)) =\n       0 \\<Longrightarrow>\n       p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       (\\<Sum>m | m \\<in> monomials p \\<and>\n                  lookup m v = MPoly_Type.degree p v.\n          monomial (MPoly_Type.coeff p m) (Poly_Mapping.update v 0 m)) =\n       0 \\<Longrightarrow>\n       p = 0", "fix pa :: \"'a mpoly\" and va :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       (\\<Sum>m | m \\<in> monomials p \\<and>\n                  lookup m v = MPoly_Type.degree p v.\n          monomial (MPoly_Type.coeff p m) (Poly_Mapping.update v 0 m)) =\n       0 \\<Longrightarrow>\n       p = 0", "assume \"(\\<Sum>m | m \\<in> monomials pa \\<and> lookup m va = MPoly_Type.degree pa va. monomial (MPoly_Type.coeff pa m) (Poly_Mapping.update va 0 m)) = 0\""], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> monomials pa \\<and>\n             lookup m va = MPoly_Type.degree pa va.\n     monomial (MPoly_Type.coeff pa m) (Poly_Mapping.update va 0 m)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       (\\<Sum>m | m \\<in> monomials p \\<and>\n                  lookup m v = MPoly_Type.degree p v.\n          monomial (MPoly_Type.coeff p m) (Poly_Mapping.update v 0 m)) =\n       0 \\<Longrightarrow>\n       p = 0", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>m | m \\<in> monomials pa \\<and>\n             lookup m va = MPoly_Type.degree pa va.\n     monomial (MPoly_Type.coeff pa m) (Poly_Mapping.update va 0 m)) =\n  0", "have \"mapping_of (isolate_variable_sparse pa va (MPoly_Type.degree pa va)) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>m | m \\<in> monomials pa \\<and>\n             lookup m va = MPoly_Type.degree pa va.\n     monomial (MPoly_Type.coeff pa m) (Poly_Mapping.update va 0 m)) =\n  0\n\ngoal (1 subgoal):\n 1. mapping_of (isolate_variable_sparse pa va (MPoly_Type.degree pa va)) = 0", "by (simp add: isolate_variable_sparse.rep_eq)"], ["proof (state)\nthis:\n  mapping_of (isolate_variable_sparse pa va (MPoly_Type.degree pa va)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       (\\<Sum>m | m \\<in> monomials p \\<and>\n                  lookup m v = MPoly_Type.degree p v.\n          monomial (MPoly_Type.coeff p m) (Poly_Mapping.update v 0 m)) =\n       0 \\<Longrightarrow>\n       p = 0", "then"], ["proof (chain)\npicking this:\n  mapping_of (isolate_variable_sparse pa va (MPoly_Type.degree pa va)) = 0", "show \"pa = 0\""], ["proof (prove)\nusing this:\n  mapping_of (isolate_variable_sparse pa va (MPoly_Type.degree pa va)) = 0\n\ngoal (1 subgoal):\n 1. pa = 0", "by (metis (no_types) coeff_def coeff_eq_zero_iff coeff_isolate_variable_sparse degree_exists_monom lookup_eq_and_update_lemma lookup_zero)"], ["proof (state)\nthis:\n  pa = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_eq_univariate_degree: \"MPoly_Type.degree p v =\n    (if p = 0 then 0 else Polynomial.degree (mpoly_to_nested_poly p v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p v =\n    (if p = 0 then 0 else Polynomial.degree (mpoly_to_nested_poly p v))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree p v = Polynomial.degree (mpoly_to_nested_poly p v)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree p v \\<le> Polynomial.degree (mpoly_to_nested_poly p v)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.degree (mpoly_to_nested_poly p v) \\<le> MPoly_Type.degree p v", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.degree p v \\<le> Polynomial.degree (mpoly_to_nested_poly p v)", "apply (rule Polynomial.le_degree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly.coeff (mpoly_to_nested_poly p v) (MPoly_Type.degree p v) \\<noteq> 0", "apply (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly.coeff (mpoly_to_nested_poly p v) (MPoly_Type.degree p v) =\n     0\\<rbrakk>\n    \\<Longrightarrow> False", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>p \\<noteq> 0;\n        isolate_variable_sparse p v (MPoly_Type.degree p v) = 0\\<rbrakk>\n       \\<Longrightarrow> False", "by (simp add: isolate_variable_sparse_degree_eq_zero_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.degree (mpoly_to_nested_poly p v) \\<le> MPoly_Type.degree p v", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.degree (mpoly_to_nested_poly p v) \\<le> MPoly_Type.degree p v", "apply (rule Polynomial.degree_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>i>MPoly_Type.degree p v.\n       poly.coeff (mpoly_to_nested_poly p v) i = 0", "apply (auto simp: elim!: degree_eq_zeroE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> 0; MPoly_Type.degree p v < i\\<rbrakk>\n       \\<Longrightarrow> poly.coeff (mpoly_to_nested_poly p v) i = 0", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i p v.\n       \\<lbrakk>p \\<noteq> 0; MPoly_Type.degree p v < i\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse p v i = 0", "by (simp add: isovar_greater_degree)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_mpoly_to_nested_poly[code]:\n  \"coeffs (mpoly_to_nested_poly mp v) =\n    (if mp = 0 then []\n    else map (isolate_variable_sparse mp v) [0..<Suc(MPoly_Type.degree mp v)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.coeffs (mpoly_to_nested_poly mp v) =\n    (if mp = 0 then []\n     else map (isolate_variable_sparse mp v)\n           [0..<Suc (MPoly_Type.degree mp v)])", "unfolding coeffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if mpoly_to_nested_poly mp v = 0 then []\n     else map (poly.coeff (mpoly_to_nested_poly mp v))\n           [0..<Suc (Polynomial.degree (mpoly_to_nested_poly mp v))]) =\n    (if mp = 0 then []\n     else map (isolate_variable_sparse mp v)\n           [0..<Suc (MPoly_Type.degree mp v)])", "unfolding mpoly_to_nested_poly_eq_zero_iff degree_eq_univariate_degree"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if mp = 0 then []\n     else map (poly.coeff (mpoly_to_nested_poly mp v))\n           [0..<Suc (Polynomial.degree (mpoly_to_nested_poly mp v))]) =\n    (if mp = 0 then []\n     else map (isolate_variable_sparse mp v)\n           [0..<\n            Suc (if mp = 0 then 0\n                 else Polynomial.degree (mpoly_to_nested_poly mp v))])", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mp \\<noteq> 0;\n        x < Polynomial.degree (mpoly_to_nested_poly mp v)\\<rbrakk>\n       \\<Longrightarrow> poly.coeff (mpoly_to_nested_poly mp v) x =\n                         isolate_variable_sparse mp v x\n 2. mp \\<noteq> 0 \\<Longrightarrow>\n    lead_coeff (mpoly_to_nested_poly mp v) =\n    isolate_variable_sparse mp v\n     (Polynomial.degree (mpoly_to_nested_poly mp v))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mp \\<noteq> 0;\n     x_ < Polynomial.degree (mpoly_to_nested_poly mp v)\\<rbrakk>\n    \\<Longrightarrow> poly.coeff (mpoly_to_nested_poly mp v) x_ =\n                      isolate_variable_sparse mp v x_", "by transfer' (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mp \\<noteq> 0 \\<Longrightarrow>\n    lead_coeff (mpoly_to_nested_poly mp v) =\n    isolate_variable_sparse mp v\n     (Polynomial.degree (mpoly_to_nested_poly mp v))", "by transfer' (rule refl)"], ["", "end"], ["", "lemma isolate_variable_sparse_monom: \"isolate_variable_sparse (MPoly_Type.monom m a) v i =\n  (if a = 0 \\<or> lookup m v \\<noteq> i then 0 else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) v i =\n    (if a = (0::'a) \\<or> lookup m v \\<noteq> i then 0\n     else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) v i =\n    (if a = (0::'a) \\<or> lookup m v \\<noteq> i then 0\n     else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)", "have *: \"{x. x = m \\<and> lookup x v = i} = (if lookup m v = i then {m} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x = m \\<and> lookup x v = i} = (if lookup m v = i then {m} else {})", "by auto"], ["proof (state)\nthis:\n  {x. x = m \\<and> lookup x v = i} = (if lookup m v = i then {m} else {})\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) v i =\n    (if a = (0::'a) \\<or> lookup m v \\<noteq> i then 0\n     else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a) v i =\n    (if a = (0::'a) \\<or> lookup m v \\<noteq> i then 0\n     else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)", "by (transfer' fixing: m a v i) (simp add:*)"], ["proof (state)\nthis:\n  isolate_variable_sparse (MPoly_Type.monom m a) v i =\n  (if a = (0::'a) \\<or> lookup m v \\<noteq> i then 0\n   else MPoly_Type.monom (Poly_Mapping.update v 0 m) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isolate_variable_sparse_monom_mult:\n  \"isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n    (if n \\<ge> lookup m v\n    then MPoly_Type.monom (Poly_Mapping.update v 0 m) a * isolate_variable_sparse q v (n - lookup m v)\n    else 0)\"\n  for q::\"'a::semiring_no_zero_divisors mpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n    (if lookup m v \\<le> n\n     then MPoly_Type.monom (Poly_Mapping.update v 0 m) a *\n          isolate_variable_sparse q v (n - lookup m v)\n     else 0)", "apply (auto simp: MPoly_Type.mult_monom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lookup m v \\<le> n \\<Longrightarrow>\n    isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n    MPoly_Type.monom (Poly_Mapping.update v 0 m) a *\n    isolate_variable_sparse q v (n - lookup m v)\n 2. \\<not> lookup m v \\<le> n \\<Longrightarrow>\n    isolate_variable_sparse (MPoly_Type.monom m a * q) v n = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m v \\<le> n \\<Longrightarrow>\n    isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n    MPoly_Type.monom (Poly_Mapping.update v 0 m) a *\n    isolate_variable_sparse q v (n - lookup m v)", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v n a q.\n       lookup m v \\<le> n \\<Longrightarrow>\n       (\\<Sum>m | m \\<in> monomials (MPoly_Type.monom m a * q) \\<and>\n                  lookup m v = n.\n          monomial (MPoly_Type.coeff (MPoly_Type.monom m a * q) m)\n           (Poly_Mapping.update v 0 m)) =\n       monomial a (Poly_Mapping.update v 0 m) *\n       (\\<Sum>m | m \\<in> monomials q \\<and> lookup m v = n - lookup m v.\n          monomial (MPoly_Type.coeff q m) (Poly_Mapping.update v 0 m))", "subgoal for mon v i a q"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup mon v \\<le> i \\<Longrightarrow>\n    (\\<Sum>m | m \\<in> monomials (MPoly_Type.monom mon a * q) \\<and>\n               lookup m v = i.\n       monomial (MPoly_Type.coeff (MPoly_Type.monom mon a * q) m)\n        (Poly_Mapping.update v 0 m)) =\n    monomial a (Poly_Mapping.update v 0 mon) *\n    (\\<Sum>m | m \\<in> monomials q \\<and> lookup m v = i - lookup mon v.\n       monomial (MPoly_Type.coeff q m) (Poly_Mapping.update v 0 m))", "apply (auto simp add: monomials_monom_mult sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>m | m \\<in> (+) mon ` monomials q \\<and>\n                                 lookup m v = i.\n                         monomial\n                          (MPoly_Type.coeff (MPoly_Type.monom mon a * q) m)\n                          (Poly_Mapping.update v 0 m)) =\n                      (\\<Sum>n\\<in>{m \\<in> monomials q.\n                                    lookup m v = i - lookup mon v}.\n                         monomial a (Poly_Mapping.update v 0 mon) *\n                         monomial (MPoly_Type.coeff q n)\n                          (Poly_Mapping.update v 0 n))", "apply (rule sum.reindex_bij_witness_not_neutral[where\n            j=\"\\<lambda>a. a - mon\"\n            and i=\"\\<lambda>a. mon + a\"\n            and S'=\"{}\"\n            and T'=\"{}\"\n            ])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> finite {}\n 2. \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> finite {}\n 3. \\<And>a.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        a \\<in> {m \\<in> (+) mon ` monomials q. lookup m v = i} -\n                {}\\<rbrakk>\n       \\<Longrightarrow> mon + (a - mon) = a\n 4. \\<And>a.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        a \\<in> {m \\<in> (+) mon ` monomials q. lookup m v = i} -\n                {}\\<rbrakk>\n       \\<Longrightarrow> a - mon\n                         \\<in> {m \\<in> monomials q.\n                                lookup m v = i - lookup mon v} -\n                               {}\n 5. \\<And>b.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        b \\<in> {m \\<in> monomials q. lookup m v = i - lookup mon v} -\n                {}\\<rbrakk>\n       \\<Longrightarrow> mon + b - mon = b\n 6. \\<And>b.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        b \\<in> {m \\<in> monomials q. lookup m v = i - lookup mon v} -\n                {}\\<rbrakk>\n       \\<Longrightarrow> mon + b\n                         \\<in> {m \\<in> (+) mon ` monomials q.\n                                lookup m v = i} -\n                               {}\n 7. \\<And>a.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        a \\<in> {}\\<rbrakk>\n       \\<Longrightarrow> monomial\n                          (MPoly_Type.coeff (MPoly_Type.monom mon a * q) a)\n                          (Poly_Mapping.update v 0 a) =\n                         0\n 8. \\<And>b.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        b \\<in> {}\\<rbrakk>\n       \\<Longrightarrow> monomial a (Poly_Mapping.update v 0 mon) *\n                         monomial (MPoly_Type.coeff q b)\n                          (Poly_Mapping.update v 0 b) =\n                         0\n 9. \\<And>a.\n       \\<lbrakk>lookup mon v \\<le> i; a \\<noteq> (0::'a);\n        a \\<in> {m \\<in> (+) mon ` monomials q. lookup m v = i}\\<rbrakk>\n       \\<Longrightarrow> monomial a (Poly_Mapping.update v 0 mon) *\n                         monomial (MPoly_Type.coeff q (a - mon))\n                          (Poly_Mapping.update v 0 (a - mon)) =\n                         monomial\n                          (MPoly_Type.coeff (MPoly_Type.monom mon a * q) a)\n                          (Poly_Mapping.update v 0 a)", "apply (auto simp: lookup_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<noteq> (0::'a); i = lookup mon v + lookup x v;\n        x \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> monomial a (Poly_Mapping.update v 0 mon) *\n                         monomial (MPoly_Type.coeff q x)\n                          (Poly_Mapping.update v 0 x) =\n                         monomial\n                          (MPoly_Type.coeff (MPoly_Type.monom mon a * q)\n                            (mon + x))\n                          (Poly_Mapping.update v 0 (mon + x))", "apply (auto simp: poly_mapping_eq_iff fun_eq_iff single.rep_eq Poly_Mapping.mult_single)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>a \\<noteq> (0::'a); i = lookup mon v + lookup x v;\n        x \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> (a * MPoly_Type.coeff q x when\n                          (\\<forall>xb.\n                              lookup\n                               (Poly_Mapping.update v 0 mon +\n                                Poly_Mapping.update v 0 x)\n                               xb =\n                              lookup xa xb)) =\n                         (MPoly_Type.coeff (MPoly_Type.monom mon a * q)\n                           (mon + x) when\n                          (\\<forall>xb.\n                              lookup (Poly_Mapping.update v 0 (mon + x))\n                               xb =\n                              lookup xa xb))", "apply (auto simp: when_def More_MPoly_Type.coeff_monom_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>a \\<noteq> (0::'a); i = lookup mon v + lookup x v;\n        x \\<in> monomials q;\n        \\<forall>xb.\n           lookup (Poly_Mapping.update v 0 mon + Poly_Mapping.update v 0 x)\n            xb =\n           lookup xa xb;\n        lookup (Poly_Mapping.update v 0 (mon + x)) xb \\<noteq>\n        lookup xa xb\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff q x = (0::'a)\n 2. \\<And>x xa xb.\n       \\<lbrakk>a \\<noteq> (0::'a); i = lookup mon v + lookup x v;\n        x \\<in> monomials q;\n        lookup (Poly_Mapping.update v 0 mon + Poly_Mapping.update v 0 x)\n         xb \\<noteq>\n        lookup xa xb;\n        \\<forall>xb.\n           lookup (Poly_Mapping.update v 0 (mon + x)) xb =\n           lookup xa xb\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff q x = (0::'a)", "by (auto simp: lookup_update lookup_add split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lookup m v \\<le> n \\<Longrightarrow>\n    isolate_variable_sparse (MPoly_Type.monom m a * q) v n = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lookup m v \\<le> n \\<Longrightarrow>\n    isolate_variable_sparse (MPoly_Type.monom m a * q) v n = 0", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v n a q.\n       \\<not> lookup m v \\<le> n \\<Longrightarrow>\n       (\\<Sum>m | m \\<in> monomials (MPoly_Type.monom m a * q) \\<and>\n                  lookup m v = n.\n          monomial (MPoly_Type.coeff (MPoly_Type.monom m a * q) m)\n           (Poly_Mapping.update v 0 m)) =\n       0", "apply (auto intro!: sum.neutral simp: monomials_monom_mult )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v a q xa.\n       \\<lbrakk>\\<not> lookup m v \\<le> lookup (m + xa) v;\n        a \\<noteq> (0::'a); xa \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> monomial\n                          (MPoly_Type.coeff (MPoly_Type.monom m a * q)\n                            (m + xa))\n                          (Poly_Mapping.update v 0 (m + xa)) =\n                         0", "apply (rule poly_mapping_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v a q xa k.\n       \\<lbrakk>\\<not> lookup m v \\<le> lookup (m + xa) v;\n        a \\<noteq> (0::'a); xa \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (monomial\n                            (MPoly_Type.coeff (MPoly_Type.monom m a * q)\n                              (m + xa))\n                            (Poly_Mapping.update v 0 (m + xa)))\n                          k =\n                         lookup 0 k", "apply (auto simp: lookup_single when_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v a q xa.\n       \\<lbrakk>\\<not> lookup m v \\<le> lookup (m + xa) v;\n        a \\<noteq> (0::'a); xa \\<in> monomials q\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.coeff (MPoly_Type.monom m a * q)\n                          (m + xa) =\n                         (0::'a)", "by (simp add: lookup_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isolate_variable_sparse_mult:\n  \"isolate_variable_sparse (p * q) v n = (\\<Sum>i\\<le>n. isolate_variable_sparse p v i * isolate_variable_sparse q v (n - i))\"\n  for p q::\"'a::semiring_no_zero_divisors mpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (p * q) v n =\n    (\\<Sum>i\\<le>n.\n        isolate_variable_sparse p v i * isolate_variable_sparse q v (n - i))", "proof (induction p rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n       (\\<Sum>i\\<le>n.\n           isolate_variable_sparse (MPoly_Type.monom m a) v i *\n           isolate_variable_sparse q v (n - i))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>isolate_variable_sparse (p1 * q) v n =\n                (\\<Sum>i\\<le>n.\n                    isolate_variable_sparse p1 v i *\n                    isolate_variable_sparse q v (n - i));\n        isolate_variable_sparse (p2 * q) v n =\n        (\\<Sum>i\\<le>n.\n            isolate_variable_sparse p2 v i *\n            isolate_variable_sparse q v (n - i));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse ((p1 + p2) * q) v n =\n                         (\\<Sum>i\\<le>n.\n                             isolate_variable_sparse (p1 + p2) v i *\n                             isolate_variable_sparse q v (n - i))", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n       (\\<Sum>i\\<le>n.\n           isolate_variable_sparse (MPoly_Type.monom m a) v i *\n           isolate_variable_sparse q v (n - i))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>isolate_variable_sparse (p1 * q) v n =\n                (\\<Sum>i\\<le>n.\n                    isolate_variable_sparse p1 v i *\n                    isolate_variable_sparse q v (n - i));\n        isolate_variable_sparse (p2 * q) v n =\n        (\\<Sum>i\\<le>n.\n            isolate_variable_sparse p2 v i *\n            isolate_variable_sparse q v (n - i));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse ((p1 + p2) * q) v n =\n                         (\\<Sum>i\\<le>n.\n                             isolate_variable_sparse (p1 + p2) v i *\n                             isolate_variable_sparse q v (n - i))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n    (\\<Sum>i\\<le>n.\n        isolate_variable_sparse (MPoly_Type.monom m a) v i *\n        isolate_variable_sparse q v (n - i))", "by (cases \"a = 0\")\n      (auto simp add: mpoly_eq_iff coeff_sum coeff_mult if_conn if_distrib if_distribR\n        isolate_variable_sparse_monom isolate_variable_sparse_monom_mult\n        cong: if_cong)"], ["proof (state)\nthis:\n  isolate_variable_sparse (MPoly_Type.monom m a * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse (MPoly_Type.monom m a) v i *\n      isolate_variable_sparse q v (n - i))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>isolate_variable_sparse (p1 * q) v n =\n                (\\<Sum>i\\<le>n.\n                    isolate_variable_sparse p1 v i *\n                    isolate_variable_sparse q v (n - i));\n        isolate_variable_sparse (p2 * q) v n =\n        (\\<Sum>i\\<le>n.\n            isolate_variable_sparse p2 v i *\n            isolate_variable_sparse q v (n - i));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse ((p1 + p2) * q) v n =\n                         (\\<Sum>i\\<le>n.\n                             isolate_variable_sparse (p1 + p2) v i *\n                             isolate_variable_sparse q v (n - i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>isolate_variable_sparse (p1 * q) v n =\n                (\\<Sum>i\\<le>n.\n                    isolate_variable_sparse p1 v i *\n                    isolate_variable_sparse q v (n - i));\n        isolate_variable_sparse (p2 * q) v n =\n        (\\<Sum>i\\<le>n.\n            isolate_variable_sparse p2 v i *\n            isolate_variable_sparse q v (n - i));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse ((p1 + p2) * q) v n =\n                         (\\<Sum>i\\<le>n.\n                             isolate_variable_sparse (p1 + p2) v i *\n                             isolate_variable_sparse q v (n - i))", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  isolate_variable_sparse (p1 * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse p1 v i * isolate_variable_sparse q v (n - i))\n  isolate_variable_sparse (p2 * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse p2 v i * isolate_variable_sparse q v (n - i))\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>isolate_variable_sparse (p1 * q) v n =\n                (\\<Sum>i\\<le>n.\n                    isolate_variable_sparse p1 v i *\n                    isolate_variable_sparse q v (n - i));\n        isolate_variable_sparse (p2 * q) v n =\n        (\\<Sum>i\\<le>n.\n            isolate_variable_sparse p2 v i *\n            isolate_variable_sparse q v (n - i));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> isolate_variable_sparse ((p1 + p2) * q) v n =\n                         (\\<Sum>i\\<le>n.\n                             isolate_variable_sparse (p1 + p2) v i *\n                             isolate_variable_sparse q v (n - i))", "then"], ["proof (chain)\npicking this:\n  isolate_variable_sparse (p1 * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse p1 v i * isolate_variable_sparse q v (n - i))\n  isolate_variable_sparse (p2 * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse p2 v i * isolate_variable_sparse q v (n - i))\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  isolate_variable_sparse (p1 * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse p1 v i * isolate_variable_sparse q v (n - i))\n  isolate_variable_sparse (p2 * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse p2 v i * isolate_variable_sparse q v (n - i))\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse ((p1 + p2) * q) v n =\n    (\\<Sum>i\\<le>n.\n        isolate_variable_sparse (p1 + p2) v i *\n        isolate_variable_sparse q v (n - i))", "by (simp add: distrib_right isovarspar_sum sum.distrib)"], ["proof (state)\nthis:\n  isolate_variable_sparse ((p1 + p2) * q) v n =\n  (\\<Sum>i\\<le>n.\n      isolate_variable_sparse (p1 + p2) v i *\n      isolate_variable_sparse q v (n - i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"More Miscellaneous\""], ["", "lemma var_not_in_Const : \"var\\<notin>vars (Const x :: real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (Const x)", "unfolding vars_def keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> \\<Union>\n              (map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0}) `\n               map_fun lookup id (\\<lambda>f. {k. f k \\<noteq> 0})\n                (mapping_of (Const x)))", "by (smt UN_iff coeff_def coeff_isolate_variable_sparse const_lookup_zero keys_def lookup_eq_zero_in_keys_contradict)"], ["", "lemma mpoly_to_nested_poly_mult:\n  \"mpoly_to_nested_poly (p * q) v = mpoly_to_nested_poly p v * mpoly_to_nested_poly q v\"\n  for p q::\"'a::{comm_semiring_0, semiring_no_zero_divisors} mpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_to_nested_poly (p * q) v =\n    mpoly_to_nested_poly p v * mpoly_to_nested_poly q v", "by (auto simp: poly_eq_iff coeff_mult mpoly_to_nested_poly.rep_eq isolate_variable_sparse_mult)"], ["", "lemma get_if_const_insertion : \n  assumes \"get_if_const (p::real mpoly) = Some r\"\n  shows \"insertion f p = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p = r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f p = r", "have \"Set.is_empty (vars p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty (vars p)", "apply(cases \"Set.is_empty (vars p)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Set.is_empty (vars p) \\<Longrightarrow> Set.is_empty (vars p)\n 2. \\<not> Set.is_empty (vars p) \\<Longrightarrow> Set.is_empty (vars p)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty (vars p) \\<Longrightarrow> Set.is_empty (vars p)", "using assms"], ["proof (prove)\nusing this:\n  get_if_const p = Some r\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty (vars p) \\<Longrightarrow> Set.is_empty (vars p)", "by(simp)"], ["proof (state)\nthis:\n  Set.is_empty (vars p)\n\ngoal (1 subgoal):\n 1. insertion f p = r", "then"], ["proof (chain)\npicking this:\n  Set.is_empty (vars p)", "have \"(MPoly_Type.coeff p 0) = r\""], ["proof (prove)\nusing this:\n  Set.is_empty (vars p)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p 0 = r", "using assms"], ["proof (prove)\nusing this:\n  Set.is_empty (vars p)\n  get_if_const p = Some r\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p 0 = r", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff p 0 = r\n\ngoal (1 subgoal):\n 1. insertion f p = r", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff p 0 = r", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p 0 = r\n\ngoal (1 subgoal):\n 1. insertion f p = r", "by (metis Set.is_empty_def \\<open>Set.is_empty (vars p)\\<close> empty_iff insertion_irrelevant_vars insertion_trivial)"], ["proof (state)\nthis:\n  insertion f p = r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Yet more Degree Lemmas\""], ["", "lemma degree_mult:\n  fixes p q::\"'a::{comm_semiring_0, ring_1_no_zero_divisors} mpoly\"\n  assumes \"p \\<noteq> 0\"\n  assumes \"q \\<noteq> 0\"\n  shows \"MPoly_Type.degree (p * q) v = MPoly_Type.degree p v + MPoly_Type.degree q v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) v =\n    MPoly_Type.degree p v + MPoly_Type.degree q v", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p * q) v =\n    MPoly_Type.degree p v + MPoly_Type.degree q v", "by (auto simp add: degree_eq_univariate_degree mpoly_to_nested_poly_mult Polynomial.degree_mult_eq)"], ["", "lemma degree_eq:\n  assumes \"(p::real mpoly) = (q:: real mpoly)\"\n  shows \"MPoly_Type.degree p x = MPoly_Type.degree q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree q x", "by (simp add: assms)"], ["", "lemma degree_var_i : \"MPoly_Type.degree (((Var x)^i:: real mpoly)) x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ i) x = i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree (Var x ^ 0) x = 0\n 2. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. MPoly_Type.degree (Var x ^ 0) x = 0\n 2. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ 0) x = 0", "using degree_const"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Const ?z) ?x = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ 0) x = 0", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree (Var x ^ 0) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  MPoly_Type.degree (Var x ^ i) x = i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "have multh: \"(Var x)^(Suc i) = ((Var x)^i::real mpoly) * (Var x:: real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x ^ Suc i = Var x ^ i * Var x", "using power_Suc2"], ["proof (prove)\nusing this:\n  ?a ^ Suc ?n = ?a ^ ?n * ?a\n\ngoal (1 subgoal):\n 1. Var x ^ Suc i = Var x ^ i * Var x", "by blast"], ["proof (state)\nthis:\n  Var x ^ Suc i = Var x ^ i * Var x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "have deg0h: \"MPoly_Type.degree 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree 0 x = 0", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree 0 x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "have deg1h: \"MPoly_Type.degree (Var x::real mpoly) x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x) x = 1", "using degree_one"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Var ?x) ?x = 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x) x = 1", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.degree (Var x) x = 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "have nonzeroh1: \"(Var x:: real mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x \\<noteq> 0", "using degree_eq deg0h deg1h"], ["proof (prove)\nusing this:\n  ?p = ?q \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree ?q ?x\n  MPoly_Type.degree 0 x = 0\n  MPoly_Type.degree (Var x) x = 1\n\ngoal (1 subgoal):\n 1. Var x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Var x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "have nonzeroh2: \"((Var x)^i:: real mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x ^ i \\<noteq> 0", "using degree_eq deg0h Suc.hyps"], ["proof (prove)\nusing this:\n  ?p = ?q \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree ?q ?x\n  MPoly_Type.degree 0 x = 0\n  MPoly_Type.degree (Var x ^ i) x = i\n\ngoal (1 subgoal):\n 1. Var x ^ i \\<noteq> 0", "by (metis one_neq_zero power_0)"], ["proof (state)\nthis:\n  Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "have sumh: \"(MPoly_Type.degree (((Var x)^i:: real mpoly) * (Var x:: real mpoly)) x) = (MPoly_Type.degree ((Var x)^i::real mpoly) x) + (MPoly_Type.degree (Var x::real mpoly) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ i * Var x) x =\n    MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x", "using degree_mult[where p = \"(Var x)^i::real mpoly\", where q = \"Var x::real mpoly\"]  nonzeroh1 nonzeroh2"], ["proof (prove)\nusing this:\n  \\<lbrakk>Var x ^ i \\<noteq> 0; Var x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (Var x ^ i * Var x) ?v =\n                    MPoly_Type.degree (Var x ^ i) ?v +\n                    MPoly_Type.degree (Var x) ?v\n  Var x \\<noteq> 0\n  Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ i * Var x) x =\n    MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.degree (Var x ^ i * Var x) x =\n  MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       MPoly_Type.degree (Var x ^ i) x = i \\<Longrightarrow>\n       MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree (Var x ^ i * Var x) x =\n  MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x", "show ?case"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Var x ^ i * Var x) x =\n  MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "using sumh deg1h"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Var x ^ i * Var x) x =\n  MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x\n  MPoly_Type.degree (Var x ^ i * Var x) x =\n  MPoly_Type.degree (Var x ^ i) x + MPoly_Type.degree (Var x) x\n  MPoly_Type.degree (Var x) x = 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Var x ^ Suc i) x = Suc i", "by (metis Suc.hyps Suc_eq_plus1 multh)"], ["proof (state)\nthis:\n  MPoly_Type.degree (Var x ^ Suc i) x = Suc i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_less_sum: \n  assumes \"MPoly_Type.degree (p::real mpoly) var = n\"\n  assumes \"MPoly_Type.degree (q::real mpoly) var = m\"\n  assumes \"m < n\"\n  shows \"MPoly_Type.degree (p + q) var = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "have h1: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using assms(3) neq0_conv"], ["proof (prove)\nusing this:\n  m < n\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. 0 < n", "by blast"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "have h2: \"(\\<exists>m\\<in>monomials p. lookup m var = n) \\<and> (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<in>monomials p. lookup m var = n) \\<and>\n    (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)", "using degree_eq_iff assms(1)"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n  MPoly_Type.degree p var = n\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<in>monomials p. lookup m var = n) \\<and>\n    (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)", "by (metis degree_ge_iff h1 order_refl)"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>monomials p. lookup m var = n) \\<and>\n  (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "have h3: \"(\\<exists>m\\<in>monomials (p + q). lookup m var = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials (p + q). lookup m var = n", "using h2"], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>monomials p. lookup m var = n) \\<and>\n  (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials (p + q). lookup m var = n", "by (metis MPolyExtension.coeff_add add.right_neutral assms(2) assms(3) coeff_eq_zero_iff degree_not_exists_monom)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>monomials (p + q). lookup m var = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "have h4: \"(\\<forall>m\\<in>monomials (p + q). lookup m var \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials (p + q). lookup m var \\<le> n", "using h2 assms(3) assms(2)"], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>monomials p. lookup m var = n) \\<and>\n  (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)\n  m < n\n  MPoly_Type.degree q var = m\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials (p + q). lookup m var \\<le> n", "using degree_add_leq degree_le_iff dual_order.strict_iff_order"], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>monomials p. lookup m var = n) \\<and>\n  (\\<forall>m\\<in>monomials p. lookup m var \\<le> n)\n  m < n\n  MPoly_Type.degree q var = m\n  \\<lbrakk>MPoly_Type.degree ?a ?var \\<le> ?x;\n   MPoly_Type.degree ?b ?var \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (?a + ?b) ?var \\<le> ?x\n  (MPoly_Type.degree ?p ?x \\<le> ?k) =\n  (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k)\n  (?b < ?a) = (?b \\<le> ?a \\<and> ?a \\<noteq> ?b)\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>monomials (p + q). lookup m var \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<in>monomials (p + q). lookup m var \\<le> n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "using degree_eq_iff h3 h4"], ["proof (prove)\nusing this:\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n  \\<exists>m\\<in>monomials (p + q). lookup m var = n\n  \\<forall>m\\<in>monomials (p + q). lookup m var \\<le> n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = n", "by (metis assms(3) gr_implies_not0)"], ["proof (state)\nthis:\n  MPoly_Type.degree (p + q) var = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_less_sum': \n  assumes \"MPoly_Type.degree (p::real mpoly) var = n\"\n  assumes \"MPoly_Type.degree (q::real mpoly) var = m\"\n  assumes \"n < m\"\n  shows \"MPoly_Type.degree (p + q) var = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = m", "using degree_less_sum[OF assms(2) assms(1) assms(3)]"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (q + p) var = m\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (p + q) var = m", "by (simp add: add.commute)"], ["", "(* Result on the degree of the derivative  *)"], ["", "lemma nonzero_const_is_nonzero: \n  assumes \"(k::real) \\<noteq> 0\"\n  shows \"((Const k)::real mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const k \\<noteq> 0", "by (metis MPoly_Type.insertion_zero assms insertion_const)"], ["", "lemma degree_derivative : \n  assumes \"MPoly_Type.degree p x > 0\"\n  shows \"MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "define f where \"f i = (isolate_variable_sparse p x (i+1) * (Var x)^(i) * (Const (i+1)))\" for i"], ["proof (state)\nthis:\n  f ?i =\n  isolate_variable_sparse p x (?i + 1) * Var x ^ ?i * Const (real ?i + 1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "define n where \"n = MPoly_Type.degree p x-1\""], ["proof (state)\nthis:\n  n = MPoly_Type.degree p x - 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have d : \"\\<exists>m\\<in>monomials p. lookup m x = n+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m x = n + 1", "using n_def degree_eq_iff assms"], ["proof (prove)\nusing this:\n  n = MPoly_Type.degree p x - 1\n  (MPoly_Type.degree ?p ?x = ?k) =\n  (if ?k = 0 then \\<forall>m\\<in>monomials ?p. lookup m ?x = 0\n   else (\\<exists>m\\<in>monomials ?p. lookup m ?x = ?k) \\<and>\n        (\\<forall>m\\<in>monomials ?p. lookup m ?x \\<le> ?k))\n  0 < MPoly_Type.degree p x\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>monomials p. lookup m x = n + 1", "by (metis add.commute less_not_refl2 less_one linordered_semidom_class.add_diff_inverse)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>monomials p. lookup m x = n + 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h1a : \"\\<forall>i. MPoly_Type.degree (isolate_variable_sparse p x i) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. MPoly_Type.degree (isolate_variable_sparse p x i) x = 0", "by (simp add: not_in_isovarspar varNotIn_degree)"], ["proof (state)\nthis:\n  \\<forall>i. MPoly_Type.degree (isolate_variable_sparse p x i) x = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h1b : \"\\<forall>i::nat. MPoly_Type.degree ((Var x)^i:: real mpoly) x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. MPoly_Type.degree (Var x ^ i) x = i", "using degree_var_i"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Var ?x ^ ?i) ?x = ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i. MPoly_Type.degree (Var x ^ i) x = i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. MPoly_Type.degree (Var x ^ i) x = i\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h1c1 : \"\\<forall>i. (Var(x)^(i)::real mpoly)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. Var x ^ i \\<noteq> 0", "by (metis MPoly_Type.degree_zero h1b power_0 zero_neq_one)"], ["proof (state)\nthis:\n  \\<forall>i. Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h1c1var: \"((Var x)^i:: real mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x ^ i \\<noteq> 0", "using h1c1"], ["proof (prove)\nusing this:\n  \\<forall>i. Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Var x ^ i \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h1c2 : \"((Const ((i::nat) + 1))::real mpoly)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (real (i + 1)) \\<noteq> 0", "using nonzero_const_is_nonzero"], ["proof (prove)\nusing this:\n  ?k \\<noteq> 0 \\<Longrightarrow> Const ?k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Const (real (i + 1)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Const (real (i + 1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h1c3: \"(isolate_variable_sparse p x (n + 1)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (n + 1) \\<noteq> 0", "using d"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>monomials p. lookup m x = n + 1\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (n + 1) \\<noteq> 0", "by (metis One_nat_def Suc_pred add.commute assms isolate_variable_sparse_degree_eq_zero_iff n_def not_gr_zero not_in_isovarspar plus_1_eq_Suc varNotIn_degree)"], ["proof (state)\nthis:\n  isolate_variable_sparse p x (n + 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h3: \"(isolate_variable_sparse p x (i+1) = 0) \\<longrightarrow> (MPoly_Type.degree (f i) x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (i + 1) = 0 \\<longrightarrow>\n    MPoly_Type.degree (f i) x = 0", "by (simp add: f_def)"], ["proof (state)\nthis:\n  isolate_variable_sparse p x (i + 1) = 0 \\<longrightarrow>\n  MPoly_Type.degree (f i) x = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have degh1: \"(MPoly_Type.degree (((Const ((i::nat)+1))::real mpoly)*(Var x)^i) x) = \n    ((MPoly_Type.degree ((Const (i+1))::real mpoly) x) + (MPoly_Type.degree ((Var x)^i:: real mpoly) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x =\n    MPoly_Type.degree (Const (real (i + 1))) x +\n    MPoly_Type.degree (Var x ^ i) x", "using h1c2 h1c1var degree_mult[where p=\"((Const ((i::nat)+1))::real mpoly)\", where q=\"((Var x)^i:: real mpoly)\"]"], ["proof (prove)\nusing this:\n  Const (real (i + 1)) \\<noteq> 0\n  Var x ^ i \\<noteq> 0\n  \\<lbrakk>Const (real (i + 1)) \\<noteq> 0; Var x ^ i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i)\n                     ?v =\n                    MPoly_Type.degree (Const (real (i + 1))) ?v +\n                    MPoly_Type.degree (Var x ^ i) ?v\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x =\n    MPoly_Type.degree (Const (real (i + 1))) x +\n    MPoly_Type.degree (Var x ^ i) x", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x =\n  MPoly_Type.degree (Const (real (i + 1))) x +\n  MPoly_Type.degree (Var x ^ i) x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x =\n  MPoly_Type.degree (Const (real (i + 1))) x +\n  MPoly_Type.degree (Var x ^ i) x", "have degh2: \"(MPoly_Type.degree (((Const ((i::nat)+1))::real mpoly)*(Var x)^i) x) = i\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x =\n  MPoly_Type.degree (Const (real (i + 1))) x +\n  MPoly_Type.degree (Var x ^ i) x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x = i", "using degree_var_i degree_const"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x =\n  MPoly_Type.degree (Const (real (i + 1))) x +\n  MPoly_Type.degree (Var x ^ i) x\n  MPoly_Type.degree (Var ?x ^ ?i) ?x = ?i\n  MPoly_Type.degree (Const ?z) ?x = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x = i", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x = i\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have nonzerohyp: \"(((Const ((i::nat)+1))::real mpoly)*(Var x)^i) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (real (i + 1)) * Var x ^ i \\<noteq> 0", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. Const (real (0 + 1)) * Var x ^ 0 \\<noteq> 0\n 2. \\<And>i.\n       Const (real (i + 1)) * Var x ^ i \\<noteq> 0 \\<Longrightarrow>\n       Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Const (real (0 + 1)) * Var x ^ 0 \\<noteq> 0\n 2. \\<And>i.\n       Const (real (i + 1)) * Var x ^ i \\<noteq> 0 \\<Longrightarrow>\n       Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (real (0 + 1)) * Var x ^ 0 \\<noteq> 0", "by (simp add: nonzero_const_is_nonzero)"], ["proof (state)\nthis:\n  Const (real (0 + 1)) * Var x ^ 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       Const (real (i + 1)) * Var x ^ i \\<noteq> 0 \\<Longrightarrow>\n       Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       Const (real (i + 1)) * Var x ^ i \\<noteq> 0 \\<Longrightarrow>\n       Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "case (Suc i)"], ["proof (state)\nthis:\n  Const (real (i + 1)) * Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       Const (real (i + 1)) * Var x ^ i \\<noteq> 0 \\<Longrightarrow>\n       Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  Const (real (i + 1)) * Var x ^ i \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  Const (real (i + 1)) * Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "using degree_eq degh2"], ["proof (prove)\nusing this:\n  Const (real (i + 1)) * Var x ^ i \\<noteq> 0\n  ?p = ?q \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree ?q ?x\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x = i\n\ngoal (1 subgoal):\n 1. Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0", "by (metis Suc_eq_plus1 h1c1 mult_eq_0_iff nat.simps(3) nonzero_const_is_nonzero of_nat_eq_0_iff)"], ["proof (state)\nthis:\n  Const (real (Suc i + 1)) * Var x ^ Suc i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Const (real (i + 1)) * Var x ^ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h4a1: \"(isolate_variable_sparse p x (i+1) \\<noteq> 0) \\<longrightarrow> (MPoly_Type.degree (isolate_variable_sparse p x (i+1) * ((Var x)^(i) * (Const (i+1)))::real mpoly) x = \n      (MPoly_Type.degree (isolate_variable_sparse p x (i+1):: real mpoly) x) + (MPoly_Type.degree (((Const (i+1)) *  (Var x)^(i))::real mpoly) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n    MPoly_Type.degree\n     (isolate_variable_sparse p x (i + 1) *\n      (Var x ^ i * Const (real (i + 1))))\n     x =\n    MPoly_Type.degree (isolate_variable_sparse p x (i + 1)) x +\n    MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x", "using nonzerohyp degree_mult[where p = \"(isolate_variable_sparse p x (i+1))::real mpoly\", where q = \"((Const (i+1)) *  (Var x)^(i)):: real mpoly\", where v = \"x\"]"], ["proof (prove)\nusing this:\n  Const (real (i + 1)) * Var x ^ i \\<noteq> 0\n  \\<lbrakk>isolate_variable_sparse p x (i + 1) \\<noteq> 0;\n   Const (real (i + 1)) * Var x ^ i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree\n                     (isolate_variable_sparse p x (i + 1) *\n                      (Const (real (i + 1)) * Var x ^ i))\n                     x =\n                    MPoly_Type.degree (isolate_variable_sparse p x (i + 1))\n                     x +\n                    MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n    MPoly_Type.degree\n     (isolate_variable_sparse p x (i + 1) *\n      (Var x ^ i * Const (real (i + 1))))\n     x =\n    MPoly_Type.degree (isolate_variable_sparse p x (i + 1)) x +\n    MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n  MPoly_Type.degree\n   (isolate_variable_sparse p x (i + 1) *\n    (Var x ^ i * Const (real (i + 1))))\n   x =\n  MPoly_Type.degree (isolate_variable_sparse p x (i + 1)) x +\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h4: \"(isolate_variable_sparse p x (i+1) \\<noteq> 0) \\<longrightarrow> (MPoly_Type.degree (f i) x) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n    MPoly_Type.degree (f i) x = i", "using h4a1 f_def degh2 h1a"], ["proof (prove)\nusing this:\n  isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n  MPoly_Type.degree\n   (isolate_variable_sparse p x (i + 1) *\n    (Var x ^ i * Const (real (i + 1))))\n   x =\n  MPoly_Type.degree (isolate_variable_sparse p x (i + 1)) x +\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x\n  f ?i =\n  isolate_variable_sparse p x (?i + 1) * Var x ^ ?i * Const (real ?i + 1)\n  MPoly_Type.degree (Const (real (i + 1)) * Var x ^ i) x = i\n  \\<forall>i. MPoly_Type.degree (isolate_variable_sparse p x i) x = 0\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n    MPoly_Type.degree (f i) x = i", "by (metis (no_types, hide_lams) add.left_neutral mult.commute mult.left_commute of_nat_1 of_nat_add)"], ["proof (state)\nthis:\n  isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n  MPoly_Type.degree (f i) x = i\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h5: \"(MPoly_Type.degree (f i) x) \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (f i) x \\<le> i", "using h3 h4"], ["proof (prove)\nusing this:\n  isolate_variable_sparse p x (i + 1) = 0 \\<longrightarrow>\n  MPoly_Type.degree (f i) x = 0\n  isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n  MPoly_Type.degree (f i) x = i\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (f i) x \\<le> i", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree (f i) x \\<le> i\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h6: \"(MPoly_Type.degree (f n) x) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (f n) x = n", "using h1c3 h4"], ["proof (prove)\nusing this:\n  isolate_variable_sparse p x (n + 1) \\<noteq> 0\n  isolate_variable_sparse p x (i + 1) \\<noteq> 0 \\<longrightarrow>\n  MPoly_Type.degree (f i) x = i\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (f n) x = n", "by (smt One_nat_def add.right_neutral add_Suc_right degree_const degree_mult divisors_zero f_def h1a h1b h1c1 mult.commute nonzero_const_is_nonzero of_nat_1 of_nat_add of_nat_neq_0)"], ["proof (state)\nthis:\n  MPoly_Type.degree (f n) x = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h7a: \"derivative x p = (\\<Sum>i\\<in>{0..MPoly_Type.degree p x-1}. isolate_variable_sparse p x (i+1) * (Var x)^i * (Const (i+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivative x p =\n    (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n        isolate_variable_sparse p x (i + 1) * Var x ^ i *\n        Const (real (i + 1)))", "using derivative_def"], ["proof (prove)\nusing this:\n  derivative ?x ?p =\n  (\\<Sum>i = 0..MPoly_Type.degree ?p ?x - 1.\n      isolate_variable_sparse ?p ?x (i + 1) * Var ?x ^ i *\n      Const (real (i + 1)))\n\ngoal (1 subgoal):\n 1. derivative x p =\n    (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n        isolate_variable_sparse p x (i + 1) * Var x ^ i *\n        Const (real (i + 1)))", "by auto"], ["proof (state)\nthis:\n  derivative x p =\n  (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n      isolate_variable_sparse p x (i + 1) * Var x ^ i *\n      Const (real (i + 1)))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h7b: \"(\\<Sum>i\\<in>{0..MPoly_Type.degree p x-1}. isolate_variable_sparse p x (i+1) * (Var x)^i * (Const (i+1))) = (\\<Sum>i\\<in>{0..MPoly_Type.degree p x-1}. (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n        isolate_variable_sparse p x (i + 1) * Var x ^ i *\n        Const (real (i + 1))) =\n    sum f {0..MPoly_Type.degree p x - 1}", "using f_def"], ["proof (prove)\nusing this:\n  f ?i =\n  isolate_variable_sparse p x (?i + 1) * Var x ^ ?i * Const (real ?i + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n        isolate_variable_sparse p x (i + 1) * Var x ^ i *\n        Const (real (i + 1))) =\n    sum f {0..MPoly_Type.degree p x - 1}", "by (metis Suc_eq_plus1 add.commute semiring_1_class.of_nat_simps(2))"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n      isolate_variable_sparse p x (i + 1) * Var x ^ i *\n      Const (real (i + 1))) =\n  sum f {0..MPoly_Type.degree p x - 1}\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h7c: \"derivative x p = (\\<Sum>i\\<in>{0..MPoly_Type.degree p x-1}. (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivative x p = sum f {0..MPoly_Type.degree p x - 1}", "using h7a h7b"], ["proof (prove)\nusing this:\n  derivative x p =\n  (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n      isolate_variable_sparse p x (i + 1) * Var x ^ i *\n      Const (real (i + 1)))\n  (\\<Sum>i = 0..MPoly_Type.degree p x - 1.\n      isolate_variable_sparse p x (i + 1) * Var x ^ i *\n      Const (real (i + 1))) =\n  sum f {0..MPoly_Type.degree p x - 1}\n\ngoal (1 subgoal):\n 1. derivative x p = sum f {0..MPoly_Type.degree p x - 1}", "by auto"], ["proof (state)\nthis:\n  derivative x p = sum f {0..MPoly_Type.degree p x - 1}\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h7: \"derivative x p = (\\<Sum>i\\<in>{0..n}. (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. derivative x p = sum f {0..n}", "using n_def h7c"], ["proof (prove)\nusing this:\n  n = MPoly_Type.degree p x - 1\n  derivative x p = sum f {0..MPoly_Type.degree p x - 1}\n\ngoal (1 subgoal):\n 1. derivative x p = sum f {0..n}", "by blast"], ["proof (state)\nthis:\n  derivative x p = sum f {0..n}\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h8: \"n > 0 \\<longrightarrow> ((MPoly_Type.degree (\\<Sum>i\\<in>{0..(n-1)}. (f i)) x) < n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..0 - 1}) x < 0\n 2. \\<And>n.\n       0 < n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..n - 1}) x < n \\<Longrightarrow>\n       0 < Suc n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 < 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..0 - 1}) x < 0\n 2. \\<And>n.\n       0 < n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..n - 1}) x < n \\<Longrightarrow>\n       0 < Suc n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..0 - 1}) x < 0", "by blast"], ["proof (state)\nthis:\n  0 < 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..0 - 1}) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..n - 1}) x < n \\<Longrightarrow>\n       0 < Suc n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..n - 1}) x < n \\<Longrightarrow>\n       0 < Suc n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..n - 1}) x < n \\<Longrightarrow>\n       0 < Suc n \\<longrightarrow>\n       MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "then"], ["proof (chain)\npicking this:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n", "show ?case"], ["proof (prove)\nusing this:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n\n\ngoal (1 subgoal):\n 1. 0 < Suc n \\<longrightarrow>\n    MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "using h5 degree_less_sum"], ["proof (prove)\nusing this:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n\n  MPoly_Type.degree (f i) x \\<le> i\n  \\<lbrakk>MPoly_Type.degree ?p ?var = ?n; MPoly_Type.degree ?q ?var = ?m;\n   ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (?p + ?q) ?var = ?n\n\ngoal (1 subgoal):\n 1. 0 < Suc n \\<longrightarrow>\n    MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n", "by (smt add_cancel_right_right atLeastAtMost_iff degree_const degree_mult degree_sum_less degree_var_i diff_Suc_1 f_def h1a le_imp_less_Suc mult.commute mult_eq_0_iff)"], ["proof (state)\nthis:\n  0 < Suc n \\<longrightarrow>\n  MPoly_Type.degree (sum f {0..Suc n - 1}) x < Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h9a: \"n = 0 \\<longrightarrow> MPoly_Type.degree (\\<Sum>i\\<in>{0..n}. (f i)) x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "using h6"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (f n) x = n\n\ngoal (1 subgoal):\n 1. n = 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "by auto"], ["proof (state)\nthis:\n  n = 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h9b: \"n > 0 \\<longrightarrow> MPoly_Type.degree (\\<Sum>i\\<in>{0..n}. (f i)) x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "have h9bhyp: \"n > 0 \\<longrightarrow> (MPoly_Type.degree (\\<Sum>i\\<in>{0..n}. (f i)) x = MPoly_Type.degree ((\\<Sum>i\\<in>{0..(n-1)}. (f i)) + (f n)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    MPoly_Type.degree (sum f {0..n}) x =\n    MPoly_Type.degree (sum f {0..n - 1} + f n) x", "by (metis Suc_diff_1 sum.atLeast0_atMost_Suc)"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) x =\n  MPoly_Type.degree (sum f {0..n - 1} + f n) x\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "have h9bhyp2: \"n > 0 \\<longrightarrow> ((MPoly_Type.degree ((\\<Sum>i\\<in>{0..(n-1)}. (f i)) + (f n)) x) = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n", "using h6 h8 degree_less_sum"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (f n) x = n\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1}) x < n\n  \\<lbrakk>MPoly_Type.degree ?p ?var = ?n; MPoly_Type.degree ?q ?var = ?m;\n   ?m < ?n\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (?p + ?q) ?var = ?n\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "then"], ["proof (chain)\npicking this:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "using h9bhyp2 h9bhyp"], ["proof (prove)\nusing this:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n - 1} + f n) x = n\n  0 < n \\<longrightarrow>\n  MPoly_Type.degree (sum f {0..n}) x =\n  MPoly_Type.degree (sum f {0..n - 1} + f n) x\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n", "by linarith"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h9:  \"MPoly_Type.degree (\\<Sum>i\\<in>{0..n}. (f i)) x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (sum f {0..n}) x = n", "using h9a h9b"], ["proof (prove)\nusing this:\n  n = 0 \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n\n  0 < n \\<longrightarrow> MPoly_Type.degree (sum f {0..n}) x = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (sum f {0..n}) x = n", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.degree (sum f {0..n}) x = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "have h10: \"MPoly_Type.degree (derivative x p) x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (derivative x p) x = n", "using h9 h7"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (sum f {0..n}) x = n\n  derivative x p = sum f {0..n}\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (derivative x p) x = n", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree (derivative x p) x = n\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "using h10 n_def"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (derivative x p) x = n\n  n = MPoly_Type.degree p x - 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (derivative x p) x = n\n  n = MPoly_Type.degree p x - 1\n  0 < MPoly_Type.degree p x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1", "by linarith"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = MPoly_Type.degree (derivative x p) x + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma express_poly :\n  assumes h : \"MPoly_Type.degree (p::real mpoly) var = 1 \\<or> MPoly_Type.degree p var = 2\"\n  shows \"p =\n     (isolate_variable_sparse p var 2)*(Var var)^2\n    +(isolate_variable_sparse p var 1)*(Var var)\n    +(isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h1a: \"MPoly_Type.degree p var = 1 \\<longrightarrow> p =\n    isolate_variable_sparse p var 0 + \n    isolate_variable_sparse p var 1 * Var var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var", "using sum_over_zero[where mp=\"p\",where x=\"var\"]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<longrightarrow>\n  p =\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h1b: \"MPoly_Type.degree p var = 1 \\<longrightarrow> isolate_variable_sparse p var 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<longrightarrow>\n    isolate_variable_sparse p var 2 = 0", "using isovar_greater_degree"], ["proof (prove)\nusing this:\n  \\<forall>i>MPoly_Type.degree ?p ?var.\n     isolate_variable_sparse ?p ?var i = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<longrightarrow>\n    isolate_variable_sparse p var 2 = 0", "by (simp add: isovar_greater_degree)"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<longrightarrow>\n  isolate_variable_sparse p var 2 = 0\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h1: \"MPoly_Type.degree p var = 1 \\<longrightarrow> p =\n    isolate_variable_sparse p var 0 + \n    isolate_variable_sparse p var 1 * Var var\n    + isolate_variable_sparse p var 2 * (Var var)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "using h1a h1b"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1 \\<longrightarrow>\n  p =\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var\n  MPoly_Type.degree p var = 1 \\<longrightarrow>\n  isolate_variable_sparse p var 2 = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<longrightarrow>\n  p =\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h2a: \"MPoly_Type.degree p var = 2 \\<longrightarrow> p = (\\<Sum>i::nat \\<le> 2. isolate_variable_sparse p var i * Var var^i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2 \\<longrightarrow>\n    p = (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i)", "using sum_over_zero[where mp=\"p\", where x=\"var\"]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2 \\<longrightarrow>\n    p = (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i)", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2 \\<longrightarrow>\n  p = (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h2b: \"(\\<Sum>i::nat \\<le> 2. isolate_variable_sparse p var i * Var var^i) =\n   (\\<Sum>i::nat \\<le> 1. isolate_variable_sparse p var i * Var var^i) +\n   isolate_variable_sparse p var 2 * (Var var)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    (\\<Sum>i\\<le>1. isolate_variable_sparse p var i * Var var ^ i) +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var (Suc 0) * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "by (simp add: numerals(2))"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i\\<le>1. isolate_variable_sparse p var i * Var var ^ i) +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h2:  \"MPoly_Type.degree p var = 2 \\<longrightarrow> p =\n    isolate_variable_sparse p var 0 + \n    isolate_variable_sparse p var 1 * Var var + \n    isolate_variable_sparse p var 2 * (Var var)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2 \\<longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "using h2a h2b"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2 \\<longrightarrow>\n  p = (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i)\n  (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n  (\\<Sum>i\\<le>1. isolate_variable_sparse p var i * Var var ^ i) +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2 \\<longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2 \\<longrightarrow>\n  p =\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "have h3: \"isolate_variable_sparse p var 0 + \n    isolate_variable_sparse p var 1 * Var var + \n    isolate_variable_sparse p var 2 * (Var var)^2 = \n    isolate_variable_sparse p var 2 * (Var var)^2 +\n    isolate_variable_sparse p var 1 * Var var + \n    isolate_variable_sparse p var 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 =\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 0\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "using h h1 h2 h3"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  MPoly_Type.degree p var = 1 \\<longrightarrow>\n  p =\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2\n  MPoly_Type.degree p var = 2 \\<longrightarrow>\n  p =\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2\n  isolate_variable_sparse p var 0 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 =\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 0\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "by presburger"], ["proof (state)\nthis:\n  p =\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_isovarspar : \"MPoly_Type.degree (isolate_variable_sparse (p::real mpoly) x i) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p x i) x = 0", "using not_in_isovarspar varNotIn_degree"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  ?var \\<notin> vars ?p \\<Longrightarrow> MPoly_Type.degree ?p ?var = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p x i) x = 0", "by blast"], ["", "end"]]}