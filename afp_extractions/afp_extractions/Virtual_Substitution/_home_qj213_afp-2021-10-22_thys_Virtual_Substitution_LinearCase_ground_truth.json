{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/LinearCase.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["theorem var_not_in_linear : \n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\" \n  shows \"freeIn var (Atom (linear_substitution var b c A))\"", "lemma linear_eq :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes hb :  \"insertion (nth_default 0 (list_update L var( B/C))) b = (B::real)\"\n  assumes hc : \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Eq(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Eq(p))) (list_update L var v))\"", "lemma linear_less :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Less(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Less(p))) (list_update L var v))\"", "lemma linear_leq :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Leq(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Leq(p))) (list_update L var v))\"", "lemma linear_neq :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Neq(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Neq(p))) (list_update L var v))\"", "theorem linear :\n  assumes lLength : \"length L > var\"\n  assumes \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval A (list_update L var (B/C))  = (aEval (linear_substitution var b c A) (list_update L var v))\"", "lemma var_not_in_linear_fm_helper : \n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\" \n  shows \"freeIn (var+z) (linear_substitution_fm_helper var b c F z)\"", "theorem var_not_in_linear_fm : \n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\" \n  shows \"freeIn var (linear_substitution_fm var b c F)\"", "lemma linear_fm_helper :\n  assumes \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update (drop z L) var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update (drop z L) var (B/C))) c = (C::real)\"\n  assumes lLength : \"length L > var+z\"\n  shows \"eval F (list_update L (var+z) (B/C))  = (eval (linear_substitution_fm_helper var b c F z) (list_update L (var+z) v))\"", "theorem linear_fm :\n  assumes lLength : \"length L > var\"\n  assumes \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"eval F (list_update L var (B/C))  = (\\<forall>v. eval (linear_substitution_fm var b c F) (list_update L var v))\""], "translations": [["", "theorem var_not_in_linear : \n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\" \n  shows \"freeIn var (Atom (linear_substitution var b c A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "proof(cases A)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "case (Less p)"], ["proof (state)\nthis:\n  A = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "then"], ["proof (chain)\npicking this:\n  d = MPoly_Type.degree p var", "show ?thesis"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "using Less"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n  A = Less p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = MPoly_Type.degree p var; A = Less p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = MPoly_Type.degree p var\n                          in Less\n                              (((\\<Sum>i = 0..<d.\n                                    isolate_variable_sparse p var i *\n                                    b ^ i *\n                                    c ^ (d - i)) +\n                                isolate_variable_sparse p var d * b ^ d) *\n                               c ^ (d mod 2))))", "unfolding d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = d; A = Less p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = d\n                          in Less\n                              (((\\<Sum>i = 0..<d.\n                                    isolate_variable_sparse p var i *\n                                    b ^ i *\n                                    c ^ (d - i)) +\n                                isolate_variable_sparse p var d * b ^ d) *\n                               c ^ (d mod 2))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Less p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              (((\\<Sum>i = 0..<d.\n                    isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                isolate_variable_sparse p var d * b ^ d) *\n               c ^ (d mod 2))", "using not_in_sum"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n\ngoal (1 subgoal):\n 1. A = Less p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              (((\\<Sum>i = 0..<d.\n                    isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                isolate_variable_sparse p var d * b ^ d) *\n               c ^ (d mod 2))", "using not_in_isovarspar assms  not_in_mult not_in_neg not_in_pow not_in_add"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  var \\<notin> vars b\n  var \\<notin> vars c\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n  ?var \\<notin> vars ?p \\<Longrightarrow> ?var \\<notin> vars (?p ^ ?i)\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. A = Less p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              (((\\<Sum>i = 0..<d.\n                    isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                isolate_variable_sparse p var d * b ^ d) *\n               c ^ (d mod 2))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (linear_substitution var b c A))\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "case (Eq p)"], ["proof (state)\nthis:\n  A = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 3. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "then"], ["proof (chain)\npicking this:\n  d = MPoly_Type.degree p var", "show ?thesis"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "using Eq"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n  A = Eq p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = MPoly_Type.degree p var; A = Eq p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = MPoly_Type.degree p var\n                          in Eq ((\\<Sum>i = 0..<d.\n                                     isolate_variable_sparse p var i *\n                                     b ^ i *\n                                     c ^ (d - i)) +\n                                 isolate_variable_sparse p var d * b ^ d)))", "unfolding d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = d; A = Eq p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = d\n                          in Eq ((\\<Sum>i = 0..<d.\n                                     isolate_variable_sparse p var i *\n                                     b ^ i *\n                                     c ^ (d - i)) +\n                                 isolate_variable_sparse p var d * b ^ d)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Eq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n               isolate_variable_sparse p var d * b ^ d)", "using not_in_sum"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n\ngoal (1 subgoal):\n 1. A = Eq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n               isolate_variable_sparse p var d * b ^ d)", "using not_in_isovarspar assms  not_in_mult not_in_neg not_in_pow not_in_add"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  var \\<notin> vars b\n  var \\<notin> vars c\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n  ?var \\<notin> vars ?p \\<Longrightarrow> ?var \\<notin> vars (?p ^ ?i)\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. A = Eq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n               isolate_variable_sparse p var d * b ^ d)", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (linear_substitution var b c A))\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "case (Leq p)"], ["proof (state)\nthis:\n  A = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))\n 2. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "then"], ["proof (chain)\npicking this:\n  d = MPoly_Type.degree p var", "show ?thesis"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "using Leq"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n  A = Leq p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = MPoly_Type.degree p var; A = Leq p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = MPoly_Type.degree p var\n                          in Leq (((\\<Sum>i = 0..<d.\n isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                                   isolate_variable_sparse p var d *\n                                   b ^ d) *\n                                  c ^ (d mod 2))))", "unfolding d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = d; A = Leq p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = d\n                          in Leq (((\\<Sum>i = 0..<d.\n isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                                   isolate_variable_sparse p var d *\n                                   b ^ d) *\n                                  c ^ (d mod 2))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Leq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              (((\\<Sum>i = 0..<d.\n                    isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                isolate_variable_sparse p var d * b ^ d) *\n               c ^ (d mod 2))", "using not_in_sum"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n\ngoal (1 subgoal):\n 1. A = Leq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              (((\\<Sum>i = 0..<d.\n                    isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                isolate_variable_sparse p var d * b ^ d) *\n               c ^ (d mod 2))", "using not_in_isovarspar assms  not_in_mult not_in_neg not_in_pow not_in_add"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  var \\<notin> vars b\n  var \\<notin> vars c\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n  ?var \\<notin> vars ?p \\<Longrightarrow> ?var \\<notin> vars (?p ^ ?i)\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. A = Leq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              (((\\<Sum>i = 0..<d.\n                    isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                isolate_variable_sparse p var d * b ^ d) *\n               c ^ (d mod 2))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (linear_substitution var b c A))\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "case (Neq p)"], ["proof (state)\nthis:\n  A = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       freeIn var (fm.Atom (linear_substitution var b c A))", "then"], ["proof (chain)\npicking this:\n  d = MPoly_Type.degree p var", "show ?thesis"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "using Neq"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n  A = Neq p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom (linear_substitution var b c A))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = MPoly_Type.degree p var; A = Neq p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = MPoly_Type.degree p var\n                          in Neq ((\\<Sum>i = 0..<d.\nisolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                                  isolate_variable_sparse p var d * b ^ d)))", "unfolding d_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = d; A = Neq p\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (fm.Atom\n                         (let d = d\n                          in Neq ((\\<Sum>i = 0..<d.\nisolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n                                  isolate_variable_sparse p var d * b ^ d)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Neq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n               isolate_variable_sparse p var d * b ^ d)", "using not_in_sum"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n\ngoal (1 subgoal):\n 1. A = Neq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n               isolate_variable_sparse p var d * b ^ d)", "using not_in_isovarspar assms  not_in_mult not_in_neg not_in_pow not_in_add"], ["proof (prove)\nusing this:\n  \\<forall>i. ?var \\<notin> vars (?f i) \\<Longrightarrow>\n  \\<forall>n. ?var \\<notin> vars (sum ?f {0..<n})\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n  var \\<notin> vars b\n  var \\<notin> vars c\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p * ?q)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n  ?var \\<notin> vars ?p \\<Longrightarrow> ?var \\<notin> vars (?p ^ ?i)\n  \\<lbrakk>?var \\<notin> vars ?p; ?var \\<notin> vars ?q\\<rbrakk>\n  \\<Longrightarrow> ?var \\<notin> vars (?p + ?q)\n\ngoal (1 subgoal):\n 1. A = Neq p \\<Longrightarrow>\n    var\n    \\<notin> vars\n              ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) +\n               isolate_variable_sparse p var d * b ^ d)", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (linear_substitution var b c A))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ----------------------------------------------------------------------------------------------- *)"], ["", "lemma linear_eq :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes hb :  \"insertion (nth_default 0 (list_update L var( B/C))) b = (B::real)\"\n  assumes hc : \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Eq(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Eq(p))) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "define f where \"f i = (insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i::real)\" for i"], ["proof (state)\nthis:\n  f ?i =\n  insertion (nth_default 0 (L[var := B / C]))\n   (isolate_variable_sparse p var ?i) *\n  B ^ ?i\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "have h : \"((\\<Sum>i = 0..<d+1. f i / C ^ i) = 0) =((\\<Sum>i = 0..<d+1. (f i) * C ^ (d - i)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n    ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)", "using normalize_summation nonzero"], ["proof (prove)\nusing this:\n  ?B \\<noteq> 0 \\<Longrightarrow>\n  ((\\<Sum>i = 0..<?n + 1. ?f i * ?B ^ (?n - i)) = 0) =\n  ((\\<Sum>i = 0..<?n + 1. ?f i / ?B ^ i) = 0)\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n    ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)", "by(auto)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "have \"aEval (linear_substitution var b c (Eq(p))) (list_update L var (B/C)) =\n    aEval (Eq(\\<Sum>i = 0..<d+1. isolate_variable_sparse p var i * (b) ^ i * c ^ (d - i))) (list_update L var (B/C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (linear_substitution var b c (Eq p)) (L[var := B / C]) =\n    aEval\n     (Eq (\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n     (L[var := B / C])", "by (metis (no_types, lifting) d_def linear_substitution.simps(1) sum.cong)"], ["proof (state)\nthis:\n  aEval (linear_substitution var b c (Eq p)) (L[var := B / C]) =\n  aEval\n   (Eq (\\<Sum>i = 0..<d + 1.\n           isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n   (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval (linear_substitution var b c (Eq p)) (L[var := B / C]) =\n  aEval\n   (Eq (\\<Sum>i = 0..<d + 1.\n           isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n   (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i * C ^ (d - i)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (Eq (\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n     (L[var := B / C]) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) =\n     0)", "using assms"], ["proof (prove)\nusing this:\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. aEval\n     (Eq (\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n     (L[var := B / C]) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) =\n     0)", "by(simp add: insertion_sum insertion_mult insertion_add insertion_pow insertion_neg lLength)"], ["proof (state)\nthis:\n  aEval\n   (Eq (\\<Sum>i = 0..<d + 1.\n           isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n   (L[var := B / C]) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) =\n   0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval\n   (Eq (\\<Sum>i = 0..<d + 1.\n           isolate_variable_sparse p var i * b ^ i * c ^ (d - i)))\n   (L[var := B / C]) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) =\n   0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i/ (C ^ i)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) =\n     0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i /\n         C ^ i) =\n     0)", "using h"], ["proof (prove)\nusing this:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) =\n     0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i /\n         C ^ i) =\n     0)", "by(simp add: f_def)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) =\n   0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i) =\n   0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) =\n   0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i) =\n   0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * ((B/C) ^ i)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i /\n         C ^ i) =\n     0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i) =\n     0)", "by (metis (no_types, lifting) power_divide sum.cong times_divide_eq_right)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i) =\n   0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i) =\n   0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i) =\n   0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i) =\n   0)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "have \"... = aEval (Eq(p :: real mpoly)) (list_update L var (B/C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i) =\n     0) =\n    aEval (Eq p) (L[var := B / C])", "using sum_over_degree_insertion d_def lLength"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var < length ?L; MPoly_Type.degree ?p ?var = ?d\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i = 0..<?d + 1.\n                        insertion (nth_default 0 (?L[?var := ?x]))\n                         (isolate_variable_sparse ?p ?var i) *\n                        ?x ^ i) =\n                    insertion (nth_default 0 (?L[?var := ?x])) ?p\n  d = MPoly_Type.degree p var\n  var < length L\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i) =\n     0) =\n    aEval (Eq p) (L[var := B / C])", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i) =\n   0) =\n  aEval (Eq p) (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "finally"], ["proof (chain)\npicking this:\n  aEval (linear_substitution var b c (Eq p)) (L[var := B / C]) =\n  aEval (Eq p) (L[var := B / C])", "show ?thesis"], ["proof (prove)\nusing this:\n  aEval (linear_substitution var b c (Eq p)) (L[var := B / C]) =\n  aEval (Eq p) (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "using assms plugInLinear var_not_in_linear var_not_in_eval"], ["proof (prove)\nusing this:\n  aEval (linear_substitution var b c (Eq p)) (L[var := B / C]) =\n  aEval (Eq p) (L[var := B / C])\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n  \\<lbrakk>?var < length ?L; ?B \\<noteq> 0;\n   \\<forall>v. insertion (nth_default 0 (?L[?var := v])) ?b = ?B;\n   \\<forall>v. insertion (nth_default 0 (?L[?var := v])) ?c = ?C\\<rbrakk>\n  \\<Longrightarrow> aEval (Eq (?b * Var ?var + ?c)) (?L[?var := - ?C / ?B])\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var\n                     (fm.Atom (linear_substitution ?var ?b ?c ?A))\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Eq p)) (L[var := v])", "by (meson var_not_in_aEval)"], ["proof (state)\nthis:\n  aEval (Eq p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Eq p)) (L[var := v])\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------------------------------------------------------------------- *)"], ["", "lemma linear_less :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Less(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Less(p))) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "define f where \"f i = (insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i::real)\" for i"], ["proof (state)\nthis:\n  f ?i =\n  insertion (nth_default 0 (L[var := B / C]))\n   (isolate_variable_sparse p var ?i) *\n  B ^ ?i\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "have h : \"(\\<Sum>i = 0..<(d+1). (f i) * C ^ (d - i)) * C ^ (d mod 2) < 0  \\<longleftrightarrow> (\\<Sum>i = 0..<((d::nat)+1). (f i::real) / (C ^ i)) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n    ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)", "using nonzero normalize_summation_less"], ["proof (prove)\nusing this:\n  C \\<noteq> 0\n  ?B \\<noteq> 0 \\<Longrightarrow>\n  ((\\<Sum>i = 0..<?n + 1. ?f i * ?B ^ (?n - i)) * ?B ^ (?n mod 2) < 0) =\n  ((\\<Sum>i = 0..<?n + 1. ?f i / ?B ^ i) < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n    ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "have \"aEval (linear_substitution var b c (Less(p))) (list_update L var (B/C))=aEval (Less((\\<Sum>i\\<in>{0..<(d+1)}. isolate_variable_sparse p var i * (b^i) * (c^(d-i))) * (c ^ (d mod 2)))) (list_update L var (B/C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (linear_substitution var b c (Less p)) (L[var := B / C]) =\n    aEval\n     (Less\n       ((\\<Sum>i = 0..<d + 1.\n            isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n        c ^ (d mod 2)))\n     (L[var := B / C])", "by (metis (no_types, lifting) d_def linear_substitution.simps(2) sum.cong)"], ["proof (state)\nthis:\n  aEval (linear_substitution var b c (Less p)) (L[var := B / C]) =\n  aEval\n   (Less\n     ((\\<Sum>i = 0..<d + 1.\n          isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n      c ^ (d mod 2)))\n   (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval (linear_substitution var b c (Less p)) (L[var := B / C]) =\n  aEval\n   (Less\n     ((\\<Sum>i = 0..<d + 1.\n          isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n      c ^ (d mod 2)))\n   (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i * C ^ (d - i)) * C ^ (d mod 2) < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (Less\n       ((\\<Sum>i = 0..<d + 1.\n            isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n        c ^ (d mod 2)))\n     (L[var := B / C]) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     < 0)", "using assms"], ["proof (prove)\nusing this:\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. aEval\n     (Less\n       ((\\<Sum>i = 0..<d + 1.\n            isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n        c ^ (d mod 2)))\n     (L[var := B / C]) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     < 0)", "by(simp add: insertion_sum insertion_mult insertion_add insertion_pow insertion_neg lLength)"], ["proof (state)\nthis:\n  aEval\n   (Less\n     ((\\<Sum>i = 0..<d + 1.\n          isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n      c ^ (d mod 2)))\n   (L[var := B / C]) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval\n   (Less\n     ((\\<Sum>i = 0..<d + 1.\n          isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n      c ^ (d mod 2)))\n   (L[var := B / C]) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (((B) ^ i) / (C ^ i))) < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     < 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B ^ i / C ^ i))\n     < 0)", "using f_def h"], ["proof (prove)\nusing this:\n  f ?i =\n  insertion (nth_default 0 (L[var := B / C]))\n   (isolate_variable_sparse p var ?i) *\n  B ^ ?i\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     < 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B ^ i / C ^ i))\n     < 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   < 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   < 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B/C)^i) < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B ^ i / C ^ i))\n     < 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i)\n     < 0)", "by (metis (no_types, lifting) power_divide sum.cong)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   < 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i)\n   < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   < 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i)\n   < 0)\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "have \"... = aEval (Less(p)) (list_update L var (B/C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i)\n     < 0) =\n    aEval (Less p) (L[var := B / C])", "using d_def sum_over_degree_insertion lLength"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n  \\<lbrakk>?var < length ?L; MPoly_Type.degree ?p ?var = ?d\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i = 0..<?d + 1.\n                        insertion (nth_default 0 (?L[?var := ?x]))\n                         (isolate_variable_sparse ?p ?var i) *\n                        ?x ^ i) =\n                    insertion (nth_default 0 (?L[?var := ?x])) ?p\n  var < length L\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i)\n     < 0) =\n    aEval (Less p) (L[var := B / C])", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i)\n   < 0) =\n  aEval (Less p) (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "finally"], ["proof (chain)\npicking this:\n  aEval (linear_substitution var b c (Less p)) (L[var := B / C]) =\n  aEval (Less p) (L[var := B / C])", "show ?thesis"], ["proof (prove)\nusing this:\n  aEval (linear_substitution var b c (Less p)) (L[var := B / C]) =\n  aEval (Less p) (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "using assms plugInLinear var_not_in_linear var_not_in_eval"], ["proof (prove)\nusing this:\n  aEval (linear_substitution var b c (Less p)) (L[var := B / C]) =\n  aEval (Less p) (L[var := B / C])\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n  \\<lbrakk>?var < length ?L; ?B \\<noteq> 0;\n   \\<forall>v. insertion (nth_default 0 (?L[?var := v])) ?b = ?B;\n   \\<forall>v. insertion (nth_default 0 (?L[?var := v])) ?c = ?C\\<rbrakk>\n  \\<Longrightarrow> aEval (Eq (?b * Var ?var + ?c)) (?L[?var := - ?C / ?B])\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var\n                     (fm.Atom (linear_substitution ?var ?b ?c ?A))\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. aEval (Less p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Less p)) (L[var := v])", "by (meson var_not_in_aEval)"], ["proof (state)\nthis:\n  aEval (Less p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Less p)) (L[var := v])\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------------------------------------------------------------------- *)"], ["", "lemma linear_leq :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Leq(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Leq(p))) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "define f where \"f i = (insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i::real)\" for i"], ["proof (state)\nthis:\n  f ?i =\n  insertion (nth_default 0 (L[var := B / C]))\n   (isolate_variable_sparse p var ?i) *\n  B ^ ?i\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have h1a : \"((\\<Sum>i = 0..<(d+1). (f i) * C ^ (d - i)) * C ^ (d mod 2) < 0 ) = ((\\<Sum>i = 0..<((d::nat)+1). (f i::real) / (C ^ i)) < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n    ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)", "using nonzero normalize_summation_less"], ["proof (prove)\nusing this:\n  C \\<noteq> 0\n  ?B \\<noteq> 0 \\<Longrightarrow>\n  ((\\<Sum>i = 0..<?n + 1. ?f i * ?B ^ (?n - i)) * ?B ^ (?n mod 2) < 0) =\n  ((\\<Sum>i = 0..<?n + 1. ?f i / ?B ^ i) < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n    ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have \"((\\<Sum>i = 0..<d+1. f i / C ^ i) = 0) =((\\<Sum>i = 0..<d+1. (f i) * C ^ (d - i)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n    ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)", "using normalize_summation nonzero"], ["proof (prove)\nusing this:\n  ?B \\<noteq> 0 \\<Longrightarrow>\n  ((\\<Sum>i = 0..<?n + 1. ?f i * ?B ^ (?n - i)) = 0) =\n  ((\\<Sum>i = 0..<?n + 1. ?f i / ?B ^ i) = 0)\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n    ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)", "by(auto)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have \"... =((\\<Sum>i = 0..<d+1. (f i) * C ^ (d - i))* C ^ (d mod 2) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0) =\n    ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) = 0)", "using mult_eq_0_iff nonzero power_not_zero"], ["proof (prove)\nusing this:\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  C \\<noteq> 0\n  ?a \\<noteq> (0::?'a) \\<Longrightarrow> ?a ^ ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0) =\n    ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) = 0)", "by blast"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) = 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "finally"], ["proof (chain)\npicking this:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) = 0)", "have h1 : \"((\\<Sum>i = 0..<(d+1). (f i) * C ^ (d - i)) * C ^ (d mod 2) \\<le> 0 ) = ((\\<Sum>i = 0..<((d::nat)+1). (f i::real) / (C ^ i)) \\<le> 0)\""], ["proof (prove)\nusing this:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) = 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) \\<le> 0) =\n    ((\\<Sum>i = 0..<d + 1. f i / C ^ i) \\<le> 0)", "using h1a"], ["proof (prove)\nusing this:\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) = 0) =\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) = 0)\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) < 0) =\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) < 0)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) \\<le> 0) =\n    ((\\<Sum>i = 0..<d + 1. f i / C ^ i) \\<le> 0)", "by smt"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have \"aEval (linear_substitution var b c (Leq(p))) (list_update L var (B/C))=aEval (Leq((\\<Sum>i\\<in>{0..<(d+1)}. isolate_variable_sparse p var i * (b^i) * (c^(d-i))) * (c ^ (d mod 2)))) (list_update L var (B/C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (linear_substitution var b c (Leq p)) (L[var := B / C]) =\n    aEval\n     (Leq ((\\<Sum>i = 0..<d + 1.\n               isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n           c ^ (d mod 2)))\n     (L[var := B / C])", "by (metis (no_types, lifting) d_def linear_substitution.simps(3) sum.cong)"], ["proof (state)\nthis:\n  aEval (linear_substitution var b c (Leq p)) (L[var := B / C]) =\n  aEval\n   (Leq ((\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n         c ^ (d mod 2)))\n   (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval (linear_substitution var b c (Leq p)) (L[var := B / C]) =\n  aEval\n   (Leq ((\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n         c ^ (d mod 2)))\n   (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i * C ^ (d - i)) * C ^ (d mod 2) \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (Leq ((\\<Sum>i = 0..<d + 1.\n               isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n           c ^ (d mod 2)))\n     (L[var := B / C]) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     \\<le> 0)", "using assms"], ["proof (prove)\nusing this:\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. aEval\n     (Leq ((\\<Sum>i = 0..<d + 1.\n               isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n           c ^ (d mod 2)))\n     (L[var := B / C]) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     \\<le> 0)", "by(simp add: insertion_sum insertion_mult insertion_add insertion_pow insertion_neg lLength)"], ["proof (state)\nthis:\n  aEval\n   (Leq ((\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n         c ^ (d mod 2)))\n   (L[var := B / C]) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval\n   (Leq ((\\<Sum>i = 0..<d + 1.\n             isolate_variable_sparse p var i * b ^ i * c ^ (d - i)) *\n         c ^ (d mod 2)))\n   (L[var := B / C]) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have\"...= ((\\<Sum>i = 0..<(d+1). (insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B) ^ i) / (C ^ i)) \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     \\<le> 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i /\n         C ^ i)\n     \\<le> 0)", "using h1 f_def"], ["proof (prove)\nusing this:\n  ((\\<Sum>i = 0..<d + 1. f i * C ^ (d - i)) * C ^ (d mod 2) \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1. f i / C ^ i) \\<le> 0)\n  f ?i =\n  insertion (nth_default 0 (L[var := B / C]))\n   (isolate_variable_sparse p var ?i) *\n  B ^ ?i\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i *\n         C ^ (d - i)) *\n     C ^ (d mod 2)\n     \\<le> 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i /\n         C ^ i)\n     \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i)\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i *\n       C ^ (d - i)) *\n   C ^ (d mod 2)\n   \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i)\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (((B) ^ i) / (C ^ i))) \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         B ^ i /\n         C ^ i)\n     \\<le> 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B ^ i / C ^ i))\n     \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i)\n   \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       B ^ i /\n       C ^ i)\n   \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have \"... = ((\\<Sum>i = 0..<(d+1). insertion (nth_default 0 (list_update L var (B/C))) (isolate_variable_sparse p var i) * (B/C)^i) \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B ^ i / C ^ i))\n     \\<le> 0) =\n    ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i)\n     \\<le> 0)", "by (metis (no_types, lifting) power_divide sum.cong)"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i)\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B ^ i / C ^ i))\n   \\<le> 0) =\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i)\n   \\<le> 0)\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "have  \"... = aEval (Leq(p)) (list_update L var (B/C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i)\n     \\<le> 0) =\n    aEval (Leq p) (L[var := B / C])", "using d_def sum_over_degree_insertion lLength"], ["proof (prove)\nusing this:\n  d = MPoly_Type.degree p var\n  \\<lbrakk>?var < length ?L; MPoly_Type.degree ?p ?var = ?d\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i = 0..<?d + 1.\n                        insertion (nth_default 0 (?L[?var := ?x]))\n                         (isolate_variable_sparse ?p ?var i) *\n                        ?x ^ i) =\n                    insertion (nth_default 0 (?L[?var := ?x])) ?p\n  var < length L\n\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<d + 1.\n         insertion (nth_default 0 (L[var := B / C]))\n          (isolate_variable_sparse p var i) *\n         (B / C) ^ i)\n     \\<le> 0) =\n    aEval (Leq p) (L[var := B / C])", "by auto"], ["proof (state)\nthis:\n  ((\\<Sum>i = 0..<d + 1.\n       insertion (nth_default 0 (L[var := B / C]))\n        (isolate_variable_sparse p var i) *\n       (B / C) ^ i)\n   \\<le> 0) =\n  aEval (Leq p) (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "finally"], ["proof (chain)\npicking this:\n  aEval (linear_substitution var b c (Leq p)) (L[var := B / C]) =\n  aEval (Leq p) (L[var := B / C])", "show ?thesis"], ["proof (prove)\nusing this:\n  aEval (linear_substitution var b c (Leq p)) (L[var := B / C]) =\n  aEval (Leq p) (L[var := B / C])\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "using assms plugInLinear var_not_in_eval var_not_in_linear"], ["proof (prove)\nusing this:\n  aEval (linear_substitution var b c (Leq p)) (L[var := B / C]) =\n  aEval (Leq p) (L[var := B / C])\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n  \\<lbrakk>?var < length ?L; ?B \\<noteq> 0;\n   \\<forall>v. insertion (nth_default 0 (?L[?var := v])) ?b = ?B;\n   \\<forall>v. insertion (nth_default 0 (?L[?var := v])) ?c = ?C\\<rbrakk>\n  \\<Longrightarrow> aEval (Eq (?b * Var ?var + ?c)) (?L[?var := - ?C / ?B])\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var\n                     (fm.Atom (linear_substitution ?var ?b ?c ?A))\n\ngoal (1 subgoal):\n 1. aEval (Leq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Leq p)) (L[var := v])", "by (meson var_not_in_aEval)"], ["proof (state)\nthis:\n  aEval (Leq p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Leq p)) (L[var := v])\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ----------------------------------------------------------------------------------------------- *)"], ["", "lemma linear_neq :\n  assumes lLength : \"length L > var\"\n  assumes nonzero : \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval (Neq(p)) (list_update L var (B/C)) = (aEval (linear_substitution var b c (Neq(p))) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "define d where \"d = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  d = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "have \"aEval (Eq(p)) (list_update L var (B/C)) = (\\<forall>v. aEval (linear_substitution var b c (Eq(p))) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v]))", "using linear_eq assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var < length ?L; ?C \\<noteq> 0; ?var \\<notin> vars ?b;\n   ?var \\<notin> vars ?c;\n   insertion (nth_default 0 (?L[?var := ?B / ?C])) ?b = ?B;\n   insertion (nth_default 0 (?L[?var := ?B / ?C])) ?c = ?C\\<rbrakk>\n  \\<Longrightarrow> aEval (Eq ?p) (?L[?var := ?B / ?C]) =\n                    aEval (linear_substitution ?var ?b ?c (Eq ?p))\n                     (?L[?var := ?v])\n  var < length L\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (L[var := B / C]) =\n    (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v]))", "by auto"], ["proof (state)\nthis:\n  aEval (Eq p) (L[var := B / C]) =\n  (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v]))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  aEval (Eq p) (L[var := B / C]) =\n  (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v]))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "have \"... = (\\<forall>v. eval (Atom (Eq ((\\<Sum>i = 0..<d+1. isolate_variable_sparse p var i * (b) ^ i * c ^ (d - i))))) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v])) =\n    (\\<forall>v.\n        eval\n         (fm.Atom\n           (Eq (\\<Sum>i = 0..<d + 1.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i))))\n         (L[var := v]))", "by (metis (no_types, lifting) d_def eval.simps(1) linear_substitution.simps(1) sum.cong)"], ["proof (state)\nthis:\n  (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v])) =\n  (\\<forall>v.\n      eval\n       (fm.Atom\n         (Eq (\\<Sum>i = 0..<d + 1.\n                 isolate_variable_sparse p var i * b ^ i * c ^ (d - i))))\n       (L[var := v]))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  (\\<forall>v. aEval (linear_substitution var b c (Eq p)) (L[var := v])) =\n  (\\<forall>v.\n      eval\n       (fm.Atom\n         (Eq (\\<Sum>i = 0..<d + 1.\n                 isolate_variable_sparse p var i * b ^ i * c ^ (d - i))))\n       (L[var := v]))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "have \"... = (\\<not>(\\<forall>v. eval (Atom (Neq ((\\<Sum>i = 0..<d+1. isolate_variable_sparse p var i * (b) ^ i * c ^ (d - i))))) (list_update L var v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        eval\n         (fm.Atom\n           (Eq (\\<Sum>i = 0..<d + 1.\n                   isolate_variable_sparse p var i * b ^ i * c ^ (d - i))))\n         (L[var := v])) =\n    (\\<not> (\\<forall>v.\n                eval\n                 (fm.Atom\n                   (Neq (\\<Sum>i = 0..<d + 1.\n                            isolate_variable_sparse p var i * b ^ i *\n                            c ^ (d - i))))\n                 (L[var := v])))", "by (metis (no_types, lifting) aEval.simps(1) aEval.simps(4) eval.simps(1) assms(3) assms(4) not_contains_insertion not_in_isovarspar not_in_mult not_in_pow not_in_sum)"], ["proof (state)\nthis:\n  (\\<forall>v.\n      eval\n       (fm.Atom\n         (Eq (\\<Sum>i = 0..<d + 1.\n                 isolate_variable_sparse p var i * b ^ i * c ^ (d - i))))\n       (L[var := v])) =\n  (\\<not> (\\<forall>v.\n              eval\n               (fm.Atom\n                 (Neq (\\<Sum>i = 0..<d + 1.\n                          isolate_variable_sparse p var i * b ^ i *\n                          c ^ (d - i))))\n               (L[var := v])))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "also"], ["proof (state)\nthis:\n  (\\<forall>v.\n      eval\n       (fm.Atom\n         (Eq (\\<Sum>i = 0..<d + 1.\n                 isolate_variable_sparse p var i * b ^ i * c ^ (d - i))))\n       (L[var := v])) =\n  (\\<not> (\\<forall>v.\n              eval\n               (fm.Atom\n                 (Neq (\\<Sum>i = 0..<d + 1.\n                          isolate_variable_sparse p var i * b ^ i *\n                          c ^ (d - i))))\n               (L[var := v])))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "have \"... = (\\<not>(\\<forall>v. aEval (linear_substitution var b c (Neq(p))) (list_update L var v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>v.\n                eval\n                 (fm.Atom\n                   (Neq (\\<Sum>i = 0..<d + 1.\n                            isolate_variable_sparse p var i * b ^ i *\n                            c ^ (d - i))))\n                 (L[var := v]))) =\n    (\\<not> (\\<forall>v.\n                aEval (linear_substitution var b c (Neq p)) (L[var := v])))", "by (metis (full_types) d_def eval.simps(1) linear_substitution.simps(4))"], ["proof (state)\nthis:\n  (\\<not> (\\<forall>v.\n              eval\n               (fm.Atom\n                 (Neq (\\<Sum>i = 0..<d + 1.\n                          isolate_variable_sparse p var i * b ^ i *\n                          c ^ (d - i))))\n               (L[var := v]))) =\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v])))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "finally"], ["proof (chain)\npicking this:\n  aEval (Eq p) (L[var := B / C]) =\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v])))", "have \"... = (\\<not>(aEval (Neq(p)) (list_update L var (B/C))))\""], ["proof (prove)\nusing this:\n  aEval (Eq p) (L[var := B / C]) =\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v])))\n\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>v.\n                aEval (linear_substitution var b c (Neq p))\n                 (L[var := v]))) =\n    (\\<not> aEval (Neq p) (L[var := B / C]))", "by simp"], ["proof (state)\nthis:\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v]))) =\n  (\\<not> aEval (Neq p) (L[var := B / C]))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "then"], ["proof (chain)\npicking this:\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v]))) =\n  (\\<not> aEval (Neq p) (L[var := B / C]))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v]))) =\n  (\\<not> aEval (Neq p) (L[var := B / C]))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "using assms(3) assms(4) var_not_in_aEval var_not_in_linear"], ["proof (prove)\nusing this:\n  (\\<not> (\\<forall>v.\n              aEval (linear_substitution var b c (Neq p)) (L[var := v]))) =\n  (\\<not> aEval (Neq p) (L[var := B / C]))\n  var \\<notin> vars b\n  var \\<notin> vars c\n  freeIn ?var (fm.Atom ?\\<phi>) \\<Longrightarrow>\n  (\\<exists>x. aEval ?\\<phi> (?L[?var := x])) =\n  (\\<forall>x. aEval ?\\<phi> (?L[?var := x]))\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn ?var\n                     (fm.Atom (linear_substitution ?var ?b ?c ?A))\n\ngoal (1 subgoal):\n 1. aEval (Neq p) (L[var := B / C]) =\n    aEval (linear_substitution var b c (Neq p)) (L[var := v])", "by blast"], ["proof (state)\nthis:\n  aEval (Neq p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Neq p)) (L[var := v])\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------------------------------------------------------------------- *)"], ["", "theorem linear :\n  assumes lLength : \"length L > var\"\n  assumes \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"aEval A (list_update L var (B/C))  = (aEval (linear_substitution var b c A) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval A (L[var := B / C]) =\n    aEval (linear_substitution var b c A) (L[var := v])", "apply(cases A)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])", "using linear_less[OF assms(1-6)] linear_eq[OF assms(1-6)] linear_leq[OF assms(1-6)] linear_neq[OF assms(1-6)]"], ["proof (prove)\nusing this:\n  aEval (Less ?p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Less ?p)) (L[var := ?v])\n  aEval (Eq ?p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Eq ?p)) (L[var := ?v])\n  aEval (Leq ?p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Leq ?p)) (L[var := ?v])\n  aEval (Neq ?p) (L[var := B / C]) =\n  aEval (linear_substitution var b c (Neq ?p)) (L[var := ?v])\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow>\n       aEval A (L[var := B / C]) =\n       aEval (linear_substitution var b c A) (L[var := v])", "by auto"], ["", "lemma var_not_in_linear_fm_helper : \n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\" \n  shows \"freeIn (var+z) (linear_substitution_fm_helper var b c F z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c F z)", "proof(induction F arbitrary: z)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c TrueF z)\n 2. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)\n 3. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 5. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 8. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 10. \\<And>x1 F z.\n        (\\<And>z.\n            freeIn (var + z)\n             (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n        freeIn (var + z)\n         (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case TrueF"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c TrueF z)\n 2. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)\n 3. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 5. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 8. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 10. \\<And>x1 F z.\n        (\\<And>z.\n            freeIn (var + z)\n             (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n        freeIn (var + z)\n         (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c TrueF z)", "by(simp)"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c TrueF z)\n\ngoal (9 subgoals):\n 1. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)\n 2. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 3. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)\n 2. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 3. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case FalseF"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<And>z.\n       freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)\n 2. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 3. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)", "by simp"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c FalseF z)\n\ngoal (8 subgoals):\n 1. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 2. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 3. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 2. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 3. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>x z.\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (fm.Atom x) z)\n 2. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 3. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (fm.Atom x) z)", "unfolding linear_substitution_fm_helper.simps liftmap.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z)\n     (fm.Atom\n       (linear_substitution (var + z) (liftPoly 0 z b) (liftPoly 0 z c) x))", "using var_not_in_linear[OF not_in_lift[OF assms(1)] not_in_lift[OF assms(2)], of z]"], ["proof (prove)\nusing this:\n  freeIn (var + z)\n   (fm.Atom\n     (linear_substitution (var + z) (liftPoly 0 z b) (liftPoly 0 z c) ?A))\n\ngoal (1 subgoal):\n 1. freeIn (var + z)\n     (fm.Atom\n       (linear_substitution (var + z) (liftPoly 0 z b) (liftPoly 0 z c) x))", "by blast"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (fm.Atom x) z)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 2. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 2. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (And F1 F2)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F1 ?z)\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F2 ?z)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n 2. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F1 ?z)\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F2 ?z)", "show ?case"], ["proof (prove)\nusing this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F1 ?z)\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F2 ?z)\n\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (And F1 F2) z)", "by simp"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (And F1 F2) z)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (Or F1 F2)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F1 ?z)\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F2 ?z)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (linear_substitution_fm_helper var b c F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F1 ?z)\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F2 ?z)", "show ?case"], ["proof (prove)\nusing this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F1 ?z)\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F2 ?z)\n\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (Or F1 F2) z)", "by simp"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (Or F1 F2) z)\n\ngoal (5 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (Neg F)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F ?z)\n\ngoal (5 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F ?z)", "show ?case"], ["proof (prove)\nusing this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F ?z)\n\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)", "by simp"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (Neg F) z)\n\ngoal (4 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (ExQ F)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F ?z)\n\ngoal (4 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)", "using ExQ[of \"z+1\"]"], ["proof (prove)\nusing this:\n  freeIn (var + (z + 1)) (linear_substitution_fm_helper var b c F (z + 1))\n\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)", "by simp"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (ExQ F) z)\n\ngoal (3 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (AllQ F)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c F ?z)\n\ngoal (3 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)", "using AllQ[of \"z+1\"]"], ["proof (prove)\nusing this:\n  freeIn (var + (z + 1)) (linear_substitution_fm_helper var b c F (z + 1))\n\ngoal (1 subgoal):\n 1. freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)", "by simp"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (AllQ F) z)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c \\<phi> ?z)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 F) z)\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c \\<phi> ?z)", "show ?case"], ["proof (prove)\nusing this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c \\<phi> ?z)\n\ngoal (1 subgoal):\n 1. freeIn (var + z)\n     (linear_substitution_fm_helper var b c (ExN x1 \\<phi>) z)", "by (metis (no_types, lifting) freeIn.simps(13) group_cancel.add1 liftmap.simps(10) linear_substitution_fm_helper.simps)"], ["proof (state)\nthis:\n  freeIn (var + z) (linear_substitution_fm_helper var b c (ExN x1 \\<phi>) z)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c \\<phi> ?z)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (linear_substitution_fm_helper var b c F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (linear_substitution_fm_helper var b c (AllN x1 F) z)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c \\<phi> ?z)", "show ?case"], ["proof (prove)\nusing this:\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c \\<phi> ?z)\n\ngoal (1 subgoal):\n 1. freeIn (var + z)\n     (linear_substitution_fm_helper var b c (AllN x1 \\<phi>) z)", "by (metis (no_types, lifting) freeIn.simps(12) group_cancel.add1 liftmap.simps(9) linear_substitution_fm_helper.simps)"], ["proof (state)\nthis:\n  freeIn (var + z)\n   (linear_substitution_fm_helper var b c (AllN x1 \\<phi>) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem var_not_in_linear_fm : \n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\" \n  shows \"freeIn var (linear_substitution_fm var b c F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (linear_substitution_fm var b c F)", "using var_not_in_linear_fm_helper[OF assms, of 0]"], ["proof (prove)\nusing this:\n  freeIn (var + 0) (linear_substitution_fm_helper var b c ?F 0)\n\ngoal (1 subgoal):\n 1. freeIn var (linear_substitution_fm var b c F)", "by auto"], ["", "lemma linear_fm_helper :\n  assumes \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update (drop z L) var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update (drop z L) var (B/C))) c = (C::real)\"\n  assumes lLength : \"length L > var+z\"\n  shows \"eval F (list_update L (var+z) (B/C))  = (eval (linear_substitution_fm_helper var b c F z) (list_update L (var+z) v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c F z) (L[var + z := v])", "using assms"], ["proof (prove)\nusing this:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. eval F (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c F z) (L[var + z := v])", "proof(induction F arbitrary:z L)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval TrueF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c TrueF z)\n                          (L[var + z := v])\n 2. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c FalseF z)\n                          (L[var + z := v])\n 3. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 7. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 8. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 9. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 10. \\<And>x1 F z L.\n        \\<lbrakk>\\<And>z L.\n                    \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                     var \\<notin> vars c;\n                     insertion (nth_default 0 ((drop z L)[var := B / C]))\n                      b =\n                     B;\n                     insertion (nth_default 0 ((drop z L)[var := B / C]))\n                      c =\n                     C;\n                     var + z < length L\\<rbrakk>\n                    \\<Longrightarrow> eval F (L[var + z := B / C]) =\neval (linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n         C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n         insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n         insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n         var + z < length L\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                          eval\n                           (linear_substitution_fm_helper var b c\n                             (AllN x1 F) z)\n                           (L[var + z := v])", "case TrueF"], ["proof (state)\nthis:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (10 subgoals):\n 1. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval TrueF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c TrueF z)\n                          (L[var + z := v])\n 2. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c FalseF z)\n                          (L[var + z := v])\n 3. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 7. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 8. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 9. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 10. \\<And>x1 F z L.\n        \\<lbrakk>\\<And>z L.\n                    \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                     var \\<notin> vars c;\n                     insertion (nth_default 0 ((drop z L)[var := B / C]))\n                      b =\n                     B;\n                     insertion (nth_default 0 ((drop z L)[var := B / C]))\n                      c =\n                     C;\n                     var + z < length L\\<rbrakk>\n                    \\<Longrightarrow> eval F (L[var + z := B / C]) =\neval (linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n         C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n         insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n         insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n         var + z < length L\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                          eval\n                           (linear_substitution_fm_helper var b c\n                             (AllN x1 F) z)\n                           (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L", "show ?case"], ["proof (prove)\nusing this:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. eval TrueF (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c TrueF z) (L[var + z := v])", "by auto"], ["proof (state)\nthis:\n  eval TrueF (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c TrueF z) (L[var + z := v])\n\ngoal (9 subgoals):\n 1. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c FalseF z)\n                          (L[var + z := v])\n 2. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 7. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 9. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c FalseF z)\n                          (L[var + z := v])\n 2. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 7. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 9. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case FalseF"], ["proof (state)\nthis:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (9 subgoals):\n 1. \\<And>z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c FalseF z)\n                          (L[var + z := v])\n 2. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 7. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 9. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L", "show ?case"], ["proof (prove)\nusing this:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. eval FalseF (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c FalseF z) (L[var + z := v])", "by auto"], ["proof (state)\nthis:\n  eval FalseF (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c FalseF z) (L[var + z := v])\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (Atom x)"], ["proof (state)\nthis:\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "define L1 where \"L1 = drop z L\""], ["proof (state)\nthis:\n  L1 = drop z L\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "define L2 where \"L2 = take z L\""], ["proof (state)\nthis:\n  L2 = take z L\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have L_def : \"L = L2 @ L1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = L2 @ L1", "using L1_def L2_def"], ["proof (prove)\nusing this:\n  L1 = drop z L\n  L2 = take z L\n\ngoal (1 subgoal):\n 1. L = L2 @ L1", "by auto"], ["proof (state)\nthis:\n  L = L2 @ L1\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have h1a : \"insertion (nth_default 0 L1) b = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 L1) b = B", "using not_contains_insertion[OF Atom(2), of L1 \"B/C\" B] Atom(4)"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L1[var := B / C])) b = B \\<Longrightarrow>\n  insertion (nth_default 0 (L1[var := ?y])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 L1) b = B", "unfolding L1_def nth_default_def"], ["proof (prove)\nusing this:\n  insertion\n   (\\<lambda>n.\n       if n < length ((drop z L)[var := B / C])\n       then (drop z L)[var := B / C] ! n else 0)\n   b =\n  B \\<Longrightarrow>\n  insertion\n   (\\<lambda>n.\n       if n < length ((drop z L)[var := ?y]) then (drop z L)[var := ?y] ! n\n       else 0)\n   b =\n  B\n  insertion\n   (\\<lambda>a.\n       if a < length ((drop z L)[var := B / C])\n       then (drop z L)[var := B / C] ! a else 0)\n   b =\n  B\n\ngoal (1 subgoal):\n 1. insertion\n     (\\<lambda>n. if n < length (drop z L) then drop z L ! n else 0) b =\n    B", "by (metis list_update_id)"], ["proof (state)\nthis:\n  insertion (nth_default 0 L1) b = B\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have lengthl2 : \"length L2 = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L2 = z", "using L2_def"], ["proof (prove)\nusing this:\n  L2 = take z L\n\ngoal (1 subgoal):\n 1. length L2 = z", "using Atom.prems(6) min.absorb2"], ["proof (prove)\nusing this:\n  L2 = take z L\n  var + z < length L\n  ?b \\<le> ?a \\<Longrightarrow> min ?a ?b = ?b\n\ngoal (1 subgoal):\n 1. length L2 = z", "by auto"], ["proof (state)\nthis:\n  length L2 = z\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"(\\<forall>I amount.\n         length I = amount \\<longrightarrow>\n         (\\<forall>xs. eval (fm.Atom (Eq (b - Const B))) ([] @ xs) =\n               eval (liftFm 0 amount (fm.Atom (Eq (b - Const B)))) ([] @ I @ xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I amount.\n       length I = amount \\<longrightarrow>\n       (\\<forall>xs.\n           eval (fm.Atom (Eq (b - Const B))) ([] @ xs) =\n           eval (liftFm 0 amount (fm.Atom (Eq (b - Const B))))\n            ([] @ I @ xs))", "by (metis eval_liftFm_helper list.size(3))"], ["proof (state)\nthis:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (b - Const B))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (b - Const B)))) ([] @ I @ xs))\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (b - Const B))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (b - Const B)))) ([] @ I @ xs))", "have \"eval (Atom(Eq (b-Const B))) ([] @ L1) = eval (liftFm 0 z (Atom(Eq (b- Const B)))) ([] @ L2 @ L1)\""], ["proof (prove)\nusing this:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (b - Const B))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (b - Const B)))) ([] @ I @ xs))\n\ngoal (1 subgoal):\n 1. eval (fm.Atom (Eq (b - Const B))) ([] @ L1) =\n    eval (liftFm 0 z (fm.Atom (Eq (b - Const B)))) ([] @ L2 @ L1)", "using lengthl2"], ["proof (prove)\nusing this:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (b - Const B))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (b - Const B)))) ([] @ I @ xs))\n  length L2 = z\n\ngoal (1 subgoal):\n 1. eval (fm.Atom (Eq (b - Const B))) ([] @ L1) =\n    eval (liftFm 0 z (fm.Atom (Eq (b - Const B)))) ([] @ L2 @ L1)", "by auto"], ["proof (state)\nthis:\n  eval (fm.Atom (Eq (b - Const B))) ([] @ L1) =\n  eval (liftFm 0 z (fm.Atom (Eq (b - Const B)))) ([] @ L2 @ L1)\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  eval (fm.Atom (Eq (b - Const B))) ([] @ L1) =\n  eval (liftFm 0 z (fm.Atom (Eq (b - Const B)))) ([] @ L2 @ L1)", "have \"(insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0)\""], ["proof (prove)\nusing this:\n  eval (fm.Atom (Eq (b - Const B))) ([] @ L1) =\n  eval (liftFm 0 z (fm.Atom (Eq (b - Const B)))) ([] @ L2 @ L1)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0", "apply(simp add: insertion_sub insertion_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 L1) b = B) =\n    (insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) =\n     0) \\<Longrightarrow>\n    insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0", "using h1a"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 L1) b = B\n\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 L1) b = B) =\n    (insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) =\n     0) \\<Longrightarrow>\n    insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0", "have \"insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B", "using lift_minus"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (b - Const B)) = 0\n  insertion ?f (liftPoly 0 ?z (?c - Const ?C)) = 0 \\<Longrightarrow>\n  insertion ?f (liftPoly 0 ?z ?c) = ?C\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B", "by blast"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B", "have h1 : \"insertion (nth_default 0 (L[var + z := B/C])) (liftPoly 0 z b) = B\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var + z := B / C])) (liftPoly 0 z b) = B", "using not_in_lift[OF Atom(2), of z] L_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z b) = B\n  var + z \\<notin> vars (liftPoly 0 z b)\n  L = L2 @ L1\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var + z := B / C])) (liftPoly 0 z b) = B", "by (metis list_update_id not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L[var + z := B / C])) (liftPoly 0 z b) = B\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have h2a : \"insertion (nth_default 0 L1) c = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 L1) c = C", "using not_contains_insertion[OF Atom(3), of L1 \"B/C\" C] Atom(5)"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L1[var := B / C])) c = C \\<Longrightarrow>\n  insertion (nth_default 0 (L1[var := ?y])) c = C\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 L1) c = C", "unfolding L1_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n  C \\<Longrightarrow>\n  insertion (nth_default 0 ((drop z L)[var := ?y])) c = C\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (drop z L)) c = C", "by (metis list_update_id)"], ["proof (state)\nthis:\n  insertion (nth_default 0 L1) c = C\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"(\\<forall>I amount.\n         length I = amount \\<longrightarrow>\n         (\\<forall>xs. eval (fm.Atom (Eq (c - Const C))) ([] @ xs) =\n               eval (liftFm 0 amount (fm.Atom (Eq (c - Const C)))) ([] @ I @ xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I amount.\n       length I = amount \\<longrightarrow>\n       (\\<forall>xs.\n           eval (fm.Atom (Eq (c - Const C))) ([] @ xs) =\n           eval (liftFm 0 amount (fm.Atom (Eq (c - Const C))))\n            ([] @ I @ xs))", "by (metis eval_liftFm_helper list.size(3))"], ["proof (state)\nthis:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (c - Const C))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (c - Const C)))) ([] @ I @ xs))\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (c - Const C))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (c - Const C)))) ([] @ I @ xs))", "have \"eval (Atom(Eq (c-Const C))) ([] @ L1) = eval (liftFm 0 z (Atom(Eq (c- Const C)))) ([] @ L2 @ L1)\""], ["proof (prove)\nusing this:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (c - Const C))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (c - Const C)))) ([] @ I @ xs))\n\ngoal (1 subgoal):\n 1. eval (fm.Atom (Eq (c - Const C))) ([] @ L1) =\n    eval (liftFm 0 z (fm.Atom (Eq (c - Const C)))) ([] @ L2 @ L1)", "using lengthl2"], ["proof (prove)\nusing this:\n  \\<forall>I amount.\n     length I = amount \\<longrightarrow>\n     (\\<forall>xs.\n         eval (fm.Atom (Eq (c - Const C))) ([] @ xs) =\n         eval (liftFm 0 amount (fm.Atom (Eq (c - Const C)))) ([] @ I @ xs))\n  length L2 = z\n\ngoal (1 subgoal):\n 1. eval (fm.Atom (Eq (c - Const C))) ([] @ L1) =\n    eval (liftFm 0 z (fm.Atom (Eq (c - Const C)))) ([] @ L2 @ L1)", "by auto"], ["proof (state)\nthis:\n  eval (fm.Atom (Eq (c - Const C))) ([] @ L1) =\n  eval (liftFm 0 z (fm.Atom (Eq (c - Const C)))) ([] @ L2 @ L1)\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  eval (fm.Atom (Eq (c - Const C))) ([] @ L1) =\n  eval (liftFm 0 z (fm.Atom (Eq (c - Const C)))) ([] @ L2 @ L1)", "have \"(insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0)\""], ["proof (prove)\nusing this:\n  eval (fm.Atom (Eq (c - Const C))) ([] @ L1) =\n  eval (liftFm 0 z (fm.Atom (Eq (c - Const C)))) ([] @ L2 @ L1)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0", "apply(simp add: insertion_sub insertion_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 L1) c = C) =\n    (insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) =\n     0) \\<Longrightarrow>\n    insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0", "using h2a"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 L1) c = C\n\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 L1) c = C) =\n    (insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) =\n     0) \\<Longrightarrow>\n    insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0", "have \"insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C", "using lift_minus"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z (c - Const C)) = 0\n  insertion ?f (liftPoly 0 ?z (?c - Const ?C)) = 0 \\<Longrightarrow>\n  insertion ?f (liftPoly 0 ?z ?c) = ?C\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C", "by blast"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C", "have h2 : \"insertion (nth_default 0 (L[var + z := B/C])) (liftPoly 0 z c) = C\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var + z := B / C])) (liftPoly 0 z c) = C", "using not_in_lift[OF Atom(3), of z] L_def"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (L2 @ L1)) (liftPoly 0 z c) = C\n  var + z \\<notin> vars (liftPoly 0 z c)\n  L = L2 @ L1\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (L[var + z := B / C])) (liftPoly 0 z c) = C", "by (metis list_update_id not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (L[var + z := B / C])) (liftPoly 0 z c) = C\n\ngoal (8 subgoals):\n 1. \\<And>x z L.\n       \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (fm.Atom x)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 6. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 8. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (fm.Atom x) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (fm.Atom x) z)\n     (L[var + z := v])", "using linear[OF Atom(6) Atom(1) not_in_lift[OF Atom(2)] not_in_lift[OF Atom(3)], of B, of x, OF h1 h2]"], ["proof (prove)\nusing this:\n  aEval x (L[var + z := B / C]) =\n  aEval (linear_substitution (var + z) (liftPoly 0 z b) (liftPoly 0 z c) x)\n   (L[var + z := ?v])\n\ngoal (1 subgoal):\n 1. eval (fm.Atom x) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (fm.Atom x) z)\n     (L[var + z := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps eval.simps"], ["proof (prove)\nusing this:\n  aEval x (L[var + z := B / C]) =\n  aEval (linear_substitution (var + z) (liftPoly 0 z b) (liftPoly 0 z c) x)\n   (L[var + z := ?v])\n\ngoal (1 subgoal):\n 1. aEval x (L[var + z := B / C]) =\n    aEval\n     (linear_substitution (var + z) (liftPoly 0 z b) (liftPoly 0 z c) x)\n     (L[var + z := v])", "."], ["proof (state)\nthis:\n  eval (fm.Atom x) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (fm.Atom x) z)\n   (L[var + z := v])\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 6. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 6. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (And F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (And F1 F2)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 5. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 6. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 7. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. eval (And F1 F2) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (And F1 F2) z)\n     (L[var + z := v])", "by auto"], ["proof (state)\nthis:\n  eval (And F1 F2) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (And F1 F2) z)\n   (L[var + z := v])\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 5. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 6. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 5. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 6. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (Or F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F1 z) (L[var + z := v]);\n        \\<And>z L.\n           \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n            insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n            var + z < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 (L[var + z := B / C]) =\n                             eval\n                              (linear_substitution_fm_helper var b c F2 z)\n                              (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Or F1 F2)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 4. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 5. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 6. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. eval (Or F1 F2) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (Or F1 F2) z)\n     (L[var + z := v])", "using var_not_in_linear_fm_helper var_not_in_eval"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn (?var + ?z)\n                     (linear_substitution_fm_helper ?var ?b ?c ?F ?z)\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. eval (Or F1 F2) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (Or F1 F2) z)\n     (L[var + z := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps eval.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 (?L[var + ?z := B / C]) =\n                    eval\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (var + x) (liftPoly 0 x b)\n                              (liftPoly 0 x c) A))\n                       F1 ?z)\n                     (?L[var + ?z := v])\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 (?L[var + ?z := B / C]) =\n                    eval\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (var + x) (liftPoly 0 x b)\n                              (liftPoly 0 x c) A))\n                       F2 ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn (?var + ?z)\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (?var + x)\n                              (liftPoly 0 x ?b) (liftPoly 0 x ?c) A))\n                       ?F ?z)\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. (eval F1 (L[var + z := B / C]) \\<or> eval F2 (L[var + z := B / C])) =\n    (eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x b)\n               (liftPoly 0 x c) A))\n        F1 z)\n      (L[var + z := v]) \\<or>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x b)\n               (liftPoly 0 x c) A))\n        F2 z)\n      (L[var + z := v]))", "by blast"], ["proof (state)\nthis:\n  eval (Or F1 F2) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (Or F1 F2) z)\n   (L[var + z := v])\n\ngoal (5 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (Neg F)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (5 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (Neg F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 3. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 5. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. eval (Neg F) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (Neg F) z) (L[var + z := v])", "using var_not_in_linear_fm_helper var_not_in_eval"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn (?var + ?z)\n                     (linear_substitution_fm_helper ?var ?b ?c ?F ?z)\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. eval (Neg F) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (Neg F) z) (L[var + z := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps eval.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (var + x) (liftPoly 0 x b)\n                              (liftPoly 0 x c) A))\n                       F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n  \\<lbrakk>?var \\<notin> vars ?b; ?var \\<notin> vars ?c\\<rbrakk>\n  \\<Longrightarrow> freeIn (?var + ?z)\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (?var + x)\n                              (liftPoly 0 x ?b) (liftPoly 0 x ?c) A))\n                       ?F ?z)\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. (\\<not> eval F (L[var + z := B / C])) =\n    (\\<not> eval\n             (liftmap\n               (\\<lambda>x A.\n                   fm.Atom\n                    (linear_substitution (var + x) (liftPoly 0 x b)\n                      (liftPoly 0 x c) A))\n               F z)\n             (L[var + z := v]))", "by blast"], ["proof (state)\nthis:\n  eval (Neg F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (Neg F) z) (L[var + z := v])\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (ExQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have droph : \"(drop (z + 1) (x#L)) = (drop z L)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (z + 1) (x # L) = drop z L", "by auto"], ["proof (state)\nthis:\n  drop (z + 1) (?x # L) = drop z L\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have l : \"x # L[var + z := v] = ((x#L)[var+(z+1):=v])\" for x v"], ["proof (prove)\ngoal (1 subgoal):\n 1. x # L[var + z := v] = (x # L)[var + (z + 1) := v]", "by auto"], ["proof (state)\nthis:\n  ?x # L[var + z := ?v] = (?x # L)[var + (z + 1) := ?v]\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"eval (ExQ F) (L[var + z := B/C]) =\n        (\\<exists>x. eval F ((x # L)[var + (z + 1) := B/C])) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExQ F) (L[var + z := B / C]) =\n    (\\<exists>x. eval F ((x # L)[var + (z + 1) := B / C]))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "unfolding l"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (ExQ F) (L[var + z := B / C]) =\n  (\\<exists>x. eval F ((x # L)[var + (z + 1) := B / C]))\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "also"], ["proof (state)\nthis:\n  eval (ExQ F) (L[var + z := B / C]) =\n  (\\<exists>x. eval F ((x # L)[var + (z + 1) := B / C]))\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"... = (\\<exists>x. eval\n              (liftmap (\\<lambda>x. \\<lambda>a. Atom(linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c) a)) F (z + 1))\n              ((x # L)[var + (z + 1) := v]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval F ((x # L)[var + (z + 1) := B / C])) =\n    (\\<exists>x.\n        eval\n         (liftmap\n           (\\<lambda>x a.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) a))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v]))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F ((x # L)[var + (z + 1) := B / C]) =\n       eval\n        (liftmap\n          (\\<lambda>x a.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) a))\n          F (z + 1))\n        ((x # L)[var + (z + 1) := v])", "using ExQ(1)[of \"z+1\", OF assms(1) assms(2) assms(3)] droph"], ["proof (prove)\nusing this:\n  \\<lbrakk>insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) b =\n           B;\n   insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) c = C;\n   var + (z + 1) < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + (z + 1) := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F (z + 1))\n                     (?L[var + (z + 1) := v])\n  drop (z + 1) (?x # L) = drop z L\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F ((x # L)[var + (z + 1) := B / C]) =\n       eval\n        (liftmap\n          (\\<lambda>x a.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) a))\n          F (z + 1))\n        ((x # L)[var + (z + 1) := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) b =\n           B;\n   insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) c = C;\n   var + (z + 1) < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + (z + 1) := B / C]) =\n                    eval\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (var + x) (liftPoly 0 x b)\n                              (liftPoly 0 x c) A))\n                       F (z + 1))\n                     (?L[var + (z + 1) := v])\n  drop (z + 1) (?x # L) = drop z L\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F ((x # L)[var + (z + 1) := B / C]) =\n       eval\n        (liftmap\n          (\\<lambda>x a.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) a))\n          F (z + 1))\n        ((x # L)[var + (z + 1) := v])", "by (metis (mono_tags, lifting) ExQ.prems(4) ExQ.prems(5) ExQ.prems(6) One_nat_def Suc_eq_plus1 Suc_less_eq add_Suc_right list.size(4))"], ["proof (state)\nthis:\n  (\\<exists>x. eval F ((x # L)[var + (z + 1) := B / C])) =\n  (\\<exists>x.\n      eval\n       (liftmap\n         (\\<lambda>x a.\n             fm.Atom\n              (linear_substitution (var + x) (liftPoly 0 x b)\n                (liftPoly 0 x c) a))\n         F (z + 1))\n       ((x # L)[var + (z + 1) := v]))\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "also"], ["proof (state)\nthis:\n  (\\<exists>x. eval F ((x # L)[var + (z + 1) := B / C])) =\n  (\\<exists>x.\n      eval\n       (liftmap\n         (\\<lambda>x a.\n             fm.Atom\n              (linear_substitution (var + x) (liftPoly 0 x b)\n                (liftPoly 0 x c) a))\n         F (z + 1))\n       ((x # L)[var + (z + 1) := v]))\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"... = (eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (liftmap\n           (\\<lambda>x a.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) a))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v])) =\n    eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps eval.simps l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (liftmap\n           (\\<lambda>x a.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) a))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v])) =\n    (\\<exists>x.\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v]))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      eval\n       (liftmap\n         (\\<lambda>x a.\n             fm.Atom\n              (linear_substitution (var + x) (liftPoly 0 x b)\n                (liftPoly 0 x c) a))\n         F (z + 1))\n       ((x # L)[var + (z + 1) := v])) =\n  eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v])\n\ngoal (4 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExQ F) z)\n                          (L[var + z := v])\n 2. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 4. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "finally"], ["proof (chain)\npicking this:\n  eval (ExQ F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v])", "show ?case"], ["proof (prove)\nusing this:\n  eval (ExQ F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v])\n\ngoal (1 subgoal):\n 1. eval (ExQ F) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v])", "by simp"], ["proof (state)\nthis:\n  eval (ExQ F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (ExQ F) z) (L[var + z := v])\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (AllQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have droph : \"(drop (z + 1) (x#L)) = (drop z L)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (z + 1) (x # L) = drop z L", "by auto"], ["proof (state)\nthis:\n  drop (z + 1) (?x # L) = drop z L\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have l : \"x # L[var + z := v] = ((x#L)[var+(z+1):=v])\" for x v"], ["proof (prove)\ngoal (1 subgoal):\n 1. x # L[var + z := v] = (x # L)[var + (z + 1) := v]", "by auto"], ["proof (state)\nthis:\n  ?x # L[var + z := ?v] = (?x # L)[var + (z + 1) := ?v]\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"eval (AllQ F) (L[var + z := B/C]) =\n        (\\<forall>x. eval F ((x # L)[var + (z + 1) := B/C])) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllQ F) (L[var + z := B / C]) =\n    (\\<forall>x. eval F ((x # L)[var + (z + 1) := B / C]))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "unfolding l"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (AllQ F) (L[var + z := B / C]) =\n  (\\<forall>x. eval F ((x # L)[var + (z + 1) := B / C]))\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "also"], ["proof (state)\nthis:\n  eval (AllQ F) (L[var + z := B / C]) =\n  (\\<forall>x. eval F ((x # L)[var + (z + 1) := B / C]))\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"... = (\\<forall>x. eval\n             (liftmap (\\<lambda>x.\\<lambda>a. Atom(linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c) a)) F (z + 1))\n              ((x # L)[var + (z + 1) := v]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. eval F ((x # L)[var + (z + 1) := B / C])) =\n    (\\<forall>x.\n        eval\n         (liftmap\n           (\\<lambda>x a.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) a))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v]))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F ((x # L)[var + (z + 1) := B / C]) =\n       eval\n        (liftmap\n          (\\<lambda>x a.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) a))\n          F (z + 1))\n        ((x # L)[var + (z + 1) := v])", "using AllQ(1)[of \"z+1\", OF assms(1) assms(2) assms(3)]\n      var_not_in_linear_fm_helper[OF assms(2) assms(3)] var_not_in_eval droph"], ["proof (prove)\nusing this:\n  \\<lbrakk>insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) b =\n           B;\n   insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) c = C;\n   var + (z + 1) < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + (z + 1) := B / C]) =\n                    eval (linear_substitution_fm_helper var b c F (z + 1))\n                     (?L[var + (z + 1) := v])\n  freeIn (var + ?z) (linear_substitution_fm_helper var b c ?F ?z)\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n  drop (z + 1) (?x # L) = drop z L\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F ((x # L)[var + (z + 1) := B / C]) =\n       eval\n        (liftmap\n          (\\<lambda>x a.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) a))\n          F (z + 1))\n        ((x # L)[var + (z + 1) := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) b =\n           B;\n   insertion (nth_default 0 ((drop (z + 1) ?L)[var := B / C])) c = C;\n   var + (z + 1) < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F (?L[var + (z + 1) := B / C]) =\n                    eval\n                     (liftmap\n                       (\\<lambda>x A.\n                           fm.Atom\n                            (linear_substitution (var + x) (liftPoly 0 x b)\n                              (liftPoly 0 x c) A))\n                       F (z + 1))\n                     (?L[var + (z + 1) := v])\n  freeIn (var + ?z)\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c)\n            A))\n     ?F ?z)\n  \\<forall>var L.\n     freeIn var ?\\<phi> \\<longrightarrow>\n     (\\<exists>x. eval ?\\<phi> (L[var := x])) =\n     (\\<forall>x. eval ?\\<phi> (L[var := x]))\n  drop (z + 1) (?x # L) = drop z L\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F ((x # L)[var + (z + 1) := B / C]) =\n       eval\n        (liftmap\n          (\\<lambda>x a.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) a))\n          F (z + 1))\n        ((x # L)[var + (z + 1) := v])", "by (metis (mono_tags, lifting) AllQ(7) AllQ.prems(4) AllQ.prems(5) One_nat_def Suc_eq_plus1 Suc_less_eq add_Suc_right list.size(4))"], ["proof (state)\nthis:\n  (\\<forall>x. eval F ((x # L)[var + (z + 1) := B / C])) =\n  (\\<forall>x.\n      eval\n       (liftmap\n         (\\<lambda>x a.\n             fm.Atom\n              (linear_substitution (var + x) (liftPoly 0 x b)\n                (liftPoly 0 x c) a))\n         F (z + 1))\n       ((x # L)[var + (z + 1) := v]))\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "also"], ["proof (state)\nthis:\n  (\\<forall>x. eval F ((x # L)[var + (z + 1) := B / C])) =\n  (\\<forall>x.\n      eval\n       (liftmap\n         (\\<lambda>x a.\n             fm.Atom\n              (linear_substitution (var + x) (liftPoly 0 x b)\n                (liftPoly 0 x c) a))\n         F (z + 1))\n       ((x # L)[var + (z + 1) := v]))\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have \"... = (eval (linear_substitution_fm_helper var b c (AllQ F) z) (L[var + z := v]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        eval\n         (liftmap\n           (\\<lambda>x a.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) a))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v])) =\n    eval (linear_substitution_fm_helper var b c (AllQ F) z)\n     (L[var + z := v])", "unfolding linear_substitution_fm_helper.simps liftmap.simps eval.simps l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        eval\n         (liftmap\n           (\\<lambda>x a.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) a))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v])) =\n    (\\<forall>x.\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           F (z + 1))\n         ((x # L)[var + (z + 1) := v]))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>x.\n      eval\n       (liftmap\n         (\\<lambda>x a.\n             fm.Atom\n              (linear_substitution (var + x) (liftPoly 0 x b)\n                (liftPoly 0 x c) a))\n         F (z + 1))\n       ((x # L)[var + (z + 1) := v])) =\n  eval (linear_substitution_fm_helper var b c (AllQ F) z) (L[var + z := v])\n\ngoal (3 subgoals):\n 1. \\<And>F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllQ F) z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 3. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "finally"], ["proof (chain)\npicking this:\n  eval (AllQ F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (AllQ F) z) (L[var + z := v])", "show ?case"], ["proof (prove)\nusing this:\n  eval (AllQ F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (AllQ F) z) (L[var + z := v])\n\ngoal (1 subgoal):\n 1. eval (AllQ F) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (AllQ F) z)\n     (L[var + z := v])", "by simp"], ["proof (state)\nthis:\n  eval (AllQ F) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (AllQ F) z) (L[var + z := v])\n\ngoal (2 subgoals):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c \\<phi> ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (2 subgoals):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have list : \"\\<And>l. length l=x1 \\<Longrightarrow> ((drop (z + x1) l @ drop (z + x1 - length l) L)[var := B / C]) = ((drop z L)[var := B / C])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       length l = x1 \\<Longrightarrow>\n       (drop (z + x1) l @ drop (z + x1 - length l) L)[var := B / C] =\n       (drop z L)[var := B / C]", "by auto"], ["proof (state)\nthis:\n  length ?l = x1 \\<Longrightarrow>\n  (drop (z + x1) ?l @ drop (z + x1 - length ?l) L)[var := B / C] =\n  (drop z L)[var := B / C]\n\ngoal (2 subgoals):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have map : \"\\<And> z L. eval (liftmap (\\<lambda>x A. fm.Atom (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c) A)) \\<phi> (z + x1))\n      L = eval (liftmap (\\<lambda>x A. fm.Atom (linear_substitution (var + x1 + x) (liftPoly 0 (x+x1) b) (liftPoly 0 (x+x1) c) A)) \\<phi> z)\n      L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          \\<phi> (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          \\<phi> z)\n        L", "apply(induction \\<phi>)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          TrueF (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          TrueF z)\n        L\n 2. \\<And>z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          FalseF (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          FalseF z)\n        L\n 3. \\<And>x z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (fm.Atom x) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (fm.Atom x) z)\n        L\n 4. \\<And>\\<phi>1 \\<phi>2 z L.\n       \\<lbrakk>\\<And>z L.\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x) (liftPoly 0 x b)\n                             (liftPoly 0 x c) A))\n                      \\<phi>1 (z + x1))\n                    L =\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x1 + x)\n                             (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c)\n                             A))\n                      \\<phi>1 z)\n                    L;\n        \\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi>2 (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi>2 z)\n            L\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x)\n                                   (liftPoly 0 x b) (liftPoly 0 x c) A))\n                            (And \\<phi>1 \\<phi>2) (z + x1))\n                          L =\n                         eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x1 + x)\n                                   (liftPoly 0 (x + x1) b)\n                                   (liftPoly 0 (x + x1) c) A))\n                            (And \\<phi>1 \\<phi>2) z)\n                          L\n 5. \\<And>\\<phi>1 \\<phi>2 z L.\n       \\<lbrakk>\\<And>z L.\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x) (liftPoly 0 x b)\n                             (liftPoly 0 x c) A))\n                      \\<phi>1 (z + x1))\n                    L =\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x1 + x)\n                             (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c)\n                             A))\n                      \\<phi>1 z)\n                    L;\n        \\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi>2 (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi>2 z)\n            L\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x)\n                                   (liftPoly 0 x b) (liftPoly 0 x c) A))\n                            (Or \\<phi>1 \\<phi>2) (z + x1))\n                          L =\n                         eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x1 + x)\n                                   (liftPoly 0 (x + x1) b)\n                                   (liftPoly 0 (x + x1) c) A))\n                            (Or \\<phi>1 \\<phi>2) z)\n                          L\n 6. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (Neg \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (Neg \\<phi>) z)\n        L\n 7. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (ExQ \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (ExQ \\<phi>) z)\n        L\n 8. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (AllQ \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (AllQ \\<phi>) z)\n        L\n 9. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (ExN x1a \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (ExN x1a \\<phi>) z)\n        L\n 10. \\<And>x1a \\<phi> z L.\n        (\\<And>z L.\n            eval\n             (liftmap\n               (\\<lambda>x A.\n                   fm.Atom\n                    (linear_substitution (var + x) (liftPoly 0 x b)\n                      (liftPoly 0 x c) A))\n               \\<phi> (z + x1))\n             L =\n            eval\n             (liftmap\n               (\\<lambda>x A.\n                   fm.Atom\n                    (linear_substitution (var + x1 + x)\n                      (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n               \\<phi> z)\n             L) \\<Longrightarrow>\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           (AllN x1a \\<phi>) (z + x1))\n         L =\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                  (liftPoly 0 (x + x1) c) A))\n           (AllN x1a \\<phi>) z)\n         L", "apply(simp_all add:add.commute add.left_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (Suc (z + x1)))\n            (x # L)) =\n       (\\<exists>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (Suc z))\n            (x # L))\n 2. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (Suc (z + x1)))\n            (x # L)) =\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (Suc z))\n            (x # L))\n 3. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))\n 4. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (Suc (z + x1)))\n            (x # L)) =\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (Suc z))\n            (x # L))\n 2. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))\n 3. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))\n 2. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))", "by (metis (mono_tags, lifting) ab_semigroup_add_class.add_ac(1))+"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c)\n            A))\n     \\<phi> (?z + x1))\n   ?L =\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n            (liftPoly 0 (x + x1) c) A))\n     \\<phi> ?z)\n   ?L\n\ngoal (2 subgoals):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (ExN x1 F)\n                            z)\n                          (L[var + z := v])\n 2. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN x1 \\<phi>) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (ExN x1 \\<phi>) z)\n     (L[var + z := v])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l.\n        length l = x1 \\<and> eval \\<phi> (l @ L[var + z := B / C])) =\n    (\\<exists>l.\n        length l = x1 \\<and>\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           \\<phi> (z + x1))\n         (l @ L[var + z := v]))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = x1 \\<and> eval \\<phi> (l @ L[var + z := B / C])) =\n       (length l = x1 \\<and>\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           \\<phi> (z + x1))\n         (l @ L[var + z := v]))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = x1 \\<and> eval \\<phi> (l @ L[var + z := B / C])) =\n    (length l = x1 \\<and>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x b)\n               (liftPoly 0 x c) A))\n        \\<phi> (z + x1))\n      (l @ L[var + z := v]))", "using map[of z] ExN(1)[OF ExN(2-4), of \"z+x1\" \"l@L\"] ExN(5-7) list"], ["proof (prove)\nusing this:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c)\n            A))\n     \\<phi> (z + x1))\n   ?L =\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n            (liftPoly 0 (x + x1) c) A))\n     \\<phi> z)\n   ?L\n  \\<lbrakk>insertion (nth_default 0 ((drop (z + x1) (l @ L))[var := B / C]))\n            b =\n           B;\n   insertion (nth_default 0 ((drop (z + x1) (l @ L))[var := B / C])) c = C;\n   var + (z + x1) < length (l @ L)\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> ((l @ L)[var + (z + x1) := B / C]) =\n                    eval\n                     (linear_substitution_fm_helper var b c \\<phi> (z + x1))\n                     ((l @ L)[var + (z + x1) := v])\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n  length ?l = x1 \\<Longrightarrow>\n  (drop (z + x1) ?l @ drop (z + x1 - length ?l) L)[var := B / C] =\n  (drop z L)[var := B / C]\n\ngoal (1 subgoal):\n 1. (length l = x1 \\<and> eval \\<phi> (l @ L[var + z := B / C])) =\n    (length l = x1 \\<and>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x b)\n               (liftPoly 0 x c) A))\n        \\<phi> (z + x1))\n      (l @ L[var + z := v]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>L.\n                eval\n                 (liftmap\n                   (\\<lambda>x A.\n                       fm.Atom\n                        (linear_substitution (var + x) (liftPoly 0 x b)\n                          (liftPoly 0 x c) A))\n                   \\<phi> (z + x1))\n                 L =\n                eval\n                 (liftmap\n                   (\\<lambda>x A.\n                       fm.Atom\n                        (linear_substitution (var + x1 + x)\n                          (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c)\n                          A))\n                   \\<phi> z)\n                 L;\n     \\<lbrakk>insertion\n               (nth_default 0\n                 ((drop (z + x1) l @ drop (z + x1 - length l) L)\n                  [var := B / C]))\n               b =\n              B;\n      insertion\n       (nth_default 0\n         ((drop (z + x1) l @ drop (z + x1 - length l) L)[var := B / C]))\n       c =\n      C;\n      var + (z + x1) < length l + length L\\<rbrakk>\n     \\<Longrightarrow> eval \\<phi> ((l @ L)[var + (z + x1) := B / C]) =\n                       eval\n                        (liftmap\n                          (\\<lambda>x A.\n                              fm.Atom\n                               (linear_substitution (var + x1 + x)\n                                 (liftPoly 0 (x + x1) b)\n                                 (liftPoly 0 (x + x1) c) A))\n                          \\<phi> z)\n                        ((l @ L)[var + (z + x1) := v]);\n     insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n     insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n     var + z < length L\\<rbrakk>\n    \\<Longrightarrow> (length l = x1 \\<and>\n                       eval \\<phi> (l @ L[var + z := B / C])) =\n                      (length l = x1 \\<and>\n                       eval\n                        (liftmap\n                          (\\<lambda>x A.\n                              fm.Atom\n                               (linear_substitution (var + x1 + x)\n                                 (liftPoly 0 (x + x1) b)\n                                 (liftPoly 0 (x + x1) c) A))\n                          \\<phi> z)\n                        (l @ L[var + z := v]))", "by (smt (z3) add.commute add.left_commute add_diff_cancel_left' add_mono_thms_linordered_field(4) list list_update_append not_add_less1 order_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (ExN x1 \\<phi>) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (ExN x1 \\<phi>) z)\n   (L[var + z := v])\n\ngoal (1 subgoal):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop ?z ?L)[var := B / C])) c = C;\n   var + ?z < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (?L[var + ?z := B / C]) =\n                    eval (linear_substitution_fm_helper var b c \\<phi> ?z)\n                     (?L[var + ?z := v])\n  C \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n\ngoal (1 subgoal):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have list : \"\\<And>l. length l=x1 \\<Longrightarrow> ((drop (z + x1) l @ drop (z + x1 - length l) L)[var := B / C]) = ((drop z L)[var := B / C])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       length l = x1 \\<Longrightarrow>\n       (drop (z + x1) l @ drop (z + x1 - length l) L)[var := B / C] =\n       (drop z L)[var := B / C]", "by auto"], ["proof (state)\nthis:\n  length ?l = x1 \\<Longrightarrow>\n  (drop (z + x1) ?l @ drop (z + x1 - length ?l) L)[var := B / C] =\n  (drop z L)[var := B / C]\n\ngoal (1 subgoal):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "have map : \"\\<And> z L. eval (liftmap (\\<lambda>x A. fm.Atom (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c) A)) \\<phi> (z + x1))\n      L = eval (liftmap (\\<lambda>x A. fm.Atom (linear_substitution (var + x1 + x) (liftPoly 0 (x+x1) b) (liftPoly 0 (x+x1) c) A)) \\<phi> z)\n      L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          \\<phi> (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          \\<phi> z)\n        L", "apply(induction \\<phi>)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          TrueF (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          TrueF z)\n        L\n 2. \\<And>z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          FalseF (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          FalseF z)\n        L\n 3. \\<And>x z L.\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (fm.Atom x) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (fm.Atom x) z)\n        L\n 4. \\<And>\\<phi>1 \\<phi>2 z L.\n       \\<lbrakk>\\<And>z L.\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x) (liftPoly 0 x b)\n                             (liftPoly 0 x c) A))\n                      \\<phi>1 (z + x1))\n                    L =\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x1 + x)\n                             (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c)\n                             A))\n                      \\<phi>1 z)\n                    L;\n        \\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi>2 (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi>2 z)\n            L\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x)\n                                   (liftPoly 0 x b) (liftPoly 0 x c) A))\n                            (And \\<phi>1 \\<phi>2) (z + x1))\n                          L =\n                         eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x1 + x)\n                                   (liftPoly 0 (x + x1) b)\n                                   (liftPoly 0 (x + x1) c) A))\n                            (And \\<phi>1 \\<phi>2) z)\n                          L\n 5. \\<And>\\<phi>1 \\<phi>2 z L.\n       \\<lbrakk>\\<And>z L.\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x) (liftPoly 0 x b)\n                             (liftPoly 0 x c) A))\n                      \\<phi>1 (z + x1))\n                    L =\n                   eval\n                    (liftmap\n                      (\\<lambda>x A.\n                          fm.Atom\n                           (linear_substitution (var + x1 + x)\n                             (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c)\n                             A))\n                      \\<phi>1 z)\n                    L;\n        \\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi>2 (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi>2 z)\n            L\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x)\n                                   (liftPoly 0 x b) (liftPoly 0 x c) A))\n                            (Or \\<phi>1 \\<phi>2) (z + x1))\n                          L =\n                         eval\n                          (liftmap\n                            (\\<lambda>x A.\n                                fm.Atom\n                                 (linear_substitution (var + x1 + x)\n                                   (liftPoly 0 (x + x1) b)\n                                   (liftPoly 0 (x + x1) c) A))\n                            (Or \\<phi>1 \\<phi>2) z)\n                          L\n 6. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (Neg \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (Neg \\<phi>) z)\n        L\n 7. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (ExQ \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (ExQ \\<phi>) z)\n        L\n 8. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (AllQ \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (AllQ \\<phi>) z)\n        L\n 9. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (var + x1 + x)\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x b)\n                 (liftPoly 0 x c) A))\n          (ExN x1a \\<phi>) (z + x1))\n        L =\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                 (liftPoly 0 (x + x1) c) A))\n          (ExN x1a \\<phi>) z)\n        L\n 10. \\<And>x1a \\<phi> z L.\n        (\\<And>z L.\n            eval\n             (liftmap\n               (\\<lambda>x A.\n                   fm.Atom\n                    (linear_substitution (var + x) (liftPoly 0 x b)\n                      (liftPoly 0 x c) A))\n               \\<phi> (z + x1))\n             L =\n            eval\n             (liftmap\n               (\\<lambda>x A.\n                   fm.Atom\n                    (linear_substitution (var + x1 + x)\n                      (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n               \\<phi> z)\n             L) \\<Longrightarrow>\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           (AllN x1a \\<phi>) (z + x1))\n         L =\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n                  (liftPoly 0 (x + x1) c) A))\n           (AllN x1a \\<phi>) z)\n         L", "apply(simp_all add:add.commute add.left_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (Suc (z + x1)))\n            (x # L)) =\n       (\\<exists>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (Suc z))\n            (x # L))\n 2. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (Suc (z + x1)))\n            (x # L)) =\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (Suc z))\n            (x # L))\n 3. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))\n 4. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (Suc (z + x1)))\n            (x # L)) =\n       (\\<forall>x.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (Suc z))\n            (x # L))\n 2. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))\n 3. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<exists>l.\n           length l = x1a \\<and>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))\n 2. \\<And>x1a \\<phi> z L.\n       (\\<And>z L.\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (z + x1))\n            L =\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> z)\n            L) \\<Longrightarrow>\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + var) (liftPoly 0 x b)\n                     (liftPoly 0 x c) A))\n              \\<phi> (x1a + (z + x1)))\n            (l @ L)) =\n       (\\<forall>l.\n           length l = x1a \\<longrightarrow>\n           eval\n            (liftmap\n              (\\<lambda>x A.\n                  fm.Atom\n                   (linear_substitution (x + (var + x1))\n                     (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c) A))\n              \\<phi> (x1a + z))\n            (l @ L))", "by (metis (mono_tags, lifting) ab_semigroup_add_class.add_ac(1))+"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c)\n            A))\n     \\<phi> (?z + x1))\n   ?L =\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n            (liftPoly 0 (x + x1) c) A))\n     \\<phi> ?z)\n   ?L\n\ngoal (1 subgoal):\n 1. \\<And>x1 F z L.\n       \\<lbrakk>\\<And>z L.\n                   \\<lbrakk>C \\<noteq> 0; var \\<notin> vars b;\n                    var \\<notin> vars c;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) b =\n                    B;\n                    insertion (nth_default 0 ((drop z L)[var := B / C])) c =\n                    C;\n                    var + z < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F (L[var + z := B / C]) =\n                                     eval\n(linear_substitution_fm_helper var b c F z) (L[var + z := v]);\n        C \\<noteq> 0; var \\<notin> vars b; var \\<notin> vars c;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n        insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n        var + z < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (L[var + z := B / C]) =\n                         eval\n                          (linear_substitution_fm_helper var b c (AllN x1 F)\n                            z)\n                          (L[var + z := v])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllN x1 \\<phi>) (L[var + z := B / C]) =\n    eval (linear_substitution_fm_helper var b c (AllN x1 \\<phi>) z)\n     (L[var + z := v])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        eval \\<phi> (l @ L[var + z := B / C])) =\n    (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           \\<phi> (z + x1))\n         (l @ L[var + z := v]))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = x1 \\<longrightarrow>\n        eval \\<phi> (l @ L[var + z := B / C])) =\n       (length l = x1 \\<longrightarrow>\n        eval\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x b)\n                  (liftPoly 0 x c) A))\n           \\<phi> (z + x1))\n         (l @ L[var + z := v]))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = x1 \\<longrightarrow>\n     eval \\<phi> (l @ L[var + z := B / C])) =\n    (length l = x1 \\<longrightarrow>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x b)\n               (liftPoly 0 x c) A))\n        \\<phi> (z + x1))\n      (l @ L[var + z := v]))", "using map[of z] AllN(1)[OF AllN(2-4), of \"z+x1\" \"l@L\"] AllN(5-7) list"], ["proof (prove)\nusing this:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x b) (liftPoly 0 x c)\n            A))\n     \\<phi> (z + x1))\n   ?L =\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x1 + x) (liftPoly 0 (x + x1) b)\n            (liftPoly 0 (x + x1) c) A))\n     \\<phi> z)\n   ?L\n  \\<lbrakk>insertion (nth_default 0 ((drop (z + x1) (l @ L))[var := B / C]))\n            b =\n           B;\n   insertion (nth_default 0 ((drop (z + x1) (l @ L))[var := B / C])) c = C;\n   var + (z + x1) < length (l @ L)\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> ((l @ L)[var + (z + x1) := B / C]) =\n                    eval\n                     (linear_substitution_fm_helper var b c \\<phi> (z + x1))\n                     ((l @ L)[var + (z + x1) := v])\n  insertion (nth_default 0 ((drop z L)[var := B / C])) b = B\n  insertion (nth_default 0 ((drop z L)[var := B / C])) c = C\n  var + z < length L\n  length ?l = x1 \\<Longrightarrow>\n  (drop (z + x1) ?l @ drop (z + x1 - length ?l) L)[var := B / C] =\n  (drop z L)[var := B / C]\n\ngoal (1 subgoal):\n 1. (length l = x1 \\<longrightarrow>\n     eval \\<phi> (l @ L[var + z := B / C])) =\n    (length l = x1 \\<longrightarrow>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x b)\n               (liftPoly 0 x c) A))\n        \\<phi> (z + x1))\n      (l @ L[var + z := v]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>L.\n                eval\n                 (liftmap\n                   (\\<lambda>x A.\n                       fm.Atom\n                        (linear_substitution (var + x) (liftPoly 0 x b)\n                          (liftPoly 0 x c) A))\n                   \\<phi> (z + x1))\n                 L =\n                eval\n                 (liftmap\n                   (\\<lambda>x A.\n                       fm.Atom\n                        (linear_substitution (var + x1 + x)\n                          (liftPoly 0 (x + x1) b) (liftPoly 0 (x + x1) c)\n                          A))\n                   \\<phi> z)\n                 L;\n     \\<lbrakk>insertion\n               (nth_default 0\n                 ((drop (z + x1) l @ drop (z + x1 - length l) L)\n                  [var := B / C]))\n               b =\n              B;\n      insertion\n       (nth_default 0\n         ((drop (z + x1) l @ drop (z + x1 - length l) L)[var := B / C]))\n       c =\n      C;\n      var + (z + x1) < length l + length L\\<rbrakk>\n     \\<Longrightarrow> eval \\<phi> ((l @ L)[var + (z + x1) := B / C]) =\n                       eval\n                        (liftmap\n                          (\\<lambda>x A.\n                              fm.Atom\n                               (linear_substitution (var + x1 + x)\n                                 (liftPoly 0 (x + x1) b)\n                                 (liftPoly 0 (x + x1) c) A))\n                          \\<phi> z)\n                        ((l @ L)[var + (z + x1) := v]);\n     insertion (nth_default 0 ((drop z L)[var := B / C])) b = B;\n     insertion (nth_default 0 ((drop z L)[var := B / C])) c = C;\n     var + z < length L\\<rbrakk>\n    \\<Longrightarrow> (length l = x1 \\<longrightarrow>\n                       eval \\<phi> (l @ L[var + z := B / C])) =\n                      (length l = x1 \\<longrightarrow>\n                       eval\n                        (liftmap\n                          (\\<lambda>x A.\n                              fm.Atom\n                               (linear_substitution (var + x1 + x)\n                                 (liftPoly 0 (x + x1) b)\n                                 (liftPoly 0 (x + x1) c) A))\n                          \\<phi> z)\n                        (l @ L[var + z := v]))", "by (smt (z3) add.commute add.left_commute add_diff_cancel_left' add_mono_thms_linordered_field(4) list list_update_append not_add_less1 order_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (AllN x1 \\<phi>) (L[var + z := B / C]) =\n  eval (linear_substitution_fm_helper var b c (AllN x1 \\<phi>) z)\n   (L[var + z := v])\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem linear_fm :\n  assumes lLength : \"length L > var\"\n  assumes \"C \\<noteq> 0\"\n  assumes \"var \\<notin> vars b\"\n  assumes \"var \\<notin> vars c\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) b = (B::real)\"\n  assumes \"insertion (nth_default 0 (list_update L var (B/C))) c = (C::real)\"\n  shows \"eval F (list_update L var (B/C))  = (\\<forall>v. eval (linear_substitution_fm var b c F) (list_update L var v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (L[var := B / C]) =\n    (\\<forall>v. eval (linear_substitution_fm var b c F) (L[var := v]))", "unfolding linear_substitution_fm.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (L[var := B / C]) =\n    (\\<forall>v.\n        eval (linear_substitution_fm_helper var b c F 0) (L[var := v]))", "using linear_fm_helper[OF assms(2) assms(3) assms(4), of 0 L B] assms(1) assms(5) assms(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>insertion (nth_default 0 ((drop 0 L)[var := B / C])) b = B;\n   insertion (nth_default 0 ((drop 0 L)[var := B / C])) c = C;\n   var + 0 < length L\\<rbrakk>\n  \\<Longrightarrow> eval ?F (L[var + 0 := B / C]) =\n                    eval (linear_substitution_fm_helper var b c ?F 0)\n                     (L[var + 0 := ?v])\n  var < length L\n  insertion (nth_default 0 (L[var := B / C])) b = B\n  insertion (nth_default 0 (L[var := B / C])) c = C\n\ngoal (1 subgoal):\n 1. eval F (L[var := B / C]) =\n    (\\<forall>v.\n        eval (linear_substitution_fm_helper var b c F 0) (L[var := v]))", "by (simp add: lLength)"], ["", "end"]]}