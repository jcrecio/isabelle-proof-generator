{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/VSQuad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma existN_eval : \"\\<forall>xs. eval (ExN n \\<phi>) xs = (\\<exists>L. (length L = n \\<and> eval \\<phi> (L@xs)))\"", "lemma boundedFlipNegQuantifier : \"(\\<not>(\\<forall>x\\<in>A. \\<not> P x)) = (\\<exists>x\\<in>A. P x)\"", "theorem QE_dnf'_eval: \n  assumes steph : \"\\<And>amount F \\<Gamma>.\n    (\\<exists>xs. (length xs = amount \\<and> eval (list_disj (map(\\<lambda>(L,F,n). ExN n (list_conj (map fm.Atom L @ F))) F))  (xs @ \\<Gamma>))) = (eval (step amount F)  \\<Gamma>)\"\n  assumes opt : \"\\<And>xs F . eval (opt F) xs = eval F xs\"\n  shows \"eval (QE_dnf' opt step \\<phi>) xs = eval \\<phi> xs\"", "theorem QE_dnf_eval: \n  assumes steph : \"\\<And>var amount new L F \\<Gamma>.\n  amount\\<le>var+1 \\<Longrightarrow>\n    (\\<exists>xs. (length xs = var+1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))) = (\\<exists>xs. (length xs = var+1 \\<and>eval (step amount var L F) (xs @ \\<Gamma>)))\"\n  assumes opt : \"\\<And>xs F . eval (opt F) xs = eval F xs\"\n  shows \"eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs\"", "lemma opt: \"eval ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers) F) L= eval F L\"", "lemma opt': \"eval ((push_forall ( nnf ( unpower 0 ( groupQuantifiers (clearQuantifiers F)))))) L= eval F L\"", "lemma opt_no_group: \"eval ((push_forall \\<circ> nnf \\<circ> unpower 0 o clearQuantifiers) F) L= eval F L\"", "lemma  repeatAmountOfQuantifiers_helper_eval : \n  assumes  \"\\<And>xs F. eval F xs = eval (step F) xs\"\n  shows  \"eval F xs = eval (repeatAmountOfQuantifiers_helper step n F) xs\"", "lemma  repeatAmountOfQuantifiers_eval : \n  assumes  \"\\<And>xs F. eval F xs = eval (step F) xs\"\n  shows  \"eval F xs = eval (repeatAmountOfQuantifiers step F) xs\""], "translations": [["", "lemma existN_eval : \"\\<forall>xs. eval (ExN n \\<phi>) xs = (\\<exists>L. (length L = n \\<and> eval \\<phi> (L@xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (ExN n \\<phi>) xs =\n       (\\<exists>L. length L = n \\<and> eval \\<phi> (L @ xs))", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>xs.\n       eval (ExN 0 \\<phi>) xs =\n       (\\<exists>L. length L = 0 \\<and> eval \\<phi> (L @ xs))\n 2. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>xs.\n       eval (ExN 0 \\<phi>) xs =\n       (\\<exists>L. length L = 0 \\<and> eval \\<phi> (L @ xs))\n 2. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (ExN 0 \\<phi>) xs =\n       (\\<exists>L. length L = 0 \\<and> eval \\<phi> (L @ xs))", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (ExN 0 \\<phi>) xs =\n     (\\<exists>L. length L = 0 \\<and> eval \\<phi> (L @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (ExN n \\<phi>) xs =\n     (\\<exists>L. length L = n \\<and> eval \\<phi> (L @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "{"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (ExN n \\<phi>) xs =\n     (\\<exists>L. length L = n \\<and> eval \\<phi> (L @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "have \"eval (ExN (Suc n) \\<phi>) xs = (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN (Suc n) \\<phi>) xs =\n    (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs))", "by simp"], ["proof (state)\nthis:\n  eval (ExN (Suc n) \\<phi>) xs =\n  (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "also"], ["proof (state)\nthis:\n  eval (ExN (Suc n) \\<phi>) xs =\n  (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "have \"... = (\\<exists>x.\\<exists>L. (length L = n \\<and> eval \\<phi> (L@(x#xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs)) =\n    (\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = Suc n; eval \\<phi> (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x L.\n                            length L = n \\<and> eval \\<phi> (L @ x # xs)\n 2. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = Suc n; eval \\<phi> (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x L.\n                            length L = n \\<and> eval \\<phi> (L @ x # xs)\n 2. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "assume h : \"length l = Suc n\" \"eval \\<phi> (l @ xs)\""], ["proof (state)\nthis:\n  length l = Suc n\n  eval \\<phi> (l @ xs)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = Suc n; eval \\<phi> (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x L.\n                            length L = n \\<and> eval \\<phi> (L @ x # xs)\n 2. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "show \"\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs)", "apply(rule exI[where x=\"l ! n\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L. length L = n \\<and> eval \\<phi> (L @ l ! n # xs)", "apply(rule exI[where x=\"take n l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take n l) = n \\<and> eval \\<phi> (take n l @ l ! n # xs)", "using h"], ["proof (prove)\nusing this:\n  length l = Suc n\n  eval \\<phi> (l @ xs)\n\ngoal (1 subgoal):\n 1. length (take n l) = n \\<and> eval \\<phi> (take n l @ l ! n # xs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc n; eval \\<phi> (l @ xs)\\<rbrakk>\n    \\<Longrightarrow> eval \\<phi> (take n l @ l ! n # xs)", "by (metis Cons_nth_drop_Suc append.assoc append_Cons append_take_drop_id lessI order_refl self_append_conv self_append_conv2 take_all)"], ["proof (state)\nthis:\n  \\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "fix x L"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "assume h : \"eval \\<phi> (L @ x # xs)\" \"n = length L\""], ["proof (state)\nthis:\n  eval \\<phi> (L @ x # xs)\n  n = length L\n\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>eval \\<phi> (L @ x # xs); n = length L\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            eval \\<phi> (l @ xs)", "show \"\\<exists>l. length l = Suc (length L) \\<and> eval \\<phi> (l @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. length l = Suc (length L) \\<and> eval \\<phi> (l @ xs)", "apply(rule exI[where x=\"L@[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (L @ [x]) = Suc (length L) \\<and> eval \\<phi> ((L @ [x]) @ xs)", "using h"], ["proof (prove)\nusing this:\n  eval \\<phi> (L @ x # xs)\n  n = length L\n\ngoal (1 subgoal):\n 1. length (L @ [x]) = Suc (length L) \\<and> eval \\<phi> ((L @ [x]) @ xs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. length l = Suc (length L) \\<and> eval \\<phi> (l @ xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs)) =\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "also"], ["proof (state)\nthis:\n  (\\<exists>l. length l = Suc n \\<and> eval \\<phi> (l @ xs)) =\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "have \"... = (\\<exists>x.\\<exists>L. (length L = n \\<and> eval \\<phi> ((L@[x])@xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs)) =\n    (\\<exists>x L. length L = n \\<and> eval \\<phi> ((L @ [x]) @ xs))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs)) =\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> ((L @ [x]) @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "also"], ["proof (state)\nthis:\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> (L @ x # xs)) =\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> ((L @ [x]) @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "have \"... = (\\<exists>x.\\<exists>L. (length (L@[x]) = (Suc n) \\<and> eval \\<phi> ((L@[x])@xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x L. length L = n \\<and> eval \\<phi> ((L @ [x]) @ xs)) =\n    (\\<exists>x L.\n        length (L @ [x]) = Suc n \\<and> eval \\<phi> ((L @ [x]) @ xs))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> ((L @ [x]) @ xs)) =\n  (\\<exists>x L.\n      length (L @ [x]) = Suc n \\<and> eval \\<phi> ((L @ [x]) @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "also"], ["proof (state)\nthis:\n  (\\<exists>x L. length L = n \\<and> eval \\<phi> ((L @ [x]) @ xs)) =\n  (\\<exists>x L.\n      length (L @ [x]) = Suc n \\<and> eval \\<phi> ((L @ [x]) @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "have \"... = (\\<exists>L. (length L = (Suc n) \\<and> eval \\<phi> (L@xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x L.\n        length (L @ [x]) = Suc n \\<and> eval \\<phi> ((L @ [x]) @ xs)) =\n    (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "by (metis append_butlast_last_id length_0_conv nat.simps(3))"], ["proof (state)\nthis:\n  (\\<exists>x L.\n      length (L @ [x]) = Suc n \\<and> eval \\<phi> ((L @ [x]) @ xs)) =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "finally"], ["proof (chain)\npicking this:\n  eval (ExN (Suc n) \\<phi>) xs =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "have \"eval (ExN (Suc n) \\<phi>) xs = (\\<exists>L. (length L = (Suc n) \\<and> eval \\<phi> (L@xs)))\""], ["proof (prove)\nusing this:\n  eval (ExN (Suc n) \\<phi>) xs =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))\n\ngoal (1 subgoal):\n 1. eval (ExN (Suc n) \\<phi>) xs =\n    (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "by simp"], ["proof (state)\nthis:\n  eval (ExN (Suc n) \\<phi>) xs =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "}"], ["proof (state)\nthis:\n  eval (ExN (Suc n) \\<phi>) ?xs2 =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ ?xs2))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>xs.\n          eval (ExN n \\<phi>) xs =\n          (\\<exists>L.\n              length L = n \\<and> eval \\<phi> (L @ xs)) \\<Longrightarrow>\n       \\<forall>xs.\n          eval (ExN (Suc n) \\<phi>) xs =\n          (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "then"], ["proof (chain)\npicking this:\n  eval (ExN (Suc n) \\<phi>) ?xs2 =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ ?xs2))", "show ?case"], ["proof (prove)\nusing this:\n  eval (ExN (Suc n) \\<phi>) ?xs2 =\n  (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ ?xs2))\n\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       eval (ExN (Suc n) \\<phi>) xs =\n       (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs.\n     eval (ExN (Suc n) \\<phi>) xs =\n     (\\<exists>L. length L = Suc n \\<and> eval \\<phi> (L @ xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma boundedFlipNegQuantifier : \"(\\<not>(\\<forall>x\\<in>A. \\<not> P x)) = (\\<exists>x\\<in>A. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>x\\<in>A. \\<not> P x)) = (\\<exists>x\\<in>A. P x)", "by blast"], ["", "theorem QE_dnf'_eval: \n  assumes steph : \"\\<And>amount F \\<Gamma>.\n    (\\<exists>xs. (length xs = amount \\<and> eval (list_disj (map(\\<lambda>(L,F,n). ExN n (list_conj (map fm.Atom L @ F))) F))  (xs @ \\<Gamma>))) = (eval (step amount F)  \\<Gamma>)\"\n  assumes opt : \"\\<And>xs F . eval (opt F) xs = eval F xs\"\n  shows \"eval (QE_dnf' opt step \\<phi>) xs = eval \\<phi> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step \\<phi>) xs = eval \\<phi> xs", "proof(induction \\<phi> arbitrary : xs)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x xs. eval (QE_dnf' opt step (fm.Atom x)) xs = eval (fm.Atom x) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 8. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 10. \\<And>x1 \\<phi> xs.\n        (\\<And>xs.\n            eval (QE_dnf' opt step \\<phi>) xs =\n            eval \\<phi> xs) \\<Longrightarrow>\n        eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n        eval (AllN x1 \\<phi>) xs", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x xs. eval (QE_dnf' opt step (fm.Atom x)) xs = eval (fm.Atom x) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 8. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 10. \\<And>x1 \\<phi> xs.\n        (\\<And>xs.\n            eval (QE_dnf' opt step \\<phi>) xs =\n            eval \\<phi> xs) \\<Longrightarrow>\n        eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n        eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (fm.Atom x)) xs = eval (fm.Atom x) xs", "by (simp add: simp_atom_eval)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (fm.Atom x)) xs = eval (fm.Atom x) xs\n\ngoal (9 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf' opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (9 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf' opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf' opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf' opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf' opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n    eval (And \\<phi>1 \\<phi>2) xs", "by (simp add: eval_and)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (And \\<phi>1 \\<phi>2)) xs =\n  eval (And \\<phi>1 \\<phi>2) xs\n\ngoal (8 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf' opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (8 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf' opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf' opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf' opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf' opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf' opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf' opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n    eval (Or \\<phi>1 \\<phi>2) xs", "by (simp add: eval_or)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (Or \\<phi>1 \\<phi>2)) xs =\n  eval (Or \\<phi>1 \\<phi>2) xs\n\ngoal (7 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (7 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        eval (QE_dnf' opt step \\<phi>) xs =\n        eval \\<phi> xs) \\<Longrightarrow>\n    eval (neg (QE_dnf' opt step \\<phi>)) xs = (\\<not> eval \\<phi> xs)", "by (metis  eval_neg )"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (ExQ \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "have h1 : \"\\<And>F. (\\<exists>xs. length xs = Suc 0 \\<and>\n          F xs) = (\\<exists>x.\n          F [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<exists>xs. length xs = Suc 0 \\<and> F xs) = (\\<exists>x. F [x])", "by (metis length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  (\\<exists>xs. length xs = Suc 0 \\<and> ?F xs) = (\\<exists>x. ?F [x])\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (step (Suc 0) (dnf_modified (opt (QE_dnf' opt step \\<phi>)))) xs =\n    (\\<exists>x. eval \\<phi> (x # xs))", "unfolding steph[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>(L, F, n). ExN n (list_conj (map fm.Atom L @ F)))\n             (dnf_modified (opt (QE_dnf' opt step \\<phi>)))))\n         (xs @ xs)) =\n    (\\<exists>x. eval \\<phi> (x # xs))", "apply(simp add: eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ xs))) =\n    (\\<exists>x. eval \\<phi> (x # xs))", "unfolding h1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n    (\\<exists>x. eval \\<phi> (x # xs))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n       eval \\<phi> (x # xs)", "unfolding ExQ[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n       eval (QE_dnf' opt step \\<phi>) (x # xs)", "unfolding opt[symmetric, of \"(QE_dnf' opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n       eval (opt (QE_dnf' opt step \\<phi>)) (x # xs)", "unfolding dnf_modified_eval[symmetric, of \"(opt (QE_dnf' opt step \\<phi>))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n       (\\<exists>(al, fl, n)\n                 \\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       set (dnf_modified (opt (QE_dnf' opt step \\<phi>))) =\n       set (dnf_modified (opt (QE_dnf' opt step \\<phi>)))\n 2. \\<And>x f.\n       f \\<in> set (dnf_modified\n                     (opt (QE_dnf' opt step \\<phi>))) \\<Longrightarrow>\n       eval\n        (case f of\n         (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n        ([x] @ xs) =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       f \\<in> set (dnf_modified\n                     (opt (QE_dnf' opt step \\<phi>))) \\<Longrightarrow>\n       eval\n        (case f of\n         (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n        ([x] @ xs) =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "subgoal for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified\n                  (opt (QE_dnf' opt step \\<phi>))) \\<Longrightarrow>\n    eval\n     (case f of\n      (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n     ([x] @ xs) =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>L.\n          length L = n \\<and>\n          (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n          (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          ([x] @ xs) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x # xs)) \\<and>\n                               (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply (auto simp add:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l.\n       \\<lbrakk>(a, b, length l)\n                \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, length l);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            length L = length l \\<and>\n                            (\\<forall>a\\<in>set a.\n                                aEval a (L @ x # xs)) \\<and>\n                            (\\<forall>f\\<in>set b. eval f (L @ x # xs))", "by (metis Un_iff eval.simps(1) imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "have h1 : \"\\<And>F. (\\<forall>xs::real list. (length xs = Suc 0 \\<longrightarrow>\n          F xs)) = (\\<forall>x.\n          F [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<forall>xs. length xs = Suc 0 \\<longrightarrow> F xs) =\n       (\\<forall>x. F [x])", "by (metis length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  (\\<forall>xs. length xs = Suc 0 \\<longrightarrow> ?F xs) =\n  (\\<forall>x. ?F [x])\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> eval\n             (step (Suc 0)\n               (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))))\n             xs) =\n    (\\<forall>x. eval \\<phi> (x # xs))", "unfolding steph[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>xs.\n        length xs = Suc 0 \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>(L, F, n). ExN n (list_conj (map fm.Atom L @ F)))\n             (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))))))\n         (xs @ xs)) =\n    (\\<forall>x. eval \\<phi> (x # xs))", "apply(simp add: eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>xs.\n        length xs = Suc 0 \\<longrightarrow>\n        (\\<forall>f\\<in>set (dnf_modified\n                              (opt (neg (QE_dnf' opt step \\<phi>)))).\n            \\<not> eval\n                    (case f of\n                     (L, F, n) \\<Rightarrow>\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                    (xs @ xs))) =\n    (\\<forall>x. eval \\<phi> (x # xs))", "unfolding h1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        \\<forall>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           \\<not> eval\n                   (case f of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n                   ([x] @ xs)) =\n    (\\<forall>x. eval \\<phi> (x # xs))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           \\<not> eval\n                   (case f of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n                   ([x] @ xs)) =\n       eval \\<phi> (x # xs)", "unfolding AllQ[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           \\<not> eval\n                   (case f of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n                   ([x] @ xs)) =\n       eval (QE_dnf' opt step \\<phi>) (x # xs)", "unfolding eval_neg[symmetric, of \"(QE_dnf' opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           \\<not> eval\n                   (case f of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n                   ([x] @ xs)) =\n       (\\<not> eval (neg (QE_dnf' opt step \\<phi>)) (x # xs))", "unfolding opt[symmetric, of \"neg(QE_dnf' opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           \\<not> eval\n                   (case f of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n                   ([x] @ xs)) =\n       (\\<not> eval (opt (neg (QE_dnf' opt step \\<phi>))) (x # xs))", "unfolding Set.bex_simps(8)[symmetric] HOL.Not_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n       eval (opt (neg (QE_dnf' opt step \\<phi>))) (x # xs)", "unfolding dnf_modified_eval[symmetric, of \"(opt (neg(QE_dnf' opt step \\<phi>)))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>f\\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            ([x] @ xs)) =\n       (\\<exists>(al, fl, n)\n                 \\<in>set (dnf_modified\n                            (opt (neg (QE_dnf' opt step \\<phi>)))).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))) =\n       set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))))\n 2. \\<And>x f.\n       f \\<in> set (dnf_modified\n                     (opt (neg (QE_dnf' opt step\n                                 \\<phi>)))) \\<Longrightarrow>\n       eval\n        (case f of\n         (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n        ([x] @ xs) =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       f \\<in> set (dnf_modified\n                     (opt (neg (QE_dnf' opt step\n                                 \\<phi>)))) \\<Longrightarrow>\n       eval\n        (case f of\n         (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n        ([x] @ xs) =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "subgoal for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified\n                  (opt (neg (QE_dnf' opt step \\<phi>)))) \\<Longrightarrow>\n    eval\n     (case f of\n      (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n     ([x] @ xs) =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>L.\n          length L = n \\<and>\n          (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n          (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified\n                              (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          ([x] @ xs) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x # xs)) \\<and>\n                               (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply (auto simp add:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l.\n       \\<lbrakk>(a, b, length l)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, length l);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            length L = length l \\<and>\n                            (\\<forall>a\\<in>set a.\n                                aEval a (L @ x # xs)) \\<and>\n                            (\\<forall>f\\<in>set b. eval f (L @ x # xs))", "by (metis Un_iff eval.simps(1) imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (ExN amount \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (ExN amount \\<phi>)) xs =\n    eval (ExN amount \\<phi>) xs", "apply(cases amount)"], ["proof (prove)\ngoal (2 subgoals):\n 1. amount = 0 \\<Longrightarrow>\n    eval (QE_dnf' opt step (ExN amount \\<phi>)) xs =\n    eval (ExN amount \\<phi>) xs\n 2. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       eval (QE_dnf' opt step (ExN amount \\<phi>)) xs =\n       eval (ExN amount \\<phi>) xs", "apply (simp_all add: ExN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       eval (step (Suc nat) (dnf_modified (opt (QE_dnf' opt step \\<phi>))))\n        xs =\n       (\\<exists>l. length l = Suc nat \\<and> eval \\<phi> (l @ xs))", "unfolding steph[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                (dnf_modified (opt (QE_dnf' opt step \\<phi>)))))\n            (xs @ xs)) =\n       (\\<exists>l. length l = Suc nat \\<and> eval \\<phi> (l @ xs))", "apply(simp add: eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (QE_dnf' opt step \\<phi>))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<exists>l. length l = Suc nat \\<and> eval \\<phi> (l @ xs))", "unfolding ExN[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (QE_dnf' opt step \\<phi>))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<exists>l.\n           length l = Suc nat \\<and>\n           eval (QE_dnf' opt step \\<phi>) (l @ xs))", "unfolding opt[of \"(QE_dnf' opt step \\<phi>)\",symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (QE_dnf' opt step \\<phi>))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<exists>l.\n           length l = Suc nat \\<and>\n           eval (opt (QE_dnf' opt step \\<phi>)) (l @ xs))", "unfolding dnf_modified_eval[of \"(opt (QE_dnf' opt step \\<phi>))\",symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (QE_dnf' opt step \\<phi>))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<exists>l.\n           length l = Suc nat \\<and>\n           (\\<exists>(al, fl, n)\n                     \\<in>set (dnf_modified\n                                (opt (QE_dnf' opt step \\<phi>))).\n               \\<exists>L.\n                  length L = n \\<and>\n                  (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                  (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat xs.\n       amount = Suc nat \\<Longrightarrow>\n       (length xs = Suc nat \\<and>\n        (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ xs))) =\n       (length xs = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ xs @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ xs @ xs))))", "subgoal for nat xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount = Suc nat \\<Longrightarrow>\n    (length xs = Suc nat \\<and>\n     (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n         eval\n          (case f of\n           (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n          (xs @ xsa__))) =\n    (length xs = Suc nat \\<and>\n     (\\<exists>(al, fl, n)\n               \\<in>set (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n         \\<exists>L.\n            length L = n \\<and>\n            (\\<forall>a\\<in>set al. aEval a (L @ xs @ xsa__)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (L @ xs @ xsa__))))", "apply(cases \"length xs = Suc nat\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat\\<rbrakk>\n    \\<Longrightarrow> (length xs = Suc nat \\<and>\n                       (\\<exists>f\\<in>set\n  (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n                           eval\n                            (case f of\n                             (L, F, n) \\<Rightarrow>\n                               ExN n (list_conj (map fm.Atom L @ F)))\n                            (xs @ xsa__))) =\n                      (length xs = Suc nat \\<and>\n                       (\\<exists>(al, fl, n)\n                                 \\<in>set\n (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n                           \\<exists>L.\n                              length L = n \\<and>\n                              (\\<forall>a\\<in>set al.\n                                  aEval a (L @ xs @ xsa__)) \\<and>\n                              (\\<forall>f\\<in>set fl.\n                                  eval f (L @ xs @ xsa__))))\n 2. \\<lbrakk>amount = Suc nat; length xs \\<noteq> Suc nat\\<rbrakk>\n    \\<Longrightarrow> (length xs = Suc nat \\<and>\n                       (\\<exists>f\\<in>set\n  (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n                           eval\n                            (case f of\n                             (L, F, n) \\<Rightarrow>\n                               ExN n (list_conj (map fm.Atom L @ F)))\n                            (xs @ xsa__))) =\n                      (length xs = Suc nat \\<and>\n                       (\\<exists>(al, fl, n)\n                                 \\<in>set\n (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n                           \\<exists>L.\n                              length L = n \\<and>\n                              (\\<forall>a\\<in>set al.\n                                  aEval a (L @ xs @ xsa__)) \\<and>\n                              (\\<forall>f\\<in>set fl.\n                                  eval f (L @ xs @ xsa__))))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>f\\<in>set\n (dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n                          eval\n                           (case f of\n                            (L, F, n) \\<Rightarrow>\n                              ExN n (list_conj (map fm.Atom L @ F)))\n                           (xs @ xsa__)) =\n                      (\\<exists>(al, fl, n)\n                                \\<in>set\n(dnf_modified (opt (QE_dnf' opt step \\<phi>))).\n                          \\<exists>L.\n                             length L = n \\<and>\n                             (\\<forall>a\\<in>set al.\n                                 aEval a (L @ xs @ xsa__)) \\<and>\n                             (\\<forall>f\\<in>set fl.\n                                 eval f (L @ xs @ xsa__)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat\\<rbrakk>\n    \\<Longrightarrow> set (dnf_modified (opt (QE_dnf' opt step \\<phi>))) =\n                      set (dnf_modified (opt (QE_dnf' opt step \\<phi>)))\n 2. \\<And>f.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        f \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)))\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (xs @ xsa__) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ xs @ xsa__)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ xs @ xsa__)))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        f \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)))\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (xs @ xsa__) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ xs @ xsa__)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ xs @ xsa__)))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n     f \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)))\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xsa__) =\n                      (case f of\n                       (al, fl, n) \\<Rightarrow>\n                         \\<exists>L.\n                            length L = n \\<and>\n                            (\\<forall>a\\<in>set al.\n                                aEval a (L @ xs @ xsa__)) \\<and>\n                            (\\<forall>f\\<in>set fl.\n                                eval f (L @ xs @ xsa__)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        f \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (xs @ xsa__) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ xs @ xsa__)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ xs @ xsa__)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, c) \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l.\n                             length l = c \\<and>\n                             eval (list_conj (map fm.Atom a @ b))\n                              (l @ xs @ xsa__)) =\n                         (\\<exists>L.\n                             length L = c \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (L @ xs @ xsa__)) \\<and>\n                             (\\<forall>f\\<in>set b.\n                                 eval f (L @ xs @ xsa__)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c l.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, c) \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (length l = c \\<and>\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ xsa__)) =\n                         (length l = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (l @ xs @ xsa__)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (l @ xs @ xsa__)))", "unfolding eval_list_conj"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c l.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, c) \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (length l = c \\<and>\n                          (\\<forall>f\\<in>set (map fm.Atom a @ b).\n                              eval f (l @ xs @ xsa__))) =\n                         (length l = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (l @ xs @ xsa__)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (l @ xs @ xsa__)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, length l)\n        \\<in> set (dnf_modified (opt (QE_dnf' opt step \\<phi>)));\n        f = (a, b, length l);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ xs @ xsa__);\n        aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval aa (l @ xs @ xsa__)", "by (meson Un_iff eval.simps(1) imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (ExN amount \\<phi>)) xs =\n  eval (ExN amount \\<phi>) xs\n\ngoal (3 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "case (AllN amount \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (3 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf' opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN x1 \\<phi>)) xs =\n       eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf' opt step (AllN amount \\<phi>)) xs =\n    eval (AllN amount \\<phi>) xs", "apply(cases amount)"], ["proof (prove)\ngoal (2 subgoals):\n 1. amount = 0 \\<Longrightarrow>\n    eval (QE_dnf' opt step (AllN amount \\<phi>)) xs =\n    eval (AllN amount \\<phi>) xs\n 2. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       eval (QE_dnf' opt step (AllN amount \\<phi>)) xs =\n       eval (AllN amount \\<phi>) xs", "apply (simp_all add: AllN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<not> eval\n                (step (Suc nat)\n                  (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))))\n                xs) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow> eval \\<phi> (l @ xs))", "unfolding steph[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<nexists>xs.\n           length xs = Suc nat \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))))))\n            (xs @ xs)) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow> eval \\<phi> (l @ xs))", "apply(simp add: eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           length xs = Suc nat \\<longrightarrow>\n           (\\<forall>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               \\<not> eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xs))) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow> eval \\<phi> (l @ xs))", "unfolding AllN[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           length xs = Suc nat \\<longrightarrow>\n           (\\<forall>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               \\<not> eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xs))) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow>\n           eval (QE_dnf' opt step \\<phi>) (l @ xs))", "unfolding eval_neg[symmetric, of \"(QE_dnf' opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           length xs = Suc nat \\<longrightarrow>\n           (\\<forall>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               \\<not> eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xs))) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow>\n           \\<not> eval (neg (QE_dnf' opt step \\<phi>)) (l @ xs))", "unfolding opt[symmetric, of \"neg(QE_dnf' opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           length xs = Suc nat \\<longrightarrow>\n           (\\<forall>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               \\<not> eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xs))) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow>\n           \\<not> eval (opt (neg (QE_dnf' opt step \\<phi>))) (l @ xs))", "unfolding Set.bex_simps(8)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           length xs = Suc nat \\<longrightarrow>\n           \\<not> (\\<exists>f\\<in>set (dnf_modified\n  (opt (neg (QE_dnf' opt step \\<phi>)))).\n                      eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xs))) =\n       (\\<forall>l.\n           length l = Suc nat \\<longrightarrow>\n           \\<not> eval (opt (neg (QE_dnf' opt step \\<phi>))) (l @ xs))", "unfolding HOL.imp_conv_disj"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           length xs \\<noteq> Suc nat \\<or>\n           \\<not> (\\<exists>f\\<in>set (dnf_modified\n  (opt (neg (QE_dnf' opt step \\<phi>)))).\n                      eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xs))) =\n       (\\<forall>l.\n           length l \\<noteq> Suc nat \\<or>\n           \\<not> eval (opt (neg (QE_dnf' opt step \\<phi>))) (l @ xs))", "unfolding HOL.de_Morgan_conj[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<forall>xs.\n           \\<not> (length xs = Suc nat \\<and>\n                   (\\<exists>f\\<in>set (dnf_modified\n   (opt (neg (QE_dnf' opt step \\<phi>)))).\n                       eval\n                        (case f of\n                         (L, F, n) \\<Rightarrow>\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                        (xs @ xs)))) =\n       (\\<forall>l.\n           \\<not> (length l = Suc nat \\<and>\n                   eval (opt (neg (QE_dnf' opt step \\<phi>))) (l @ xs)))", "unfolding HOL.not_ex[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<nexists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<nexists>l.\n           length l = Suc nat \\<and>\n           eval (opt (neg (QE_dnf' opt step \\<phi>))) (l @ xs))", "unfolding  HOL.Not_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<exists>l.\n           length l = Suc nat \\<and>\n           eval (opt (neg (QE_dnf' opt step \\<phi>))) (l @ xs))", "unfolding dnf_modified_eval[symmetric, of \"(opt (neg(QE_dnf' opt step \\<phi>)))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       amount = Suc nat \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc nat \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (opt (neg (QE_dnf' opt step \\<phi>)))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ xs))) =\n       (\\<exists>l.\n           length l = Suc nat \\<and>\n           (\\<exists>(al, fl, n)\n                     \\<in>set (dnf_modified\n                                (opt (neg (QE_dnf' opt step \\<phi>)))).\n               \\<exists>L.\n                  length L = n \\<and>\n                  (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                  (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat xs.\n       amount = Suc nat \\<Longrightarrow>\n       (length xs = Suc nat \\<and>\n        (\\<exists>f\\<in>set (dnf_modified\n                              (opt (neg (QE_dnf' opt step \\<phi>)))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ xs))) =\n       (length xs = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified\n                             (opt (neg (QE_dnf' opt step \\<phi>)))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ xs @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ xs @ xs))))", "subgoal for nat xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount = Suc nat \\<Longrightarrow>\n    (length xs = Suc nat \\<and>\n     (\\<exists>f\\<in>set (dnf_modified\n                           (opt (neg (QE_dnf' opt step \\<phi>)))).\n         eval\n          (case f of\n           (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n          (xs @ xsa__))) =\n    (length xs = Suc nat \\<and>\n     (\\<exists>(al, fl, n)\n               \\<in>set (dnf_modified\n                          (opt (neg (QE_dnf' opt step \\<phi>)))).\n         \\<exists>L.\n            length L = n \\<and>\n            (\\<forall>a\\<in>set al. aEval a (L @ xs @ xsa__)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (L @ xs @ xsa__))))", "apply(cases \"length xs = Suc nat\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat\\<rbrakk>\n    \\<Longrightarrow> (length xs = Suc nat \\<and>\n                       (\\<exists>f\\<in>set\n  (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))).\n                           eval\n                            (case f of\n                             (L, F, n) \\<Rightarrow>\n                               ExN n (list_conj (map fm.Atom L @ F)))\n                            (xs @ xsa__))) =\n                      (length xs = Suc nat \\<and>\n                       (\\<exists>(al, fl, n)\n                                 \\<in>set\n (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))).\n                           \\<exists>L.\n                              length L = n \\<and>\n                              (\\<forall>a\\<in>set al.\n                                  aEval a (L @ xs @ xsa__)) \\<and>\n                              (\\<forall>f\\<in>set fl.\n                                  eval f (L @ xs @ xsa__))))\n 2. \\<lbrakk>amount = Suc nat; length xs \\<noteq> Suc nat\\<rbrakk>\n    \\<Longrightarrow> (length xs = Suc nat \\<and>\n                       (\\<exists>f\\<in>set\n  (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))).\n                           eval\n                            (case f of\n                             (L, F, n) \\<Rightarrow>\n                               ExN n (list_conj (map fm.Atom L @ F)))\n                            (xs @ xsa__))) =\n                      (length xs = Suc nat \\<and>\n                       (\\<exists>(al, fl, n)\n                                 \\<in>set\n (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))).\n                           \\<exists>L.\n                              length L = n \\<and>\n                              (\\<forall>a\\<in>set al.\n                                  aEval a (L @ xs @ xsa__)) \\<and>\n                              (\\<forall>f\\<in>set fl.\n                                  eval f (L @ xs @ xsa__))))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>f\\<in>set\n (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))).\n                          eval\n                           (case f of\n                            (L, F, n) \\<Rightarrow>\n                              ExN n (list_conj (map fm.Atom L @ F)))\n                           (xs @ xsa__)) =\n                      (\\<exists>(al, fl, n)\n                                \\<in>set\n(dnf_modified (opt (neg (QE_dnf' opt step \\<phi>)))).\n                          \\<exists>L.\n                             length L = n \\<and>\n                             (\\<forall>a\\<in>set al.\n                                 aEval a (L @ xs @ xsa__)) \\<and>\n                             (\\<forall>f\\<in>set fl.\n                                 eval f (L @ xs @ xsa__)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat\\<rbrakk>\n    \\<Longrightarrow> set (dnf_modified\n                            (opt (neg (QE_dnf' opt step \\<phi>)))) =\n                      set (dnf_modified\n                            (opt (neg (QE_dnf' opt step \\<phi>))))\n 2. \\<And>f.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        f \\<in> set (dnf_modified\n                      (opt (neg (QE_dnf' opt step \\<phi>))))\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (xs @ xsa__) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ xs @ xsa__)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ xs @ xsa__)))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        f \\<in> set (dnf_modified\n                      (opt (neg (QE_dnf' opt step \\<phi>))))\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (xs @ xsa__) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ xs @ xsa__)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ xs @ xsa__)))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n     f \\<in> set (dnf_modified\n                   (opt (neg (QE_dnf' opt step \\<phi>))))\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (case f of\n                        (L, F, n) \\<Rightarrow>\n                          ExN n (list_conj (map fm.Atom L @ F)))\n                       (xs @ xsa__) =\n                      (case f of\n                       (al, fl, n) \\<Rightarrow>\n                         \\<exists>L.\n                            length L = n \\<and>\n                            (\\<forall>a\\<in>set al.\n                                aEval a (L @ xs @ xsa__)) \\<and>\n                            (\\<forall>f\\<in>set fl.\n                                eval f (L @ xs @ xsa__)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        f \\<in> set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (xs @ xsa__) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ xs @ xsa__)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ xs @ xsa__)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, c)\n        \\<in> set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l.\n                             length l = c \\<and>\n                             eval (list_conj (map fm.Atom a @ b))\n                              (l @ xs @ xsa__)) =\n                         (\\<exists>L.\n                             length L = c \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (L @ xs @ xsa__)) \\<and>\n                             (\\<forall>f\\<in>set b.\n                                 eval f (L @ xs @ xsa__)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c l.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, c)\n        \\<in> set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (length l = c \\<and>\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ xsa__)) =\n                         (length l = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (l @ xs @ xsa__)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (l @ xs @ xsa__)))", "unfolding eval_list_conj"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c l.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, c)\n        \\<in> set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (length l = c \\<and>\n                          (\\<forall>f\\<in>set (map fm.Atom a @ b).\n                              eval f (l @ xs @ xsa__))) =\n                         (length l = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (l @ xs @ xsa__)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (l @ xs @ xsa__)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa.\n       \\<lbrakk>amount = Suc nat; length xs = Suc nat;\n        (a, b, length l)\n        \\<in> set (dnf_modified (opt (neg (QE_dnf' opt step \\<phi>))));\n        f = (a, b, length l);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ xs @ xsa__);\n        aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval aa (l @ xs @ xsa__)", "by (meson Un_iff eval.simps(1) imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf' opt step (AllN amount \\<phi>)) xs =\n  eval (AllN amount \\<phi>) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. eval (QE_dnf' opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf' opt step FalseF) xs = eval FalseF xs", "qed auto"], ["", "theorem QE_dnf_eval: \n  assumes steph : \"\\<And>var amount new L F \\<Gamma>.\n  amount\\<le>var+1 \\<Longrightarrow>\n    (\\<exists>xs. (length xs = var+1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))) = (\\<exists>xs. (length xs = var+1 \\<and>eval (step amount var L F) (xs @ \\<Gamma>)))\"\n  assumes opt : \"\\<And>xs F . eval (opt F) xs = eval F xs\"\n  shows \"eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs", "proof(induction \\<phi> arbitrary:xs)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x xs. eval (QE_dnf opt step (fm.Atom x)) xs = eval (fm.Atom x) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 8. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 10. \\<And>x1 \\<phi> xs.\n        (\\<And>xs.\n            eval (QE_dnf opt step \\<phi>) xs =\n            eval \\<phi> xs) \\<Longrightarrow>\n        eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n        eval (AllN x1 \\<phi>) xs", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x xs. eval (QE_dnf opt step (fm.Atom x)) xs = eval (fm.Atom x) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 8. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 10. \\<And>x1 \\<phi> xs.\n        (\\<And>xs.\n            eval (QE_dnf opt step \\<phi>) xs =\n            eval \\<phi> xs) \\<Longrightarrow>\n        eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n        eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (fm.Atom x)) xs = eval (fm.Atom x) xs", "by (simp add: simp_atom_eval)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (fm.Atom x)) xs = eval (fm.Atom x) xs\n\ngoal (9 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (9 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n                         eval (And \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 7. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 9. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n    eval (And \\<phi>1 \\<phi>2) xs", "by (simp add: eval_and)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (And \\<phi>1 \\<phi>2)) xs =\n  eval (And \\<phi>1 \\<phi>2) xs\n\ngoal (8 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (8 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi>1 \\<phi>2 xs.\n       \\<lbrakk>\\<And>xs.\n                   eval (QE_dnf opt step \\<phi>1) xs = eval \\<phi>1 xs;\n        \\<And>xs.\n           eval (QE_dnf opt step \\<phi>2) xs = eval \\<phi>2 xs\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n                         eval (Or \\<phi>1 \\<phi>2) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 6. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 8. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf opt step \\<phi>1) ?xs = eval \\<phi>1 ?xs\n  eval (QE_dnf opt step \\<phi>2) ?xs = eval \\<phi>2 ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n    eval (Or \\<phi>1 \\<phi>2) xs", "by (simp add: eval_or)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (Or \\<phi>1 \\<phi>2)) xs =\n  eval (Or \\<phi>1 \\<phi>2) xs\n\ngoal (7 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (7 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 5. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 7. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs", "by (metis eval.simps(6) eval_neg QE_dnf.simps(3))"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (Neg \\<phi>)) xs = eval (Neg \\<phi>) xs\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (ExQ \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "have h : \"(\\<exists>x. \\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n            \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ x # xs))) = \n        (\\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))). \\<exists>x. \n            \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<exists>(al, fl, n)\n                 \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x # xs))) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        \\<exists>x L.\n           length L = n \\<and>\n           (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b L.\n       \\<lbrakk>(a, aa, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set aa. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(al, fl, n)\n                                  \\<in>set\n  (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n                            \\<exists>x L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x # xs)) \\<and>\n                               (\\<forall>f\\<in>set fl. eval f (L @ x # xs))\n 2. \\<And>a aa b x L.\n       \\<lbrakk>(a, aa, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set aa. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>(al, fl, n)\n                                     \\<in>set\n     (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n                               \\<exists>L.\n                                  length L = n \\<and>\n                                  (\\<forall>a\\<in>set al.\naEval a (L @ x # xs)) \\<and>\n                                  (\\<forall>f\\<in>set fl.\neval f (L @ x # xs))", "by blast+"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<exists>(al, fl, n)\n               \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n         \\<exists>L.\n            length L = n \\<and>\n            (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (L @ x # xs))) =\n  (\\<exists>(al, fl, n)\n            \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n      \\<exists>x L.\n         length L = n \\<and>\n         (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "have lessThan : \"\\<And>c. Suc 0 \\<le> c + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. Suc 0 \\<le> c + 1", "by simp"], ["proof (state)\nthis:\n  Suc 0 \\<le> ?c + 1\n\ngoal (6 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n 4. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 6. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs", "apply (simp add:eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>x. eval \\<phi> (x # xs))", "unfolding ExQ[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>x. eval (QE_dnf opt step \\<phi>) (x # xs))", "unfolding opt[symmetric, of \"(QE_dnf opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>x. eval (opt (QE_dnf opt step \\<phi>)) (x # xs))", "unfolding dnf_modified_eval[symmetric, of \"opt(QE_dnf opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>x.\n        \\<exists>(al, fl, n)\n                 \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        \\<exists>x L.\n           length L = n \\<and>\n           (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (dnf_modified (opt (QE_dnf opt step \\<phi>))) =\n    set (dnf_modified (opt (QE_dnf opt step \\<phi>)))\n 2. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (QE_dnf opt step \\<phi>))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>x L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (QE_dnf opt step \\<phi>))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>x L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified\n                  (opt (QE_dnf opt step \\<phi>))) \\<Longrightarrow>\n    eval\n     (case f of\n      (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n     xs =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>x L.\n          length L = n \\<and>\n          (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n          (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (al, fl, n) \\<Rightarrow>\n                             ExN (Suc n) (step (Suc 0) n al fl))\n                          xs =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>x L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x # xs)) \\<and>\n                               (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l.\n                             length l = Suc c \\<and>\n                             eval (step (Suc 0) c a b) (l @ xs)) =\n                         (\\<exists>x L.\n                             length L = c \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (L @ x # xs)) \\<and>\n                             (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "subgoal for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc c \\<and>\n                          eval (step (Suc 0) c a b) (l @ xs)) =\n                      (\\<exists>x L.\n                          length L = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (L @ x # xs)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "using steph[of \"Suc 0\" c a b xs, symmetric, OF lessThan]"], ["proof (prove)\nusing this:\n  (\\<exists>xs.\n      length xs = c + 1 \\<and> eval (step (Suc 0) c a b) (xs @ xs)) =\n  (\\<exists>xs.\n      length xs = c + 1 \\<and>\n      eval (list_conj (map fm.Atom a @ b)) (xs @ xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc c \\<and>\n                          eval (step (Suc 0) c a b) (l @ xs)) =\n                      (\\<exists>x L.\n                          length L = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (L @ x # xs)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "apply (simp add:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c);\n     (\\<exists>xs.\n         length xs = Suc c \\<and> eval (step (Suc 0) c a b) (xs @ xs)) =\n     (\\<exists>xs.\n         length xs = Suc c \\<and>\n         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n             eval f (xs @ xs)))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc c \\<and>\n                          (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                              eval f (l @ xs))) =\n                      (\\<exists>x L.\n                          length L = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (L @ x # xs)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs xsaa l.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c); length xs = Suc c;\n        eval (step (Suc 0) c a b) (xs @ xs); length xsaa = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xsaa @ xs);\n        length l = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x L.\n                            length L = c \\<and>\n                            (\\<forall>a\\<in>set a.\n                                aEval a (L @ x # xs)) \\<and>\n                            (\\<forall>f\\<in>set b. eval f (L @ x # xs))\n 2. \\<And>xs xsaa x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L); length xs = Suc (length L);\n        eval (step (Suc 0) (length L) a b) (xs @ xs);\n        length xsaa = Suc (length L);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xsaa @ xs);\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))\n 3. \\<And>x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           eval (step (Suc 0) (length L) a b) (xs @ xs);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n               eval f (xs @ xs));\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for xs' l' l''"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c); length xs' = Suc c;\n     eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n     length l'' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (l'' @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x L.\n                         length L = c \\<and>\n                         (\\<forall>a\\<in>set a. aEval a (L @ x # xs)) \\<and>\n                         (\\<forall>f\\<in>set b. eval f (L @ x # xs))", "apply(rule exI[where x=\"l'!c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c); length xs' = Suc c;\n     eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n     length l'' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (l'' @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         length L = c \\<and>\n                         (\\<forall>a\\<in>set a.\n                             aEval a (L @ l' ! c # xs)) \\<and>\n                         (\\<forall>f\\<in>set b. eval f (L @ l' ! c # xs))", "apply(rule exI[where x=\"take c l'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c); length xs' = Suc c;\n     eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n     length l'' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (l'' @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (take c l') = c \\<and>\n                      (\\<forall>a\\<in>set a.\n                          aEval a (take c l' @ l' ! c # xs)) \\<and>\n                      (\\<forall>f\\<in>set b.\n                          eval f (take c l' @ l' ! c # xs))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c); length xs' = Suc c;\n        eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n        length l'' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l'' @ xs);\n        aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval aa (take c l' @ l' ! c # xs)\n 2. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c); length xs' = Suc c;\n        eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n        length l'' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l'' @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c l' @ l' ! c # xs)", "apply (metis Un_iff append.assoc append_Cons append_Nil eval.simps(1) image_eqI lessI order_refl take_Suc_conv_app_nth take_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c); length xs' = Suc c;\n        eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n        length l'' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l'' @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c l' @ l' ! c # xs)", "by (metis Un_iff append.assoc append_Cons append_Nil lessI order_refl take_Suc_conv_app_nth take_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsaa x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L); length xs = Suc (length L);\n        eval (step (Suc 0) (length L) a b) (xs @ xs);\n        length xsaa = Suc (length L);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xsaa @ xs);\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))\n 2. \\<And>x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           eval (step (Suc 0) (length L) a b) (xs @ xs);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n               eval f (xs @ xs));\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for A B C D"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length D)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, length D); length A = Suc (length D);\n     eval (step (Suc 0) (length D) a b) (A @ xs); length B = Suc (length D);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (B @ xs);\n     c = length D; \\<forall>a\\<in>set a. aEval a (D @ C # xs);\n     \\<forall>f\\<in>set b. eval f (D @ C # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = Suc (length D) \\<and>\n                         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                             eval f (l @ xs))", "apply(rule exI[where x=\"D@[C]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length D)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, length D); length A = Suc (length D);\n     eval (step (Suc 0) (length D) a b) (A @ xs); length B = Suc (length D);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (B @ xs);\n     c = length D; \\<forall>a\\<in>set a. aEval a (D @ C # xs);\n     \\<forall>f\\<in>set b. eval f (D @ C # xs)\\<rbrakk>\n    \\<Longrightarrow> length (D @ [C]) = Suc (length D) \\<and>\n                      (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                          eval f ((D @ [C]) @ xs))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           eval (step (Suc 0) (length L) a b) (xs @ xs);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n               eval f (xs @ xs));\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length B)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, length B);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        eval (step (Suc 0) (length B) a b) (xs @ xs);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xs @ xs));\n     c = length B; \\<forall>a\\<in>set a. aEval a (B @ A # xs);\n     \\<forall>f\\<in>set b. eval f (B @ A # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = Suc (length B) \\<and>\n                         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                             eval f (l @ xs))", "apply(rule exI[where x=\"B@[A]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length B)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, length B);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        eval (step (Suc 0) (length B) a b) (xs @ xs);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xs @ xs));\n     c = length B; \\<forall>a\\<in>set a. aEval a (B @ A # xs);\n     \\<forall>f\\<in>set b. eval f (B @ A # xs)\\<rbrakk>\n    \\<Longrightarrow> length (B @ [A]) = Suc (length B) \\<and>\n                      (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                          eval f ((B @ [A]) @ xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (ExQ \\<phi>)) xs = eval (ExQ \\<phi>) xs\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "have h : \"(\\<exists>x. \\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (neg(QE_dnf opt step \\<phi>)))).\n            \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ x # xs))) = \n        (\\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (neg(QE_dnf opt step \\<phi>)))). \\<exists>x. \n            \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<exists>(al, fl, n)\n                 \\<in>set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>)))).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x # xs))) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<exists>x L.\n           length L = n \\<and>\n           (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a aa b L.\n       \\<lbrakk>(a, aa, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set aa. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(al, fl, n)\n                                  \\<in>set\n  (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n                            \\<exists>x L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x # xs)) \\<and>\n                               (\\<forall>f\\<in>set fl. eval f (L @ x # xs))\n 2. \\<And>a aa b x L.\n       \\<lbrakk>(a, aa, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set aa. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>(al, fl, n)\n                                     \\<in>set\n     (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n                               \\<exists>L.\n                                  length L = n \\<and>\n                                  (\\<forall>a\\<in>set al.\naEval a (L @ x # xs)) \\<and>\n                                  (\\<forall>f\\<in>set fl.\neval f (L @ x # xs))", "by blast+"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<exists>(al, fl, n)\n               \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n         \\<exists>L.\n            length L = n \\<and>\n            (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (L @ x # xs))) =\n  (\\<exists>(al, fl, n)\n            \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n      \\<exists>x L.\n         length L = n \\<and>\n         (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "have lessThan : \"\\<And>c. Suc 0 \\<le> c + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. Suc 0 \\<le> c + 1", "by simp"], ["proof (state)\nthis:\n  Suc 0 \\<le> ?c + 1\n\ngoal (5 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>\\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 5. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs", "apply (simp add:eval_list_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc n) (step (Suc 0) n al fl))\n                xs) =\n    (\\<forall>x. eval \\<phi> (x # xs))", "unfolding AllQ[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc n) (step (Suc 0) n al fl))\n                xs) =\n    (\\<forall>x. eval (QE_dnf opt step \\<phi>) (x # xs))", "unfolding eval_neg[symmetric, of \"(QE_dnf opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc n) (step (Suc 0) n al fl))\n                xs) =\n    (\\<forall>x. \\<not> eval (neg (QE_dnf opt step \\<phi>)) (x # xs))", "unfolding opt[symmetric, of \"neg(QE_dnf opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc n) (step (Suc 0) n al fl))\n                xs) =\n    (\\<forall>x. \\<not> eval (opt (neg (QE_dnf opt step \\<phi>))) (x # xs))", "unfolding HOL.Not_eq_iff[symmetric, of \"(\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))). \\<not> eval (case f of (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl)) xs)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>f\\<in>set (dnf_modified\n                                  (opt (neg (QE_dnf opt step \\<phi>)))).\n                \\<not> eval\n                        (case f of\n                         (al, fl, n) \\<Rightarrow>\n                           ExN (Suc n) (step (Suc 0) n al fl))\n                        xs)) =\n    (\\<not> (\\<forall>x.\n                \\<not> eval (opt (neg (QE_dnf opt step \\<phi>))) (x # xs)))", "unfolding SMT.verit_connective_def(3)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>f\\<in>set (dnf_modified\n                                  (opt (neg (QE_dnf opt step \\<phi>)))).\n                \\<not> eval\n                        (case f of\n                         (al, fl, n) \\<Rightarrow>\n                           ExN (Suc n) (step (Suc 0) n al fl))\n                        xs)) =\n    (\\<exists>x. eval (opt (neg (QE_dnf opt step \\<phi>))) (x # xs))", "unfolding boundedFlipNegQuantifier"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>x. eval (opt (neg (QE_dnf opt step \\<phi>))) (x # xs))", "unfolding dnf_modified_eval[symmetric, of \"opt(neg(QE_dnf opt step \\<phi>))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>x.\n        \\<exists>(al, fl, n)\n                 \\<in>set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>)))).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n         xs) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<exists>x L.\n           length L = n \\<and>\n           (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))) =\n    set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))))\n 2. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (neg (QE_dnf opt step \\<phi>)))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>x L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (neg (QE_dnf opt step \\<phi>)))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>x L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified\n                  (opt (neg (QE_dnf opt step \\<phi>)))) \\<Longrightarrow>\n    eval\n     (case f of\n      (al, fl, n) \\<Rightarrow> ExN (Suc n) (step (Suc 0) n al fl))\n     xs =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>x L.\n          length L = n \\<and>\n          (\\<forall>a\\<in>set al. aEval a (L @ x # xs)) \\<and>\n          (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified\n                              (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (al, fl, n) \\<Rightarrow>\n                             ExN (Suc n) (step (Suc 0) n al fl))\n                          xs =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>x L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x # xs)) \\<and>\n                               (\\<forall>f\\<in>set fl. eval f (L @ x # xs)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l.\n                             length l = Suc c \\<and>\n                             eval (step (Suc 0) c a b) (l @ xs)) =\n                         (\\<exists>x L.\n                             length L = c \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (L @ x # xs)) \\<and>\n                             (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "subgoal for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc c \\<and>\n                          eval (step (Suc 0) c a b) (l @ xs)) =\n                      (\\<exists>x L.\n                          length L = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (L @ x # xs)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "using steph[of \"Suc 0\" c a b xs, symmetric,OF lessThan]"], ["proof (prove)\nusing this:\n  (\\<exists>xs.\n      length xs = c + 1 \\<and> eval (step (Suc 0) c a b) (xs @ xs)) =\n  (\\<exists>xs.\n      length xs = c + 1 \\<and>\n      eval (list_conj (map fm.Atom a @ b)) (xs @ xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc c \\<and>\n                          eval (step (Suc 0) c a b) (l @ xs)) =\n                      (\\<exists>x L.\n                          length L = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (L @ x # xs)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "apply (simp add:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c);\n     (\\<exists>xs.\n         length xs = Suc c \\<and> eval (step (Suc 0) c a b) (xs @ xs)) =\n     (\\<exists>xs.\n         length xs = Suc c \\<and>\n         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n             eval f (xs @ xs)))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc c \\<and>\n                          (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                              eval f (l @ xs))) =\n                      (\\<exists>x L.\n                          length L = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (L @ x # xs)) \\<and>\n                          (\\<forall>f\\<in>set b. eval f (L @ x # xs)))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs xsaa l.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c); length xs = Suc c;\n        eval (step (Suc 0) c a b) (xs @ xs); length xsaa = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xsaa @ xs);\n        length l = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x L.\n                            length L = c \\<and>\n                            (\\<forall>a\\<in>set a.\n                                aEval a (L @ x # xs)) \\<and>\n                            (\\<forall>f\\<in>set b. eval f (L @ x # xs))\n 2. \\<And>xs xsaa x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L); length xs = Suc (length L);\n        eval (step (Suc 0) (length L) a b) (xs @ xs);\n        length xsaa = Suc (length L);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xsaa @ xs);\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))\n 3. \\<And>x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           eval (step (Suc 0) (length L) a b) (xs @ xs);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n               eval f (xs @ xs));\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for xs' l' l''"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c); length xs' = Suc c;\n     eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n     length l'' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (l'' @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x L.\n                         length L = c \\<and>\n                         (\\<forall>a\\<in>set a. aEval a (L @ x # xs)) \\<and>\n                         (\\<forall>f\\<in>set b. eval f (L @ x # xs))", "apply(rule exI[where x=\"l'!c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c); length xs' = Suc c;\n     eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n     length l'' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (l'' @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         length L = c \\<and>\n                         (\\<forall>a\\<in>set a.\n                             aEval a (L @ l' ! c # xs)) \\<and>\n                         (\\<forall>f\\<in>set b. eval f (L @ l' ! c # xs))", "apply(rule exI[where x=\"take c l'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c); length xs' = Suc c;\n     eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n     length l'' = Suc c;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (l'' @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (take c l') = c \\<and>\n                      (\\<forall>a\\<in>set a.\n                          aEval a (take c l' @ l' ! c # xs)) \\<and>\n                      (\\<forall>f\\<in>set b.\n                          eval f (take c l' @ l' ! c # xs))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c); length xs' = Suc c;\n        eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n        length l'' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l'' @ xs);\n        aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval aa (take c l' @ l' ! c # xs)\n 2. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c); length xs' = Suc c;\n        eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n        length l'' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l'' @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c l' @ l' ! c # xs)", "apply (metis Un_iff append.assoc append_Cons append_Nil eval.simps(1) image_eqI lessI order_refl take_Suc_conv_app_nth take_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c); length xs' = Suc c;\n        eval (step (Suc 0) c a b) (xs' @ xs); length l' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l' @ xs);\n        length l'' = Suc c;\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (l'' @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c l' @ l' ! c # xs)", "by (metis Un_iff append.assoc append_Cons append_Nil lessI order_refl take_Suc_conv_app_nth take_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsaa x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L); length xs = Suc (length L);\n        eval (step (Suc 0) (length L) a b) (xs @ xs);\n        length xsaa = Suc (length L);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xsaa @ xs);\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))\n 2. \\<And>x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           eval (step (Suc 0) (length L) a b) (xs @ xs);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n               eval f (xs @ xs));\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for A B C D"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length D)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, length D); length A = Suc (length D);\n     eval (step (Suc 0) (length D) a b) (A @ xs); length B = Suc (length D);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (B @ xs);\n     c = length D; \\<forall>a\\<in>set a. aEval a (D @ C # xs);\n     \\<forall>f\\<in>set b. eval f (D @ C # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = Suc (length D) \\<and>\n                         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                             eval f (l @ xs))", "apply(rule exI[where x=\"D@[C]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length D)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, length D); length A = Suc (length D);\n     eval (step (Suc 0) (length D) a b) (A @ xs); length B = Suc (length D);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (B @ xs);\n     c = length D; \\<forall>a\\<in>set a. aEval a (D @ C # xs);\n     \\<forall>f\\<in>set b. eval f (D @ C # xs)\\<rbrakk>\n    \\<Longrightarrow> length (D @ [C]) = Suc (length D) \\<and>\n                      (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                          eval f ((D @ [C]) @ xs))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           eval (step (Suc 0) (length L) a b) (xs @ xs);\n        \\<nexists>xs.\n           length xs = Suc (length L) \\<and>\n           (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n               eval f (xs @ xs));\n        c = length L; \\<forall>a\\<in>set a. aEval a (L @ x # xs);\n        \\<forall>f\\<in>set b. eval f (L @ x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length B)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, length B);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        eval (step (Suc 0) (length B) a b) (xs @ xs);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xs @ xs));\n     c = length B; \\<forall>a\\<in>set a. aEval a (B @ A # xs);\n     \\<forall>f\\<in>set b. eval f (B @ A # xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = Suc (length B) \\<and>\n                         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                             eval f (l @ xs))", "apply(rule exI[where x=\"B@[A]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length B)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, length B);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        eval (step (Suc 0) (length B) a b) (xs @ xs);\n     \\<nexists>xs.\n        length xs = Suc (length B) \\<and>\n        (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xs @ xs));\n     c = length B; \\<forall>a\\<in>set a. aEval a (B @ A # xs);\n     \\<forall>f\\<in>set b. eval f (B @ A # xs)\\<rbrakk>\n    \\<Longrightarrow> length (B @ [A]) = Suc (length B) \\<and>\n                      (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                          eval f ((B @ [A]) @ xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (AllQ \\<phi>)) xs = eval (AllQ \\<phi>) xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 4. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "proof(cases x1)"], ["proof (state)\ngoal (2 subgoals):\n 1. x1 = 0 \\<Longrightarrow>\n    eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 2. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "case 0"], ["proof (state)\nthis:\n  x1 = 0\n\ngoal (2 subgoals):\n 1. x1 = 0 \\<Longrightarrow>\n    eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n 2. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  x1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x1 = 0\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "using ExN"], ["proof (prove)\nusing this:\n  x1 = 0\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "by simp"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "case (Suc nat)"], ["proof (state)\nthis:\n  x1 = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "have h : \"(\\<exists>l. length l = Suc nat \\<and>\n         (\\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n             \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))) = \n        (\\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))). (\\<exists>l. length l = Suc nat \\<and>\n             (\\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l.\n        length l = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        \\<exists>l.\n           length l = Suc nat \\<and>\n           (\\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a aa b L.\n       \\<lbrakk>length l = Suc nat;\n        (a, aa, length L)\n        \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set aa. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(al, fl, n)\n                                  \\<in>set\n  (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n                            \\<exists>l.\n                               length l = Suc nat \\<and>\n                               (\\<exists>L.\n                                   length L = n \\<and>\n                                   (\\<forall>a\\<in>set al.\n aEval a (L @ l @ xs)) \\<and>\n                                   (\\<forall>f\\<in>set fl.\n eval f (L @ l @ xs)))\n 2. \\<And>a aa b l L.\n       \\<lbrakk>(a, aa, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        length l = Suc nat; \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set aa. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc nat \\<and>\n                            (\\<exists>(al, fl, n)\n\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n                                \\<exists>L.\n                                   length L = n \\<and>\n                                   (\\<forall>a\\<in>set al.\n aEval a (L @ l @ xs)) \\<and>\n                                   (\\<forall>f\\<in>set fl.\n eval f (L @ l @ xs)))", "by blast+"], ["proof (state)\nthis:\n  (\\<exists>l.\n      length l = Suc nat \\<and>\n      (\\<exists>(al, fl, n)\n                \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))) =\n  (\\<exists>(al, fl, n)\n            \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n      \\<exists>l.\n         length l = Suc nat \\<and>\n         (\\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "have lessThan : \"\\<And>c. Suc nat \\<le> c + nat + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. Suc nat \\<le> c + nat + 1", "by simp"], ["proof (state)\nthis:\n  Suc nat \\<le> ?c + nat + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       x1 = Suc nat \\<Longrightarrow>\n       eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs", "apply (simp add:eval_list_disj Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>l. length l = Suc nat \\<and> eval \\<phi> (l @ xs))", "unfolding ExN[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>l.\n        length l = Suc nat \\<and> eval (QE_dnf opt step \\<phi>) (l @ xs))", "unfolding opt[symmetric, of \"(QE_dnf opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>l.\n        length l = Suc nat \\<and>\n        eval (opt (QE_dnf opt step \\<phi>)) (l @ xs))", "unfolding dnf_modified_eval[symmetric, of \"(opt (QE_dnf opt step \\<phi>))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>l.\n        length l = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (QE_dnf opt step \\<phi>))).\n        \\<exists>l.\n           length l = Suc nat \\<and>\n           (\\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (dnf_modified (opt (QE_dnf opt step \\<phi>))) =\n    set (dnf_modified (opt (QE_dnf opt step \\<phi>)))\n 2. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (QE_dnf opt step \\<phi>))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow>\n           ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>l.\n             length l = Suc nat \\<and>\n             (\\<exists>L.\n                 length L = n \\<and>\n                 (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                 (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (QE_dnf opt step \\<phi>))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow>\n           ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>l.\n             length l = Suc nat \\<and>\n             (\\<exists>L.\n                 length L = n \\<and>\n                 (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                 (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified\n                  (opt (QE_dnf opt step \\<phi>))) \\<Longrightarrow>\n    eval\n     (case f of\n      (al, fl, n) \\<Rightarrow>\n        ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n     xs =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>l.\n          length l = Suc nat \\<and>\n          (\\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (al, fl, n) \\<Rightarrow>\n                             ExN (Suc (n + nat))\n                              (step (Suc nat) (n + nat) al fl))\n                          xs =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>l.\n                               length l = Suc nat \\<and>\n                               (\\<exists>L.\n                                   length L = n \\<and>\n                                   (\\<forall>a\\<in>set al.\n aEval a (L @ l @ xs)) \\<and>\n                                   (\\<forall>f\\<in>set fl.\n eval f (L @ l @ xs))))", "subgoal for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (case f of\n                        (al, fl, n) \\<Rightarrow>\n                          ExN (Suc (n + nat))\n                           (step (Suc nat) (n + nat) al fl))\n                       xs =\n                      (case f of\n                       (al, fl, n) \\<Rightarrow>\n                         \\<exists>l.\n                            length l = Suc nat \\<and>\n                            (\\<exists>L.\n                                length L = n \\<and>\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (L @ l @ xs)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (L @ l @ xs))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc (c + nat) \\<and>\n                          eval (step (Suc nat) (c + nat) a b) (l @ xs)) =\n                      (\\<exists>l.\n                          length l = Suc nat \\<and>\n                          (\\<exists>L.\n                              length L = c \\<and>\n                              (\\<forall>a\\<in>set a.\n                                  aEval a (L @ l @ xs)) \\<and>\n                              (\\<forall>f\\<in>set b. eval f (L @ l @ xs))))", "using steph[of \"Suc nat\" \"c+nat\",symmetric, OF lessThan]"], ["proof (prove)\nusing this:\n  (\\<exists>xs.\n      length xs = c + nat + 1 \\<and>\n      eval (step (Suc nat) (c + nat) ?L ?F) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = c + nat + 1 \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc (c + nat) \\<and>\n                          eval (step (Suc nat) (c + nat) a b) (l @ xs)) =\n                      (\\<exists>l.\n                          length l = Suc nat \\<and>\n                          (\\<exists>L.\n                              length L = c \\<and>\n                              (\\<forall>a\\<in>set a.\n                                  aEval a (L @ l @ xs)) \\<and>\n                              (\\<forall>f\\<in>set b. eval f (L @ l @ xs))))", "apply (auto simp add:eval_list_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length l = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc nat \\<and>\n                            (\\<exists>L.\n                                length L = c \\<and>\n                                (\\<forall>a\\<in>set a.\n                                    aEval a (L @ l @ xs)) \\<and>\n                                (\\<forall>f\\<in>set b. eval f (L @ l @ xs)))\n 2. \\<And>l L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L);\n        \\<And>La F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               eval (step (Suc nat) (length L + nat) La F)\n                (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set La \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length l = Suc nat; c = length L;\n        \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set b. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L + nat) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for L"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = Suc nat \\<and>\n                         (\\<exists>L.\n                             length L = c \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (L @ l @ xs)) \\<and>\n                             (\\<forall>f\\<in>set b. eval f (L @ l @ xs)))", "apply(rule exI[where x=\"drop c L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (drop c L) = Suc nat \\<and>\n                      (\\<exists>La.\n                          length La = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (La @ drop c L @ xs)) \\<and>\n                          (\\<forall>f\\<in>set b.\n                              eval f (La @ drop c L @ xs)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>La.\n                         length La = c \\<and>\n                         (\\<forall>a\\<in>set a.\n                             aEval a (La @ drop c L @ xs)) \\<and>\n                         (\\<forall>f\\<in>set b. eval f (La @ drop c L @ xs))", "apply(rule exI[where x=\"take c L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (take c L) = c \\<and>\n                      (\\<forall>a\\<in>set a.\n                          aEval a (take c L @ drop c L @ xs)) \\<and>\n                      (\\<forall>f\\<in>set b.\n                          eval f (take c L @ drop c L @ xs))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length L = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs);\n        aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval aa (take c L @ drop c L @ xs)\n 2. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length L = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c L @ drop c L @ xs)", "apply (metis Un_iff append.assoc append_take_drop_id eval.simps(1) image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length L = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c L @ drop c L @ xs)", "by (metis Un_iff append.assoc append_take_drop_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n        f = (a, b, length L);\n        \\<And>La F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               eval (step (Suc nat) (length L + nat) La F)\n                (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set La \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length l = Suc nat; c = length L;\n        \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set b. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L + nat) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for L l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length l)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, length l);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            eval (step (Suc nat) (length l + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc nat; c = length l;\n     \\<forall>a\\<in>set a. aEval a (l @ L @ xs);\n     \\<forall>f\\<in>set b. eval f (l @ L @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la.\n                         length la = Suc (length l + nat) \\<and>\n                         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                             eval f (la @ xs))", "apply(rule exI[where x=\"l@L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length l)\n             \\<in> set (dnf_modified (opt (QE_dnf opt step \\<phi>)));\n     f = (a, b, length l);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            eval (step (Suc nat) (length l + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc nat; c = length l;\n     \\<forall>a\\<in>set a. aEval a (l @ L @ xs);\n     \\<forall>f\\<in>set b. eval f (l @ L @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (l @ L) = Suc (length l + nat) \\<and>\n                      (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                          eval f ((l @ L) @ xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (ExN x1 \\<phi>)) xs = eval (ExN x1 \\<phi>) xs\n\ngoal (3 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (3 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs\n 3. \\<And>x1 \\<phi> xs.\n       (\\<And>xs.\n           eval (QE_dnf opt step \\<phi>) xs =\n           eval \\<phi> xs) \\<Longrightarrow>\n       eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs", "show ?case"], ["proof (prove)\nusing this:\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "proof(cases x1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n     x1 = 0\\<rbrakk>\n    \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                      eval (AllN x1 \\<phi>) xs\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "case 0"], ["proof (state)\nthis:\n  x1 = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n     x1 = 0\\<rbrakk>\n    \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                      eval (AllN x1 \\<phi>) xs\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "then"], ["proof (chain)\npicking this:\n  x1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x1 = 0\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "using AllN"], ["proof (prove)\nusing this:\n  x1 = 0\n  eval (QE_dnf opt step \\<phi>) ?xs = eval \\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "by simp"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "case (Suc nat)"], ["proof (state)\nthis:\n  x1 = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "have h : \"(\\<exists>l. length l = Suc nat \\<and>\n         (\\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (neg(QE_dnf opt step \\<phi>)))).\n             \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))) = \n        (\\<exists>(al, fl, n)\\<in>set (dnf_modified (opt (neg(QE_dnf opt step \\<phi>)))). (\\<exists>l. length l = Suc nat \\<and>\n             (\\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l.\n        length l = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified\n                             (opt (neg (QE_dnf opt step \\<phi>)))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<exists>l.\n           length l = Suc nat \\<and>\n           (\\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a aa b L.\n       \\<lbrakk>length l = Suc nat;\n        (a, aa, length L)\n        \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n        \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set aa. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(al, fl, n)\n                                  \\<in>set\n  (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n                            \\<exists>l.\n                               length l = Suc nat \\<and>\n                               (\\<exists>L.\n                                   length L = n \\<and>\n                                   (\\<forall>a\\<in>set al.\n aEval a (L @ l @ xs)) \\<and>\n                                   (\\<forall>f\\<in>set fl.\n eval f (L @ l @ xs)))\n 2. \\<And>a aa b l L.\n       \\<lbrakk>(a, aa, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        length l = Suc nat; \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set aa. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc nat \\<and>\n                            (\\<exists>(al, fl, n)\n\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n                                \\<exists>L.\n                                   length L = n \\<and>\n                                   (\\<forall>a\\<in>set al.\n aEval a (L @ l @ xs)) \\<and>\n                                   (\\<forall>f\\<in>set fl.\n eval f (L @ l @ xs)))", "by blast+"], ["proof (state)\nthis:\n  (\\<exists>l.\n      length l = Suc nat \\<and>\n      (\\<exists>(al, fl, n)\n                \\<in>set (dnf_modified\n                           (opt (neg (QE_dnf opt step \\<phi>)))).\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))) =\n  (\\<exists>(al, fl, n)\n            \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n      \\<exists>l.\n         length l = Suc nat \\<and>\n         (\\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "have lessThan : \"\\<And>c. Suc nat \\<le> c + nat + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. Suc nat \\<le> c + nat + 1", "by simp"], ["proof (state)\nthis:\n  Suc nat \\<le> ?c + nat + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>xs. eval (QE_dnf opt step \\<phi>) xs = eval \\<phi> xs;\n        x1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval (QE_dnf opt step (AllN x1 \\<phi>)) xs =\n                         eval (AllN x1 \\<phi>) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs", "apply (simp add:eval_list_disj Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l. length l = Suc nat \\<longrightarrow> eval \\<phi> (l @ xs))", "unfolding AllN[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l.\n        length l = Suc nat \\<longrightarrow>\n        eval (QE_dnf opt step \\<phi>) (l @ xs))", "unfolding eval_neg[symmetric, of \"QE_dnf opt step \\<phi>\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l.\n        length l = Suc nat \\<longrightarrow>\n        \\<not> eval (neg (QE_dnf opt step \\<phi>)) (l @ xs))", "unfolding HOL.imp_conv_disj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l.\n        length l \\<noteq> Suc nat \\<or>\n        \\<not> eval (neg (QE_dnf opt step \\<phi>)) (l @ xs))", "unfolding HOL.de_Morgan_conj[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l.\n        \\<not> (length l = Suc nat \\<and>\n                eval (neg (QE_dnf opt step \\<phi>)) (l @ xs)))", "unfolding opt[symmetric, of \"neg(QE_dnf opt step \\<phi>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l.\n        \\<not> (length l = Suc nat \\<and>\n                eval (opt (neg (QE_dnf opt step \\<phi>))) (l @ xs)))", "unfolding dnf_modified_eval[symmetric, of \"(opt (neg(QE_dnf opt step \\<phi>)))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval\n                (case f of\n                 (al, fl, n) \\<Rightarrow>\n                   ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n                xs) =\n    (\\<forall>l.\n        \\<not> (length l = Suc nat \\<and>\n                (\\<exists>(al, fl, n)\n                          \\<in>set (dnf_modified\n                                     (opt (neg (QE_dnf opt step \\<phi>)))).\n                    \\<exists>L.\n                       length L = n \\<and>\n                       (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                       (\\<forall>f\\<in>set fl. eval f (L @ l @ xs)))))", "unfolding HOL.Not_eq_iff[symmetric, of \"(\\<forall>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<not> eval (case f of (al, fl, n) \\<Rightarrow> ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl)) xs)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>f\\<in>set (dnf_modified\n                                  (opt (neg (QE_dnf opt step \\<phi>)))).\n                \\<not> eval\n                        (case f of\n                         (al, fl, n) \\<Rightarrow>\n                           ExN (Suc (n + nat))\n                            (step (Suc nat) (n + nat) al fl))\n                        xs)) =\n    (\\<not> (\\<forall>l.\n                \\<not> (length l = Suc nat \\<and>\n                        (\\<exists>(al, fl, n)\n                                  \\<in>set\n  (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ l @ xs)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ l @ xs))))))", "unfolding SMT.verit_connective_def(3)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<forall>f\\<in>set (dnf_modified\n                                  (opt (neg (QE_dnf opt step \\<phi>)))).\n                \\<not> eval\n                        (case f of\n                         (al, fl, n) \\<Rightarrow>\n                           ExN (Suc (n + nat))\n                            (step (Suc nat) (n + nat) al fl))\n                        xs)) =\n    (\\<exists>l.\n        length l = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified\n                             (opt (neg (QE_dnf opt step \\<phi>)))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "unfolding boundedFlipNegQuantifier"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>l.\n        length l = Suc nat \\<and>\n        (\\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified\n                             (opt (neg (QE_dnf opt step \\<phi>)))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        eval\n         (case f of\n          (al, fl, n) \\<Rightarrow>\n            ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n         xs) =\n    (\\<exists>(al, fl, n)\n              \\<in>set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))).\n        \\<exists>l.\n           length l = Suc nat \\<and>\n           (\\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>)))) =\n    set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))))\n 2. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (neg (QE_dnf opt step \\<phi>)))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow>\n           ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>l.\n             length l = Suc nat \\<and>\n             (\\<exists>L.\n                 length L = n \\<and>\n                 (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                 (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (dnf_modified\n                     (opt (neg (QE_dnf opt step \\<phi>)))) \\<Longrightarrow>\n       eval\n        (case f of\n         (al, fl, n) \\<Rightarrow>\n           ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n        xs =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>l.\n             length l = Suc nat \\<and>\n             (\\<exists>L.\n                 length L = n \\<and>\n                 (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n                 (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified\n                  (opt (neg (QE_dnf opt step \\<phi>)))) \\<Longrightarrow>\n    eval\n     (case f of\n      (al, fl, n) \\<Rightarrow>\n        ExN (Suc (n + nat)) (step (Suc nat) (n + nat) al fl))\n     xs =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>l.\n          length l = Suc nat \\<and>\n          (\\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ l @ xs)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ l @ xs))))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified\n                              (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (al, fl, n) \\<Rightarrow>\n                             ExN (Suc (n + nat))\n                              (step (Suc nat) (n + nat) al fl))\n                          xs =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>l.\n                               length l = Suc nat \\<and>\n                               (\\<exists>L.\n                                   length L = n \\<and>\n                                   (\\<forall>a\\<in>set al.\n aEval a (L @ l @ xs)) \\<and>\n                                   (\\<forall>f\\<in>set fl.\n eval f (L @ l @ xs))))", "subgoal for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> set (dnf_modified\n                           (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (case f of\n                        (al, fl, n) \\<Rightarrow>\n                          ExN (Suc (n + nat))\n                           (step (Suc nat) (n + nat) al fl))\n                       xs =\n                      (case f of\n                       (al, fl, n) \\<Rightarrow>\n                         \\<exists>l.\n                            length l = Suc nat \\<and>\n                            (\\<exists>L.\n                                length L = n \\<and>\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (L @ l @ xs)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (L @ l @ xs))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc (c + nat) \\<and>\n                          eval (step (Suc nat) (c + nat) a b) (l @ xs)) =\n                      (\\<exists>l.\n                          length l = Suc nat \\<and>\n                          (\\<exists>L.\n                              length L = c \\<and>\n                              (\\<forall>a\\<in>set a.\n                                  aEval a (L @ l @ xs)) \\<and>\n                              (\\<forall>f\\<in>set b. eval f (L @ l @ xs))))", "using steph[of \"Suc nat\" \"c+nat\",symmetric, OF lessThan]"], ["proof (prove)\nusing this:\n  (\\<exists>xs.\n      length xs = c + nat + 1 \\<and>\n      eval (step (Suc nat) (c + nat) ?L ?F) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = c + nat + 1 \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l.\n                          length l = Suc (c + nat) \\<and>\n                          eval (step (Suc nat) (c + nat) a b) (l @ xs)) =\n                      (\\<exists>l.\n                          length l = Suc nat \\<and>\n                          (\\<exists>L.\n                              length L = c \\<and>\n                              (\\<forall>a\\<in>set a.\n                                  aEval a (L @ l @ xs)) \\<and>\n                              (\\<forall>f\\<in>set b. eval f (L @ l @ xs))))", "apply (auto simp add:eval_list_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length l = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc nat \\<and>\n                            (\\<exists>L.\n                                length L = c \\<and>\n                                (\\<forall>a\\<in>set a.\n                                    aEval a (L @ l @ xs)) \\<and>\n                                (\\<forall>f\\<in>set b. eval f (L @ l @ xs)))\n 2. \\<And>l L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L);\n        \\<And>La F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               eval (step (Suc nat) (length L + nat) La F)\n                (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set La \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length l = Suc nat; c = length L;\n        \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set b. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L + nat) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for L"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = Suc nat \\<and>\n                         (\\<exists>L.\n                             length L = c \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (L @ l @ xs)) \\<and>\n                             (\\<forall>f\\<in>set b. eval f (L @ l @ xs)))", "apply(rule exI[where x=\"drop c L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (drop c L) = Suc nat \\<and>\n                      (\\<exists>La.\n                          length La = c \\<and>\n                          (\\<forall>a\\<in>set a.\n                              aEval a (La @ drop c L @ xs)) \\<and>\n                          (\\<forall>f\\<in>set b.\n                              eval f (La @ drop c L @ xs)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>La.\n                         length La = c \\<and>\n                         (\\<forall>a\\<in>set a.\n                             aEval a (La @ drop c L @ xs)) \\<and>\n                         (\\<forall>f\\<in>set b. eval f (La @ drop c L @ xs))", "apply(rule exI[where x=\"take c L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, c)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, c);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (c + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc (c + nat);\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (take c L) = c \\<and>\n                      (\\<forall>a\\<in>set a.\n                          aEval a (take c L @ drop c L @ xs)) \\<and>\n                      (\\<forall>f\\<in>set b.\n                          eval f (take c L @ drop c L @ xs))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length L = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs);\n        aa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval aa (take c L @ drop c L @ xs)\n 2. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length L = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c L @ drop c L @ xs)", "apply (metis Un_iff append.assoc append_take_drop_id eval.simps(1) image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>(a, b, c)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, c);\n        \\<And>L F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               eval (step (Suc nat) (c + nat) L F) (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (c + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length L = Suc (c + nat);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (L @ xs);\n        fa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval fa (take c L @ drop c L @ xs)", "by (metis Un_iff append.assoc append_take_drop_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l L.\n       \\<lbrakk>(a, b, length L)\n                \\<in> set (dnf_modified\n                            (opt (neg (QE_dnf opt step \\<phi>))));\n        f = (a, b, length L);\n        \\<And>La F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               eval (step (Suc nat) (length L + nat) La F)\n                (xs @ \\<Gamma>)) =\n           (\\<exists>xs.\n               length xs = Suc (length L + nat) \\<and>\n               (\\<forall>f\\<in>fm.Atom ` set La \\<union> set F.\n                   eval f (xs @ \\<Gamma>)));\n        length l = Suc nat; c = length L;\n        \\<forall>a\\<in>set a. aEval a (L @ l @ xs);\n        \\<forall>f\\<in>set b. eval f (L @ l @ xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = Suc (length L + nat) \\<and>\n                            (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                                eval f (l @ xs))", "subgoal for L l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length l)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, length l);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            eval (step (Suc nat) (length l + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc nat; c = length l;\n     \\<forall>a\\<in>set a. aEval a (l @ L @ xs);\n     \\<forall>f\\<in>set b. eval f (l @ L @ xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la.\n                         length la = Suc (length l + nat) \\<and>\n                         (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                             eval f (la @ xs))", "apply(rule exI[where x=\"l@L\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b, length l)\n             \\<in> set (dnf_modified (opt (neg (QE_dnf opt step \\<phi>))));\n     f = (a, b, length l);\n     \\<And>L F \\<Gamma>.\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            eval (step (Suc nat) (length l + nat) L F) (xs @ \\<Gamma>)) =\n        (\\<exists>xs.\n            length xs = Suc (length l + nat) \\<and>\n            (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                eval f (xs @ \\<Gamma>)));\n     length L = Suc nat; c = length l;\n     \\<forall>a\\<in>set a. aEval a (l @ L @ xs);\n     \\<forall>f\\<in>set b. eval f (l @ L @ xs)\\<rbrakk>\n    \\<Longrightarrow> length (l @ L) = Suc (length l + nat) \\<and>\n                      (\\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n                          eval f ((l @ L) @ xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (QE_dnf opt step (AllN x1 \\<phi>)) xs = eval (AllN x1 \\<phi>) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. eval (QE_dnf opt step TrueF) xs = eval TrueF xs\n 2. \\<And>xs. eval (QE_dnf opt step FalseF) xs = eval FalseF xs", "qed auto"], ["", "lemma opt: \"eval ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers) F) L= eval F L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n       groupQuantifiers \\<circ>\n       clearQuantifiers)\n       F)\n     L =\n    eval F L", "using push_forall_eval eval_nnf unpower_eval groupQuantifiers_eval clearQuantifiers_eval"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval ?\\<phi> xs = eval (push_forall ?\\<phi>) xs\n  \\<forall>\\<Gamma>. eval ?\\<phi> \\<Gamma> = eval (nnf ?\\<phi>) \\<Gamma>\n  eval (unpower ?v ?\\<phi>) ?L = eval ?\\<phi> ?L\n  eval ?F ?L = eval (groupQuantifiers ?F) ?L\n  eval (clearQuantifiers ?\\<phi>) ?xs = eval ?\\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval\n     ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n       groupQuantifiers \\<circ>\n       clearQuantifiers)\n       F)\n     L =\n    eval F L", "by auto"], ["", "lemma opt': \"eval ((push_forall ( nnf ( unpower 0 ( groupQuantifiers (clearQuantifiers F)))))) L= eval F L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (push_forall (nnf (unpower 0 (groupQuantifiers (clearQuantifiers F)))))\n     L =\n    eval F L", "using push_forall_eval eval_nnf unpower_eval groupQuantifiers_eval clearQuantifiers_eval"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval ?\\<phi> xs = eval (push_forall ?\\<phi>) xs\n  \\<forall>\\<Gamma>. eval ?\\<phi> \\<Gamma> = eval (nnf ?\\<phi>) \\<Gamma>\n  eval (unpower ?v ?\\<phi>) ?L = eval ?\\<phi> ?L\n  eval ?F ?L = eval (groupQuantifiers ?F) ?L\n  eval (clearQuantifiers ?\\<phi>) ?xs = eval ?\\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval\n     (push_forall (nnf (unpower 0 (groupQuantifiers (clearQuantifiers F)))))\n     L =\n    eval F L", "by auto"], ["", "lemma opt_no_group: \"eval ((push_forall \\<circ> nnf \\<circ> unpower 0 o clearQuantifiers) F) L= eval F L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ> clearQuantifiers)\n       F)\n     L =\n    eval F L", "using push_forall_eval eval_nnf unpower_eval clearQuantifiers_eval"], ["proof (prove)\nusing this:\n  \\<forall>xs. eval ?\\<phi> xs = eval (push_forall ?\\<phi>) xs\n  \\<forall>\\<Gamma>. eval ?\\<phi> \\<Gamma> = eval (nnf ?\\<phi>) \\<Gamma>\n  eval (unpower ?v ?\\<phi>) ?L = eval ?\\<phi> ?L\n  eval (clearQuantifiers ?\\<phi>) ?xs = eval ?\\<phi> ?xs\n\ngoal (1 subgoal):\n 1. eval\n     ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ> clearQuantifiers)\n       F)\n     L =\n    eval F L", "by auto"], ["", "lemma  repeatAmountOfQuantifiers_helper_eval : \n  assumes  \"\\<And>xs F. eval F xs = eval (step F) xs\"\n  shows  \"eval F xs = eval (repeatAmountOfQuantifiers_helper step n F) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F xs = eval (repeatAmountOfQuantifiers_helper step n F) xs", "apply(induction n arbitrary : F)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F. eval F xs = eval (repeatAmountOfQuantifiers_helper step 0 F) xs\n 2. \\<And>n F.\n       (\\<And>F.\n           eval F xs =\n           eval (repeatAmountOfQuantifiers_helper step n F)\n            xs) \\<Longrightarrow>\n       eval F xs = eval (repeatAmountOfQuantifiers_helper step (Suc n) F) xs", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n F.\n       (\\<And>F.\n           eval F xs =\n           eval (repeatAmountOfQuantifiers_helper step n F)\n            xs) \\<Longrightarrow>\n       eval F xs = eval (step F) xs", "subgoal for n F"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F.\n        eval F xs =\n        eval (repeatAmountOfQuantifiers_helper step n F)\n         xs) \\<Longrightarrow>\n    eval F xs = eval (step F) xs", "using assms[of F xs]"], ["proof (prove)\nusing this:\n  eval F xs = eval (step F) xs\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        eval F xs =\n        eval (repeatAmountOfQuantifiers_helper step n F)\n         xs) \\<Longrightarrow>\n    eval F xs = eval (step F) xs", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  repeatAmountOfQuantifiers_eval : \n  assumes  \"\\<And>xs F. eval F xs = eval (step F) xs\"\n  shows  \"eval F xs = eval (repeatAmountOfQuantifiers step F) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F xs = eval (repeatAmountOfQuantifiers step F) xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eval F xs = eval (repeatAmountOfQuantifiers step F) xs", "define F' where \"F' = step F\""], ["proof (state)\nthis:\n  F' = step F\n\ngoal (1 subgoal):\n 1. eval F xs = eval (repeatAmountOfQuantifiers step F) xs", "have h:  \"eval F xs = eval F' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F xs = eval F' xs", "using assms"], ["proof (prove)\nusing this:\n  eval ?F ?xs = eval (step ?F) ?xs\n\ngoal (1 subgoal):\n 1. eval F xs = eval F' xs", "unfolding F'_def"], ["proof (prove)\nusing this:\n  eval ?F ?xs = eval (step ?F) ?xs\n\ngoal (1 subgoal):\n 1. eval F xs = eval (step F) xs", "by auto"], ["proof (state)\nthis:\n  eval F xs = eval F' xs\n\ngoal (1 subgoal):\n 1. eval F xs = eval (repeatAmountOfQuantifiers step F) xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F xs = eval (repeatAmountOfQuantifiers step F) xs", "apply (simp add: F'_def[symmetric] h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F' xs =\n    eval (repeatAmountOfQuantifiers_helper step (countQuantifiers F') F') xs", "using repeatAmountOfQuantifiers_helper_eval[OF assms]"], ["proof (prove)\nusing this:\n  eval ?F ?xs = eval (repeatAmountOfQuantifiers_helper step ?n ?F) ?xs\n\ngoal (1 subgoal):\n 1. eval F' xs =\n    eval (repeatAmountOfQuantifiers_helper step (countQuantifiers F') F') xs", "by auto"], ["proof (state)\nthis:\n  eval F xs = eval (repeatAmountOfQuantifiers step F) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}