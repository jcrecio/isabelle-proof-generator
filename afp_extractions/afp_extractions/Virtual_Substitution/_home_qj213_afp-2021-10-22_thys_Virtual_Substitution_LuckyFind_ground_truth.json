{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/LuckyFind.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["theorem luckyFind_eval:\n  assumes \"luckyFind x L F = Some F'\"\n  assumes \"length xs = x\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval F' (xs @ (x#\\<Gamma>))))\"", "lemma luckyFind'_eval : \n  assumes \"length xs = var\"\n  shows \"(\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))\"", "lemma luckiestFind_eval : \n  assumes \"length xs = var\"\n  shows \"(\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))\""], "translations": [["", "theorem luckyFind_eval:\n  assumes \"luckyFind x L F = Some F'\"\n  assumes \"length xs = x\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval F' (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "proof(cases \"find_lucky_eq x L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_lucky_eq x L = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "case None"], ["proof (state)\nthis:\n  find_lucky_eq x L = None\n\ngoal (2 subgoals):\n 1. find_lucky_eq x L = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x L = None", "show ?thesis"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "using assms"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = None\n  luckyFind x L F = Some F'\n  length xs = x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval F' (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "case (Some p)"], ["proof (state)\nthis:\n  find_lucky_eq x L = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "have inset : \"Eq p \\<in> set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eq p \\<in> set L", "using Some"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set L", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_lucky_eq x [] = Some p \\<Longrightarrow> Eq p \\<in> set []\n 2. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "case Nil"], ["proof (state)\nthis:\n  find_lucky_eq x [] = Some p\n\ngoal (2 subgoals):\n 1. find_lucky_eq x [] = Some p \\<Longrightarrow> Eq p \\<in> set []\n 2. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x [] = Some p", "show ?case"], ["proof (prove)\nusing this:\n  find_lucky_eq x [] = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set []", "by auto"], ["proof (state)\nthis:\n  Eq p \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "case (Cons a L)"], ["proof (state)\nthis:\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p", "show ?case"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "case (Less x1)"], ["proof (state)\nthis:\n  a = Less x1\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "then"], ["proof (chain)\npicking this:\n  a = Less x1", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Less x1\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "using Cons"], ["proof (prove)\nusing this:\n  a = Less x1\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "by auto"], ["proof (state)\nthis:\n  Eq p \\<in> set (a # L)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "case (Eq p')"], ["proof (state)\nthis:\n  a = Eq p'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "using Cons"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "unfolding Eq"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (Eq p' # L) = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (Eq p' # L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n          MPoly_Type.degree p' x = 2) \\<and>\n         ((case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty\n                    (vars (isolate_variable_sparse p' x (Suc 0)))\n                then Some\n                      (MPoly_Type.coeff\n                        (isolate_variable_sparse p' x (Suc 0)) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n                else None of\n           None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n      then Some p' else find_lucky_eq x L) =\n     Some p\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"(MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n          MPoly_Type.degree p' x = 2) \\<and>\n         ((case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty\n                    (vars (isolate_variable_sparse p' x (Suc 0)))\n                then Some\n                      (MPoly_Type.coeff\n                        (isolate_variable_sparse p' x (Suc 0)) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n                else None of\n           None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n          MPoly_Type.degree p' x = 2) \\<and>\n         ((case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty\n                    (vars (isolate_variable_sparse p' x (Suc 0)))\n                then Some\n                      (MPoly_Type.coeff\n                        (isolate_variable_sparse p' x (Suc 0)) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n                else None of\n           None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     \\<not> (MPoly_Type.degree p' x = Suc 0 \\<or>\n             MPoly_Type.degree p' x = 2)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False\n             | Some x \\<Rightarrow> x \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n              then Some\n                    (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n              else None of\n         None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case if Set.is_empty\n                      (vars (isolate_variable_sparse p' x (Suc 0)))\n                  then Some\n                        (MPoly_Type.coeff\n                          (isolate_variable_sparse p' x (Suc 0)) 0)\n                  else None of\n             None \\<Rightarrow> False\n             | Some x \\<Rightarrow> x \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 0)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n              then Some\n                    (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n              else None of\n         None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case if Set.is_empty\n                      (vars (isolate_variable_sparse p' x (Suc 0)))\n                  then Some\n                        (MPoly_Type.coeff\n                          (isolate_variable_sparse p' x (Suc 0)) 0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L;\n     (if case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n              then Some\n                    (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n              else None of\n         None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case if Set.is_empty\n                      (vars (isolate_variable_sparse p' x (Suc 0)))\n                  then Some\n                        (MPoly_Type.coeff\n                          (isolate_variable_sparse p' x (Suc 0)) 0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "by(simp_all)"], ["proof (state)\nthis:\n  Eq p \\<in> set (a # L)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "case (Leq x3)"], ["proof (state)\nthis:\n  a = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "then"], ["proof (chain)\npicking this:\n  a = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Leq x3\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "using Cons"], ["proof (prove)\nusing this:\n  a = Leq x3\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "by auto"], ["proof (state)\nthis:\n  Eq p \\<in> set (a # L)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "case (Neq x4)"], ["proof (state)\nthis:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "then"], ["proof (chain)\npicking this:\n  a = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "using Cons"], ["proof (prove)\nusing this:\n  a = Neq x4\n  find_lucky_eq x L = Some p \\<Longrightarrow> Eq p \\<in> set L\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set (a # L)", "by auto"], ["proof (state)\nthis:\n  Eq p \\<in> set (a # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Eq p \\<in> set (a # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Eq p \\<in> set L\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "have degree : \"MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "using Some"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_lucky_eq x [] = Some p \\<Longrightarrow>\n    MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n 2. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "case Nil"], ["proof (state)\nthis:\n  find_lucky_eq x [] = Some p\n\ngoal (2 subgoals):\n 1. find_lucky_eq x [] = Some p \\<Longrightarrow>\n    MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n 2. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x [] = Some p", "show ?case"], ["proof (prove)\nusing this:\n  find_lucky_eq x [] = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "case (Cons a L)"], ["proof (state)\nthis:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p", "show ?case"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 3. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 4. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "case (Less x1)"], ["proof (state)\nthis:\n  a = Less x1\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 3. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 4. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "then"], ["proof (chain)\npicking this:\n  a = Less x1", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Less x1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "using Cons"], ["proof (prove)\nusing this:\n  a = Less x1\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "case (Eq p')"], ["proof (state)\nthis:\n  a = Eq p'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "using Cons"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "unfolding Eq"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (Eq p' # L) = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n          MPoly_Type.degree p' x = 2) \\<and>\n         ((case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty\n                    (vars (isolate_variable_sparse p' x (Suc 0)))\n                then Some\n                      (MPoly_Type.coeff\n                        (isolate_variable_sparse p' x (Suc 0)) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n                else None of\n           None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n      then Some p' else find_lucky_eq x L) =\n     Some p\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply(cases \"(MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n          MPoly_Type.degree p' x = 2) \\<and>\n         ((case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty\n                    (vars (isolate_variable_sparse p' x (Suc 0)))\n                then Some\n                      (MPoly_Type.coeff\n                        (isolate_variable_sparse p' x (Suc 0)) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n                else None of\n           None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n          MPoly_Type.degree p' x = 2) \\<and>\n         ((case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty\n                    (vars (isolate_variable_sparse p' x (Suc 0)))\n                then Some\n                      (MPoly_Type.coeff\n                        (isolate_variable_sparse p' x (Suc 0)) 0)\n                else None of\n           None \\<Rightarrow> False\n           | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n          (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n                then Some\n                      (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n                else None of\n           None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     \\<not> (MPoly_Type.degree p' x = Suc 0 \\<or>\n             MPoly_Type.degree p' x = 2)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 2) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False\n             | Some x \\<Rightarrow> x \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if (case if Set.is_empty (vars (isolate_variable_sparse p' x (Suc 0)))\n               then Some\n                     (MPoly_Type.coeff\n                       (isolate_variable_sparse p' x (Suc 0)) 0)\n               else None of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n               then Some\n                     (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n               else None of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0)\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n              then Some\n                    (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n              else None of\n         None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case if Set.is_empty\n                      (vars (isolate_variable_sparse p' x (Suc 0)))\n                  then Some\n                        (MPoly_Type.coeff\n                          (isolate_variable_sparse p' x (Suc 0)) 0)\n                  else None of\n             None \\<Rightarrow> False\n             | Some x \\<Rightarrow> x \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 0)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n              then Some\n                    (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n              else None of\n         None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case if Set.is_empty\n                      (vars (isolate_variable_sparse p' x (Suc 0)))\n                  then Some\n                        (MPoly_Type.coeff\n                          (isolate_variable_sparse p' x (Suc 0)) 0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2\n 2. \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n             MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     (if case if Set.is_empty (vars (isolate_variable_sparse p' x 0))\n              then Some\n                    (MPoly_Type.coeff (isolate_variable_sparse p' x 0) 0)\n              else None of\n         None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\n      then Some p' else find_lucky_eq x L) =\n     Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> (case if Set.is_empty (vars (isolate_variable_sparse p' x 2))\n                  then Some\n                        (MPoly_Type.coeff (isolate_variable_sparse p' x 2)\n                          0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case if Set.is_empty\n                      (vars (isolate_variable_sparse p' x (Suc 0)))\n                  then Some\n                        (MPoly_Type.coeff\n                          (isolate_variable_sparse p' x (Suc 0)) 0)\n                  else None of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p x = Suc 0 \\<or>\n                      MPoly_Type.degree p x = 2", "by(simp_all)"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "case (Leq x3)"], ["proof (state)\nthis:\n  a = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "then"], ["proof (chain)\npicking this:\n  a = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Leq x3\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "using Cons"], ["proof (prove)\nusing this:\n  a = Leq x3\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "case (Neq x4)"], ["proof (state)\nthis:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p x = 1 \\<or>\n                         MPoly_Type.degree p x = 2", "then"], ["proof (chain)\npicking this:\n  a = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "using Cons"], ["proof (prove)\nusing this:\n  a = Neq x4\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.degree p x = 1 \\<or> MPoly_Type.degree p x = 2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "have nonzero : \"\\<forall>xa. insertion (nth_default 0 (xs @ xa # \\<Gamma>)) (isolate_variable_sparse p x 2) \\<noteq> 0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) (isolate_variable_sparse p x 1) \\<noteq> 0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) (isolate_variable_sparse p x 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "using Some"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_lucky_eq x [] = Some p \\<Longrightarrow>\n    \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0\n 2. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "case Nil"], ["proof (state)\nthis:\n  find_lucky_eq x [] = Some p\n\ngoal (2 subgoals):\n 1. find_lucky_eq x [] = Some p \\<Longrightarrow>\n    \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0\n 2. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x [] = Some p", "show ?case"], ["proof (prove)\nusing this:\n  find_lucky_eq x [] = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "case (Cons a L)"], ["proof (state)\nthis:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "then"], ["proof (chain)\npicking this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p", "show ?case"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 3. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 4. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "case (Less x1)"], ["proof (state)\nthis:\n  a = Less x1\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 3. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 4. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "then"], ["proof (chain)\npicking this:\n  a = Less x1", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Less x1\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "using Cons"], ["proof (prove)\nusing this:\n  a = Less x1\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "case (Eq p')"], ["proof (state)\nthis:\n  a = Eq p'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "have h : \"\\<And>p xa. check_nonzero_const p \\<Longrightarrow> insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "fix p xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "assume h : \"check_nonzero_const p\""], ["proof (state)\nthis:\n  check_nonzero_const p\n\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "show \"insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "apply(cases \"get_if_const p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. get_if_const p = None \\<Longrightarrow>\n    insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\n 2. \\<And>a.\n       get_if_const p = Some a \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "using h get_if_const_insertion"], ["proof (prove)\nusing this:\n  check_nonzero_const p\n  get_if_const ?p = Some ?r \\<Longrightarrow> insertion ?f ?p = ?r\n\ngoal (2 subgoals):\n 1. get_if_const p = None \\<Longrightarrow>\n    insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\n 2. \\<And>a.\n       get_if_const p = Some a \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_nonzero_const ?p \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>)) ?p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 3. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "using Cons(2)"], ["proof (prove)\nusing this:\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "unfolding Eq"], ["proof (prove)\nusing this:\n  find_lucky_eq x (Eq p' # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "apply (simp del:get_if_const.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (MPoly_Type.degree p' x = Suc 0 \\<or>\n         MPoly_Type.degree p' x = 2) \\<and>\n        ((case get_if_const (isolate_variable_sparse p' x 2) of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case get_if_const (isolate_variable_sparse p' x (Suc 0)) of\n          None \\<Rightarrow> False\n          | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n         (case get_if_const (isolate_variable_sparse p' x 0) of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0))\n     then Some p' else find_lucky_eq x L) =\n    Some p \\<Longrightarrow>\n    \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x (Suc 0)) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "apply(cases \"(MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     \\<not> (MPoly_Type.degree p' x = Suc 0 \\<or>\n             MPoly_Type.degree p' x = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     \\<not> (MPoly_Type.degree p' x = Suc 0 \\<or>\n             MPoly_Type.degree p' x = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "using Cons"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     \\<not> (MPoly_Type.degree p' x = Suc 0 \\<or>\n             MPoly_Type.degree p' x = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (MPoly_Type.degree p' x = Suc 0 \\<or>\n                  MPoly_Type.degree p' x = 2) \\<and>\n                 ((case get_if_const (isolate_variable_sparse p' x 2) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const\n                         (isolate_variable_sparse p' x (Suc 0)) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                  (case get_if_const (isolate_variable_sparse p' x 0) of\n                   None \\<Rightarrow> False\n                   | Some x \\<Rightarrow> x \\<noteq> 0))\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply (simp del:get_if_const.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or>\n     MPoly_Type.degree p' x = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply(simp del:get_if_const.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = p;\n     MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     case get_if_const (isolate_variable_sparse p x 2) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "using h"], ["proof (prove)\nusing this:\n  check_nonzero_const ?p \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>)) ?p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = p;\n     MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     case get_if_const (isolate_variable_sparse p x 2) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply(simp del:get_if_const.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = p;\n     MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     \\<not> (case get_if_const (isolate_variable_sparse p x 2) of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     case get_if_const (isolate_variable_sparse p x (Suc 0)) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "using h"], ["proof (prove)\nusing this:\n  check_nonzero_const ?p \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>)) ?p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = p;\n     MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     \\<not> (case get_if_const (isolate_variable_sparse p x 2) of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     case get_if_const (isolate_variable_sparse p x (Suc 0)) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply(cases \"check_nonzero_const (isolate_variable_sparse p' x 0)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1);\n     check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply(simp del:get_if_const.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = p;\n     MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     \\<not> (case get_if_const (isolate_variable_sparse p x 2) of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case get_if_const (isolate_variable_sparse p x (Suc 0)) of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     case get_if_const (isolate_variable_sparse p x 0) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "using h"], ["proof (prove)\nusing this:\n  check_nonzero_const ?p \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>)) ?p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p' = p;\n     MPoly_Type.degree p x = Suc 0 \\<or> MPoly_Type.degree p x = 2;\n     \\<not> (case get_if_const (isolate_variable_sparse p x 2) of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     \\<not> (case get_if_const (isolate_variable_sparse p x (Suc 0)) of\n             None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0);\n     case get_if_const (isolate_variable_sparse p x 0) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0\n 2. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "using Cons"], ["proof (prove)\nusing this:\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (case get_if_const (isolate_variable_sparse p' x 2) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const\n                        (isolate_variable_sparse p' x (Suc 0)) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0) \\<or>\n                 (case get_if_const (isolate_variable_sparse p' x 0) of\n                  None \\<Rightarrow> False\n                  | Some x \\<Rightarrow> x \\<noteq> 0)\n              then Some p' else find_lucky_eq x L) =\n             Some p;\n     MPoly_Type.degree p' x = Suc 0 \\<or> MPoly_Type.degree p' x = 2;\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 2);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 1);\n     \\<not> check_nonzero_const (isolate_variable_sparse p' x 0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                          (isolate_variable_sparse p x 0) \\<noteq>\n                         0", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "case (Leq x3)"], ["proof (state)\nthis:\n  a = Leq x3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0\n 2. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "then"], ["proof (chain)\npicking this:\n  a = Leq x3", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Leq x3\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "using Cons"], ["proof (prove)\nusing this:\n  a = Leq x3\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "case (Neq x4)"], ["proof (state)\nthis:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>find_lucky_eq x L = Some p \\<Longrightarrow>\n                \\<forall>xa.\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                    (isolate_variable_sparse p x 0) \\<noteq>\n                   0;\n        find_lucky_eq x (a # L) = Some p; a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n                             (isolate_variable_sparse p x 0) \\<noteq>\n                            0", "then"], ["proof (chain)\npicking this:\n  a = Neq x4", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Neq x4\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "using Cons"], ["proof (prove)\nusing this:\n  a = Neq x4\n  find_lucky_eq x L = Some p \\<Longrightarrow>\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n  find_lucky_eq x (a # L) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p x 0) \\<noteq>\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xa.\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n      (isolate_variable_sparse p x 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq x L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "using elimVar_eq_2[OF assms(2) inset degree nonzero] Some assms"], ["proof (prove)\nusing this:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ ?F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>xa. eval (elimVar x L ?F (Eq p)) (xs @ xa # \\<Gamma>))\n  find_lucky_eq x L = Some p\n  luckyFind x L F = Some F'\n  length xs = x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval F' (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval F' (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma luckyFind'_eval : \n  assumes \"length xs = var\"\n  shows \"(\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "proof(cases \"find_lucky_eq var L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "case None"], ["proof (state)\nthis:\n  find_lucky_eq var L = None\n\ngoal (2 subgoals):\n 1. find_lucky_eq var L = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "apply(simp add:eval_list_conj None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        (\\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set F. eval f (xs @ x # \\<Gamma>)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ x # \\<Gamma>)) =\n       ((\\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set F. eval f (xs @ x # \\<Gamma>)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ x # \\<Gamma>);\n        f \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> aEval f (xs @ x # \\<Gamma>)", "by (meson UnCI eval.simps(1) image_eqI)"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "case (Some p)"], ["proof (state)\nthis:\n  find_lucky_eq var L = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "have \"\\<exists>F'. luckyFind var L F = Some F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F'. luckyFind var L F = Some F'", "by (simp add:Some)"], ["proof (state)\nthis:\n  \\<exists>F'. luckyFind var L F = Some F'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>F'. luckyFind var L F = Some F'", "obtain F' where F'_def: \"luckyFind var L F = Some F'\""], ["proof (prove)\nusing this:\n  \\<exists>F'. luckyFind var L F = Some F'\n\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        luckyFind var L F = Some F' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  luckyFind var L F = Some F'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_lucky_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "unfolding luckyFind_eval[OF F'_def assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval F' (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "using F'_def Some"], ["proof (prove)\nusing this:\n  luckyFind var L F = Some F'\n  find_lucky_eq var L = Some p\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval F' (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma luckiestFind_eval : \n  assumes \"length xs = var\"\n  shows \"(\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "proof(cases \"find_luckiest_eq var L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_luckiest_eq var L = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "case None"], ["proof (state)\nthis:\n  find_luckiest_eq var L = None\n\ngoal (2 subgoals):\n 1. find_luckiest_eq var L = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "apply(simp add:eval_list_conj None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        (\\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set F. eval f (xs @ x # \\<Gamma>)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ x # \\<Gamma>)) =\n       ((\\<forall>f\\<in>set L. aEval f (xs @ x # \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set F. eval f (xs @ x # \\<Gamma>)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>\\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n                   eval f (xs @ x # \\<Gamma>);\n        f \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> aEval f (xs @ x # \\<Gamma>)", "by (meson UnCI eval.simps(1) image_eqI)"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "case (Some p)"], ["proof (state)\nthis:\n  find_luckiest_eq var L = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "have h1: \"Eq p \\<in> set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eq p \\<in> set L", "using Some"], ["proof (prove)\nusing this:\n  find_luckiest_eq var L = Some p\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set L", "apply(induction L arbitrary:p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       find_luckiest_eq var [] = Some p \\<Longrightarrow> Eq p \\<in> set []\n 2. \\<And>a L p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "subgoal for a L p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq var L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n    \\<Longrightarrow> Eq p \\<in> set (a # L)", "apply(rule find_luckiest_eq.elims[of var \"a#L\" \"Some p\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq var L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n    \\<Longrightarrow> find_luckiest_eq var (a # L) = Some p\n 2. \\<And>v.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = [];\n        Some p = None\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 3. \\<And>v p L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Eq p # L;\n        Some p =\n        (if MPoly_Type.degree p v = 1 \\<or> MPoly_Type.degree p v = 2\n         then let (a, b, c) = get_coeffs v p\n              in case get_if_const a of\n                 None \\<Rightarrow> find_luckiest_eq v L\n                 | Some a \\<Rightarrow>\n                     case get_if_const b of\n                     None \\<Rightarrow> find_luckiest_eq v L\n                     | Some b \\<Rightarrow>\n                         case get_if_const c of\n                         None \\<Rightarrow> find_luckiest_eq v L\n                         | Some c \\<Rightarrow>\n                             if a \\<noteq> 0 \\<or>\n                                b \\<noteq> 0 \\<or> c \\<noteq> 0\n                             then Some p else find_luckiest_eq v L\n         else find_luckiest_eq v L)\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 4. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Less va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 5. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Leq va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)\n 6. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Neq va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> Eq p \\<in> set (a # L)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq v L = Some p \\<Longrightarrow>\n                   Eq p \\<in> set L;\n        var = v; a = Eq p;\n        Some p =\n        (if MPoly_Type.degree p v = Suc 0 \\<or> MPoly_Type.degree p v = 2\n         then let (a, b, c) = get_coeffs v p\n              in case get_if_const a of\n                 None \\<Rightarrow> find_luckiest_eq v L\n                 | Some a \\<Rightarrow>\n                     case get_if_const b of\n                     None \\<Rightarrow> find_luckiest_eq v L\n                     | Some b \\<Rightarrow>\n                         case get_if_const c of\n                         None \\<Rightarrow> find_luckiest_eq v L\n                         | Some c \\<Rightarrow>\n                             if a \\<noteq> 0 \\<or>\n                                b \\<noteq> 0 \\<or> c \\<noteq> 0\n                             then Some p else find_luckiest_eq v L\n         else find_luckiest_eq v L)\\<rbrakk>\n       \\<Longrightarrow> p = p \\<or> Eq p \\<in> set L", "subgoal for v p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or>\n     MPoly_Type.degree p' v = 2\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L);\n     \\<not> (MPoly_Type.degree p' v = Suc 0 \\<or>\n             MPoly_Type.degree p' v = 2)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or>\n     MPoly_Type.degree p' v = 2\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v 2))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     \\<not> Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     \\<not> Set.is_empty\n             (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v 0))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     \\<not> Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "apply(cases \"MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 = 0 \\<longrightarrow>\n        MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 = 0 \\<longrightarrow> MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                Eq p \\<in> set L;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     \\<not> (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n             0 \\<longrightarrow>\n             MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n             0 \\<longrightarrow>\n             MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq>\n             0)\\<rbrakk>\n    \\<Longrightarrow> p = p' \\<or> Eq p \\<in> set L", "by simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Eq p \\<in> set L\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "have h2 : \"MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using Some"], ["proof (prove)\nusing this:\n  find_luckiest_eq var L = Some p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "apply(induction L arbitrary:p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       find_luckiest_eq var [] = Some p \\<Longrightarrow>\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 2. \\<And>a L p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "subgoal for a L p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq var L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p var = 1 \\<or>\n                MPoly_Type.degree p var = 2;\n     find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2", "apply(rule find_luckiest_eq.elims[of var \"a#L\" \"Some p\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq var L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p var = 1 \\<or>\n                MPoly_Type.degree p var = 2;\n     find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n    \\<Longrightarrow> find_luckiest_eq var (a # L) = Some p\n 2. \\<And>v.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = [];\n        Some p = None\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 3. \\<And>v p L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Eq p # L;\n        Some p =\n        (if MPoly_Type.degree p v = 1 \\<or> MPoly_Type.degree p v = 2\n         then let (a, b, c) = get_coeffs v p\n              in case get_if_const a of\n                 None \\<Rightarrow> find_luckiest_eq v L\n                 | Some a \\<Rightarrow>\n                     case get_if_const b of\n                     None \\<Rightarrow> find_luckiest_eq v L\n                     | Some b \\<Rightarrow>\n                         case get_if_const c of\n                         None \\<Rightarrow> find_luckiest_eq v L\n                         | Some c \\<Rightarrow>\n                             if a \\<noteq> 0 \\<or>\n                                b \\<noteq> 0 \\<or> c \\<noteq> 0\n                             then Some p else find_luckiest_eq v L\n         else find_luckiest_eq v L)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 4. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Less va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 5. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Leq va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 6. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p var = 1 \\<or>\n                   MPoly_Type.degree p var = 2;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Neq va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq v L = Some p \\<Longrightarrow>\n                   MPoly_Type.degree p v = Suc 0 \\<or>\n                   MPoly_Type.degree p v = 2;\n        var = v; a = Eq p;\n        Some p =\n        (if MPoly_Type.degree p v = Suc 0 \\<or> MPoly_Type.degree p v = 2\n         then let (a, b, c) = get_coeffs v p\n              in case get_if_const a of\n                 None \\<Rightarrow> find_luckiest_eq v L\n                 | Some a \\<Rightarrow>\n                     case get_if_const b of\n                     None \\<Rightarrow> find_luckiest_eq v L\n                     | Some b \\<Rightarrow>\n                         case get_if_const c of\n                         None \\<Rightarrow> find_luckiest_eq v L\n                         | Some c \\<Rightarrow>\n                             if a \\<noteq> 0 \\<or>\n                                b \\<noteq> 0 \\<or> c \\<noteq> 0\n                             then Some p else find_luckiest_eq v L\n         else find_luckiest_eq v L)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                         MPoly_Type.degree p v = 2", "subgoal for v p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply(cases \"MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or>\n     MPoly_Type.degree p' v = 2\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L);\n     \\<not> (MPoly_Type.degree p' v = Suc 0 \\<or>\n             MPoly_Type.degree p' v = 2)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or>\n     MPoly_Type.degree p' v = 2\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v 2))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     \\<not> Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     \\<not> Set.is_empty\n             (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v 0))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     \\<not> Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "apply(cases \"MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 = 0 \\<longrightarrow>\n        MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 = 0 \\<longrightarrow> MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                MPoly_Type.degree p v = Suc 0 \\<or>\n                MPoly_Type.degree p v = 2;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     \\<not> (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n             0 \\<longrightarrow>\n             MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n             0 \\<longrightarrow>\n             MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq>\n             0)\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p v = Suc 0 \\<or>\n                      MPoly_Type.degree p v = 2", "by simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "have h : \"\\<And>p xa. check_nonzero_const p \\<Longrightarrow> insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "fix p xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "assume h : \"check_nonzero_const p\""], ["proof (state)\nthis:\n  check_nonzero_const p\n\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       check_nonzero_const p \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "show \"insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "apply(cases \"get_if_const p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. get_if_const p = None \\<Longrightarrow>\n    insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\n 2. \\<And>a.\n       get_if_const p = Some a \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "using h get_if_const_insertion"], ["proof (prove)\nusing this:\n  check_nonzero_const p\n  get_if_const ?p = Some ?r \\<Longrightarrow> insertion ?f ?p = ?r\n\ngoal (2 subgoals):\n 1. get_if_const p = None \\<Longrightarrow>\n    insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\n 2. \\<And>a.\n       get_if_const p = Some a \\<Longrightarrow>\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs @ xa # \\<Gamma>)) p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_nonzero_const ?p \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>)) ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "have h3 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 2) \\<noteq> 0 \\<or>\n        insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 1) \\<noteq> 0 \\<or>\n        insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using Some"], ["proof (prove)\nusing this:\n  find_luckiest_eq var L = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "apply(induction L arbitrary:p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       find_luckiest_eq var [] = Some p \\<Longrightarrow>\n       \\<forall>x.\n          insertion (nth_default 0 (xs @ x # \\<Gamma>))\n           (isolate_variable_sparse p var 2) \\<noteq>\n          0 \\<or>\n          insertion (nth_default 0 (xs @ x # \\<Gamma>))\n           (isolate_variable_sparse p var 1) \\<noteq>\n          0 \\<or>\n          insertion (nth_default 0 (xs @ x # \\<Gamma>))\n           (isolate_variable_sparse p var 0) \\<noteq>\n          0\n 2. \\<And>a L p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0", "subgoal for a L p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq var L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p var 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p var 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p var 0) \\<noteq>\n                   0;\n     find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p var 2) \\<noteq>\n                         0 \\<or>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p var 1) \\<noteq>\n                         0 \\<or>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p var 0) \\<noteq>\n                         0", "apply(rule find_luckiest_eq.elims[of var \"a#L\" \"Some p\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq var L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p var 2) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p var 1) \\<noteq>\n                   0 \\<or>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p var 0) \\<noteq>\n                   0;\n     find_luckiest_eq var (a # L) = Some p\\<rbrakk>\n    \\<Longrightarrow> find_luckiest_eq var (a # L) = Some p\n 2. \\<And>v.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = [];\n        Some p = None\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0\n 3. \\<And>v p L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Eq p # L;\n        Some p =\n        (if MPoly_Type.degree p v = 1 \\<or> MPoly_Type.degree p v = 2\n         then let (a, b, c) = get_coeffs v p\n              in case get_if_const a of\n                 None \\<Rightarrow> find_luckiest_eq v L\n                 | Some a \\<Rightarrow>\n                     case get_if_const b of\n                     None \\<Rightarrow> find_luckiest_eq v L\n                     | Some b \\<Rightarrow>\n                         case get_if_const c of\n                         None \\<Rightarrow> find_luckiest_eq v L\n                         | Some c \\<Rightarrow>\n                             if a \\<noteq> 0 \\<or>\n                                b \\<noteq> 0 \\<or> c \\<noteq> 0\n                             then Some p else find_luckiest_eq v L\n         else find_luckiest_eq v L)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0\n 4. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Less va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0\n 5. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Leq va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0\n 6. \\<And>v va L.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq var L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 2) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 1) \\<noteq>\n                      0 \\<or>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p var 0) \\<noteq>\n                      0;\n        find_luckiest_eq var (a # L) = Some p; var = v; a # L = Neq va # L;\n        Some p = find_luckiest_eq v L\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 2) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 1) \\<noteq>\n                            0 \\<or>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p var 0) \\<noteq>\n                            0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v p.\n       \\<lbrakk>\\<And>p.\n                   find_luckiest_eq v L = Some p \\<Longrightarrow>\n                   \\<forall>x.\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p v (Suc 0)) =\n                      0 \\<longrightarrow>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p v 2) =\n                      0 \\<longrightarrow>\n                      insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                       (isolate_variable_sparse p v 0) \\<noteq>\n                      0;\n        var = v; a = Eq p;\n        Some p =\n        (if MPoly_Type.degree p v = Suc 0 \\<or> MPoly_Type.degree p v = 2\n         then let (a, b, c) = get_coeffs v p\n              in case get_if_const a of\n                 None \\<Rightarrow> find_luckiest_eq v L\n                 | Some a \\<Rightarrow>\n                     case get_if_const b of\n                     None \\<Rightarrow> find_luckiest_eq v L\n                     | Some b \\<Rightarrow>\n                         case get_if_const c of\n                         None \\<Rightarrow> find_luckiest_eq v L\n                         | Some c \\<Rightarrow>\n                             if a \\<noteq> 0 \\<or>\n                                b \\<noteq> 0 \\<or> c \\<noteq> 0\n                             then Some p else find_luckiest_eq v L\n         else find_luckiest_eq v L)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p v (Suc 0)) =\n                            0 \\<longrightarrow>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p v 2) =\n                            0 \\<longrightarrow>\n                            insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                             (isolate_variable_sparse p v 0) \\<noteq>\n                            0", "subgoal for v p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply(cases \"MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or>\n     MPoly_Type.degree p' v = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2\n      then let (a, b, c) = get_coeffs v p'\n           in case get_if_const a of None \\<Rightarrow> find_luckiest_eq v L\n              | Some a \\<Rightarrow>\n                  case get_if_const b of\n                  None \\<Rightarrow> find_luckiest_eq v L\n                  | Some b \\<Rightarrow>\n                      case get_if_const c of\n                      None \\<Rightarrow> find_luckiest_eq v L\n                      | Some c \\<Rightarrow>\n                          if a \\<noteq> 0 \\<or>\n                             b \\<noteq> 0 \\<or> c \\<noteq> 0\n                          then Some p' else find_luckiest_eq v L\n      else find_luckiest_eq v L);\n     \\<not> (MPoly_Type.degree p' v = Suc 0 \\<or>\n             MPoly_Type.degree p' v = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or>\n     MPoly_Type.degree p' v = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v 2))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 2))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some a \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v (Suc 0)) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some b \\<Rightarrow>\n              case get_if_const (isolate_variable_sparse p' v 0) of\n              None \\<Rightarrow> find_luckiest_eq v L\n              | Some c \\<Rightarrow>\n                  if a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n                  then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     \\<not> Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\n           then Some\n                 (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some b \\<Rightarrow>\n          case get_if_const (isolate_variable_sparse p' v 0) of\n          None \\<Rightarrow> find_luckiest_eq v L\n          | Some c \\<Rightarrow>\n              if MPoly_Type.coeff (isolate_variable_sparse p' v 2)\n                  0 \\<noteq>\n                 0 \\<or>\n                 b \\<noteq> 0 \\<or> c \\<noteq> 0\n              then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     \\<not> Set.is_empty\n             (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply(cases \"Set.is_empty (vars (isolate_variable_sparse p' v 0))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (case if Set.is_empty (vars (isolate_variable_sparse p' v 0))\n           then Some (MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0)\n           else None of\n      None \\<Rightarrow> find_luckiest_eq v L\n      | Some c \\<Rightarrow>\n          if MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n             0 \\<or>\n             MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0))\n              0 \\<noteq>\n             0 \\<or>\n             c \\<noteq> 0\n          then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     \\<not> Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply(cases \"MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 = 0 \\<longrightarrow>\n        MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 = 0 \\<longrightarrow> MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0\n 2. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p';\n     Some p =\n     (if MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n         0 \\<longrightarrow>\n         MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\n      then Some p' else find_luckiest_eq v L);\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     \\<not> (MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n             0 \\<longrightarrow>\n             MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n             0 \\<longrightarrow>\n             MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq>\n             0)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p v 0) \\<noteq>\n                         0", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p'; p = p';\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v 0) \\<noteq>\n                         0", "using h[of \"isolate_variable_sparse p' v 0\"] h[of \"isolate_variable_sparse p' v (Suc 0)\"] h[of \"isolate_variable_sparse p' v 2\"]"], ["proof (prove)\nusing this:\n  check_nonzero_const (isolate_variable_sparse p' v 0) \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>))\n   (isolate_variable_sparse p' v 0) \\<noteq>\n  0\n  check_nonzero_const\n   (isolate_variable_sparse p' v (Suc 0)) \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>))\n   (isolate_variable_sparse p' v (Suc 0)) \\<noteq>\n  0\n  check_nonzero_const (isolate_variable_sparse p' v 2) \\<Longrightarrow>\n  insertion (nth_default 0 (xs @ ?xa # \\<Gamma>))\n   (isolate_variable_sparse p' v 2) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p'; p = p';\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v 0) \\<noteq>\n                         0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                find_luckiest_eq v L = Some p \\<Longrightarrow>\n                \\<forall>x.\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v (Suc 0)) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 2) =\n                   0 \\<longrightarrow>\n                   insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                    (isolate_variable_sparse p v 0) \\<noteq>\n                   0;\n     var = v; a = Eq p'; p = p';\n     MPoly_Type.degree p' v = Suc 0 \\<or> MPoly_Type.degree p' v = 2;\n     Set.is_empty (vars (isolate_variable_sparse p' v 2));\n     Set.is_empty (vars (isolate_variable_sparse p' v (Suc 0)));\n     Set.is_empty (vars (isolate_variable_sparse p' v 0));\n     MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 =\n     0 \\<longrightarrow>\n     MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq> 0;\n     \\<And>xa.\n        MPoly_Type.coeff (isolate_variable_sparse p' v 0) 0 \\<noteq>\n        0 \\<Longrightarrow>\n        insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n         (isolate_variable_sparse p' v 0) \\<noteq>\n        0;\n     \\<And>xa.\n        MPoly_Type.coeff (isolate_variable_sparse p' v (Suc 0)) 0 \\<noteq>\n        0 \\<Longrightarrow>\n        insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n         (isolate_variable_sparse p' v (Suc 0)) \\<noteq>\n        0;\n     \\<And>xa.\n        MPoly_Type.coeff (isolate_variable_sparse p' v 2) 0 \\<noteq>\n        0 \\<Longrightarrow>\n        insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n         (isolate_variable_sparse p' v 2) \\<noteq>\n        0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v (Suc 0)) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v 2) =\n                         0 \\<longrightarrow>\n                         insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                          (isolate_variable_sparse p' v 0) \\<noteq>\n                         0", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x.\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_luckiest_eq var L = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "apply(simp_all add:Some del:elimVar.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))", "apply(rule elimVar_eq_2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. length xs = var\n 2. Eq p \\<in> set L\n 3. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 4. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using assms"], ["proof (prove)\nusing this:\n  length xs = var\n\ngoal (4 subgoals):\n 1. length xs = var\n 2. Eq p \\<in> set L\n 3. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 4. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. Eq p \\<in> set L\n 2. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 3. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using h1 h2 h3"], ["proof (prove)\nusing this:\n  Eq p \\<in> set L\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  \\<forall>x.\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 0) \\<noteq>\n     0\n\ngoal (3 subgoals):\n 1. Eq p \\<in> set L\n 2. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 3. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}