{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Refinement/Examples/Eg1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Refinement", "problem_names": ["lemma \\<C>_simp[simp]:\n  \"\\<C> = {control_var}\"", "lemma type_aexpr_Load:\n  \"v \\<notin> dom \\<Gamma> \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)\"", "lemma type_aexpr_Load':\n  \"v \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> v)) \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t\"", "lemma type_aexpr_Const:\n  \"type_aexpr \\<Gamma> (Const c) {}\"", "lemma [simp]: \"pred_entailment P {}\"", "lemma [simp]: \"e \\<in> P \\<Longrightarrow> pred_entailment P {e}\"", "lemma [simp]: \"FF \\<in> P \\<Longrightarrow> pred_entailment P Q\"", "lemma read_buffer_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\"", "lemma read_buffer_typed_auto:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\"", "lemma read_buffer_com_sifum_secure:\n  \"com_sifum_secure (read_buffer,(\\<lambda>m. {}))\""], "translations": [["", "lemma \\<C>_simp[simp]:\n  \"\\<C> = {control_var}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> = {control_var}", "by(auto simp: \\<C>_def \\<C>_vars_def split: if_splits)"], ["", "lemma type_aexpr_Load:\n  \"v \\<notin> dom \\<Gamma> \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> dom \\<Gamma> \\<Longrightarrow>\n    type_aexpr \\<Gamma> (Load v) (dma_type v)", "apply(insert type_aexpr[of \\<Gamma> \"Load v\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> dom \\<Gamma>;\n     type_aexpr \\<Gamma> (Load v) (to_total \\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Load':\n  \"v \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> v)) \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom \\<Gamma>; t = the (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t", "apply(insert type_aexpr[of \\<Gamma> \"Load v\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom \\<Gamma>; t = the (\\<Gamma> v);\n     type_aexpr \\<Gamma> (Load v) (to_total \\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Const:\n  \"type_aexpr \\<Gamma> (Const c) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_aexpr \\<Gamma> (Const c) {}", "apply(insert type_aexpr[of \\<Gamma> \"Const c\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. type_aexpr \\<Gamma> (Const c) {} \\<Longrightarrow>\n    type_aexpr \\<Gamma> (Const c) {}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare restrict_preds_to_vars_def [simp]"], ["", "declare add_pred_def [simp]"], ["", "declare stable_def [simp]"], ["", "declare to_total_def [simp]"], ["", "declare \\<C>_vars_def [simp]"], ["", "declare anno_type_stable_def [simp]"], ["", "declare anno_type_sec_def [simp]"], ["", "lemma [simp]: \"pred_entailment P {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_entailment P {}", "by(simp add: pred_entailment_def pred_def)"], ["", "lemma [simp]: \"e \\<in> P \\<Longrightarrow> pred_entailment P {e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> P \\<Longrightarrow> pred_entailment P {e}", "by(blast intro: subset_entailment)"], ["", "lemma [simp]: \"FF \\<in> P \\<Longrightarrow> pred_entailment P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<in> P \\<Longrightarrow> pred_entailment P Q", "by(auto simp: pred_entailment_def pred_def)"], ["", "lemma read_buffer_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>'\n                          \\<S>' P'", "apply(intro exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type \\<Gamma> \\<S> P read_buffer ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply(simp add: read_buffer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       ((Skip@[control_var +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       (Skip@[control_var +=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({}, {})\n                         (control_var +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({}, {})\n                         (control_var +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({}, {})\n                                (control_var +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {} Skip\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       (Skip@[temp +=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       ((temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_var}, {})\n                         (temp +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable ({control_var}, {})\n                         (temp +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_var}, {})\n                                (temp +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       ((temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} Skip ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       ((temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp) ;;\n                           (temp \\<leftarrow> Const 0) ;;\n                           Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp) ;;\n                           (temp \\<leftarrow> Const 0) ;;\n                           Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp) ;;\n                           (temp \\<leftarrow> Const 0) ;;\n                           Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp) ;;\n                           (temp \\<leftarrow> Const 0) ;;\n                           Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp) ;;\n                           (temp \\<leftarrow> Const 0) ;;\n                           Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (temp \\<leftarrow> Load buffer) ?\\<Gamma>'37\n                       ?\\<S>'37 ?P'37\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load buffer) ?t40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t40\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t40\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}, temp \\<mapsto> ?t40]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load buffer) ?t40\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t40\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}, temp \\<mapsto> ?t40]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> buffer \\<notin> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) (dma_type buffer)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type buffer)\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) (dma_type buffer)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type buffer)\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type buffer)\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Load buffer).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp) ;;\n                        (temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Load buffer).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>'51 ?\\<S>'51 ?P'51\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'51 ?\\<S>'51 ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule if_type')"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Eq control_var 0) ?t54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {e \\<in> assign_post {} temp (Load buffer).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       ?t54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P'54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'51 ?\\<S>'51 ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t54 =\n                      \\<Union>\n                       (to_total [temp \\<mapsto> {Eq control_var 0}] `\n                        bexp_vars (Eq control_var 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {e \\<in> assign_post {} temp (Load buffer).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       ?t54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P'54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'51 ?\\<S>'51 ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {e \\<in> assign_post {} temp (Load buffer).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P'54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P''54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'51 ?\\<S>'51 ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P'54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>'51\n                       ?\\<S>'51 ?P''54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'51 ?\\<S>'51 ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>1)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var\n                      \\<notin> dom [temp \\<mapsto> {Eq control_var 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var \\<notin> \\<C>\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t66\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t66\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var \\<notin> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t66\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t66\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t66\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t66\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {Eq control_var 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t66 = the ([temp \\<mapsto> {Eq control_var 0}] temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t66\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t66 = the ([temp \\<mapsto> {Eq control_var 0}] temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t66\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype {Eq control_var 0}\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subtype_def pred_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 \\<subseteq> ?P'54 \\<inter> ?P''54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp})\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P''54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var\n                      \\<notin> dom [temp \\<mapsto> {Eq control_var 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var \\<notin> \\<C>\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t77\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t77\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var \\<notin> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t77\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t77\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t77\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t77\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {Eq control_var 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t77 = the ([temp \\<mapsto> {Eq control_var 0}] temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t77\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t77 = the ([temp \\<mapsto> {Eq control_var 0}] temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t77\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype {Eq control_var 0}\n                       (add_pred\n                         {e \\<in> assign_post {} temp (Load buffer).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subtype_def pred_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''54 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           {e \\<in> assign_post {} temp (Load buffer).\n                            bexp_vars e\n                            \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<inter>\n                                  {e \\<in> assign_post\n      (insert (Neq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      high_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Eq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      low_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}} \\<and>\n                      ?P'51\n                      \\<subseteq> {e \\<in> assign_post\n      (insert (Neq control_var 0)\n        {e \\<in> assign_post {} temp (Load buffer).\n         bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}})\n      high_var (Load temp).\n                                   bexp_vars e\n                                   \\<subseteq> {v.\n          v = temp \\<or> v = control_var}}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) ?P'51\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) {}\n                       ((temp \\<leftarrow> Const 0) ;;\n                        Skip@[temp -=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {Eq control_var 0}]\n                       ({control_var}, {temp}) {}\n                       (temp \\<leftarrow> Const 0) ?\\<Gamma>'109 ?\\<S>'109\n                       ?P'109\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'109 ?\\<S>'109 ?P'109\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {Eq control_var 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Const 0) ?t112\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t112\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t112\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {Eq control_var 0}, temp \\<mapsto>\n                        ?t112]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Const 0) ?t112\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t112\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t112\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {Eq control_var 0}, temp \\<mapsto>\n                        ?t112]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Const)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype {}\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {Eq control_var 0}, temp \\<mapsto>\n                        {}]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype {}\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {Eq control_var 0}, temp \\<mapsto>\n                        {}]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {Eq control_var 0}, temp \\<mapsto>\n                        {}]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Const 0))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (Skip@[temp -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno [temp \\<mapsto> {}] ({control_var}, {temp})\n                         (temp -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable ({control_var}, {temp})\n                         (temp -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         {e \\<in> assign_post {} temp (Const 0).\n                          bexp_vars e\n                          \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                         {v. stable\n                              (add_anno_stable ({control_var}, {temp})\n                                (temp -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>' ?\\<S>'1 ?P'2\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [temp \\<mapsto> {}] x)\n                          (restrict_preds_to_vars\n                            {e \\<in> assign_post {} temp (Const 0).\n                             bexp_vars e\n                             \\<subseteq> {v.\n    v = temp \\<or> v = control_var}}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {temp})\n                                   (temp -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [temp \\<mapsto> {}]\n                              ({control_var}, {temp})\n                              (temp -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or>\n  v = control_var} \\<and>\n                        bexp_vars e \\<subseteq> {control_var}}\n                       Skip ?\\<Gamma>' ?\\<S>'1 ?P'2\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [temp \\<mapsto> {}] x)\n                          (restrict_preds_to_vars\n                            {e \\<in> assign_post {} temp (Const 0).\n                             bexp_vars e\n                             \\<subseteq> {v.\n    v = temp \\<or> v = control_var}}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {temp})\n                                   (temp -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [temp \\<mapsto> {}]\n                              ({control_var}, {temp})\n                              (temp -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)", "apply(rule skip_type)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [temp \\<mapsto> {}] x)\n                          (restrict_preds_to_vars\n                            {e \\<in> assign_post {} temp (Const 0).\n                             bexp_vars e\n                             \\<subseteq> {v.\n    v = temp \\<or> v = control_var}}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {temp})\n                                   (temp -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [temp \\<mapsto> {}]\n                              ({control_var}, {temp})\n                              (temp -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [temp \\<mapsto> {}] x)\n                          (restrict_preds_to_vars\n                            {e \\<in> assign_post {} temp (Const 0).\n                             bexp_vars e\n                             \\<subseteq> {v.\n    v = temp \\<or> v = control_var}}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {temp})\n                                   (temp -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [temp \\<mapsto> {}]\n                              ({control_var}, {temp})\n                              (temp -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)", "apply(clarsimp simp: add_anno_def subtype_def pred_def bot_Sec_def[symmetric] pred_entailment_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [temp \\<mapsto> {}]\n                       ({control_var}, {temp})\n                       {e \\<in> assign_post {} temp (Const 0).\n                        bexp_vars e\n                        \\<subseteq> {v. v = temp \\<or> v = control_var}}\n                       (temp -=\\<^sub>m AsmNoReadOrWrite)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma read_buffer_typed_auto:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>'\n                          \\<S>' P'", "by (has_type_tac \n            prog: read_buffer_def \n            aexpr: type_aexpr_Load type_aexpr_Load' type_aexpr_Const\n            bexpr: type_bexprI)"], ["", "lemma read_buffer_com_sifum_secure:\n  \"com_sifum_secure (read_buffer,(\\<lambda>m. {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. com_sifum_secure (read_buffer, \\<lambda>m. {})", "apply(insert read_buffer_typed[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>' \\<S>' P'.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' \\<S>'\n        P' \\<Longrightarrow>\n    com_sifum_secure (read_buffer, \\<lambda>m. {})", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       com_sifum_secure (read_buffer, \\<lambda>m. {})", "apply(rule typed_secure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       has_type (\\<Gamma>_of_mds (\\<lambda>m. {}))\n        (\\<S>_of_mds (\\<lambda>m. {})) {} read_buffer\n        (?\\<Gamma>'8 \\<Gamma>' a b x) (?\\<S>'8 \\<Gamma>' a b x)\n        (?P'8 \\<Gamma>' a b x)\n 2. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       mds_yields_stable_types (\\<lambda>m. {})", "apply(fastforce simp: \\<Gamma>_of_mds_def \\<S>_of_mds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       mds_yields_stable_types (\\<lambda>m. {})", "apply(auto simp: mds_yields_stable_types_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Toby: removed manual bisimulation proof since we now use the type system\n   and the manual proofs take quite a while to process. See git log to recover them. *)"], ["", "end"], ["", "end"]]}