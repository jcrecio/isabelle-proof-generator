{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Refinement/Examples/Eg1RefinementTrivial.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Refinement", "problem_names": ["lemma Id_secure_refinement:\n  \"secure_refinement R Id P_true\"", "lemma \"strong_low_bisim_mm (gen_refine.R\\<^sub>C_of (\\<R> \\<Gamma> \\<S> P) Id P_true)\""], "translations": [["", "lemma Id_secure_refinement:\n  \"secure_refinement R Id P_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure_refinement R Id P_true", "unfolding secure_refinement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_others Id \\<and>\n    preserves_modes_mem Id \\<and>\n    abs.closed_glob_consistent P_true \\<and>\n    (\\<forall>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C.\n        (\\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n         \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C)\n        \\<in> Id \\<longrightarrow>\n        (\\<forall>c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n            gen_refine.eval_abv\\<^sub>C\n             \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n             \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<longrightarrow>\n            (\\<exists>n c\\<^sub>1\\<^sub>A'.\n                abs.neval\n                 \\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n                 n \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n                (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                 \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n                \\<in> Id \\<and>\n                (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n                    c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n                    (\\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n                     \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n                    \\<in> R \\<and>\n                    (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n                     \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n                    \\<in> Id \\<and>\n                    (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n                     \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n                    \\<in> P_true \\<and>\n                    abs.neval\n                     \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                     n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n                    (\\<exists>c\\<^sub>2\\<^sub>C'.\n                        gen_refine.eval_abv\\<^sub>C\n                         \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                         \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                        (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                         \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                        \\<in> Id \\<and>\n                        (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                         \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                        \\<in> P_true)))))", "proof(safe)"], ["proof (state)\ngoal (4 subgoals):\n 1. closed_others Id\n 2. preserves_modes_mem Id\n 3. abs.closed_glob_consistent P_true\n 4. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "show \"closed_others Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_others Id", "unfolding closed_others_def Id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>A mds mem c\\<^sub>C mem'.\n       (\\<langle>c\\<^sub>A, mds, mem\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>C, mds, mem\\<rangle>\\<^sub>C)\n       \\<in> {p. \\<exists>x. p = (x, x)} \\<longrightarrow>\n       (\\<forall>x.\n           mem x \\<noteq> mem' x \\<longrightarrow>\n           \\<not> var_asm_not_written mds x) \\<longrightarrow>\n       (\\<forall>x.\n           dma mem x \\<noteq> dma mem' x \\<longrightarrow>\n           \\<not> var_asm_not_written mds x) \\<longrightarrow>\n       (\\<langle>c\\<^sub>A, mds, mem'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>C, mds, mem'\\<rangle>\\<^sub>C)\n       \\<in> {p. \\<exists>x. p = (x, x)}", "by blast"], ["proof (state)\nthis:\n  closed_others Id\n\ngoal (3 subgoals):\n 1. preserves_modes_mem Id\n 2. abs.closed_glob_consistent P_true\n 3. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. preserves_modes_mem Id\n 2. abs.closed_glob_consistent P_true\n 3. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "show \"preserves_modes_mem Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserves_modes_mem Id", "unfolding preserves_modes_mem_def Id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>A mds\\<^sub>A mem\\<^sub>A c\\<^sub>C mds\\<^sub>C\n       mem\\<^sub>C.\n       (\\<langle>c\\<^sub>A, mds\\<^sub>A, mem\\<^sub>A\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>C, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C)\n       \\<in> {p. \\<exists>x. p = (x, x)} \\<longrightarrow>\n       mem\\<^sub>A = mem\\<^sub>C \\<and> mds\\<^sub>A = mds\\<^sub>C", "by blast"], ["proof (state)\nthis:\n  preserves_modes_mem Id\n\ngoal (2 subgoals):\n 1. abs.closed_glob_consistent P_true\n 2. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. abs.closed_glob_consistent P_true\n 2. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "fix c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'"], ["proof (state)\ngoal (2 subgoals):\n 1. abs.closed_glob_consistent P_true\n 2. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "assume step: \"(\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C) \\<in> eval\\<^sub>w\""], ["proof (state)\nthis:\n  gen_refine.eval_abv\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n\ngoal (2 subgoals):\n 1. abs.closed_glob_consistent P_true\n 2. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1 c\\<^sub>1\\<^sub>C\n       c\\<^sub>1\\<^sub>C' mds' mem\\<^sub>1'.\n       gen_refine.eval_abv\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<Longrightarrow>\n       \\<exists>n c\\<^sub>1\\<^sub>A'.\n          abs.neval\n           \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n           \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n           \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n          \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n              c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n               \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n              \\<in> P_true \\<and>\n              abs.neval\n               \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n               n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  gen_refine.eval_abv\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                   \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> P_true))", "show\n      \"\\<exists>n c\\<^sub>1\\<^sub>A'.\n          neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n          (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C) \\<in> Id \\<and>\n          (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C) \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C) \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C) \\<in> P_true \\<and>\n              neval \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  (\\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> eval\\<^sub>w \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C) \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C) \\<in> P_true))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "let ?n = \"Suc 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "let ?c\\<^sub>1\\<^sub>A' = c\\<^sub>1\\<^sub>C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "from step"], ["proof (chain)\npicking this:\n  gen_refine.eval_abv\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C", "have \"neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C ?n \\<langle>?c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\""], ["proof (prove)\nusing this:\n  gen_refine.eval_abv\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n     (Suc 0)\n     \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C", "by simp"], ["proof (state)\nthis:\n  abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   (Suc 0) \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "moreover"], ["proof (state)\nthis:\n  abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   (Suc 0) \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "have \"(\\<langle>?c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n     \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n    \\<in> Id", "by simp"], ["proof (state)\nthis:\n  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n  \\<in> Id\n\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "moreover"], ["proof (state)\nthis:\n  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n  \\<in> Id\n\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "have \"(\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C) \\<in> R \\<and>\n              (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C) \\<in> Id \\<and>\n              (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C) \\<in> P_true \\<and>\n              neval \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C ?n \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n              (\\<exists>c\\<^sub>2\\<^sub>C'.\n                  (\\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n                  \\<in> eval\\<^sub>w \\<and>\n                  (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C) \\<in> Id \\<and>\n                  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C, \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C) \\<in> P_true))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n       c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n       (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> R \\<and>\n       (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> P_true \\<and>\n       abs.neval\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n        (Suc 0)\n        \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n       (\\<exists>c\\<^sub>2\\<^sub>C'.\n           gen_refine.eval_abv\\<^sub>C\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n           \\<in> P_true)", "using step"], ["proof (prove)\nusing this:\n  gen_refine.eval_abv\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n       c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n       (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> R \\<and>\n       (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> P_true \\<and>\n       abs.neval\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n        (Suc 0)\n        \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n       (\\<exists>c\\<^sub>2\\<^sub>C'.\n           gen_refine.eval_abv\\<^sub>C\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n           \\<in> P_true)", "unfolding P_true_def"], ["proof (prove)\nusing this:\n  gen_refine.eval_abv\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n       c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n       (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> R \\<and>\n       (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n       \\<in> UNIV \\<and>\n       abs.neval\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n        (Suc 0)\n        \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n       (\\<exists>c\\<^sub>2\\<^sub>C'.\n           gen_refine.eval_abv\\<^sub>C\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n           \\<in> UNIV)", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n     c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n     (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> R \\<and>\n     (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> Id \\<and>\n     (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> P_true \\<and>\n     abs.neval \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n      (Suc 0)\n      \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n     (\\<exists>c\\<^sub>2\\<^sub>C'.\n         gen_refine.eval_abv\\<^sub>C\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n         (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n         \\<in> Id \\<and>\n         (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n         \\<in> P_true)\n\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "ultimately"], ["proof (chain)\npicking this:\n  abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   (Suc 0) \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n  \\<in> Id\n  \\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n     c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n     (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> R \\<and>\n     (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> Id \\<and>\n     (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> P_true \\<and>\n     abs.neval \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n      (Suc 0)\n      \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n     (\\<exists>c\\<^sub>2\\<^sub>C'.\n         gen_refine.eval_abv\\<^sub>C\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n         (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n         \\<in> Id \\<and>\n         (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n         \\<in> P_true)", "show ?thesis"], ["proof (prove)\nusing this:\n  abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n   (Suc 0) \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C\n  (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n   \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n  \\<in> Id\n  \\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n     c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n     (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> R \\<and>\n     (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> Id \\<and>\n     (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n     \\<in> P_true \\<and>\n     abs.neval \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n      (Suc 0)\n      \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n     (\\<exists>c\\<^sub>2\\<^sub>C'.\n         gen_refine.eval_abv\\<^sub>C\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n         (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n         \\<in> Id \\<and>\n         (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n         \\<in> P_true)\n\ngoal (1 subgoal):\n 1. \\<exists>n c\\<^sub>1\\<^sub>A'.\n       abs.neval\n        \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C n\n        \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n       (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n        \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n       \\<in> Id \\<and>\n       (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n           c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> R \\<and>\n           (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> Id \\<and>\n           (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n            \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n           \\<in> P_true \\<and>\n           abs.neval\n            \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n            \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n           (\\<exists>c\\<^sub>2\\<^sub>C'.\n               gen_refine.eval_abv\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n               (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> Id \\<and>\n               (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n                \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n               \\<in> P_true))", "by blast"], ["proof (state)\nthis:\n  \\<exists>n c\\<^sub>1\\<^sub>A'.\n     abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n      n \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n     (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n     \\<in> Id \\<and>\n     (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n         c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n         (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n         \\<in> R \\<and>\n         (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n         \\<in> Id \\<and>\n         (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n         \\<in> P_true \\<and>\n         abs.neval\n          \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n          \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n         (\\<exists>c\\<^sub>2\\<^sub>C'.\n             gen_refine.eval_abv\\<^sub>C\n              \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n              \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n             (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n              \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n             \\<in> Id \\<and>\n             (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n              \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n             \\<in> P_true))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n c\\<^sub>1\\<^sub>A'.\n     abs.neval \\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C\n      n \\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C \\<and>\n     (\\<langle>c\\<^sub>1\\<^sub>A', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n      \\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C)\n     \\<in> Id \\<and>\n     (\\<forall>c\\<^sub>2\\<^sub>A mem\\<^sub>2 c\\<^sub>2\\<^sub>C\n         c\\<^sub>2\\<^sub>A' mem\\<^sub>2'.\n         (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n         \\<in> R \\<and>\n         (\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n         \\<in> Id \\<and>\n         (\\<langle>c\\<^sub>1\\<^sub>C, mds, mem\\<^sub>1\\<rangle>\\<^sub>C,\n          \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C)\n         \\<in> P_true \\<and>\n         abs.neval\n          \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<rangle>\\<^sub>C n\n          \\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<longrightarrow>\n         (\\<exists>c\\<^sub>2\\<^sub>C'.\n             gen_refine.eval_abv\\<^sub>C\n              \\<langle>c\\<^sub>2\\<^sub>C, mds, mem\\<^sub>2\\<rangle>\\<^sub>C\n              \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C \\<and>\n             (\\<langle>c\\<^sub>2\\<^sub>A', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C,\n              \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n             \\<in> Id \\<and>\n             (\\<langle>c\\<^sub>1\\<^sub>C', mds', mem\\<^sub>1'\\<rangle>\\<^sub>C,\n              \\<langle>c\\<^sub>2\\<^sub>C', mds', mem\\<^sub>2'\\<rangle>\\<^sub>C)\n             \\<in> P_true))\n\ngoal (1 subgoal):\n 1. abs.closed_glob_consistent P_true", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. abs.closed_glob_consistent P_true", "show \"closed_glob_consistent P_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs.closed_glob_consistent P_true", "by(auto simp: closed_glob_consistent_def P_true_def)"], ["proof (state)\nthis:\n  abs.closed_glob_consistent P_true\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This doesn't really mean much, but shows the lemmas in action.\n  (I suspect that @{term \"R\\<^sub>C_of R Id\"} is equivalent to @{term R}. But who cares?)\n\\<close>"], ["", "lemma \"strong_low_bisim_mm (gen_refine.R\\<^sub>C_of (\\<R> \\<Gamma> \\<S> P) Id P_true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs.strong_low_bisim_mm\n     (gen_refine.R\\<^sub>C_of (\\<R> \\<Gamma> \\<S> P) Id P_true)", "apply(rule R\\<^sub>C_of_strong_low_bisim_mm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. abs.strong_low_bisim_mm (\\<R> \\<Gamma> \\<S> P)\n 2. secure_refinement (\\<R> \\<Gamma> \\<S> P) Id P_true\n 3. sym P_true", "apply(rule \\<R>_bisim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. secure_refinement (\\<R> \\<Gamma> \\<S> P) Id P_true\n 2. sym P_true", "apply(rule Id_secure_refinement)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym P_true", "unfolding P_true_def sym_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (x, y) \\<in> UNIV \\<longrightarrow> (y, x) \\<in> UNIV", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}