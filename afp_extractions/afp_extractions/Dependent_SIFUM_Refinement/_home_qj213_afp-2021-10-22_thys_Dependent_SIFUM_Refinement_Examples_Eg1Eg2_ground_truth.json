{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Refinement/Examples/Eg1Eg2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Refinement", "problem_names": ["lemma bisim_simple_\\<R>:\n  \"bisim_simple (A.\\<R> \\<Gamma> \\<S> P)\"", "lemma conc_only_vars_not_visible_abs:\n  \"(\\<forall>v\\<^sub>C. v\\<^sub>C \\<in> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow> mem\\<^sub>C v\\<^sub>C = mem\\<^sub>C' v\\<^sub>C) \\<Longrightarrow> mem\\<^sub>A_of mem\\<^sub>C = mem\\<^sub>A_of mem\\<^sub>C'\"", "lemma conc_only_var_assign_not_visible_abs:\n  \"\\<forall>v\\<^sub>C e. v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow> mem\\<^sub>A_of mem\\<^sub>C = mem\\<^sub>A_of (mem\\<^sub>C(v\\<^sub>C := e))\"", "lemma reg\\<^sub>C_is_not_the_var\\<^sub>C_of_anything:\n  \"reg\\<^sub>C = Eg2_var\\<^sub>C_of_Eg1 x \\<Longrightarrow> False\"", "lemma reg\\<^sub>C_not_visible_abs:\n  \"reg\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1\"", "lemma reg\\<^sub>C_the_only_concrete_only_var:\n  \"v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\"", "lemma NoRW\\<^sub>A_implies_NoRW\\<^sub>C:\n  \"x \\<in> mds\\<^sub>A_of mds\\<^sub>C AsmNoReadOrWrite \\<Longrightarrow>\n   Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoReadOrWrite\"", "lemma NoWrite\\<^sub>A_implies_NoWrite\\<^sub>C:\n  \"x \\<in> mds\\<^sub>A_of mds\\<^sub>C AsmNoWrite \\<Longrightarrow>\n   Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoWrite\"", "lemma assign_eval\\<^sub>w_load\\<^sub>A:\n  shows \"(\\<langle>x \\<leftarrow> Eg1.Load y, mds, mem\\<rangle>\\<^sub>A, \\<langle>Stop, mds, mem (x := mem y)\\<rangle>\\<^sub>A) \\<in> A.eval\\<^sub>w\"", "lemma assign_eval\\<^sub>w_load\\<^sub>C:\n  shows \"(\\<langle>x \\<leftarrow> Load y, mds, mem\\<rangle>\\<^sub>C, \\<langle>Stop, mds, mem (x := mem y)\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\"", "lemma assign_eval\\<^sub>w_const\\<^sub>A:\n  shows \"(\\<langle>x \\<leftarrow> Eg1.Const c, mds, mem\\<rangle>, \\<langle>Stop, mds, mem (x := c)\\<rangle>) \\<in> A.eval\\<^sub>w\"", "lemma assign_eval\\<^sub>w_const\\<^sub>C:\n  shows \"(\\<langle>x \\<leftarrow> Const c, mds, mem\\<rangle>, \\<langle>Stop, mds, mem (x := c)\\<rangle>) \\<in> C.eval\\<^sub>w\"", "lemma if_seq_eval\\<^sub>w_helper\\<^sub>A:\n  \"(\\<langle>If B T E, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B mem B then T else E, mds, mem\\<rangle>\\<^sub>A) \\<in> A.eval\\<^sub>w\n    \\<Longrightarrow>\n   (\\<langle>If B T E ;; TAIL, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B mem B then T ;; TAIL else E ;; TAIL, mds, mem\\<rangle>\\<^sub>A) \\<in> A.eval\\<^sub>w\"", "lemma if_seq_eval\\<^sub>w_helper\\<^sub>C:\n  \"(\\<langle>If B T E, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T else E, mds, mem\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\n    \\<Longrightarrow>\n   (\\<langle>If B T E ;; TAIL, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T ;; TAIL else E ;; TAIL, mds, mem\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\"", "lemma mem_assign_refinement_helper_var:\n  \"mem\\<^sub>A_of (mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x := mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y)))\n       = (mem\\<^sub>A_of mem\\<^sub>C) (x := (mem\\<^sub>A_of mem\\<^sub>C) y)\"", "lemma mem_assign_refinement_helper_const:\n  \"mem\\<^sub>A_of (mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x := c))\n       = (mem\\<^sub>A_of mem\\<^sub>C) (x := c)\"", "lemma if_true_eval\\<^sub>w\\<^sub>C:\n  shows \"mem\\<^sub>C x = 0 \\<longrightarrow>\n     (\\<langle>(If (Eq x 0) c\\<^sub>C_then c\\<^sub>C_else) ;; c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C,\n      \\<langle>(c\\<^sub>C_then ;; c\\<^sub>C_tail), mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\"", "lemma if_false_eval\\<^sub>w\\<^sub>C:\n  shows \"mem\\<^sub>C x \\<noteq> 0 \\<longrightarrow>\n     (\\<langle>(If (Eq x 0) c\\<^sub>C_then c\\<^sub>C_else) ;; c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C,\n      \\<langle>(c\\<^sub>C_else ;; c\\<^sub>C_tail), mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\""], "translations": [["", "lemma bisim_simple_\\<R>:\n  \"bisim_simple (A.\\<R> \\<Gamma> \\<S> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim_simple (A.\\<R> \\<Gamma> \\<S> P)", "unfolding bisim_simple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1\\<^sub>A c\\<^sub>2\\<^sub>A\n       mem\\<^sub>2\\<^sub>A.\n       A.\\<R>_abv\n        \\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<^sub>A\\<rangle>\\<^sub>A\n        \\<Gamma> \\<S> P\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<^sub>A\\<rangle>\\<^sub>A \\<longrightarrow>\n       c\\<^sub>1\\<^sub>A = c\\<^sub>2\\<^sub>A", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1\\<^sub>A c\\<^sub>2\\<^sub>A\n       mem\\<^sub>2\\<^sub>A.\n       A.\\<R>_abv\n        \\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<^sub>A\\<rangle>\\<^sub>A\n        \\<Gamma> \\<S> P\n        \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<^sub>A\\<rangle>\\<^sub>A \\<Longrightarrow>\n       c\\<^sub>1\\<^sub>A = c\\<^sub>2\\<^sub>A", "apply(drule_tac lc=\"\\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<^sub>A\\<rangle>\\<^sub>A\" and lc'=\"\\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<^sub>A\\<rangle>\\<^sub>A\" in A.bisim_simple_\\<R>\\<^sub>u)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1\\<^sub>A mds mem\\<^sub>1\\<^sub>A c\\<^sub>2\\<^sub>A\n       mem\\<^sub>2\\<^sub>A.\n       fst (fst \\<langle>c\\<^sub>1\\<^sub>A, mds, mem\\<^sub>1\\<^sub>A\\<rangle>\\<^sub>A) =\n       fst (fst \\<langle>c\\<^sub>2\\<^sub>A, mds, mem\\<^sub>2\\<^sub>A\\<rangle>\\<^sub>A) \\<Longrightarrow>\n       c\\<^sub>1\\<^sub>A = c\\<^sub>2\\<^sub>A", "by simp"], ["", "(* Don't know to what extent these helpers can be made generic enough to go into any parent theories.\n   Again, mightn't be able to (or bother to) make some generic considering the aexp evaluator\n   is going to be specific to each language. *)"], ["", "lemma conc_only_vars_not_visible_abs:\n  \"(\\<forall>v\\<^sub>C. v\\<^sub>C \\<in> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow> mem\\<^sub>C v\\<^sub>C = mem\\<^sub>C' v\\<^sub>C) \\<Longrightarrow> mem\\<^sub>A_of mem\\<^sub>C = mem\\<^sub>A_of mem\\<^sub>C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<^sub>C.\n       v\\<^sub>C \\<in> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow>\n       mem\\<^sub>C v\\<^sub>C = mem\\<^sub>C' v\\<^sub>C \\<Longrightarrow>\n    mem\\<^sub>A_of mem\\<^sub>C = mem\\<^sub>A_of mem\\<^sub>C'", "by (simp add: mem\\<^sub>A_of_def)"], ["", "lemma conc_only_var_assign_not_visible_abs:\n  \"\\<forall>v\\<^sub>C e. v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow> mem\\<^sub>A_of mem\\<^sub>C = mem\\<^sub>A_of (mem\\<^sub>C(v\\<^sub>C := e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<^sub>C e.\n       v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow>\n       mem\\<^sub>A_of mem\\<^sub>C =\n       mem\\<^sub>A_of (mem\\<^sub>C(v\\<^sub>C := e))", "using conc_only_vars_not_visible_abs"], ["proof (prove)\nusing this:\n  \\<forall>v\\<^sub>C.\n     v\\<^sub>C \\<in> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow>\n     ?mem\\<^sub>C v\\<^sub>C = ?mem\\<^sub>C' v\\<^sub>C \\<Longrightarrow>\n  mem\\<^sub>A_of ?mem\\<^sub>C = mem\\<^sub>A_of ?mem\\<^sub>C'\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<^sub>C e.\n       v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<longrightarrow>\n       mem\\<^sub>A_of mem\\<^sub>C =\n       mem\\<^sub>A_of (mem\\<^sub>C(v\\<^sub>C := e))", "by simp"], ["", "lemma reg\\<^sub>C_is_not_the_var\\<^sub>C_of_anything:\n  \"reg\\<^sub>C = Eg2_var\\<^sub>C_of_Eg1 x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reg\\<^sub>C = Eg2_var\\<^sub>C_of_Eg1 x \\<Longrightarrow> False", "by (induct x, clarsimp+)"], ["", "lemma reg\\<^sub>C_not_visible_abs:\n  \"reg\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reg\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1", "using reg\\<^sub>C_is_not_the_var\\<^sub>C_of_anything"], ["proof (prove)\nusing this:\n  reg\\<^sub>C = Eg2_var\\<^sub>C_of_Eg1 ?x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. reg\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1", "by blast"], ["", "(* This one's pretty specific to this refinement... *)"], ["", "lemma reg\\<^sub>C_the_only_concrete_only_var:\n  \"v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1 \\<Longrightarrow>\n    v\\<^sub>C = reg\\<^sub>C", "apply(case_tac v\\<^sub>C)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = control_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 2. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = buffer\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 3. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = high_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 4. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = low_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 5. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = temp\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 6. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = reg\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C", "apply(erule rev_notE, clarsimp, rule_tac x=control_var in range_eqI, clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = buffer\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 2. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = high_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 3. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = low_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 4. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = temp\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 5. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = reg\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C", "apply(erule rev_notE, clarsimp, rule_tac x=buffer in range_eqI, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = high_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 2. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = low_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 3. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = temp\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 4. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = reg\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C", "apply(erule rev_notE, clarsimp, rule_tac x=high_var in range_eqI, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = low_var\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 2. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = temp\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 3. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = reg\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C", "apply(erule rev_notE, clarsimp, rule_tac x=low_var in range_eqI, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = temp\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C\n 2. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = reg\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C", "apply(erule rev_notE, clarsimp, rule_tac x=temp in range_eqI, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v\\<^sub>C \\<notin> range Eg2_var\\<^sub>C_of_Eg1;\n     v\\<^sub>C = reg\\<^sub>C\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>C = reg\\<^sub>C", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NoRW\\<^sub>A_implies_NoRW\\<^sub>C:\n  \"x \\<in> mds\\<^sub>A_of mds\\<^sub>C AsmNoReadOrWrite \\<Longrightarrow>\n   Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoReadOrWrite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> mds\\<^sub>A_of mds\\<^sub>C AsmNoReadOrWrite \\<Longrightarrow>\n    Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoReadOrWrite", "unfolding mds\\<^sub>A_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> inv Eg2_var\\<^sub>C_of_Eg1 `\n            (range Eg2_var\\<^sub>C_of_Eg1 \\<inter>\n             mds\\<^sub>C AsmNoReadOrWrite) \\<Longrightarrow>\n    Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoReadOrWrite", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x = inv Eg2_var\\<^sub>C_of_Eg1 (Eg2_var\\<^sub>C_of_Eg1 xa);\n        Eg2_var\\<^sub>C_of_Eg1 xa\n        \\<in> mds\\<^sub>C AsmNoReadOrWrite\\<rbrakk>\n       \\<Longrightarrow> Eg2_var\\<^sub>C_of_Eg1\n                          (inv Eg2_var\\<^sub>C_of_Eg1\n                            (Eg2_var\\<^sub>C_of_Eg1 xa))\n                         \\<in> mds\\<^sub>C AsmNoReadOrWrite", "apply (simp only: Eg2_var\\<^sub>C_of_Eg1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x =\n                inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                      high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C)\n                 (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                   high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C xa);\n        rec_var control_var\\<^sub>C buffer\\<^sub>C high_var\\<^sub>C\n         low_var\\<^sub>C temp\\<^sub>C xa\n        \\<in> mds\\<^sub>C AsmNoReadOrWrite\\<rbrakk>\n       \\<Longrightarrow> rec_var control_var\\<^sub>C buffer\\<^sub>C\n                          high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                          (inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                                 high_var\\<^sub>C low_var\\<^sub>C\n                                 temp\\<^sub>C)\n                            (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                              high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                              xa))\n                         \\<in> mds\\<^sub>C AsmNoReadOrWrite", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x =\n                inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                      high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C)\n                 (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                   high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C xa);\n        rec_var control_var\\<^sub>C buffer\\<^sub>C high_var\\<^sub>C\n         low_var\\<^sub>C temp\\<^sub>C xa\n        \\<in> mds\\<^sub>C AsmNoReadOrWrite\\<rbrakk>\n       \\<Longrightarrow> rec_var control_var\\<^sub>C buffer\\<^sub>C\n                          high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                          (inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                                 high_var\\<^sub>C low_var\\<^sub>C\n                                 temp\\<^sub>C)\n                            (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                              high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                              xa))\n                         \\<in> mds\\<^sub>C AsmNoReadOrWrite", "apply (simp add: f_inv_into_f)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NoWrite\\<^sub>A_implies_NoWrite\\<^sub>C:\n  \"x \\<in> mds\\<^sub>A_of mds\\<^sub>C AsmNoWrite \\<Longrightarrow>\n   Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoWrite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> mds\\<^sub>A_of mds\\<^sub>C AsmNoWrite \\<Longrightarrow>\n    Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoWrite", "unfolding mds\\<^sub>A_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> inv Eg2_var\\<^sub>C_of_Eg1 `\n            (range Eg2_var\\<^sub>C_of_Eg1 \\<inter>\n             mds\\<^sub>C AsmNoWrite) \\<Longrightarrow>\n    Eg2_var\\<^sub>C_of_Eg1 x \\<in> mds\\<^sub>C AsmNoWrite", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x = inv Eg2_var\\<^sub>C_of_Eg1 (Eg2_var\\<^sub>C_of_Eg1 xa);\n        Eg2_var\\<^sub>C_of_Eg1 xa \\<in> mds\\<^sub>C AsmNoWrite\\<rbrakk>\n       \\<Longrightarrow> Eg2_var\\<^sub>C_of_Eg1\n                          (inv Eg2_var\\<^sub>C_of_Eg1\n                            (Eg2_var\\<^sub>C_of_Eg1 xa))\n                         \\<in> mds\\<^sub>C AsmNoWrite", "apply (simp only: Eg2_var\\<^sub>C_of_Eg1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x =\n                inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                      high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C)\n                 (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                   high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C xa);\n        rec_var control_var\\<^sub>C buffer\\<^sub>C high_var\\<^sub>C\n         low_var\\<^sub>C temp\\<^sub>C xa\n        \\<in> mds\\<^sub>C AsmNoWrite\\<rbrakk>\n       \\<Longrightarrow> rec_var control_var\\<^sub>C buffer\\<^sub>C\n                          high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                          (inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                                 high_var\\<^sub>C low_var\\<^sub>C\n                                 temp\\<^sub>C)\n                            (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                              high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                              xa))\n                         \\<in> mds\\<^sub>C AsmNoWrite", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x =\n                inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                      high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C)\n                 (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                   high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C xa);\n        rec_var control_var\\<^sub>C buffer\\<^sub>C high_var\\<^sub>C\n         low_var\\<^sub>C temp\\<^sub>C xa\n        \\<in> mds\\<^sub>C AsmNoWrite\\<rbrakk>\n       \\<Longrightarrow> rec_var control_var\\<^sub>C buffer\\<^sub>C\n                          high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                          (inv (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                                 high_var\\<^sub>C low_var\\<^sub>C\n                                 temp\\<^sub>C)\n                            (rec_var control_var\\<^sub>C buffer\\<^sub>C\n                              high_var\\<^sub>C low_var\\<^sub>C temp\\<^sub>C\n                              xa))\n                         \\<in> mds\\<^sub>C AsmNoWrite", "apply (simp add: f_inv_into_f)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assign_eval\\<^sub>w_load\\<^sub>A:\n  shows \"(\\<langle>x \\<leftarrow> Eg1.Load y, mds, mem\\<rangle>\\<^sub>A, \\<langle>Stop, mds, mem (x := mem y)\\<rangle>\\<^sub>A) \\<in> A.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>A\n     \\<langle>x \\<leftarrow> aexp.Load y, mds, mem\\<rangle>\\<^sub>A\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>A", "by (metis A.assign_eval\\<^sub>w ev\\<^sub>A.simps(2))"], ["", "lemma assign_eval\\<^sub>w_load\\<^sub>C:\n  shows \"(\\<langle>x \\<leftarrow> Load y, mds, mem\\<rangle>\\<^sub>C, \\<langle>Stop, mds, mem (x := mem y)\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>C", "using C.unannotated[OF C.assign, where E=\"[]\", simplified]"], ["proof (prove)\nusing this:\n  eval_abv\\<^sub>C\n   \\<langle>?x1 \\<leftarrow> ?e1, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>Stop, ?mds, ?mem\n   (?x1 := ev\\<^sub>A\\<^sub>C ?mem ?e1)\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>C", "apply(drule_tac x=x in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e mds mem.\n        eval_abv\\<^sub>C\n         \\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>C\n         \\<langle>Stop, mds, mem\n         (x := ev\\<^sub>A\\<^sub>C mem e)\\<rangle>\\<^sub>C) \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>C", "apply(drule_tac x=\"Load y\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mds mem.\n        eval_abv\\<^sub>C\n         \\<langle>x \\<leftarrow>\n                  aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n         \\<langle>Stop, mds, mem\n         (x := ev\\<^sub>A\\<^sub>C mem\n                (aexp\\<^sub>C.Load y))\\<rangle>\\<^sub>C) \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>C", "apply(drule_tac x=mds in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mem.\n        eval_abv\\<^sub>C\n         \\<langle>x \\<leftarrow>\n                  aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n         \\<langle>Stop, mds, mem\n         (x := ev\\<^sub>A\\<^sub>C mem\n                (aexp\\<^sub>C.Load y))\\<rangle>\\<^sub>C) \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>C", "apply(drule_tac x=mem in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem\n     (x := ev\\<^sub>A\\<^sub>C mem\n            (aexp\\<^sub>C.Load y))\\<rangle>\\<^sub>C \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Load y, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := mem y)\\<rangle>\\<^sub>C", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assign_eval\\<^sub>w_const\\<^sub>A:\n  shows \"(\\<langle>x \\<leftarrow> Eg1.Const c, mds, mem\\<rangle>, \\<langle>Stop, mds, mem (x := c)\\<rangle>) \\<in> A.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>A\n     \\<langle>x \\<leftarrow> aexp.Const c, mds, mem\\<rangle>\\<^sub>A\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>A", "by (metis A.assign_eval\\<^sub>w ev\\<^sub>A.simps(1))"], ["", "lemma assign_eval\\<^sub>w_const\\<^sub>C:\n  shows \"(\\<langle>x \\<leftarrow> Const c, mds, mem\\<rangle>, \\<langle>Stop, mds, mem (x := c)\\<rangle>) \\<in> C.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>C", "using C.unannotated[OF C.assign, where E=\"[]\", simplified]"], ["proof (prove)\nusing this:\n  eval_abv\\<^sub>C\n   \\<langle>?x1 \\<leftarrow> ?e1, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>Stop, ?mds, ?mem\n   (?x1 := ev\\<^sub>A\\<^sub>C ?mem ?e1)\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>C", "apply(drule_tac x=x in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e mds mem.\n        eval_abv\\<^sub>C\n         \\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>C\n         \\<langle>Stop, mds, mem\n         (x := ev\\<^sub>A\\<^sub>C mem e)\\<rangle>\\<^sub>C) \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>C", "apply(drule_tac x=\"Const c\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mds mem.\n        eval_abv\\<^sub>C\n         \\<langle>x \\<leftarrow>\n                  aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n         \\<langle>Stop, mds, mem\n         (x := ev\\<^sub>A\\<^sub>C mem\n                (aexp\\<^sub>C.Const c))\\<rangle>\\<^sub>C) \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>C", "apply(drule_tac x=mds in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mem.\n        eval_abv\\<^sub>C\n         \\<langle>x \\<leftarrow>\n                  aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n         \\<langle>Stop, mds, mem\n         (x := ev\\<^sub>A\\<^sub>C mem\n                (aexp\\<^sub>C.Const c))\\<rangle>\\<^sub>C) \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>C", "apply(drule_tac x=mem in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem\n     (x := ev\\<^sub>A\\<^sub>C mem\n            (aexp\\<^sub>C.Const c))\\<rangle>\\<^sub>C \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>x \\<leftarrow> aexp\\<^sub>C.Const c, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>Stop, mds, mem(x := c)\\<rangle>\\<^sub>C", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_seq_eval\\<^sub>w_helper\\<^sub>A:\n  \"(\\<langle>If B T E, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B mem B then T else E, mds, mem\\<rangle>\\<^sub>A) \\<in> A.eval\\<^sub>w\n    \\<Longrightarrow>\n   (\\<langle>If B T E ;; TAIL, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B mem B then T ;; TAIL else E ;; TAIL, mds, mem\\<rangle>\\<^sub>A) \\<in> A.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>A \\<langle>Stmt.If B T E, mds, mem\\<rangle>\\<^sub>A\n     \\<langle>if ev\\<^sub>B mem B then T\n              else E, mds, mem\\<rangle>\\<^sub>A \\<Longrightarrow>\n    eval_abv\\<^sub>A\n     \\<langle>Stmt.If B T E ;; TAIL, mds, mem\\<rangle>\\<^sub>A\n     \\<langle>if ev\\<^sub>B mem B then T ;; TAIL\n              else E ;; TAIL, mds, mem\\<rangle>\\<^sub>A", "using A.eval\\<^sub>w.seq"], ["proof (prove)\nusing this:\n  eval_abv\\<^sub>A \\<langle>?c\\<^sub>1, ?mds, ?mem\\<rangle>\\<^sub>A\n   \\<langle>?c\\<^sub>1', ?mds', ?mem'\\<rangle>\\<^sub>A \\<Longrightarrow>\n  eval_abv\\<^sub>A\n   \\<langle>?c\\<^sub>1 ;; ?c\\<^sub>2, ?mds, ?mem\\<rangle>\\<^sub>A\n   \\<langle>?c\\<^sub>1' ;; ?c\\<^sub>2, ?mds', ?mem'\\<rangle>\\<^sub>A\n\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>A \\<langle>Stmt.If B T E, mds, mem\\<rangle>\\<^sub>A\n     \\<langle>if ev\\<^sub>B mem B then T\n              else E, mds, mem\\<rangle>\\<^sub>A \\<Longrightarrow>\n    eval_abv\\<^sub>A\n     \\<langle>Stmt.If B T E ;; TAIL, mds, mem\\<rangle>\\<^sub>A\n     \\<langle>if ev\\<^sub>B mem B then T ;; TAIL\n              else E ;; TAIL, mds, mem\\<rangle>\\<^sub>A", "by auto"], ["", "lemma if_seq_eval\\<^sub>w_helper\\<^sub>C:\n  \"(\\<langle>If B T E, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T else E, mds, mem\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\n    \\<Longrightarrow>\n   (\\<langle>If B T E ;; TAIL, mds, mem\\<rangle>,\n    \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T ;; TAIL else E ;; TAIL, mds, mem\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C \\<langle>Stmt.If B T E, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T\n              else E, mds, mem\\<rangle>\\<^sub>C \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>Stmt.If B T E ;; TAIL, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T ;; TAIL\n              else E ;; TAIL, mds, mem\\<rangle>\\<^sub>C", "using C.eval\\<^sub>w.seq"], ["proof (prove)\nusing this:\n  eval_abv\\<^sub>C \\<langle>?c\\<^sub>1, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>?c\\<^sub>1', ?mds', ?mem'\\<rangle>\\<^sub>C \\<Longrightarrow>\n  eval_abv\\<^sub>C\n   \\<langle>?c\\<^sub>1 ;; ?c\\<^sub>2, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>?c\\<^sub>1' ;; ?c\\<^sub>2, ?mds', ?mem'\\<rangle>\\<^sub>C\n\ngoal (1 subgoal):\n 1. eval_abv\\<^sub>C \\<langle>Stmt.If B T E, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T\n              else E, mds, mem\\<rangle>\\<^sub>C \\<Longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>Stmt.If B T E ;; TAIL, mds, mem\\<rangle>\\<^sub>C\n     \\<langle>if ev\\<^sub>B\\<^sub>C mem B then T ;; TAIL\n              else E ;; TAIL, mds, mem\\<rangle>\\<^sub>C", "by auto"], ["", "lemma mem_assign_refinement_helper_var:\n  \"mem\\<^sub>A_of (mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x := mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y)))\n       = (mem\\<^sub>A_of mem\\<^sub>C) (x := (mem\\<^sub>A_of mem\\<^sub>C) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>A_of\n     (mem\\<^sub>C\n      (Eg2_var\\<^sub>C_of_Eg1 x :=\n         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y))) =\n    (mem\\<^sub>A_of mem\\<^sub>C)(x := mem\\<^sub>A_of mem\\<^sub>C y)", "apply(clarsimp simp: mem\\<^sub>A_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^sub>A.\n        if Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x\n        then mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y)\n        else mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A)) =\n    (\\<lambda>x\\<^sub>A. mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A))\n    (x := mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y))", "apply(rule ext, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y) =\n                         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)", "apply(cases x)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = control_var\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y) =\n                         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 2. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = buffer\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y) =\n                         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 3. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = high_var\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y) =\n                         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 4. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = low_var\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y) =\n                         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 5. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = temp\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 y) =\n                         mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)", "apply(case_tac x\\<^sub>A, clarsimp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mem_assign_refinement_helper_const:\n  \"mem\\<^sub>A_of (mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x := c))\n       = (mem\\<^sub>A_of mem\\<^sub>C) (x := c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>A_of (mem\\<^sub>C(Eg2_var\\<^sub>C_of_Eg1 x := c)) =\n    (mem\\<^sub>A_of mem\\<^sub>C)(x := c)", "apply(clarsimp simp: mem\\<^sub>A_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^sub>A.\n        if Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x\n        then c else mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A)) =\n    (\\<lambda>x\\<^sub>A. mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A))\n    (x := c)", "apply(rule ext, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> c = mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)", "apply(cases x)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = control_var\\<rbrakk>\n       \\<Longrightarrow> c = mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 2. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = buffer\\<rbrakk>\n       \\<Longrightarrow> c = mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 3. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = high_var\\<rbrakk>\n       \\<Longrightarrow> c = mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 4. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = low_var\\<rbrakk>\n       \\<Longrightarrow> c = mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)\n 5. \\<And>x\\<^sub>A.\n       \\<lbrakk>Eg2_var\\<^sub>C_of_Eg1 x\\<^sub>A = Eg2_var\\<^sub>C_of_Eg1 x;\n        x\\<^sub>A \\<noteq> x; x = temp\\<rbrakk>\n       \\<Longrightarrow> c = mem\\<^sub>C (Eg2_var\\<^sub>C_of_Eg1 x)", "apply(case_tac x\\<^sub>A, clarsimp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_true_eval\\<^sub>w\\<^sub>C:\n  shows \"mem\\<^sub>C x = 0 \\<longrightarrow>\n     (\\<langle>(If (Eq x 0) c\\<^sub>C_then c\\<^sub>C_else) ;; c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C,\n      \\<langle>(c\\<^sub>C_then ;; c\\<^sub>C_tail), mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>C x = 0 \\<longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>Stmt.If (bexp\\<^sub>C.Eq x 0) c\\<^sub>C_then c\\<^sub>C_else ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C\n     \\<langle>c\\<^sub>C_then ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C", "using C.if_eval\\<^sub>w C.eval\\<^sub>w.seq ev\\<^sub>B\\<^sub>C.simps"], ["proof (prove)\nusing this:\n  eval_abv\\<^sub>C \\<langle>Stmt.If ?b ?t ?e, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>if ev\\<^sub>B\\<^sub>C ?mem ?b then ?t\n            else ?e, ?mds, ?mem\\<rangle>\\<^sub>C\n  eval_abv\\<^sub>C \\<langle>?c\\<^sub>1, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>?c\\<^sub>1', ?mds', ?mem'\\<rangle>\\<^sub>C \\<Longrightarrow>\n  eval_abv\\<^sub>C\n   \\<langle>?c\\<^sub>1 ;; ?c\\<^sub>2, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>?c\\<^sub>1' ;; ?c\\<^sub>2, ?mds', ?mem'\\<rangle>\\<^sub>C\n  ev\\<^sub>B\\<^sub>C ?mem (bexp\\<^sub>C.Eq ?x ?v) = (?mem ?x = ?v)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>C x = 0 \\<longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>Stmt.If (bexp\\<^sub>C.Eq x 0) c\\<^sub>C_then c\\<^sub>C_else ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C\n     \\<langle>c\\<^sub>C_then ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C", "by presburger"], ["", "lemma if_false_eval\\<^sub>w\\<^sub>C:\n  shows \"mem\\<^sub>C x \\<noteq> 0 \\<longrightarrow>\n     (\\<langle>(If (Eq x 0) c\\<^sub>C_then c\\<^sub>C_else) ;; c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C,\n      \\<langle>(c\\<^sub>C_else ;; c\\<^sub>C_tail), mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C) \\<in> C.eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>C x \\<noteq> 0 \\<longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>Stmt.If (bexp\\<^sub>C.Eq x 0) c\\<^sub>C_then c\\<^sub>C_else ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C\n     \\<langle>c\\<^sub>C_else ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C", "using C.if_eval\\<^sub>w C.eval\\<^sub>w.seq ev\\<^sub>B\\<^sub>C.simps"], ["proof (prove)\nusing this:\n  eval_abv\\<^sub>C \\<langle>Stmt.If ?b ?t ?e, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>if ev\\<^sub>B\\<^sub>C ?mem ?b then ?t\n            else ?e, ?mds, ?mem\\<rangle>\\<^sub>C\n  eval_abv\\<^sub>C \\<langle>?c\\<^sub>1, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>?c\\<^sub>1', ?mds', ?mem'\\<rangle>\\<^sub>C \\<Longrightarrow>\n  eval_abv\\<^sub>C\n   \\<langle>?c\\<^sub>1 ;; ?c\\<^sub>2, ?mds, ?mem\\<rangle>\\<^sub>C\n   \\<langle>?c\\<^sub>1' ;; ?c\\<^sub>2, ?mds', ?mem'\\<rangle>\\<^sub>C\n  ev\\<^sub>B\\<^sub>C ?mem (bexp\\<^sub>C.Eq ?x ?v) = (?mem ?x = ?v)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>C x \\<noteq> 0 \\<longrightarrow>\n    eval_abv\\<^sub>C\n     \\<langle>Stmt.If (bexp\\<^sub>C.Eq x 0) c\\<^sub>C_then c\\<^sub>C_else ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C\n     \\<langle>c\\<^sub>C_else ;;\n              c\\<^sub>C_tail, mds\\<^sub>C, mem\\<^sub>C\\<rangle>\\<^sub>C", "by presburger"], ["", "end"], ["", "end"]]}