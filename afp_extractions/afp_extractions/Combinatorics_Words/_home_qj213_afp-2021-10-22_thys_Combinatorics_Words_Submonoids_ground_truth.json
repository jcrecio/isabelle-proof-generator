{"file_name": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words/Submonoids.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words", "problem_names": ["lemmas [intro] = hull.intros", "lemma hull_closed: \"w1 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\"", "lemma gen_in [intro]: \"w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\"", "lemma hull_induct: assumes \"x \\<in> \\<langle>G\\<rangle>\" \"P \\<epsilon>\" \"\\<And>w. w \\<in> G \\<Longrightarrow> P w\" \n\"\\<And>w1 w2. w1 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> P w1 \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> P w2 \\<Longrightarrow> P (w1 \\<cdot> w2)\" shows  \"P x\"", "lemma genset_sub: \"G \\<subseteq> \\<langle>G\\<rangle>\"", "lemma in_lists_conv_set_subset: \"set ws \\<subseteq> G \\<longleftrightarrow> ws \\<in> lists G\"", "lemma concat_in_hull [intro]:\n  assumes \"set ws \\<subseteq> G\"\n  shows   \"concat ws \\<in> \\<langle>G\\<rangle>\"", "lemma concat_in_hull' [intro]:\n  assumes \"ws \\<in> lists G\"\n  shows   \"concat ws \\<in> \\<langle>G\\<rangle>\"", "lemma hull_concat_lists0: \"w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> (\\<exists> ws \\<in> lists G. concat ws = w)\"", "lemma hull_concat_lists: \"\\<langle>G\\<rangle> = concat ` lists G\"", "lemma concat_tl: \"x # xs \\<in> lists G \\<Longrightarrow> concat xs \\<in> \\<langle>G\\<rangle>\"", "lemma nemp_concat_hull: assumes \"us \\<noteq> \\<epsilon>\" and \"us \\<in> lists G\\<^sub>+\"\n  shows \"concat us \\<in> \\<langle>G\\<rangle>\" and \"concat us \\<noteq> \\<epsilon>\"", "lemma hull_mon: \"A \\<subseteq> B \\<Longrightarrow> \\<langle>A\\<rangle> \\<subseteq> \\<langle>B\\<rangle>\"", "lemma emp_gen_set: \"\\<langle>{}\\<rangle> = {\\<epsilon>}\"", "lemma hull_drop_one: \"\\<langle>G\\<rangle> = \\<langle>G\\<^sub>+\\<rangle>\"", "lemma sing_gen_power: \"u \\<in> \\<langle>{x}\\<rangle> \\<Longrightarrow> \\<exists>k. u = x\\<^sup>@k\"", "lemma sing_gen: \"w \\<in> \\<langle>{z}\\<rangle> \\<Longrightarrow> w \\<in> z*\"", "lemma lists_gen_to_hull: \"us \\<in> lists G\\<^sub>+ \\<Longrightarrow> us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\"", "lemma rev_hull0: \"x \\<in> rev ` \\<langle>G\\<rangle> \\<Longrightarrow> x \\<in> \\<langle>rev ` G\\<rangle>\"", "lemma rev_hull1: \"x \\<in>  \\<langle>rev ` G\\<rangle> \\<Longrightarrow> x \\<in> rev ` \\<langle>G\\<rangle>\"", "lemma rev_hull: \"rev`\\<langle>G\\<rangle> = \\<langle>rev`G\\<rangle>\"", "lemma power_in: \"x \\<in> \\<langle>G\\<rangle>  \\<Longrightarrow> x\\<^sup>@k \\<in> \\<langle>G\\<rangle>\"", "lemma hull_closed_lists:  \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> concat us \\<in> \\<langle>G\\<rangle>\"", "lemma self_gen: \"\\<langle>\\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>\"", "lemma hulls_inter: \"\\<langle>\\<Inter> {\\<langle>G\\<rangle> | G. G \\<in> S}\\<rangle> = \\<Inter> {\\<langle>G\\<rangle> | G. G \\<in> S}\"", "lemma dec_ex:  assumes \"u \\<in> \\<langle>G\\<rangle>\" shows \"\\<exists> us. (us \\<in> lists G\\<^sub>+ \\<and> concat us = u)\"", "lemma decI': \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> (Dec G u) \\<in> lists G\\<^sub>+\"", "lemma decI: \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> concat (Dec G u) = u\"", "lemma dec_emp: \"Dec G \\<epsilon> = \\<epsilon>\"", "lemma dec_nemp: \"u \\<in> \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow>  Dec G u \\<noteq> \\<epsilon>\"", "lemma dec_nemp': \"u \\<noteq> \\<epsilon> \\<Longrightarrow> u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> Dec G u \\<noteq> \\<epsilon>\"", "lemma dec_dom': \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> Dec G u \\<in> lists G\"", "lemma dec_hd: assumes \"u \\<noteq> \\<epsilon>\" \"u \\<in> \\<langle>G\\<rangle>\" shows \"hd (Dec G u) \\<in> G\"", "lemma non_gen_dec: \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> u \\<notin> G \\<Longrightarrow> Dec G u  \\<noteq> [u]\"", "lemma ref_morph: \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> vs \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> refine G (us \\<cdot> vs) = refine G us \\<cdot> refine G vs\"", "lemma ref_morph_plus: \"us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow> vs \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow> refine G (us \\<cdot> vs) = refine G us \\<cdot> refine G vs\"", "lemma ref_pop_hd: \"us \\<noteq> \\<epsilon> \\<Longrightarrow> us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> refine G us = decompose G (hd us) \\<cdot> refine G (tl us)\"", "lemma ref_in: \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> (Ref G us) \\<in> lists G\\<^sub>+\"", "lemma ref: \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> concat (Ref G us) = concat us\"", "lemma ref_gen: \"us \\<in> lists B \\<Longrightarrow> B \\<subseteq> \\<langle>G\\<rangle> \\<Longrightarrow> Ref G us \\<in> \\<langle>decompose G ` B\\<rangle>\"", "lemma emp_ref: assumes \"us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\" and  \"Ref G us = \\<epsilon>\" shows \"us = \\<epsilon>\"", "lemma sing_ref_sing: \n  assumes \"us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\" and \"refine G us = [b]\" \n  shows \"us = [b]\"", "lemma ref_ex: assumes \"Q \\<subseteq> \\<langle>G\\<rangle>\" and \"us \\<in> lists Q\" \n  shows \"Ref G us \\<in> lists G\\<^sub>+\" and \"concat (Ref G us) = concat us\"", "lemma simp_el_el: \"b \\<in>B G \\<Longrightarrow> b \\<in> G\"", "lemma simp_elD: \"b \\<in>B G \\<Longrightarrow> us \\<in> lists G\\<^sub>+ \\<Longrightarrow> concat us = b \\<Longrightarrow> \\<^bold>|us\\<^bold>| = 1\"", "lemma simp_el_sing: assumes \"b \\<in>B G\" \"us \\<in> lists G\\<^sub>+\" \"concat us = b\" shows \"us = [b]\"", "lemma nonsimp: \"us \\<in> lists G\\<^sub>+ \\<Longrightarrow> concat us \\<in>B G \\<Longrightarrow>  us = [concat us]\"", "lemma emp_nonsimp: \"\\<not> \\<epsilon> \\<in>B G\"", "lemma basis_no_fact: assumes \"u \\<in> \\<langle>G\\<rangle>\" and \"v \\<in> \\<langle>G\\<rangle>\" and \"u \\<cdot> v \\<in>B G\" shows \"u = \\<epsilon> \\<or> v = \\<epsilon>\"", "lemma simp_elI:\n  assumes \"b \\<in> G\" and \"b \\<noteq> \\<epsilon>\"  and all: \"\\<forall> u v. u \\<noteq> \\<epsilon> \\<and> u \\<in> \\<langle>G\\<rangle> \\<and> v \\<noteq> \\<epsilon> \\<and> v \\<in> \\<langle>G\\<rangle> \\<longrightarrow> u \\<cdot> v \\<noteq> b\"\n  shows \"b \\<in>B G\"", "lemma simp_el_indecomp: \n  assumes \"b \\<in>B G\" \n  shows \"b \\<in> G\" and  \"b \\<noteq> \\<epsilon>\" and \"\\<forall> u v. u \\<noteq> \\<epsilon> \\<and> u \\<in> \\<langle>G\\<rangle> \\<and> v \\<noteq> \\<epsilon> \\<and> v \\<in> \\<langle>G\\<rangle> \\<longrightarrow> u \\<cdot> v \\<noteq> b\"", "lemma basisI: \"x \\<in>B G \\<Longrightarrow> x \\<in> \\<BB> G\"", "lemma basisD: \"x \\<in> \\<BB> G \\<Longrightarrow> x \\<in>B G\"", "lemma emp_not_basis: \"x \\<in> \\<BB> G \\<Longrightarrow> x \\<noteq> \\<epsilon>\"", "lemma basis_sub: \"\\<BB> G \\<subseteq> G\"", "lemma basis_drop_emp: \"(\\<BB> G)\\<^sub>+ = \\<BB> G\"", "lemma simp_el_hull':  assumes \"b \\<in>B \\<langle>G\\<rangle>\"  shows \"b \\<in>B G\"", "lemma simp_el_hull:  assumes \"b \\<in>B G\" shows \"b \\<in>B \\<langle>G\\<rangle>\"", "lemma concat_tl_basis: \"x # xs \\<in> lists \\<BB> G \\<Longrightarrow> concat xs \\<in> \\<langle>G\\<rangle>\"", "lemma set_concat_len: assumes \"us \\<in> lists G\\<^sub>+\" \"1 < \\<^bold>|us\\<^bold>|\" \"u \\<in> set us\" shows \"\\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|\"", "lemma non_simp_dec: assumes \"w \\<notin> \\<BB> G\" \"w \\<noteq> \\<epsilon>\" \"w \\<in> G\"\n  obtains us where \"us \\<in> lists G\\<^sub>+\" \"1 < \\<^bold>|us\\<^bold>|\" \"concat us = w\"", "lemma basis_gen: \"w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>\"", "theorem basis_gen_hull: \"\\<langle>\\<BB> G\\<rangle> = \\<langle>G\\<rangle>\"", "lemma basis_gen_hull': \"\\<langle>\\<BB> \\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>\"", "theorem basis_of_hull: \"\\<BB> G = \\<BB> \\<langle>G\\<rangle>\"", "theorem \"\\<langle>S\\<rangle> = \\<langle>G\\<rangle> \\<Longrightarrow> \\<BB> G \\<subseteq> S\"", "lemma gen_sets: assumes \"\\<BB> G \\<subseteq> S\" and \"S \\<subseteq> \\<langle>G\\<rangle>\" shows \"\\<langle>S\\<rangle> = \\<langle>G\\<rangle>\"", "lemma basis_sets: \"\\<BB> G \\<subseteq> S \\<Longrightarrow> S \\<subseteq> \\<langle>G\\<rangle> \\<Longrightarrow> \\<BB> G = \\<BB> S\"", "lemma non_simp_fac: assumes \"w \\<noteq> \\<epsilon>\" and \"w \\<in> \\<langle>G\\<rangle>\" and \"w \\<notin> \\<BB> G\"\n  obtains us where \"1 < \\<^bold>|us\\<^bold>|\" and \"us \\<noteq> \\<epsilon>\" and  \"us \\<in> lists \\<BB> G\" and \n    \"hd us \\<noteq> \\<epsilon>\" and \"hd us \\<in> \\<langle>G\\<rangle>\" and \n    \"concat(tl us) \\<noteq> \\<epsilon>\" and \"concat(tl us) \\<in> \\<langle>G\\<rangle>\" and \n    \"w = hd us \\<cdot> concat(tl us)\"", "lemma basis_dec: \"p \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> s \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> p \\<cdot> s \\<in> \\<BB> G \\<Longrightarrow> p = \\<epsilon> \\<or> s = \\<epsilon>\"", "lemma non_simp_fac': \"w \\<notin> \\<BB> G \\<Longrightarrow> w \\<noteq> \\<epsilon> \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> w = concat us \\<and> \\<^bold>|us\\<^bold>| \\<noteq> 1\"", "lemma emp_gen_iff: \"G\\<^sub>+ = {} \\<longleftrightarrow> \\<langle>G\\<rangle> = {\\<epsilon>}\"", "lemma emp_basis_iff:  \"\\<BB> G = {} \\<longleftrightarrow> G\\<^sub>+ = {}\"", "lemma emp_not_in_code: \"\\<epsilon> \\<notin> \\<C>\"", "lemma code_simple: \"c \\<in> \\<C> \\<Longrightarrow> c \\<in>B \\<C>\"", "lemma code_is_basis: \"\\<BB> \\<C> = \\<C>\"", "lemma code_unique_dec: \"us \\<in> lists \\<C> \\<Longrightarrow> Dec \\<C> (concat us) = us\"", "lemma code_unique_ref: \"us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow> refine \\<C> us = decompose \\<C> (concat us)\"", "lemma code_dec_morph: assumes \"x \\<in> \\<langle>\\<C>\\<rangle>\" \"y \\<in> \\<langle>\\<C>\\<rangle>\" \n  shows \"(Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> (x\\<cdot>y)\"", "lemma code_el_dec: \"c \\<in> \\<C> \\<Longrightarrow> decompose \\<C> c = [c]\"", "lemma code_ref_list: \"us \\<in> lists \\<C> \\<Longrightarrow> refine \\<C> us = us\"", "lemma code_ref_gen: assumes \"G \\<subseteq> \\<langle>\\<C>\\<rangle>\" \"u \\<in> \\<langle>G\\<rangle>\" \n  shows \"Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>\"", "lemma bin_fst_nemp: \"u\\<^sub>0 \\<noteq> \\<epsilon>\"", "lemma bin_mismatch_neq: \"c\\<^sub>0 \\<noteq> c\\<^sub>1\"", "lemma bin_lcp_pref_fst_snd: \"\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\" and bin_lcp_pref_snd_fst: \"\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0\"", "lemma bin_lcp_short: \"\\<^bold>|\\<alpha>\\<^bold>| < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|\"", "lemma bin_lcp_fst_mismatch_pref:  \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\"", "lemma not_fst_snd_pref:  \"\\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p \\<alpha>\"", "lemma bin_lcp_fst_mismatch_pref':  \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\"", "lemmas bin_snd_nemp = symcode.bin_fst_nemp and\n       bin_snd_mismatch = symcode.bin_lcp_fst_mismatch_pref", "lemma bin_lcp_fst_lcp: \"\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\" and bin_lcp_snd_lcp: \"\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> \\<alpha>\"", "lemma bin_all_nemp: \"ws \\<in> lists {u\\<^sub>0,u\\<^sub>1} \\<Longrightarrow> concat ws = \\<epsilon> \\<Longrightarrow> ws = \\<epsilon>\"", "lemma bin_lcp_all_lcp: \"ws \\<in> lists {u\\<^sub>0,u\\<^sub>1} \\<Longrightarrow> \\<alpha> \\<le>p concat ws \\<cdot> \\<alpha>\"", "lemma bin_code_alpha: assumes \"us \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"vs \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"hd us  \\<noteq> hd vs\" \n  shows \"concat us \\<cdot> \\<alpha> \\<and>\\<^sub>p concat vs \\<cdot> \\<alpha> = \\<alpha>\"", "theorem bin_code: assumes \"us \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"vs \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"concat us = concat vs\"\n  shows \"us = vs\"", "lemmas no_comm_bin_code = binary_code.bin_code[unfolded binary_code_def]", "theorem bin_code_code: assumes \"u \\<cdot> v \\<noteq> v \\<cdot> u\" shows \"code {u, v}\"", "lemmas [intro] = free_hull.intros", "lemma free_hull_hull: \"\\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> = \\<langle>G\\<rangle>\\<^sub>F\"", "lemma hull_in_free_hull: \"\\<langle>G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\"", "lemma basis_gen_hull_free: \"\\<langle>\\<BB>\\<^sub>F G\\<rangle> = \\<langle>G\\<rangle>\\<^sub>F\"", "lemma genset_sub_free: \"G \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\"", "lemma free_basis_code: \"code (\\<BB>\\<^sub>F G)\"", "lemma code_gen_free_hull: \"code C \\<Longrightarrow> \\<langle>C\\<rangle>\\<^sub>F = \\<langle>C\\<rangle>\"", "lemma code_free_basis: assumes \"code C\" shows \"C = \\<BB>\\<^sub>F C\"", "lemma free_hull_mono: \"G \\<subseteq> H \\<Longrightarrow> \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>H\\<rangle>\\<^sub>F\"", "lemma free_hull_idem: \"\\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F = \\<langle>G\\<rangle>\\<^sub>F\"", "lemma hull_gen_free_hull: \"\\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F = \\<langle>G\\<rangle>\\<^sub>F\"", "lemma code_free_basis_hull: \"code C \\<Longrightarrow> C = \\<BB>\\<^sub>F \\<langle>C\\<rangle>\"", "theorem free_hull_min: assumes \"code C\" and \"G \\<subseteq> \\<langle>C\\<rangle>\" shows \"\\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\"", "theorem free_hull_inter: \"\\<langle>G\\<rangle>\\<^sub>F = \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\"", "lemma free_basis_dec_morph: \"u \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> v \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>  \n    Dec (\\<BB>\\<^sub>F G) (u \\<cdot> v) = (Dec (\\<BB>\\<^sub>F G) u) \\<cdot> (Dec (\\<BB>\\<^sub>F G) v)\"", "lemma sings_image: \"sings B =  (\\<lambda> x. [x]) ` B\"", "lemma lists_sing_map_concat_ident: \"xs \\<in> lists (sings B) \\<Longrightarrow> xs = map (\\<lambda> x. [x]) (concat xs)\"", "lemma code_sings: \"code (sings B)\"", "lemma sings_gen_lists: \"\\<langle>sings B\\<rangle> = lists B\"", "lemma \"sings B = \\<BB>\\<^sub>F (lists B)\"", "lemma map_sings: \"xs \\<in> lists B \\<Longrightarrow> map (\\<lambda>x. x # \\<epsilon>) xs \\<in> lists (sings B)\"", "lemma dec_sings: \"xs \\<in> lists B \\<Longrightarrow> Dec (sings B) xs = map (\\<lambda> x. [x]) xs\""], "translations": [["", "lemmas [intro] = hull.intros"], ["", "lemma hull_closed: \"w1 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w1 \\<in> \\<langle>G\\<rangle>;\n     w2 \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>", "by (rule hull.induct[of w1 G \"\\<lambda> x. (x\\<cdot>w2)\\<in>\\<langle>G\\<rangle>\"]) auto+"], ["", "lemma gen_in [intro]: \"w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>", "using hull.prod_cl"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w1.0 \\<in> ?G; ?w2.0 \\<in> \\<langle>?G\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<cdot> ?w2.0 \\<in> \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>", "by fastforce"], ["", "lemma hull_induct: assumes \"x \\<in> \\<langle>G\\<rangle>\" \"P \\<epsilon>\" \"\\<And>w. w \\<in> G \\<Longrightarrow> P w\" \n\"\\<And>w1 w2. w1 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> P w1 \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> P w2 \\<Longrightarrow> P (w1 \\<cdot> w2)\" shows  \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using hull.induct[of _ _ P, OF \\<open>x \\<in> \\<langle>G\\<rangle>\\<close>  \\<open>P \\<epsilon>\\<close>]  \n        assms"], ["proof (prove)\nusing this:\n  (\\<And>w1 w2.\n      \\<lbrakk>w1 \\<in> G; w2 \\<in> \\<langle>G\\<rangle>; P w2\\<rbrakk>\n      \\<Longrightarrow> P (w1 \\<cdot> w2)) \\<Longrightarrow>\n  P x\n  x \\<in> \\<langle>G\\<rangle>\n  P \\<epsilon>\n  ?w \\<in> G \\<Longrightarrow> P ?w\n  \\<lbrakk>?w1.0 \\<in> \\<langle>G\\<rangle>; P ?w1.0;\n   ?w2.0 \\<in> \\<langle>G\\<rangle>; P ?w2.0\\<rbrakk>\n  \\<Longrightarrow> P (?w1.0 \\<cdot> ?w2.0)\n\ngoal (1 subgoal):\n 1. P x", "by (simp add: gen_in)"], ["", "lemma genset_sub: \"G \\<subseteq> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> \\<langle>G\\<rangle>", "using gen_in"], ["proof (prove)\nusing this:\n  ?w \\<in> ?G \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. G \\<subseteq> \\<langle>G\\<rangle>", ".."], ["", "lemma in_lists_conv_set_subset: \"set ws \\<subseteq> G \\<longleftrightarrow> ws \\<in> lists G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set ws \\<subseteq> G) = (ws \\<in> lists G)", "by blast"], ["", "lemma concat_in_hull [intro]:\n  assumes \"set ws \\<subseteq> G\"\n  shows   \"concat ws \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ws \\<in> \\<langle>G\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> G\n\ngoal (1 subgoal):\n 1. concat ws \\<in> \\<langle>G\\<rangle>", "by (induction ws) auto"], ["", "lemma concat_in_hull' [intro]:\n  assumes \"ws \\<in> lists G\"\n  shows   \"concat ws \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ws \\<in> \\<langle>G\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  ws \\<in> lists G\n\ngoal (1 subgoal):\n 1. concat ws \\<in> \\<langle>G\\<rangle>", "by (induction ws) auto"], ["", "lemma hull_concat_lists0: \"w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> (\\<exists> ws \\<in> lists G. concat ws = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    \\<exists>ws\\<in>lists G. concat ws = w", "proof(rule hull.induct[of _ G], simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    \\<exists>ws\\<in>lists G. concat ws = \\<epsilon>\n 2. \\<And>w1 w2.\n       \\<lbrakk>w \\<in> \\<langle>G\\<rangle>; w1 \\<in> G;\n        w2 \\<in> \\<langle>G\\<rangle>;\n        \\<exists>ws\\<in>lists G. concat ws = w2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ws\\<in>lists G. concat ws = w1 \\<cdot> w2", "show \"\\<exists>ws\\<in>lists G. concat ws = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ws\\<in>lists G. concat ws = \\<epsilon>", "using concat.simps(1) lists.Nil[of G] exI[of \"\\<lambda> x. concat x = \\<epsilon>\", OF concat.simps(1)]"], ["proof (prove)\nusing this:\n  concat \\<epsilon> = \\<epsilon>\n  \\<epsilon> \\<in> lists G\n  \\<exists>x. concat x = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>ws\\<in>lists G. concat ws = \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  \\<exists>ws\\<in>lists G. concat ws = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>w \\<in> \\<langle>G\\<rangle>; w1 \\<in> G;\n        w2 \\<in> \\<langle>G\\<rangle>;\n        \\<exists>ws\\<in>lists G. concat ws = w2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ws\\<in>lists G. concat ws = w1 \\<cdot> w2", "show \" \\<And>w1 w2. w1 \\<in> G \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> \\<exists>ws\\<in>lists G. concat ws = w2 \\<Longrightarrow> \\<exists>ws\\<in>lists G. concat ws = w1 \\<cdot> w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> G; w2 \\<in> \\<langle>G\\<rangle>;\n        \\<exists>ws\\<in>lists G. concat ws = w2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ws\\<in>lists G. concat ws = w1 \\<cdot> w2", "by (metis Cons_in_lists_iff concat.simps(2))"], ["proof (state)\nthis:\n  \\<lbrakk>?w1.0 \\<in> G; ?w2.0 \\<in> \\<langle>G\\<rangle>;\n   \\<exists>ws\\<in>lists G. concat ws = ?w2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ws\\<in>lists G. concat ws = ?w1.0 \\<cdot> ?w2.0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hull_concat_lists: \"\\<langle>G\\<rangle> = concat ` lists G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = concat ` lists G", "unfolding image_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = concat ` lists G", "using hull_concat_lists0"], ["proof (prove)\nusing this:\n  ?w \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow>\n  \\<exists>ws\\<in>lists ?G. concat ws = ?w\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = concat ` lists G", "by blast"], ["", "lemma concat_tl: \"x # xs \\<in> lists G \\<Longrightarrow> concat xs \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs \\<in> lists G \\<Longrightarrow>\n    concat xs \\<in> \\<langle>G\\<rangle>", "by (simp add: hull_concat_lists)"], ["", "lemma nemp_concat_hull: assumes \"us \\<noteq> \\<epsilon>\" and \"us \\<in> lists G\\<^sub>+\"\n  shows \"concat us \\<in> \\<langle>G\\<rangle>\" and \"concat us \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat us \\<in> \\<langle>G\\<rangle> &&& concat us \\<noteq> \\<epsilon>", "using assms"], ["proof (prove)\nusing this:\n  us \\<noteq> \\<epsilon>\n  us \\<in> lists G\\<^sub>+\n\ngoal (1 subgoal):\n 1. concat us \\<in> \\<langle>G\\<rangle> &&& concat us \\<noteq> \\<epsilon>", "by fastforce+"], ["", "lemma hull_mon: \"A \\<subseteq> B \\<Longrightarrow> \\<langle>A\\<rangle> \\<subseteq> \\<langle>B\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    \\<langle>A\\<rangle> \\<subseteq> \\<langle>B\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B; x \\<in> \\<langle>A\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>B\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B; x \\<in> \\<langle>A\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>B\\<rangle>", "assume \"A \\<subseteq> B\" \"x \\<in> \\<langle>A\\<rangle>\""], ["proof (state)\nthis:\n  A \\<subseteq> B\n  x \\<in> \\<langle>A\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<subseteq> B; x \\<in> \\<langle>A\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>B\\<rangle>", "thus \"x \\<in> \\<langle>B\\<rangle>\""], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  x \\<in> \\<langle>A\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>B\\<rangle>", "unfolding image_def hull_concat_lists"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  x \\<in> {y. \\<exists>x\\<in>lists A. y = concat x}\n\ngoal (1 subgoal):\n 1. x \\<in> {y. \\<exists>x\\<in>lists B. y = concat x}", "using sub_lists_mono[OF \\<open>A \\<subseteq> B\\<close>]"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  x \\<in> {y. \\<exists>x\\<in>lists A. y = concat x}\n  ?x \\<in> lists A \\<Longrightarrow> ?x \\<in> lists B\n\ngoal (1 subgoal):\n 1. x \\<in> {y. \\<exists>x\\<in>lists B. y = concat x}", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<langle>B\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emp_gen_set: \"\\<langle>{}\\<rangle> = {\\<epsilon>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>{}\\<rangle> = {\\<epsilon>}", "unfolding hull_concat_lists"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ` lists {} = {\\<epsilon>}", "by auto"], ["", "lemma hull_drop_one: \"\\<langle>G\\<rangle> = \\<langle>G\\<^sub>+\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = \\<langle>G\\<^sub>+\\<rangle>", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle>\n 2. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle>\n 2. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "assume \"x \\<in> \\<langle>G\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle>\n 2. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "thus \"x \\<in> \\<langle>G\\<^sub>+\\<rangle>\""], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<^sub>+\\<rangle>", "unfolding  hull_concat_lists"], ["proof (prove)\nusing this:\n  x \\<in> concat ` lists G\n\ngoal (1 subgoal):\n 1. x \\<in> concat ` lists G\\<^sub>+", "using del_emp_concat lists_drop_emp'"], ["proof (prove)\nusing this:\n  x \\<in> concat ` lists G\n  concat ?us = concat (filter (\\<lambda>x. x \\<noteq> \\<epsilon>) ?us)\n  ?us \\<in> lists ?C \\<Longrightarrow>\n  filter (\\<lambda>x. x \\<noteq> \\<epsilon>) ?us \\<in> lists ?C\\<^sub>+\n\ngoal (1 subgoal):\n 1. x \\<in> concat ` lists G\\<^sub>+", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<^sub>+\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "assume \"x \\<in> \\<langle>G\\<^sub>+\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<^sub>+\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<^sub>+\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>", "thus \"x \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>G\\<^sub>+\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>", "unfolding  hull_concat_lists image_iff"], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>lists G\\<^sub>+. x = concat xa\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>lists G. x = concat xa", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sing_gen_power: \"u \\<in> \\<langle>{x}\\<rangle> \\<Longrightarrow> \\<exists>k. u = x\\<^sup>@k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>{x}\\<rangle> \\<Longrightarrow>\n    \\<exists>k. u = x \\<^sup>@ k", "unfolding hull_concat_lists"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> concat ` lists {x} \\<Longrightarrow>\n    \\<exists>k. u = x \\<^sup>@ k", "using one_generated_list_power"], ["proof (prove)\nusing this:\n  ?u \\<in> lists {?x} \\<Longrightarrow>\n  \\<exists>k. concat ?u = ?x \\<^sup>@ k\n\ngoal (1 subgoal):\n 1. u \\<in> concat ` lists {x} \\<Longrightarrow>\n    \\<exists>k. u = x \\<^sup>@ k", "by auto"], ["", "lemma sing_gen: \"w \\<in> \\<langle>{z}\\<rangle> \\<Longrightarrow> w \\<in> z*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>{z}\\<rangle> \\<Longrightarrow> w \\<in> z*", "using rootI sing_gen_power"], ["proof (prove)\nusing this:\n  ?r \\<^sup>@ ?k \\<in> ?r*\n  ?u \\<in> \\<langle>{?x}\\<rangle> \\<Longrightarrow>\n  \\<exists>k. ?u = ?x \\<^sup>@ k\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>{z}\\<rangle> \\<Longrightarrow> w \\<in> z*", "by blast"], ["", "lemma lists_gen_to_hull: \"us \\<in> lists G\\<^sub>+ \\<Longrightarrow> us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists G\\<^sub>+ \\<Longrightarrow>\n    us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+", "using lists_mono genset_sub"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?B \\<Longrightarrow> lists ?A \\<subseteq> lists ?B\n  ?G \\<subseteq> \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. us \\<in> lists G\\<^sub>+ \\<Longrightarrow>\n    us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+", "by force"], ["", "lemma rev_hull0: \"x \\<in> rev ` \\<langle>G\\<rangle> \\<Longrightarrow> x \\<in> \\<langle>rev ` G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rev ` \\<langle>G\\<rangle> \\<Longrightarrow>\n    x \\<in> \\<langle>rev ` G\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> rev ` \\<langle>G\\<rangle> \\<Longrightarrow>\n    x \\<in> \\<langle>rev ` G\\<rangle>", "assume \"x \\<in> rev ` \\<langle>G\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> rev ` \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> rev ` \\<langle>G\\<rangle> \\<Longrightarrow>\n    x \\<in> \\<langle>rev ` G\\<rangle>", "then"], ["proof (chain)\npicking this:\n  x \\<in> rev ` \\<langle>G\\<rangle>", "obtain xs where \"x = rev (concat xs)\" and \"xs \\<in> lists G\""], ["proof (prove)\nusing this:\n  x \\<in> rev ` \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>x = rev (concat xs); xs \\<in> lists G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding hull_concat_lists"], ["proof (prove)\nusing this:\n  x \\<in> rev ` concat ` lists G\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>x = rev (concat xs); xs \\<in> lists G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = rev (concat xs)\n  xs \\<in> lists G\n\ngoal (1 subgoal):\n 1. x \\<in> rev ` \\<langle>G\\<rangle> \\<Longrightarrow>\n    x \\<in> \\<langle>rev ` G\\<rangle>", "thus \"x \\<in> \\<langle>rev ` G\\<rangle>\""], ["proof (prove)\nusing this:\n  x = rev (concat xs)\n  xs \\<in> lists G\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>rev ` G\\<rangle>", "unfolding image_iff hull_concat_lists"], ["proof (prove)\nusing this:\n  x = rev (concat xs)\n  xs \\<in> lists G\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>lists (rev ` G). x = concat xa", "using rev_concat[of xs]"], ["proof (prove)\nusing this:\n  x = rev (concat xs)\n  xs \\<in> lists G\n  rev (concat xs) = concat (map rev (rev xs))\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>lists (rev ` G). x = concat xa", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> \\<langle>rev ` G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_hull1: \"x \\<in>  \\<langle>rev ` G\\<rangle> \\<Longrightarrow> x \\<in> rev ` \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>rev ` G\\<rangle> \\<Longrightarrow>\n    x \\<in> rev ` \\<langle>G\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>rev ` G\\<rangle> \\<Longrightarrow>\n    x \\<in> rev ` \\<langle>G\\<rangle>", "assume \"x \\<in>  \\<langle>rev ` G\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>rev ` G\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>rev ` G\\<rangle> \\<Longrightarrow>\n    x \\<in> rev ` \\<langle>G\\<rangle>", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<langle>rev ` G\\<rangle>", "obtain xs where \"x = concat xs\" and \"xs \\<in> lists (rev ` G)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>rev ` G\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>x = concat xs; xs \\<in> lists (rev ` G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding hull_concat_lists"], ["proof (prove)\nusing this:\n  x \\<in> concat ` lists (rev ` G)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>x = concat xs; xs \\<in> lists (rev ` G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = concat xs\n  xs \\<in> lists (rev ` G)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>rev ` G\\<rangle> \\<Longrightarrow>\n    x \\<in> rev ` \\<langle>G\\<rangle>", "hence \"rev x \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\nusing this:\n  x = concat xs\n  xs \\<in> lists (rev ` G)\n\ngoal (1 subgoal):\n 1. rev x \\<in> \\<langle>G\\<rangle>", "unfolding hull_concat_lists"], ["proof (prove)\nusing this:\n  x = concat xs\n  xs \\<in> lists (rev ` G)\n\ngoal (1 subgoal):\n 1. rev x \\<in> concat ` lists G", "using rev_concat"], ["proof (prove)\nusing this:\n  x = concat xs\n  xs \\<in> lists (rev ` G)\n  rev (concat ?xs) = concat (map rev (rev ?xs))\n\ngoal (1 subgoal):\n 1. rev x \\<in> concat ` lists G", "by fastforce"], ["proof (state)\nthis:\n  rev x \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>rev ` G\\<rangle> \\<Longrightarrow>\n    x \\<in> rev ` \\<langle>G\\<rangle>", "thus \"x \\<in> rev ` \\<langle>G\\<rangle>\""], ["proof (prove)\nusing this:\n  rev x \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> rev ` \\<langle>G\\<rangle>", "by (simp add: rev_in_conv)"], ["proof (state)\nthis:\n  x \\<in> rev ` \\<langle>G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_hull: \"rev`\\<langle>G\\<rangle> = \\<langle>rev`G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` \\<langle>G\\<rangle> = \\<langle>rev ` G\\<rangle>", "by (simp add: rev_hull0 rev_hull1 set_eq_subset subsetI)"], ["", "lemma power_in: \"x \\<in> \\<langle>G\\<rangle>  \\<Longrightarrow> x\\<^sup>@k \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    x \\<^sup>@ k \\<in> \\<langle>G\\<rangle>", "by (induction k, auto, simp add: hull_closed)"], ["", "lemma hull_closed_lists:  \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> concat us \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n    concat us \\<in> \\<langle>G\\<rangle>", "proof (induct us, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a us.\n       \\<lbrakk>concat us \\<in> \\<langle>G\\<rangle>;\n        a \\<in> \\<langle>G\\<rangle>;\n        \\<forall>x\\<in>set us. x \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot> concat us \\<in> \\<langle>G\\<rangle>", "show  \"\\<And>a us. concat us \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> a \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> \\<forall>x\\<in>set us. x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> a \\<cdot> concat us \\<in> \\<langle>G\\<rangle> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a us.\n       \\<lbrakk>concat us \\<in> \\<langle>G\\<rangle>;\n        a \\<in> \\<langle>G\\<rangle>;\n        \\<forall>x\\<in>set us. x \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot> concat us \\<in> \\<langle>G\\<rangle>", "by (simp add: hull_closed)"], ["proof (state)\nthis:\n  \\<lbrakk>concat ?us \\<in> \\<langle>G\\<rangle>;\n   ?a \\<in> \\<langle>G\\<rangle>;\n   \\<forall>x\\<in>set ?us. x \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<cdot> concat ?us \\<in> \\<langle>G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma self_gen: \"\\<langle>\\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>", "using image_subsetI[of \"lists \\<langle>G\\<rangle>\" concat \"\\<langle>G\\<rangle>\", unfolded hull_concat_lists[of \"\\<langle>G\\<rangle>\", symmetric],\n        THEN subset_antisym[OF _ genset_sub[of \"\\<langle>G\\<rangle>\"]]] hull_closed_lists[of _ G]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n      concat x \\<in> \\<langle>G\\<rangle>) \\<Longrightarrow>\n  \\<langle>\\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>\n  ?us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  concat ?us \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>", "by blast"], ["", "text\\<open>Intersection of hulls is a hull.\\<close>"], ["", "lemma hulls_inter: \"\\<langle>\\<Inter> {\\<langle>G\\<rangle> | G. G \\<in> S}\\<rangle> = \\<Inter> {\\<langle>G\\<rangle> | G. G \\<in> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle> =\n    \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n 2. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n 2. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "fix G"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n 2. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "assume \"G \\<in> S\""], ["proof (state)\nthis:\n  G \\<in> S\n\ngoal (2 subgoals):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n 2. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "hence \"\\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\""], ["proof (prove)\nusing this:\n  G \\<in> S\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<langle>G\\<rangle>", "using Inter_lower[of \"\\<langle>G\\<rangle>\" \"{\\<langle>G\\<rangle> |G. G \\<in> S}\"] mem_Collect_eq[of \"\\<langle>G\\<rangle>\" \"\\<lambda> A. \\<exists> G. G \\<in> S \\<and> A = \\<langle>G\\<rangle>\"] \n        hull_mon[of \"\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\" \"\\<langle>G\\<rangle>\"]"], ["proof (prove)\nusing this:\n  G \\<in> S\n  \\<langle>G\\<rangle>\n  \\<in> {\\<langle>G\\<rangle> |G. G \\<in> S} \\<Longrightarrow>\n  \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n  \\<subseteq> \\<langle>G\\<rangle>\n  (\\<langle>G\\<rangle>\n   \\<in> {A. \\<exists>G. G \\<in> S \\<and> A = \\<langle>G\\<rangle>}) =\n  (\\<exists>Ga.\n      Ga \\<in> S \\<and> \\<langle>G\\<rangle> = \\<langle>Ga\\<rangle>)\n  \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n  \\<subseteq> \\<langle>G\\<rangle> \\<Longrightarrow>\n  \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n  \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<langle>G\\<rangle>", "unfolding self_gen"], ["proof (prove)\nusing this:\n  G \\<in> S\n  \\<langle>G\\<rangle>\n  \\<in> {\\<langle>G\\<rangle> |G. G \\<in> S} \\<Longrightarrow>\n  \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n  \\<subseteq> \\<langle>G\\<rangle>\n  (\\<langle>G\\<rangle>\n   \\<in> {A. \\<exists>G. G \\<in> S \\<and> A = \\<langle>G\\<rangle>}) =\n  (\\<exists>Ga.\n      Ga \\<in> S \\<and> \\<langle>G\\<rangle> = \\<langle>Ga\\<rangle>)\n  \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n  \\<subseteq> \\<langle>G\\<rangle> \\<Longrightarrow>\n  \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n  \\<subseteq> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<langle>G\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n  \\<subseteq> \\<langle>G\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n 2. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "}"], ["proof (state)\nthis:\n  ?G2 \\<in> S \\<Longrightarrow>\n  \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n  \\<subseteq> \\<langle>?G2\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n 2. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "thus \"\\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle> \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\""], ["proof (prove)\nusing this:\n  ?G2 \\<in> S \\<Longrightarrow>\n  \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n  \\<subseteq> \\<langle>?G2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n    \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}", "by blast"], ["proof (state)\nthis:\n  \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n  \\<subseteq> \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n\ngoal (1 subgoal):\n 1. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "show \"\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S} \\<subseteq> \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n    \\<subseteq> \\<langle>\\<Inter>\n                          {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>", "by (simp add: genset_sub)"], ["proof (state)\nthis:\n  \\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\n  \\<subseteq> \\<langle>\\<Inter> {\\<langle>G\\<rangle> |G. G \\<in> S}\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Factorization into generators\""], ["", "text\\<open>We define a decomposition (or a factorization) of a into elements of a given generating set. Such a decomposition is well defined only \nif the decomposed word is an element of the hull. Even int that case, however, the decomposition need not be unique.\\<close>"], ["", "fun decompose :: \"'a list set  \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\" (\"Dec _ _\" [51,51] 64) where\n  \"decompose G u = (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u)\""], ["", "lemma dec_ex:  assumes \"u \\<in> \\<langle>G\\<rangle>\" shows \"\\<exists> us. (us \\<in> lists G\\<^sub>+ \\<and> concat us = u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u", "unfolding image_def  hull_concat_lists[of G] mem_Collect_eq"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lists G. u = concat x\n\ngoal (1 subgoal):\n 1. \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u", "using del_emp_concat lists_drop_emp'"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lists G. u = concat x\n  concat ?us = concat (filter (\\<lambda>x. x \\<noteq> \\<epsilon>) ?us)\n  ?us \\<in> lists ?C \\<Longrightarrow>\n  filter (\\<lambda>x. x \\<noteq> \\<epsilon>) ?us \\<in> lists ?C\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u", "by metis"], ["", "lemma decI': \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> (Dec G u) \\<in> lists G\\<^sub>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    Dec G u \\<in> lists G\\<^sub>+", "unfolding decompose.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u)\n    \\<in> lists G\\<^sub>+", "using someI_ex[OF dec_ex]"], ["proof (prove)\nusing this:\n  ?u1 \\<in> \\<langle>?G1\\<rangle> \\<Longrightarrow>\n  (SOME x. x \\<in> lists ?G1\\<^sub>+ \\<and> concat x = ?u1)\n  \\<in> lists ?G1\\<^sub>+ \\<and>\n  concat (SOME x. x \\<in> lists ?G1\\<^sub>+ \\<and> concat x = ?u1) = ?u1\n\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u)\n    \\<in> lists G\\<^sub>+", "by blast"], ["", "lemma decI: \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> concat (Dec G u) = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> concat (Dec G u) = u", "unfolding decompose.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    concat (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u) = u", "using someI_ex[OF dec_ex]"], ["proof (prove)\nusing this:\n  ?u1 \\<in> \\<langle>?G1\\<rangle> \\<Longrightarrow>\n  (SOME x. x \\<in> lists ?G1\\<^sub>+ \\<and> concat x = ?u1)\n  \\<in> lists ?G1\\<^sub>+ \\<and>\n  concat (SOME x. x \\<in> lists ?G1\\<^sub>+ \\<and> concat x = ?u1) = ?u1\n\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    concat (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = u) = u", "by blast"], ["", "lemma dec_emp: \"Dec G \\<epsilon> = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec G \\<epsilon> = \\<epsilon>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Dec G \\<epsilon> = \\<epsilon>", "have ex:  \"\\<epsilon> \\<in> lists G\\<^sub>+ \\<and> concat \\<epsilon> = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> lists G\\<^sub>+ \\<and> concat \\<epsilon> = \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> lists G\\<^sub>+ \\<and> concat \\<epsilon> = \\<epsilon>\n\ngoal (1 subgoal):\n 1. Dec G \\<epsilon> = \\<epsilon>", "have all: \"(us \\<in> lists G\\<^sub>+ \\<and> concat us = \\<epsilon>) \\<Longrightarrow> us = \\<epsilon>\" for us"], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists G\\<^sub>+ \\<and> concat us = \\<epsilon> \\<Longrightarrow>\n    us = \\<epsilon>", "using emp_concat_emp"], ["proof (prove)\nusing this:\n  \\<lbrakk>?us \\<in> lists ?S\\<^sub>+; concat ?us = \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> ?us = \\<epsilon>\n\ngoal (1 subgoal):\n 1. us \\<in> lists G\\<^sub>+ \\<and> concat us = \\<epsilon> \\<Longrightarrow>\n    us = \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  ?us1 \\<in> lists G\\<^sub>+ \\<and>\n  concat ?us1 = \\<epsilon> \\<Longrightarrow>\n  ?us1 = \\<epsilon>\n\ngoal (1 subgoal):\n 1. Dec G \\<epsilon> = \\<epsilon>", "show  ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec G \\<epsilon> = \\<epsilon>", "unfolding decompose.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = \\<epsilon>) =\n    \\<epsilon>", "using all[OF someI[of \"\\<lambda> x. x \\<in> lists G\\<^sub>+ \\<and> concat x = \\<epsilon>\", OF ex]]"], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> lists G\\<^sub>+ \\<and> concat x = \\<epsilon>) =\n  \\<epsilon>\n\ngoal (1 subgoal):\n 1. (SOME us. us \\<in> lists G\\<^sub>+ \\<and> concat us = \\<epsilon>) =\n    \\<epsilon>", "."], ["proof (state)\nthis:\n  Dec G \\<epsilon> = \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dec_nemp: \"u \\<in> \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow>  Dec G u \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow>\n    Dec G u \\<noteq> \\<epsilon>", "using decI[of u G]"], ["proof (prove)\nusing this:\n  u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> concat (Dec G u) = u\n\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow>\n    Dec G u \\<noteq> \\<epsilon>", "by force"], ["", "lemma dec_nemp': \"u \\<noteq> \\<epsilon> \\<Longrightarrow> u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> Dec G u \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> \\<epsilon>; u \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Dec G u \\<noteq> \\<epsilon>", "using dec_nemp"], ["proof (prove)\nusing this:\n  ?u \\<in> \\<langle>?G\\<rangle>\\<^sub>+ \\<Longrightarrow>\n  Dec ?G ?u \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> \\<epsilon>; u \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Dec G u \\<noteq> \\<epsilon>", "by blast"], ["", "lemma dec_dom': \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> Dec G u \\<in> lists G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> Dec G u \\<in> lists G", "using decI'"], ["proof (prove)\nusing this:\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow>\n  Dec ?G ?u \\<in> lists ?G\\<^sub>+\n\ngoal (1 subgoal):\n 1. u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> Dec G u \\<in> lists G", "by auto"], ["", "lemma dec_hd: assumes \"u \\<noteq> \\<epsilon>\" \"u \\<in> \\<langle>G\\<rangle>\" shows \"hd (Dec G u) \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (Dec G u) \\<in> G", "using dec_nemp'[OF assms] dec_dom'[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>] lists_hd[of \"Dec G u\" G]"], ["proof (prove)\nusing this:\n  Dec G u \\<noteq> \\<epsilon>\n  Dec G u \\<in> lists G\n  \\<lbrakk>Dec G u \\<noteq> \\<epsilon>; Dec G u \\<in> lists G\\<rbrakk>\n  \\<Longrightarrow> hd (Dec G u) \\<in> G\n\ngoal (1 subgoal):\n 1. hd (Dec G u) \\<in> G", "by blast"], ["", "lemma non_gen_dec: \"u \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> u \\<notin> G \\<Longrightarrow> Dec G u  \\<noteq> [u]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> \\<langle>G\\<rangle>; u \\<notin> G\\<rbrakk>\n    \\<Longrightarrow> Dec G u \\<noteq> [u]", "using decI'  Cons_in_lists_iff"], ["proof (prove)\nusing this:\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow>\n  Dec ?G ?u \\<in> lists ?G\\<^sub>+\n  (?x # ?xs \\<in> lists ?A) = (?x \\<in> ?A \\<and> ?xs \\<in> lists ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> \\<langle>G\\<rangle>; u \\<notin> G\\<rbrakk>\n    \\<Longrightarrow> Dec G u \\<noteq> [u]", "by fastforce"], ["", "subsection \\<open>Refinement into a specific decomposition\\<close>"], ["", "text\\<open>We extend the decomposition to lists of words. This can be seen as a refinement of a previous decomposition of some word.\\<close>"], ["", "fun refine :: \"'a list set \\<Rightarrow> 'a list list \\<Rightarrow> 'a list list\" (\"Ref _ _\" [51,51] 65) where\n  \"refine G us = concat(map (decompose G) us)\""], ["", "lemma ref_morph: \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> vs \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> refine G (us \\<cdot> vs) = refine G us \\<cdot> refine G vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle>;\n     vs \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ref G us \\<cdot> vs = (Ref G us) \\<cdot> Ref G vs", "using refine.simps"], ["proof (prove)\nusing this:\n  Ref ?G ?us = concat (map (decompose ?G) ?us)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle>;\n     vs \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ref G us \\<cdot> vs = (Ref G us) \\<cdot> Ref G vs", "by simp"], ["", "lemma ref_morph_plus: \"us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow> vs \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ \\<Longrightarrow> refine G (us \\<cdot> vs) = refine G us \\<cdot> refine G vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+;\n     vs \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\\<rbrakk>\n    \\<Longrightarrow> Ref G us \\<cdot> vs = (Ref G us) \\<cdot> Ref G vs", "using refine.simps"], ["proof (prove)\nusing this:\n  Ref ?G ?us = concat (map (decompose ?G) ?us)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+;\n     vs \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\\<rbrakk>\n    \\<Longrightarrow> Ref G us \\<cdot> vs = (Ref G us) \\<cdot> Ref G vs", "by simp"], ["", "lemma ref_pop_hd: \"us \\<noteq> \\<epsilon> \\<Longrightarrow> us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> refine G us = decompose G (hd us) \\<cdot> refine G (tl us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<noteq> \\<epsilon>;\n     us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ref G us = (Dec G hd us) \\<cdot> Ref G tl us", "unfolding  refine.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<noteq> \\<epsilon>;\n     us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> concat (map (decompose G) us) =\n                      (Dec G hd us) \\<cdot>\n                      concat (map (decompose G) (tl us))", "using list.simps(9)[of \"decompose G\" \"hd us\" \"tl us\"]"], ["proof (prove)\nusing this:\n  map (decompose G) (hd us # tl us) =\n  (Dec G hd us) # map (decompose G) (tl us)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<noteq> \\<epsilon>;\n     us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> concat (map (decompose G) us) =\n                      (Dec G hd us) \\<cdot>\n                      concat (map (decompose G) (tl us))", "by simp"], ["", "lemma ref_in: \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> (Ref G us) \\<in> lists G\\<^sub>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n    Ref G us \\<in> lists G\\<^sub>+", "proof (induction us, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a us.\n       \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n                Ref G us \\<in> lists G\\<^sub>+;\n        a # us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> Ref G a # us \\<in> lists G\\<^sub>+", "case (Cons a us)"], ["proof (state)\nthis:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  Ref G us \\<in> lists G\\<^sub>+\n  a # us \\<in> lists \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a us.\n       \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n                Ref G us \\<in> lists G\\<^sub>+;\n        a # us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> Ref G a # us \\<in> lists G\\<^sub>+", "then"], ["proof (chain)\npicking this:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  Ref G us \\<in> lists G\\<^sub>+\n  a # us \\<in> lists \\<langle>G\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  Ref G us \\<in> lists G\\<^sub>+\n  a # us \\<in> lists \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. Ref G a # us \\<in> lists G\\<^sub>+", "using Cons.IH Cons.prems decI'"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  Ref G us \\<in> lists G\\<^sub>+\n  a # us \\<in> lists \\<langle>G\\<rangle>\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  Ref G us \\<in> lists G\\<^sub>+\n  a # us \\<in> lists \\<langle>G\\<rangle>\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow>\n  Dec ?G ?u \\<in> lists ?G\\<^sub>+\n\ngoal (1 subgoal):\n 1. Ref G a # us \\<in> lists G\\<^sub>+", "by auto"], ["proof (state)\nthis:\n  Ref G a # us \\<in> lists G\\<^sub>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ref: \"us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow> concat (Ref G us) = concat us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n    concat (Ref G us) = concat us", "proof (induction us, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a us.\n       \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n                concat (Ref G us) = concat us;\n        a # us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> concat (Ref G a # us) = concat (a # us)", "case (Cons a us)"], ["proof (state)\nthis:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  concat (Ref G us) = concat us\n  a # us \\<in> lists \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a us.\n       \\<lbrakk>us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n                concat (Ref G us) = concat us;\n        a # us \\<in> lists \\<langle>G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> concat (Ref G a # us) = concat (a # us)", "then"], ["proof (chain)\npicking this:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  concat (Ref G us) = concat us\n  a # us \\<in> lists \\<langle>G\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  concat (Ref G us) = concat us\n  a # us \\<in> lists \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. concat (Ref G a # us) = concat (a # us)", "using Cons.IH Cons.prems decI"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  concat (Ref G us) = concat us\n  a # us \\<in> lists \\<langle>G\\<rangle>\n  us \\<in> lists \\<langle>G\\<rangle> \\<Longrightarrow>\n  concat (Ref G us) = concat us\n  a # us \\<in> lists \\<langle>G\\<rangle>\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow> concat (Dec ?G ?u) = ?u\n\ngoal (1 subgoal):\n 1. concat (Ref G a # us) = concat (a # us)", "by auto"], ["proof (state)\nthis:\n  concat (Ref G a # us) = concat (a # us)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ref_gen: \"us \\<in> lists B \\<Longrightarrow> B \\<subseteq> \\<langle>G\\<rangle> \\<Longrightarrow> Ref G us \\<in> \\<langle>decompose G ` B\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists B; B \\<subseteq> \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ref G us \\<in> \\<langle>decompose G ` B\\<rangle>", "by (induct us, auto)"], ["", "lemma emp_ref: assumes \"us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\" and  \"Ref G us = \\<epsilon>\" shows \"us = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us = \\<epsilon>", "using emp_concat_emp[OF \\<open>us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\\<close>]\n     ref[OF lists_drop_emp[OF assms(1)], unfolded \\<open>Ref G us = \\<epsilon>\\<close> concat.simps(1),symmetric]"], ["proof (prove)\nusing this:\n  concat us = \\<epsilon> \\<Longrightarrow> us = \\<epsilon>\n  concat us = \\<epsilon>\n\ngoal (1 subgoal):\n 1. us = \\<epsilon>", "by blast"], ["", "lemma sing_ref_sing: \n  assumes \"us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\" and \"refine G us = [b]\" \n  shows \"us = [b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us = [b]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. us = [b]", "have \"us \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<noteq> \\<epsilon>", "using \\<open>refine G us = [b]\\<close>"], ["proof (prove)\nusing this:\n  Ref G us = [b]\n\ngoal (1 subgoal):\n 1. us \\<noteq> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. us = [b]", "have \"tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\" and \"hd us \\<in> \\<langle>G\\<rangle>\\<^sub>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ &&&\n    hd us \\<in> \\<langle>G\\<rangle>\\<^sub>+", "using list.collapse[OF \\<open>us \\<noteq> \\<epsilon>\\<close>]  \\<open>us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\\<close> Cons_in_lists_iff[of \"hd us\" \"tl us\" \"\\<langle>G\\<rangle>\\<^sub>+\"]"], ["proof (prove)\nusing this:\n  hd us # tl us = us\n  us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\n  (hd us # tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+) =\n  (hd us \\<in> \\<langle>G\\<rangle>\\<^sub>+ \\<and>\n   tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+)\n\ngoal (1 subgoal):\n 1. tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ &&&\n    hd us \\<in> \\<langle>G\\<rangle>\\<^sub>+", "by auto"], ["proof (state)\nthis:\n  tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\n  hd us \\<in> \\<langle>G\\<rangle>\\<^sub>+\n\ngoal (1 subgoal):\n 1. us = [b]", "have \"Dec G (hd us) \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec G hd us \\<noteq> \\<epsilon>", "using dec_nemp[OF \\<open>hd us \\<in> \\<langle>G\\<rangle>\\<^sub>+\\<close>]"], ["proof (prove)\nusing this:\n  Dec G hd us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. Dec G hd us \\<noteq> \\<epsilon>", "."], ["proof (state)\nthis:\n  Dec G hd us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. us = [b]", "have \"us \\<in> lists \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>G\\<rangle>", "using \\<open>us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\\<close> lists_drop_emp"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\n  ?us \\<in> lists ?C\\<^sub>+ \\<Longrightarrow> ?us \\<in> lists ?C\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>G\\<rangle>", "by auto"], ["proof (state)\nthis:\n  us \\<in> lists \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. us = [b]", "have \"concat us = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat us = b", "using \\<open>us \\<in> lists \\<langle>G\\<rangle>\\<close> assms(2) ref"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>G\\<rangle>\n  Ref G us = [b]\n  ?us \\<in> lists \\<langle>?G\\<rangle> \\<Longrightarrow>\n  concat (Ref ?G ?us) = concat ?us\n\ngoal (1 subgoal):\n 1. concat us = b", "by force"], ["proof (state)\nthis:\n  concat us = b\n\ngoal (1 subgoal):\n 1. us = [b]", "have \"refine G (tl us) = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref G tl us = \\<epsilon>", "using ref_pop_hd[OF \\<open>us \\<noteq> \\<epsilon>\\<close> \\<open>us \\<in> lists \\<langle>G\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  Ref G us = (Dec G hd us) \\<cdot> Ref G tl us\n\ngoal (1 subgoal):\n 1. Ref G tl us = \\<epsilon>", "unfolding  \\<open>refine G us = [b]\\<close>"], ["proof (prove)\nusing this:\n  [b] = (Dec G hd us) \\<cdot> Ref G tl us\n\ngoal (1 subgoal):\n 1. Ref G tl us = \\<epsilon>", "using \\<open>Dec G (hd us) \\<noteq> \\<epsilon>\\<close> Cons_eq_append_conv[of b \\<epsilon> \"(Dec G (hd us))\" \"(Ref G (tl us))\"]\n      Cons_eq_append_conv[of b \\<epsilon> \"(Dec G (hd us))\" \"(Ref G (tl us))\"]  append_is_Nil_conv[of _ \"(Ref G (tl us))\"]"], ["proof (prove)\nusing this:\n  [b] = (Dec G hd us) \\<cdot> Ref G tl us\n  Dec G hd us \\<noteq> \\<epsilon>\n  ([b] = (Dec G hd us) \\<cdot> Ref G tl us) =\n  (Dec G hd us = \\<epsilon> \\<and> [b] = Ref G tl us \\<or>\n   (\\<exists>ys'.\n       b # ys' = Dec G hd us \\<and> \\<epsilon> = ys' \\<cdot> Ref G tl us))\n  ([b] = (Dec G hd us) \\<cdot> Ref G tl us) =\n  (Dec G hd us = \\<epsilon> \\<and> [b] = Ref G tl us \\<or>\n   (\\<exists>ys'.\n       b # ys' = Dec G hd us \\<and> \\<epsilon> = ys' \\<cdot> Ref G tl us))\n  (?xs \\<cdot> Ref G tl us = \\<epsilon>) =\n  (?xs = \\<epsilon> \\<and> Ref G tl us = \\<epsilon>)\n\ngoal (1 subgoal):\n 1. Ref G tl us = \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  Ref G tl us = \\<epsilon>\n\ngoal (1 subgoal):\n 1. us = [b]", "from  emp_ref[OF \\<open>tl us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+\\<close> this, symmetric]"], ["proof (chain)\npicking this:\n  \\<epsilon> = tl us", "have \"\\<epsilon> = tl us\""], ["proof (prove)\nusing this:\n  \\<epsilon> = tl us\n\ngoal (1 subgoal):\n 1. \\<epsilon> = tl us", "."], ["proof (state)\nthis:\n  \\<epsilon> = tl us\n\ngoal (1 subgoal):\n 1. us = [b]", "from this[unfolded Nil_tl]"], ["proof (chain)\npicking this:\n  us = \\<epsilon> \\<or> (\\<exists>x. us = [x])", "show ?thesis"], ["proof (prove)\nusing this:\n  us = \\<epsilon> \\<or> (\\<exists>x. us = [x])\n\ngoal (1 subgoal):\n 1. us = [b]", "using \\<open>us \\<noteq> \\<epsilon>\\<close> \\<open>concat us = b\\<close>"], ["proof (prove)\nusing this:\n  us = \\<epsilon> \\<or> (\\<exists>x. us = [x])\n  us \\<noteq> \\<epsilon>\n  concat us = b\n\ngoal (1 subgoal):\n 1. us = [b]", "by auto"], ["proof (state)\nthis:\n  us = [b]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ref_ex: assumes \"Q \\<subseteq> \\<langle>G\\<rangle>\" and \"us \\<in> lists Q\" \n  shows \"Ref G us \\<in> lists G\\<^sub>+\" and \"concat (Ref G us) = concat us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref G us \\<in> lists G\\<^sub>+ &&& concat (Ref G us) = concat us", "using  ref_in[OF sub_lists_mono[OF assms]] ref[OF sub_lists_mono[OF assms]]"], ["proof (prove)\nusing this:\n  Ref G us \\<in> lists G\\<^sub>+\n  concat (Ref G us) = concat us\n\ngoal (1 subgoal):\n 1. Ref G us \\<in> lists G\\<^sub>+ &&& concat (Ref G us) = concat us", "."], ["", "section \"Basis\""], ["", "text\\<open>An important property of monoids of words is that they have a unique minimal generating set. Which is the set consisting of indecomposable elements.\\<close>"], ["", "text\\<open>The simple element is defined as a word which has only trivial decomposition into generators: a singleton.\\<close>"], ["", "function simple_element :: \"'a list \\<Rightarrow> 'a list set  \\<Rightarrow> bool\" (\" _ \\<in>B _ \" [51,51] 50) where\n  \"simple_element b G = (b \\<in> G \\<and> (\\<forall> us. us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow> \\<^bold>|us\\<^bold>| = 1))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>b G. x = (b, G) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>b G ba Ga.\n       (b, G) = (ba, Ga) \\<Longrightarrow>\n       (b \\<in> G \\<and>\n        (\\<forall>us.\n            us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n            \\<^bold>|us\\<^bold>| = 1)) =\n       (ba \\<in> Ga \\<and>\n        (\\<forall>us.\n            us \\<in> lists Ga\\<^sub>+ \\<and>\n            concat us = ba \\<longrightarrow>\n            \\<^bold>|us\\<^bold>| = 1))", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>b G. x = (b, G) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>b G ba Ga.\n       (b, G) = (ba, Ga) \\<Longrightarrow>\n       (b \\<in> G \\<and>\n        (\\<forall>us.\n            us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n            \\<^bold>|us\\<^bold>| = 1)) =\n       (ba \\<in> Ga \\<and>\n        (\\<forall>us.\n            us \\<in> lists Ga\\<^sub>+ \\<and>\n            concat us = ba \\<longrightarrow>\n            \\<^bold>|us\\<^bold>| = 1))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All simple_element_dom", "using \"termination\""], ["proof (prove)\nusing this:\n  wf ?R \\<Longrightarrow> All simple_element_dom\n\ngoal (1 subgoal):\n 1. All simple_element_dom", "by blast"], ["", "lemma simp_el_el: \"b \\<in>B G \\<Longrightarrow> b \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  b \\<in>B G  \\<Longrightarrow> b \\<in> G", "unfolding simple_element.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> G \\<and>\n    (\\<forall>us.\n        us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n        \\<^bold>|us\\<^bold>| = 1) \\<Longrightarrow>\n    b \\<in> G", "by blast"], ["", "lemma simp_elD: \"b \\<in>B G \\<Longrightarrow> us \\<in> lists G\\<^sub>+ \\<Longrightarrow> concat us = b \\<Longrightarrow> \\<^bold>|us\\<^bold>| = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk> b \\<in>B G ; us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n    \\<Longrightarrow> \\<^bold>|us\\<^bold>| = 1", "unfolding simple_element.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> G \\<and>\n             (\\<forall>us.\n                 us \\<in> lists G\\<^sub>+ \\<and>\n                 concat us = b \\<longrightarrow>\n                 \\<^bold>|us\\<^bold>| = 1);\n     us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n    \\<Longrightarrow> \\<^bold>|us\\<^bold>| = 1", "by blast"], ["", "lemma simp_el_sing: assumes \"b \\<in>B G\" \"us \\<in> lists G\\<^sub>+\" \"concat us = b\" shows \"us = [b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us = [b]", "using simp_elD[OF assms] \\<open>concat us = b\\<close> concat_len_one sing_word"], ["proof (prove)\nusing this:\n  \\<^bold>|us\\<^bold>| = 1\n  concat us = b\n  \\<^bold>|?us\\<^bold>| = 1 \\<Longrightarrow> concat ?us = hd ?us\n  \\<^bold>|?us\\<^bold>| = 1 \\<Longrightarrow> [hd ?us] = ?us\n\ngoal (1 subgoal):\n 1. us = [b]", "by fastforce"], ["", "lemma nonsimp: \"us \\<in> lists G\\<^sub>+ \\<Longrightarrow> concat us \\<in>B G \\<Longrightarrow>  us = [concat us]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists G\\<^sub>+;  concat us \\<in>B G \\<rbrakk>\n    \\<Longrightarrow> us = [concat us]", "using simp_el_sing[of \"concat us\" G us]"], ["proof (prove)\nusing this:\n  \\<lbrakk> concat us \\<in>B G ; us \\<in> lists G\\<^sub>+;\n   concat us = concat us\\<rbrakk>\n  \\<Longrightarrow> us = [concat us]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists G\\<^sub>+;  concat us \\<in>B G \\<rbrakk>\n    \\<Longrightarrow> us = [concat us]", "unfolding simple_element.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>concat us \\<in> G \\<and>\n           (\\<forall>usa.\n               usa \\<in> lists G\\<^sub>+ \\<and>\n               concat usa = concat us \\<longrightarrow>\n               \\<^bold>|usa\\<^bold>| = 1);\n   us \\<in> lists G\\<^sub>+; concat us = concat us\\<rbrakk>\n  \\<Longrightarrow> us = [concat us]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<in> lists G\\<^sub>+;\n     concat us \\<in> G \\<and>\n     (\\<forall>usa.\n         usa \\<in> lists G\\<^sub>+ \\<and>\n         concat usa = concat us \\<longrightarrow>\n         \\<^bold>|usa\\<^bold>| = 1)\\<rbrakk>\n    \\<Longrightarrow> us = [concat us]", "by blast"], ["", "lemma emp_nonsimp: \"\\<not> \\<epsilon> \\<in>B G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not>  \\<epsilon> \\<in>B G", "unfolding simple_element.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<epsilon> \\<in> G \\<and>\n            (\\<forall>us.\n                us \\<in> lists G\\<^sub>+ \\<and>\n                concat us = \\<epsilon> \\<longrightarrow>\n                \\<^bold>|us\\<^bold>| = 1))", "using list.size(3) concat.simps(1) lists.Nil[of \"G\\<^sub>+\"]"], ["proof (prove)\nusing this:\n  \\<^bold>|\\<epsilon>\\<^bold>| = 0\n  concat \\<epsilon> = \\<epsilon>\n  \\<epsilon> \\<in> lists G\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<not> (\\<epsilon> \\<in> G \\<and>\n            (\\<forall>us.\n                us \\<in> lists G\\<^sub>+ \\<and>\n                concat us = \\<epsilon> \\<longrightarrow>\n                \\<^bold>|us\\<^bold>| = 1))", "by fastforce"], ["", "lemma basis_no_fact: assumes \"u \\<in> \\<langle>G\\<rangle>\" and \"v \\<in> \\<langle>G\\<rangle>\" and \"u \\<cdot> v \\<in>B G\" shows \"u = \\<epsilon> \\<or> v = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "have eq1: \"concat ((Dec G u) \\<cdot> (Dec G v)) = u \\<cdot> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ((Dec G u) \\<cdot> (Dec G v)) = u \\<cdot> v", "using concat_morph[of \"Dec G u\" \"Dec G v\",symmetric]"], ["proof (prove)\nusing this:\n  concat ((Dec G u) \\<cdot> (Dec G v)) =\n  concat (Dec G u) \\<cdot> concat (Dec G v)\n\ngoal (1 subgoal):\n 1. concat ((Dec G u) \\<cdot> (Dec G v)) = u \\<cdot> v", "unfolding decI[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>] decI[OF \\<open>v \\<in> \\<langle>G\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  concat ((Dec G u) \\<cdot> (Dec G v)) = u \\<cdot> v\n\ngoal (1 subgoal):\n 1. concat ((Dec G u) \\<cdot> (Dec G v)) = u \\<cdot> v", "."], ["proof (state)\nthis:\n  concat ((Dec G u) \\<cdot> (Dec G v)) = u \\<cdot> v\n\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "have eq2: \"(Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]", "using  \\<open>u \\<cdot> v \\<in>B G\\<close> nonsimp[of \"(Dec G u) \\<cdot> (Dec G v)\"]"], ["proof (prove)\nusing this:\n   u \\<cdot> v \\<in>B G \n  \\<lbrakk>(Dec G u) \\<cdot> (Dec G v) \\<in> lists ?G\\<^sub>+;\n    concat ((Dec G u) \\<cdot> (Dec G v)) \\<in>B ?G \\<rbrakk>\n  \\<Longrightarrow> (Dec G u) \\<cdot> (Dec G v) =\n                    [concat ((Dec G u) \\<cdot> (Dec G v))]\n\ngoal (1 subgoal):\n 1. (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]", "unfolding eq1 append_in_lists_conv[of \"(Dec G u)\" \"(Dec G v)\" \"G\\<^sub>+\"]"], ["proof (prove)\nusing this:\n   u \\<cdot> v \\<in>B G \n  \\<lbrakk>(Dec G u) \\<cdot> (Dec G v) \\<in> lists ?G\\<^sub>+;\n    u \\<cdot> v \\<in>B ?G \\<rbrakk>\n  \\<Longrightarrow> (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]\n\ngoal (1 subgoal):\n 1. (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]", "using decI'[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>] decI'[OF \\<open>v \\<in> \\<langle>G\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n   u \\<cdot> v \\<in>B G \n  \\<lbrakk>(Dec G u) \\<cdot> (Dec G v) \\<in> lists ?G\\<^sub>+;\n    u \\<cdot> v \\<in>B ?G \\<rbrakk>\n  \\<Longrightarrow> (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]\n  Dec G u \\<in> lists G\\<^sub>+\n  Dec G v \\<in> lists G\\<^sub>+\n\ngoal (1 subgoal):\n 1. (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]", "by (meson append_in_lists_conv)"], ["proof (state)\nthis:\n  (Dec G u) \\<cdot> (Dec G v) = [u \\<cdot> v]\n\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "have \"Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>", "using butlast_append[of \"Dec G u\" \"Dec G v\"]"], ["proof (prove)\nusing this:\n  butlast ((Dec G u) \\<cdot> (Dec G v)) =\n  (if Dec G v = \\<epsilon> then butlast (Dec G u)\n   else (Dec G u) \\<cdot> butlast (Dec G v))\n\ngoal (1 subgoal):\n 1. Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>", "unfolding eq2 butlast.simps(2)[of \"u\\<cdot>v\" \\<epsilon>]"], ["proof (prove)\nusing this:\n  (if \\<epsilon> = \\<epsilon> then \\<epsilon>\n   else (u \\<cdot> v) # butlast \\<epsilon>) =\n  (if Dec G v = \\<epsilon> then butlast (Dec G u)\n   else (Dec G u) \\<cdot> butlast (Dec G v))\n\ngoal (1 subgoal):\n 1. Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>", "using   Nil_is_append_conv[of \"Dec G u\" \"butlast (Dec G v)\"]"], ["proof (prove)\nusing this:\n  (if \\<epsilon> = \\<epsilon> then \\<epsilon>\n   else (u \\<cdot> v) # butlast \\<epsilon>) =\n  (if Dec G v = \\<epsilon> then butlast (Dec G u)\n   else (Dec G u) \\<cdot> butlast (Dec G v))\n  (\\<epsilon> = (Dec G u) \\<cdot> butlast (Dec G v)) =\n  (Dec G u = \\<epsilon> \\<and> butlast (Dec G v) = \\<epsilon>)\n\ngoal (1 subgoal):\n 1. Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>\n\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>\n\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "using decI[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>] decI[OF \\<open>v \\<in> \\<langle>G\\<rangle>\\<close>]\n      concat.simps(1)"], ["proof (prove)\nusing this:\n  Dec G u = \\<epsilon> \\<or> Dec G v = \\<epsilon>\n  concat (Dec G u) = u\n  concat (Dec G v) = v\n  concat \\<epsilon> = \\<epsilon>\n\ngoal (1 subgoal):\n 1. u = \\<epsilon> \\<or> v = \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  u = \\<epsilon> \\<or> v = \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simp_elI:\n  assumes \"b \\<in> G\" and \"b \\<noteq> \\<epsilon>\"  and all: \"\\<forall> u v. u \\<noteq> \\<epsilon> \\<and> u \\<in> \\<langle>G\\<rangle> \\<and> v \\<noteq> \\<epsilon> \\<and> v \\<in> \\<langle>G\\<rangle> \\<longrightarrow> u \\<cdot> v \\<noteq> b\"\n  shows \"b \\<in>B G\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  b \\<in>B G", "unfolding simple_element.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> G \\<and>\n    (\\<forall>us.\n        us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n        \\<^bold>|us\\<^bold>| = 1)", "proof(simp add: \\<open>b \\<in> G\\<close>, standard, standard, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "fix us"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "assume \"us \\<in> lists G\\<^sub>+\" \"concat us = b\""], ["proof (state)\nthis:\n  us \\<in> lists G\\<^sub>+\n  concat us = b\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "hence \"us \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  us \\<in> lists G\\<^sub>+\n  concat us = b\n\ngoal (1 subgoal):\n 1. us \\<noteq> \\<epsilon>", "using \\<open>b \\<noteq> \\<epsilon>\\<close> concat.simps(1)"], ["proof (prove)\nusing this:\n  us \\<in> lists G\\<^sub>+\n  concat us = b\n  b \\<noteq> \\<epsilon>\n  concat \\<epsilon> = \\<epsilon>\n\ngoal (1 subgoal):\n 1. us \\<noteq> \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "hence \"hd us \\<in> \\<langle>G\\<rangle>\" and \"hd us \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. hd us \\<in> \\<langle>G\\<rangle> &&& hd us \\<noteq> \\<epsilon>", "using \\<open>us \\<in> lists G\\<^sub>+\\<close> lists_hd  gen_in"], ["proof (prove)\nusing this:\n  us \\<noteq> \\<epsilon>\n  us \\<in> lists G\\<^sub>+\n  \\<lbrakk>?us \\<noteq> \\<epsilon>; ?us \\<in> lists ?Q\\<rbrakk>\n  \\<Longrightarrow> hd ?us \\<in> ?Q\n  ?w \\<in> ?G \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. hd us \\<in> \\<langle>G\\<rangle> &&& hd us \\<noteq> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  hd us \\<in> \\<langle>G\\<rangle>\n  hd us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "have \"tl us = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl us = \\<epsilon>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. tl us \\<noteq> \\<epsilon> \\<Longrightarrow> False", "assume \"tl us \\<noteq> \\<epsilon>\""], ["proof (state)\nthis:\n  tl us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. tl us \\<noteq> \\<epsilon> \\<Longrightarrow> False", "from nemp_concat_hull[of \"tl us\", OF this tl_lists[OF \\<open>us \\<in> lists G\\<^sub>+\\<close>]]"], ["proof (chain)\npicking this:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>", "show False"], ["proof (prove)\nusing this:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. False", "using all \\<open>hd us \\<noteq> \\<epsilon>\\<close> \\<open>hd us \\<in> \\<langle>G\\<rangle>\\<close>  concat.simps(2)[of \"hd us\" \"tl us\", symmetric]"], ["proof (prove)\nusing this:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>\n  \\<forall>u v.\n     u \\<noteq> \\<epsilon> \\<and>\n     u \\<in> \\<langle>G\\<rangle> \\<and>\n     v \\<noteq> \\<epsilon> \\<and>\n     v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n     u \\<cdot> v \\<noteq> b\n  hd us \\<noteq> \\<epsilon>\n  hd us \\<in> \\<langle>G\\<rangle>\n  hd us \\<cdot> concat (tl us) = concat (hd us # tl us)\n\ngoal (1 subgoal):\n 1. False", "unfolding list.collapse[OF \\<open>us \\<noteq> \\<epsilon>\\<close>] \\<open>concat us = b\\<close>"], ["proof (prove)\nusing this:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>\n  \\<forall>u v.\n     u \\<noteq> \\<epsilon> \\<and>\n     u \\<in> \\<langle>G\\<rangle> \\<and>\n     v \\<noteq> \\<epsilon> \\<and>\n     v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n     u \\<cdot> v \\<noteq> b\n  hd us \\<noteq> \\<epsilon>\n  hd us \\<in> \\<langle>G\\<rangle>\n  hd us \\<cdot> concat (tl us) = b\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tl us = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "hence \"\\<^bold>|us\\<^bold>| = 1\""], ["proof (prove)\nusing this:\n  tl us = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<^bold>|us\\<^bold>| = 1", "using \\<open>concat us = b\\<close> assms(2) long_list_tl nonsing_concat_len"], ["proof (prove)\nusing this:\n  tl us = \\<epsilon>\n  concat us = b\n  b \\<noteq> \\<epsilon>\n  1 < \\<^bold>|?us\\<^bold>| \\<Longrightarrow> tl ?us \\<noteq> \\<epsilon>\n  \\<lbrakk>\\<^bold>|?us\\<^bold>| \\<noteq> 1;\n   concat ?us \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> 1 < \\<^bold>|?us\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|us\\<^bold>| = 1", "by blast"], ["proof (state)\nthis:\n  \\<^bold>|us\\<^bold>| = 1\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       \\<lbrakk>us \\<in> lists G\\<^sub>+; concat us = b\\<rbrakk>\n       \\<Longrightarrow> \\<^bold>|us\\<^bold>| = Suc 0", "thus \"\\<^bold>|us\\<^bold>| = Suc 0\""], ["proof (prove)\nusing this:\n  \\<^bold>|us\\<^bold>| = 1\n\ngoal (1 subgoal):\n 1. \\<^bold>|us\\<^bold>| = Suc 0", "by (simp add: \\<open>b \\<in> G\\<close>)"], ["proof (state)\nthis:\n  \\<^bold>|us\\<^bold>| = Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simp_el_indecomp: \n  assumes \"b \\<in>B G\" \n  shows \"b \\<in> G\" and  \"b \\<noteq> \\<epsilon>\" and \"\\<forall> u v. u \\<noteq> \\<epsilon> \\<and> u \\<in> \\<langle>G\\<rangle> \\<and> v \\<noteq> \\<epsilon> \\<and> v \\<in> \\<langle>G\\<rangle> \\<longrightarrow> u \\<cdot> v \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> G &&&\n    b \\<noteq> \\<epsilon> &&&\n    \\<forall>u v.\n       u \\<noteq> \\<epsilon> \\<and>\n       u \\<in> \\<langle>G\\<rangle> \\<and>\n       v \\<noteq> \\<epsilon> \\<and>\n       v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n       u \\<cdot> v \\<noteq> b", "using assms basis_no_fact emp_nonsimp simple_element.simps"], ["proof (prove)\nusing this:\n   b \\<in>B G \n  \\<lbrakk>?u \\<in> \\<langle>?G\\<rangle>; ?v \\<in> \\<langle>?G\\<rangle>;\n    ?u \\<cdot> ?v \\<in>B ?G \\<rbrakk>\n  \\<Longrightarrow> ?u = \\<epsilon> \\<or> ?v = \\<epsilon>\n  \\<not>  \\<epsilon> \\<in>B ?G \n  ( ?b \\<in>B ?G ) =\n  (?b \\<in> ?G \\<and>\n   (\\<forall>us.\n       us \\<in> lists ?G\\<^sub>+ \\<and> concat us = ?b \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1))\n\ngoal (1 subgoal):\n 1. b \\<in> G &&&\n    b \\<noteq> \\<epsilon> &&&\n    \\<forall>u v.\n       u \\<noteq> \\<epsilon> \\<and>\n       u \\<in> \\<langle>G\\<rangle> \\<and>\n       v \\<noteq> \\<epsilon> \\<and>\n       v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n       u \\<cdot> v \\<noteq> b", "by blast+"], ["", "text\\<open>We are ready to define the \\emph{basis} as the set of all simple elements.\\<close>"], ["", "fun basis :: \"'a list set  \\<Rightarrow> 'a list set\" (\"\\<BB> _\" [51] ) where\n  basisdef:  \"basis G = {x. x \\<in>B G}\""], ["", "lemma basisI: \"x \\<in>B G \\<Longrightarrow> x \\<in> \\<BB> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  x \\<in>B G  \\<Longrightarrow> x \\<in> \\<BB> G", "by simp"], ["", "lemma basisD: \"x \\<in> \\<BB> G \\<Longrightarrow> x \\<in>B G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<BB> G \\<Longrightarrow>  x \\<in>B G", "by simp"], ["", "lemma emp_not_basis: \"x \\<in> \\<BB> G \\<Longrightarrow> x \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<BB> G \\<Longrightarrow> x \\<noteq> \\<epsilon>", "using basisD emp_nonsimp"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<BB> ?G \\<Longrightarrow>  ?x \\<in>B ?G \n  \\<not>  \\<epsilon> \\<in>B ?G \n\ngoal (1 subgoal):\n 1. x \\<in> \\<BB> G \\<Longrightarrow> x \\<noteq> \\<epsilon>", "by blast"], ["", "lemma basis_sub: \"\\<BB> G \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<BB> G \\<subseteq> G", "using  basisdef"], ["proof (prove)\nusing this:\n  \\<BB> ?G = {x.  x \\<in>B ?G }\n\ngoal (1 subgoal):\n 1. \\<BB> G \\<subseteq> G", "by simp"], ["", "lemma basis_drop_emp: \"(\\<BB> G)\\<^sub>+ = \\<BB> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<BB> G\\<^sub>+ = \\<BB> G", "using emp_not_basis"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<BB> ?G \\<Longrightarrow> ?x \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<BB> G\\<^sub>+ = \\<BB> G", "by blast"], ["", "lemma simp_el_hull':  assumes \"b \\<in>B \\<langle>G\\<rangle>\"  shows \"b \\<in>B G\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  b \\<in>B G", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1.  b \\<in>B G", "have all: \"\\<forall>us. us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow> \\<^bold>|us\\<^bold>| = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us.\n       us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "using assms lists_gen_to_hull"], ["proof (prove)\nusing this:\n   b \\<in>B \\<langle>G\\<rangle> \n  ?us \\<in> lists ?G\\<^sub>+ \\<Longrightarrow>\n  ?us \\<in> lists \\<langle>?G\\<rangle>\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<forall>us.\n       us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "unfolding simple_element.simps"], ["proof (prove)\nusing this:\n  b \\<in> \\<langle>G\\<rangle> \\<and>\n  (\\<forall>us.\n      us \\<in> lists \\<langle>G\\<rangle>\\<^sub>+ \\<and>\n      concat us = b \\<longrightarrow>\n      \\<^bold>|us\\<^bold>| = 1)\n  ?us \\<in> lists ?G\\<^sub>+ \\<Longrightarrow>\n  ?us \\<in> lists \\<langle>?G\\<rangle>\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<forall>us.\n       us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "by metis"], ["proof (state)\nthis:\n  \\<forall>us.\n     us \\<in> lists G\\<^sub>+ \\<and> concat us = b \\<longrightarrow>\n     \\<^bold>|us\\<^bold>| = 1\n\ngoal (1 subgoal):\n 1.  b \\<in>B G", "have \"b \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> \\<langle>G\\<rangle>", "using assms simp_elD"], ["proof (prove)\nusing this:\n   b \\<in>B \\<langle>G\\<rangle> \n  \\<lbrakk> ?b \\<in>B ?G ; ?us \\<in> lists ?G\\<^sub>+;\n   concat ?us = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<^bold>|?us\\<^bold>| = 1\n\ngoal (1 subgoal):\n 1. b \\<in> \\<langle>G\\<rangle>", "by auto"], ["proof (state)\nthis:\n  b \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1.  b \\<in>B G", "obtain bs where \"bs \\<in> lists G\\<^sub>+\" and \"concat bs = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>bs \\<in> lists G\\<^sub>+; concat bs = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  dec_ex[OF \\<open>b \\<in> \\<langle>G\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> concat us = b\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>bs \\<in> lists G\\<^sub>+; concat bs = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bs \\<in> lists G\\<^sub>+\n  concat bs = b\n\ngoal (1 subgoal):\n 1.  b \\<in>B G", "have \"b \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> G", "using lists_drop_emp[OF \\<open>bs \\<in> lists G\\<^sub>+\\<close>] \n          lists_gen_to_hull[OF \\<open>bs \\<in> lists G\\<^sub>+\\<close>, THEN nonsimp[of bs \"\\<langle>G\\<rangle>\"], \n          unfolded \\<open>concat bs = b\\<close>, OF \\<open>b \\<in>B \\<langle>G\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  bs \\<in> lists G\n  bs = [b]\n\ngoal (1 subgoal):\n 1. b \\<in> G", "by simp"], ["proof (state)\nthis:\n  b \\<in> G\n\ngoal (1 subgoal):\n 1.  b \\<in>B G", "thus \"b \\<in>B G\""], ["proof (prove)\nusing this:\n  b \\<in> G\n\ngoal (1 subgoal):\n 1.  b \\<in>B G", "by (simp add: all)"], ["proof (state)\nthis:\n   b \\<in>B G \n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simp_el_hull:  assumes \"b \\<in>B G\" shows \"b \\<in>B \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  b \\<in>B \\<langle>G\\<rangle>", "using simp_elI[of b \"\\<langle>G\\<rangle>\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<in> \\<langle>G\\<rangle>; b \\<noteq> \\<epsilon>;\n   \\<forall>u v.\n      u \\<noteq> \\<epsilon> \\<and>\n      u \\<in> \\<langle>\\<langle>G\\<rangle>\\<rangle> \\<and>\n      v \\<noteq> \\<epsilon> \\<and>\n      v \\<in> \\<langle>\\<langle>G\\<rangle>\\<rangle> \\<longrightarrow>\n      u \\<cdot> v \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow>  b \\<in>B \\<langle>G\\<rangle> \n\ngoal (1 subgoal):\n 1.  b \\<in>B \\<langle>G\\<rangle>", "unfolding self_gen"], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<in> \\<langle>G\\<rangle>; b \\<noteq> \\<epsilon>;\n   \\<forall>u v.\n      u \\<noteq> \\<epsilon> \\<and>\n      u \\<in> \\<langle>G\\<rangle> \\<and>\n      v \\<noteq> \\<epsilon> \\<and>\n      v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n      u \\<cdot> v \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow>  b \\<in>B \\<langle>G\\<rangle> \n\ngoal (1 subgoal):\n 1.  b \\<in>B \\<langle>G\\<rangle>", "using assms gen_in simp_el_indecomp[OF \\<open>b \\<in>B G\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<in> \\<langle>G\\<rangle>; b \\<noteq> \\<epsilon>;\n   \\<forall>u v.\n      u \\<noteq> \\<epsilon> \\<and>\n      u \\<in> \\<langle>G\\<rangle> \\<and>\n      v \\<noteq> \\<epsilon> \\<and>\n      v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n      u \\<cdot> v \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow>  b \\<in>B \\<langle>G\\<rangle> \n   b \\<in>B G \n  ?w \\<in> ?G \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\n  b \\<in> G\n  b \\<noteq> \\<epsilon>\n  \\<forall>u v.\n     u \\<noteq> \\<epsilon> \\<and>\n     u \\<in> \\<langle>G\\<rangle> \\<and>\n     v \\<noteq> \\<epsilon> \\<and>\n     v \\<in> \\<langle>G\\<rangle> \\<longrightarrow>\n     u \\<cdot> v \\<noteq> b\n\ngoal (1 subgoal):\n 1.  b \\<in>B \\<langle>G\\<rangle>", "by auto"], ["", "lemma concat_tl_basis: \"x # xs \\<in> lists \\<BB> G \\<Longrightarrow> concat xs \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs \\<in> lists \\<BB> G \\<Longrightarrow>\n    concat xs \\<in> \\<langle>G\\<rangle>", "unfolding hull_concat_lists"], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs \\<in> lists \\<BB> G \\<Longrightarrow>\n    concat xs \\<in> concat ` lists G", "by auto"], ["", "text\\<open>The basis generates the hull\\<close>"], ["", "lemma set_concat_len: assumes \"us \\<in> lists G\\<^sub>+\" \"1 < \\<^bold>|us\\<^bold>|\" \"u \\<in> set us\" shows \"\\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "obtain x y where \"us = x \\<cdot> [u] \\<cdot> y\" and \"x \\<cdot> y \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>us = x \\<cdot> [u] \\<cdot> y;\n         x \\<cdot> y \\<noteq> \\<epsilon>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_long[OF \\<open>1 < \\<^bold>|us\\<^bold>|\\<close> \\<open>u \\<in> set us\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>xs ys.\n      \\<lbrakk>us = xs \\<cdot> [u] \\<cdot> ys;\n       xs \\<cdot> ys \\<noteq> \\<epsilon>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>us = x \\<cdot> [u] \\<cdot> y;\n         x \\<cdot> y \\<noteq> \\<epsilon>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  us = x \\<cdot> [u] \\<cdot> y\n  x \\<cdot> y \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "hence \"x \\<cdot> y \\<in> lists G\\<^sub>+\""], ["proof (prove)\nusing this:\n  us = x \\<cdot> [u] \\<cdot> y\n  x \\<cdot> y \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<in> lists G\\<^sub>+", "using \\<open>us \\<in> lists G\\<^sub>+\\<close>"], ["proof (prove)\nusing this:\n  us = x \\<cdot> [u] \\<cdot> y\n  x \\<cdot> y \\<noteq> \\<epsilon>\n  us \\<in> lists G\\<^sub>+\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<in> lists G\\<^sub>+", "by auto"], ["proof (state)\nthis:\n  x \\<cdot> y \\<in> lists G\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "hence \"\\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<in> lists G\\<^sub>+\n\ngoal (1 subgoal):\n 1. \\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0", "using \\<open>x \\<cdot> y \\<noteq> \\<epsilon>\\<close> in_lists_conv_set"], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<in> lists G\\<^sub>+\n  x \\<cdot> y \\<noteq> \\<epsilon>\n  (?xs \\<in> lists ?A) = (\\<forall>x\\<in>set ?xs. x \\<in> ?A)\n\ngoal (1 subgoal):\n 1. \\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  \\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "hence \"\\<^bold>|concat us\\<^bold>| = \\<^bold>|u\\<^bold>| + \\<^bold>|concat x\\<^bold>| + \\<^bold>|concat y\\<^bold>|\""], ["proof (prove)\nusing this:\n  \\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<^bold>|concat us\\<^bold>| =\n    \\<^bold>|u\\<^bold>| + \\<^bold>|concat x\\<^bold>| +\n    \\<^bold>|concat y\\<^bold>|", "using length_append \\<open>us = x \\<cdot> [u] \\<cdot> y\\<close>"], ["proof (prove)\nusing this:\n  \\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0\n  \\<^bold>|?xs \\<cdot> ?ys\\<^bold>| =\n  \\<^bold>|?xs\\<^bold>| + \\<^bold>|?ys\\<^bold>|\n  us = x \\<cdot> [u] \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<^bold>|concat us\\<^bold>| =\n    \\<^bold>|u\\<^bold>| + \\<^bold>|concat x\\<^bold>| +\n    \\<^bold>|concat y\\<^bold>|", "by simp"], ["proof (state)\nthis:\n  \\<^bold>|concat us\\<^bold>| =\n  \\<^bold>|u\\<^bold>| + \\<^bold>|concat x\\<^bold>| +\n  \\<^bold>|concat y\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>|concat us\\<^bold>| =\n  \\<^bold>|u\\<^bold>| + \\<^bold>|concat x\\<^bold>| +\n  \\<^bold>|concat y\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "using \\<open>\\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<^bold>|concat us\\<^bold>| =\n  \\<^bold>|u\\<^bold>| + \\<^bold>|concat x\\<^bold>| +\n  \\<^bold>|concat y\\<^bold>|\n  \\<^bold>|concat (x \\<cdot> y)\\<^bold>| \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|", "by auto"], ["proof (state)\nthis:\n  \\<^bold>|u\\<^bold>| < \\<^bold>|concat us\\<^bold>|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_simp_dec: assumes \"w \\<notin> \\<BB> G\" \"w \\<noteq> \\<epsilon>\" \"w \\<in> G\"\n  obtains us where \"us \\<in> lists G\\<^sub>+\" \"1 < \\<^bold>|us\\<^bold>|\" \"concat us = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists G\\<^sub>+; 1 < \\<^bold>|us\\<^bold>|;\n         concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>w \\<noteq> \\<epsilon>\\<close> \\<open>w \\<in> G\\<close> \\<open>w \\<notin> \\<BB> G\\<close> nonsing_concat_len  basisI[of w G, unfolded simple_element.simps]"], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon>\n  w \\<in> G\n  w \\<notin> \\<BB> G\n  \\<lbrakk>\\<^bold>|?us\\<^bold>| \\<noteq> 1;\n   concat ?us \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> 1 < \\<^bold>|?us\\<^bold>|\n  w \\<in> G \\<and>\n  (\\<forall>us.\n      us \\<in> lists G\\<^sub>+ \\<and> concat us = w \\<longrightarrow>\n      \\<^bold>|us\\<^bold>| = 1) \\<Longrightarrow>\n  w \\<in> \\<BB> G\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists G\\<^sub>+; 1 < \\<^bold>|us\\<^bold>|;\n         concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma basis_gen: \"w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "proof (induct \"length w\" arbitrary: w rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "case less"], ["proof (state)\nthis:\n  \\<^bold>|?w\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n  ?w \\<in> G \\<longrightarrow> ?w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "{"], ["proof (state)\nthis:\n  \\<^bold>|?w\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n  ?w \\<in> G \\<longrightarrow> ?w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "assume \"w \\<notin> \\<BB> G\" \"w \\<noteq> \\<epsilon>\" \"w \\<in> G\""], ["proof (state)\nthis:\n  w \\<notin> \\<BB> G\n  w \\<noteq> \\<epsilon>\n  w \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "obtain us where \"us \\<in> lists G\\<^sub>+\" \"1 < \\<^bold>|us\\<^bold>|\" \"concat us = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists G\\<^sub>+; 1 < \\<^bold>|us\\<^bold>|;\n         concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using non_simp_dec[OF \\<open>w \\<notin> \\<BB> G\\<close> \\<open>w \\<noteq> \\<epsilon>\\<close> \\<open>w \\<in> G\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>us.\n      \\<lbrakk>us \\<in> lists G\\<^sub>+; 1 < \\<^bold>|us\\<^bold>|;\n       concat us = w\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists G\\<^sub>+; 1 < \\<^bold>|us\\<^bold>|;\n         concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  us \\<in> lists G\\<^sub>+\n  1 < \\<^bold>|us\\<^bold>|\n  concat us = w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "have \"u \\<in> set us \\<Longrightarrow> u \\<in> \\<langle>\\<BB> G\\<rangle>\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set us \\<Longrightarrow> u \\<in> \\<langle>\\<BB> G\\<rangle>", "using  lists_drop_emp[OF \\<open>us \\<in> lists G\\<^sub>+\\<close>] \n       set_concat_len[OF \\<open>us \\<in> lists G\\<^sub>+\\<close> \\<open>1 < \\<^bold>|us\\<^bold>|\\<close>, THEN less[unfolded \\<open>concat us = w\\<close>[symmetric], of u]]"], ["proof (prove)\nusing this:\n  us \\<in> lists G\n  u \\<in> set us \\<Longrightarrow>\n  u \\<in> G \\<longrightarrow> u \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. u \\<in> set us \\<Longrightarrow> u \\<in> \\<langle>\\<BB> G\\<rangle>", "unfolding in_lists_conv_set[of us G]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set us. x \\<in> G\n  u \\<in> set us \\<Longrightarrow>\n  u \\<in> G \\<longrightarrow> u \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. u \\<in> set us \\<Longrightarrow> u \\<in> \\<langle>\\<BB> G\\<rangle>", "by blast"], ["proof (state)\nthis:\n  ?u \\<in> set us \\<Longrightarrow> ?u \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "from subsetI[of \"set us\", OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set us \\<Longrightarrow> x \\<in> set us) \\<Longrightarrow>\n  set us \\<subseteq> \\<langle>\\<BB> G\\<rangle>", "have ?case"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set us \\<Longrightarrow> x \\<in> set us) \\<Longrightarrow>\n  set us \\<subseteq> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "using  concat_in_hull[of us \"\\<langle>\\<BB> G\\<rangle>\", unfolded self_gen \\<open>concat us = w\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set us \\<Longrightarrow> x \\<in> set us) \\<Longrightarrow>\n  set us \\<subseteq> \\<langle>\\<BB> G\\<rangle>\n  set us \\<subseteq> \\<langle>\\<BB> G\\<rangle> \\<Longrightarrow>\n  w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "by blast"], ["proof (state)\nthis:\n  w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<notin> \\<BB> G; w \\<noteq> \\<epsilon>; w \\<in> G\\<rbrakk>\n  \\<Longrightarrow> w \\<in> G \\<longrightarrow>\n                    w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (\\<And>wa.\n           \\<^bold>|wa\\<^bold>| < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n           wa \\<in> G \\<longrightarrow>\n           wa \\<in> \\<langle>\\<BB> G\\<rangle>) \\<Longrightarrow>\n       w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<notin> \\<BB> G; w \\<noteq> \\<epsilon>; w \\<in> G\\<rbrakk>\n  \\<Longrightarrow> w \\<in> G \\<longrightarrow>\n                    w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>", "by auto"], ["proof (state)\nthis:\n  w \\<in> G \\<longrightarrow> w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem basis_gen_hull: \"\\<langle>\\<BB> G\\<rangle> = \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<BB> G\\<rangle> = \\<langle>G\\<rangle>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<BB> G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\n 2. \\<langle>G\\<rangle> \\<subseteq> \\<langle>\\<BB> G\\<rangle>", "show \"\\<langle>\\<BB> G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<BB> G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>", "unfolding hull_concat_lists"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ` lists \\<BB> G \\<subseteq> concat ` lists G", "by auto"], ["proof (state)\nthis:\n  \\<langle>\\<BB> G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> \\<subseteq> \\<langle>\\<BB> G\\<rangle>", "show  \"\\<langle>G\\<rangle> \\<subseteq> \\<langle>\\<BB> G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> \\<subseteq> \\<langle>\\<BB> G\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>\\<BB> G\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>\\<BB> G\\<rangle>", "show  \"x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> x \\<in> \\<langle>\\<BB> G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n    x \\<in> \\<langle>\\<BB> G\\<rangle>", "proof (induct rule: hull.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<epsilon> \\<in> \\<langle>\\<BB> G\\<rangle>\n 2. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> G; w2 \\<in> \\<langle>G\\<rangle>;\n        w2 \\<in> \\<langle>\\<BB> G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>\\<BB> G\\<rangle>", "show \"\\<And>w1 w2. w1 \\<in> G \\<Longrightarrow> w2 \\<in> \\<langle>\\<BB> G\\<rangle> \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>\\<BB> G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> G; w2 \\<in> \\<langle>\\<BB> G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>\\<BB> G\\<rangle>", "using hull_closed[of _ \"\\<BB> G\"] basis_gen[of _ G]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w1.0 \\<in> \\<langle>\\<BB> G\\<rangle>;\n   ?w2.0 \\<in> \\<langle>\\<BB> G\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<cdot> ?w2.0 \\<in> \\<langle>\\<BB> G\\<rangle>\n  ?w \\<in> G \\<longrightarrow> ?w \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> G; w2 \\<in> \\<langle>\\<BB> G\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>\\<BB> G\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?w1.0 \\<in> G; ?w2.0 \\<in> \\<langle>\\<BB> G\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<cdot> ?w2.0 \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> \\<langle>\\<BB> G\\<rangle>", "qed auto"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n  x \\<in> \\<langle>\\<BB> G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>G\\<rangle> \\<subseteq> \\<langle>\\<BB> G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_gen_hull': \"\\<langle>\\<BB> \\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<BB> \\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>", "using basis_gen_hull self_gen"], ["proof (prove)\nusing this:\n  \\<langle>\\<BB> ?G\\<rangle> = \\<langle>?G\\<rangle>\n  \\<langle>\\<langle>?G\\<rangle>\\<rangle> = \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<BB> \\<langle>G\\<rangle>\\<rangle> = \\<langle>G\\<rangle>", "by blast"], ["", "theorem basis_of_hull: \"\\<BB> G = \\<BB> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<BB> G = \\<BB> \\<langle>G\\<rangle>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<BB> G \\<subseteq> \\<BB> \\<langle>G\\<rangle>\n 2. \\<BB> \\<langle>G\\<rangle> \\<subseteq> \\<BB> G", "show \"\\<BB> G  \\<subseteq>  \\<BB> \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<BB> G \\<subseteq> \\<BB> \\<langle>G\\<rangle>", "using basisD basisI simp_el_hull"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<BB> ?G \\<Longrightarrow>  ?x \\<in>B ?G \n   ?x \\<in>B ?G  \\<Longrightarrow> ?x \\<in> \\<BB> ?G\n   ?b \\<in>B ?G  \\<Longrightarrow>  ?b \\<in>B \\<langle>?G\\<rangle> \n\ngoal (1 subgoal):\n 1. \\<BB> G \\<subseteq> \\<BB> \\<langle>G\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<BB> G \\<subseteq> \\<BB> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<BB> \\<langle>G\\<rangle> \\<subseteq> \\<BB> G", "show \"\\<BB> \\<langle>G\\<rangle>  \\<subseteq>  \\<BB> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<BB> \\<langle>G\\<rangle> \\<subseteq> \\<BB> G", "using basisD basisI simp_el_hull'"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<BB> ?G \\<Longrightarrow>  ?x \\<in>B ?G \n   ?x \\<in>B ?G  \\<Longrightarrow> ?x \\<in> \\<BB> ?G\n   ?b \\<in>B \\<langle>?G\\<rangle>  \\<Longrightarrow>  ?b \\<in>B ?G \n\ngoal (1 subgoal):\n 1. \\<BB> \\<langle>G\\<rangle> \\<subseteq> \\<BB> G", "by blast"], ["proof (state)\nthis:\n  \\<BB> \\<langle>G\\<rangle> \\<subseteq> \\<BB> G\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The basis is the smallest generating set.\\<close>"], ["", "theorem \"\\<langle>S\\<rangle> = \\<langle>G\\<rangle> \\<Longrightarrow> \\<BB> G \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> = \\<langle>G\\<rangle> \\<Longrightarrow>\n    \\<BB> G \\<subseteq> S", "by (metis basis_of_hull basis_sub)"], ["", "text\\<open>An arbitrary set between basis and the hull is generating...\\<close>"], ["", "lemma gen_sets: assumes \"\\<BB> G \\<subseteq> S\" and \"S \\<subseteq> \\<langle>G\\<rangle>\" shows \"\\<langle>S\\<rangle> = \\<langle>G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> = \\<langle>G\\<rangle>", "using  image_mono[OF lists_mono[of S \"\\<langle>G\\<rangle>\"], of concat, OF \\<open>S \\<subseteq> \\<langle>G\\<rangle>\\<close>] image_mono[OF lists_mono[of \"\\<BB> G\" S], of concat, OF \\<open>\\<BB> G \\<subseteq> S\\<close>]"], ["proof (prove)\nusing this:\n  concat ` lists S \\<subseteq> concat ` lists \\<langle>G\\<rangle>\n  concat ` lists \\<BB> G \\<subseteq> concat ` lists S\n\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> = \\<langle>G\\<rangle>", "unfolding sym[OF hull_concat_lists]  basis_gen_hull"], ["proof (prove)\nusing this:\n  \\<langle>S\\<rangle> \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\n  \\<langle>G\\<rangle> \\<subseteq> \\<langle>S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> = \\<langle>G\\<rangle>", "using  subset_antisym[of \"\\<langle>S\\<rangle>\" \"\\<langle>G\\<rangle>\"] self_gen"], ["proof (prove)\nusing this:\n  \\<langle>S\\<rangle> \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\n  \\<langle>G\\<rangle> \\<subseteq> \\<langle>S\\<rangle>\n  \\<lbrakk>\\<langle>S\\<rangle> \\<subseteq> \\<langle>G\\<rangle>;\n   \\<langle>G\\<rangle> \\<subseteq> \\<langle>S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<langle>S\\<rangle> = \\<langle>G\\<rangle>\n  \\<langle>\\<langle>?G\\<rangle>\\<rangle> = \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> = \\<langle>G\\<rangle>", "by auto"], ["", "text\\<open>... and has the same basis\\<close>"], ["", "lemma basis_sets: \"\\<BB> G \\<subseteq> S \\<Longrightarrow> S \\<subseteq> \\<langle>G\\<rangle> \\<Longrightarrow> \\<BB> G = \\<BB> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<BB> G \\<subseteq> S;\n     S \\<subseteq> \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<BB> G = \\<BB> S", "by (metis basis_of_hull  gen_sets)"], ["", "text\\<open>Any nonempty composed element has a decomposition into basis elements with many useful properties\\<close>"], ["", "lemma non_simp_fac: assumes \"w \\<noteq> \\<epsilon>\" and \"w \\<in> \\<langle>G\\<rangle>\" and \"w \\<notin> \\<BB> G\"\n  obtains us where \"1 < \\<^bold>|us\\<^bold>|\" and \"us \\<noteq> \\<epsilon>\" and  \"us \\<in> lists \\<BB> G\" and \n    \"hd us \\<noteq> \\<epsilon>\" and \"hd us \\<in> \\<langle>G\\<rangle>\" and \n    \"concat(tl us) \\<noteq> \\<epsilon>\" and \"concat(tl us) \\<in> \\<langle>G\\<rangle>\" and \n    \"w = hd us \\<cdot> concat(tl us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain us where \"us \\<in> lists \\<BB> G\" and \"concat us = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists \\<BB> G; concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>w \\<in> \\<langle>G\\<rangle>\\<close> dec_dom'[of w \"\\<BB> G\"] decI[of w \"\\<BB> G\"]"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>G\\<rangle>\n  w \\<in> \\<langle>\\<BB> G\\<rangle> \\<Longrightarrow>\n  Dec \\<BB> G w \\<in> lists \\<BB> G\n  w \\<in> \\<langle>\\<BB> G\\<rangle> \\<Longrightarrow>\n  concat (Dec \\<BB> G w) = w\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists \\<BB> G; concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding basis_gen_hull"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>G\\<rangle>\n  w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n  Dec \\<BB> G w \\<in> lists \\<BB> G\n  w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> concat (Dec \\<BB> G w) = w\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> lists \\<BB> G; concat us = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  us \\<in> lists \\<BB> G\n  concat us = w\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"us \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  us \\<in> lists \\<BB> G\n  concat us = w\n\ngoal (1 subgoal):\n 1. us \\<noteq> \\<epsilon>", "using  \\<open>w \\<noteq> \\<epsilon>\\<close> concat.simps(1)"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<BB> G\n  concat us = w\n  w \\<noteq> \\<epsilon>\n  concat \\<epsilon> = \\<epsilon>\n\ngoal (1 subgoal):\n 1. us \\<noteq> \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from lists_hd[OF this \\<open>us \\<in> lists \\<BB> G\\<close>, THEN emp_not_basis]\n    lists_hd[OF this \\<open>us \\<in> lists \\<BB> G\\<close>, THEN gen_in[of \"hd us\" \"\\<BB> G\", unfolded basis_gen_hull]]"], ["proof (chain)\npicking this:\n  hd us \\<noteq> \\<epsilon>\n  hd us \\<in> \\<langle>G\\<rangle>", "have \"hd us \\<noteq> \\<epsilon>\" and \"hd us \\<in> \\<langle>G\\<rangle>\""], ["proof (prove)\nusing this:\n  hd us \\<noteq> \\<epsilon>\n  hd us \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. hd us \\<noteq> \\<epsilon> &&& hd us \\<in> \\<langle>G\\<rangle>", "."], ["proof (state)\nthis:\n  hd us \\<noteq> \\<epsilon>\n  hd us \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have  \"1 < \\<^bold>|us\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<^bold>|us\\<^bold>|", "using \\<open>w \\<notin> \\<BB> G\\<close> lists_hd[OF \\<open>us \\<noteq> \\<epsilon>\\<close> \\<open>us \\<in> lists \\<BB> G\\<close>] \\<open>w \\<noteq> \\<epsilon>\\<close> \\<open>w \\<in> \\<langle>G\\<rangle>\\<close> \n      concat_len_one[of us, unfolded \\<open>concat us = w\\<close>]  nonsing_concat_len[of us, unfolded \\<open>concat us = w\\<close>]"], ["proof (prove)\nusing this:\n  w \\<notin> \\<BB> G\n  hd us \\<in> \\<BB> G\n  w \\<noteq> \\<epsilon>\n  w \\<in> \\<langle>G\\<rangle>\n  \\<^bold>|us\\<^bold>| = 1 \\<Longrightarrow> w = hd us\n  \\<lbrakk>\\<^bold>|us\\<^bold>| \\<noteq> 1; w \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> 1 < \\<^bold>|us\\<^bold>|\n\ngoal (1 subgoal):\n 1. 1 < \\<^bold>|us\\<^bold>|", "by blast"], ["proof (state)\nthis:\n  1 < \\<^bold>|us\\<^bold>|\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from nemp_concat_hull[OF long_list_tl[OF this], of \"\\<BB> G\", unfolded basis_drop_emp basis_gen_hull, OF tl_lists[OF \\<open>us \\<in> lists \\<BB> G\\<close>]]"], ["proof (chain)\npicking this:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>", "have \"concat (tl us) \\<in> \\<langle>G\\<rangle>\" and \"concat(tl us) \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. concat (tl us) \\<in> \\<langle>G\\<rangle> &&&\n    concat (tl us) \\<noteq> \\<epsilon>", "."], ["proof (state)\nthis:\n  concat (tl us) \\<in> \\<langle>G\\<rangle>\n  concat (tl us) \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"w = hd us \\<cdot> concat(tl us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = hd us \\<cdot> concat (tl us)", "using \\<open>us \\<noteq> \\<epsilon>\\<close> \\<open>us \\<in> lists \\<BB> G\\<close> \\<open>concat us = w\\<close> concat.simps(2)[of \"hd us\" \"tl us\"] list.collapse[of us]"], ["proof (prove)\nusing this:\n  us \\<noteq> \\<epsilon>\n  us \\<in> lists \\<BB> G\n  concat us = w\n  concat (hd us # tl us) = hd us \\<cdot> concat (tl us)\n  us \\<noteq> \\<epsilon> \\<Longrightarrow> hd us # tl us = us\n\ngoal (1 subgoal):\n 1. w = hd us \\<cdot> concat (tl us)", "by argo"], ["proof (state)\nthis:\n  w = hd us \\<cdot> concat (tl us)\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>1 < \\<^bold>|us\\<^bold>|; us \\<noteq> \\<epsilon>;\n         us \\<in> lists \\<BB> G; hd us \\<noteq> \\<epsilon>;\n         hd us \\<in> \\<langle>G\\<rangle>;\n         concat (tl us) \\<noteq> \\<epsilon>;\n         concat (tl us) \\<in> \\<langle>G\\<rangle>;\n         w = hd us \\<cdot> concat (tl us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[OF \\<open>1 < \\<^bold>|us\\<^bold>|\\<close> \\<open>us \\<noteq> \\<epsilon>\\<close> \\<open>us \\<in> lists \\<BB> G\\<close> \\<open>hd us \\<noteq> \\<epsilon>\\<close> \\<open>hd us \\<in> \\<langle>G\\<rangle>\\<close> \\<open>concat (tl us) \\<noteq> \\<epsilon>\\<close> \\<open>concat (tl us) \\<in> \\<langle>G\\<rangle>\\<close> this]"], ["proof (chain)\npicking this:\n  thesis", "show thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_dec: \"p \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> s \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> p \\<cdot> s \\<in> \\<BB> G \\<Longrightarrow> p = \\<epsilon> \\<or> s = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> \\<langle>G\\<rangle>; s \\<in> \\<langle>G\\<rangle>;\n     p \\<cdot> s \\<in> \\<BB> G\\<rbrakk>\n    \\<Longrightarrow> p = \\<epsilon> \\<or> s = \\<epsilon>", "using basis_no_fact[of p G s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<in> \\<langle>G\\<rangle>; s \\<in> \\<langle>G\\<rangle>;\n    p \\<cdot> s \\<in>B G \\<rbrakk>\n  \\<Longrightarrow> p = \\<epsilon> \\<or> s = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> \\<langle>G\\<rangle>; s \\<in> \\<langle>G\\<rangle>;\n     p \\<cdot> s \\<in> \\<BB> G\\<rbrakk>\n    \\<Longrightarrow> p = \\<epsilon> \\<or> s = \\<epsilon>", "by simp"], ["", "lemma non_simp_fac': \"w \\<notin> \\<BB> G \\<Longrightarrow> w \\<noteq> \\<epsilon> \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle> \\<Longrightarrow> \\<exists>us. us \\<in> lists G\\<^sub>+ \\<and> w = concat us \\<and> \\<^bold>|us\\<^bold>| \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<notin> \\<BB> G; w \\<noteq> \\<epsilon>;\n     w \\<in> \\<langle>G\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>us.\n                         us \\<in> lists G\\<^sub>+ \\<and>\n                         w = concat us \\<and>\n                         \\<^bold>|us\\<^bold>| \\<noteq> 1", "by (metis basisI concat_len_one decI' dec_dom' decI dec_nemp lists_hd nemp_elem_setI simple_element.elims(3))"], ["", "lemma emp_gen_iff: \"G\\<^sub>+ = {} \\<longleftrightarrow> \\<langle>G\\<rangle> = {\\<epsilon>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G\\<^sub>+ = {}) = (\\<langle>G\\<rangle> = {\\<epsilon>})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. G\\<^sub>+ = {} \\<Longrightarrow> \\<langle>G\\<rangle> = {\\<epsilon>}\n 2. \\<langle>G\\<rangle> = {\\<epsilon>} \\<Longrightarrow> G\\<^sub>+ = {}", "assume \"G\\<^sub>+ = {}\""], ["proof (state)\nthis:\n  G\\<^sub>+ = {}\n\ngoal (2 subgoals):\n 1. G\\<^sub>+ = {} \\<Longrightarrow> \\<langle>G\\<rangle> = {\\<epsilon>}\n 2. \\<langle>G\\<rangle> = {\\<epsilon>} \\<Longrightarrow> G\\<^sub>+ = {}", "show \"\\<langle>G\\<rangle> = {\\<epsilon>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = {\\<epsilon>}", "using  hull_drop_one[of G, unfolded \\<open>G\\<^sub>+ = {}\\<close> emp_gen_set]"], ["proof (prove)\nusing this:\n  \\<langle>G\\<rangle> = {\\<epsilon>}\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = {\\<epsilon>}", "."], ["proof (state)\nthis:\n  \\<langle>G\\<rangle> = {\\<epsilon>}\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = {\\<epsilon>} \\<Longrightarrow> G\\<^sub>+ = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = {\\<epsilon>} \\<Longrightarrow> G\\<^sub>+ = {}", "assume \"\\<langle>G\\<rangle> = {\\<epsilon>}\""], ["proof (state)\nthis:\n  \\<langle>G\\<rangle> = {\\<epsilon>}\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> = {\\<epsilon>} \\<Longrightarrow> G\\<^sub>+ = {}", "thus\"G\\<^sub>+ = {}\""], ["proof (prove)\nusing this:\n  \\<langle>G\\<rangle> = {\\<epsilon>}\n\ngoal (1 subgoal):\n 1. G\\<^sub>+ = {}", "by blast"], ["proof (state)\nthis:\n  G\\<^sub>+ = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emp_basis_iff:  \"\\<BB> G = {} \\<longleftrightarrow> G\\<^sub>+ = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<BB> G = {}) = (G\\<^sub>+ = {})", "using emp_gen_iff[of \"\\<BB> G\", unfolded basis_gen_hull basis_drop_emp, folded emp_gen_iff]"], ["proof (prove)\nusing this:\n  (\\<BB> G = {}) = (G\\<^sub>+ = {})\n\ngoal (1 subgoal):\n 1. (\\<BB> G = {}) = (G\\<^sub>+ = {})", "."], ["", "section \"Code\""], ["", "text\\<open>A basis freely generating its hull is called a \\emph{code}. By definition, \nthis means that generated elements have unique factorizations into the elements of the code.\\<close>"], ["", "locale code =\n  fixes \\<C>\n  assumes \\<C>_is_code: \"xs \\<in> lists \\<C> \\<Longrightarrow> ys \\<in> lists \\<C> \\<Longrightarrow> concat xs = concat ys \\<Longrightarrow> xs = ys\"\nbegin"], ["", "lemma emp_not_in_code: \"\\<epsilon> \\<notin> \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> \\<notin> \\<C>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> \\<C> \\<Longrightarrow> False", "assume \"\\<epsilon> \\<in> \\<C>\""], ["proof (state)\nthis:\n  \\<epsilon> \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> \\<C> \\<Longrightarrow> False", "hence \"[] \\<in> lists \\<C>\" and \"[\\<epsilon>] \\<in> lists \\<C>\" and \"concat [] = concat [\\<epsilon>]\" and \"[] \\<noteq> [\\<epsilon>]\""], ["proof (prove)\nusing this:\n  \\<epsilon> \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<epsilon> \\<in> lists \\<C> &&& [\\<epsilon>] \\<in> lists \\<C>) &&&\n    concat \\<epsilon> = concat [\\<epsilon>] &&&\n    \\<epsilon> \\<noteq> [\\<epsilon>]", "by simp+"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> lists \\<C>\n  [\\<epsilon>] \\<in> lists \\<C>\n  concat \\<epsilon> = concat [\\<epsilon>]\n  \\<epsilon> \\<noteq> [\\<epsilon>]\n\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> \\<C> \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<in> lists \\<C>\n  [\\<epsilon>] \\<in> lists \\<C>\n  concat \\<epsilon> = concat [\\<epsilon>]\n  \\<epsilon> \\<noteq> [\\<epsilon>]\n\ngoal (1 subgoal):\n 1. False", "using \\<C>_is_code"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<in> lists \\<C>\n  [\\<epsilon>] \\<in> lists \\<C>\n  concat \\<epsilon> = concat [\\<epsilon>]\n  \\<epsilon> \\<noteq> [\\<epsilon>]\n  \\<lbrakk>?xs \\<in> lists \\<C>; ?ys \\<in> lists \\<C>;\n   concat ?xs = concat ?ys\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma code_simple: \"c \\<in> \\<C> \\<Longrightarrow> c \\<in>B \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> \\<C> \\<Longrightarrow>  c \\<in>B \\<C>", "unfolding   simple_element.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> \\<C> \\<Longrightarrow>\n    c \\<in> \\<C> \\<and>\n    (\\<forall>us.\n        us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n        \\<^bold>|us\\<^bold>| = 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> \\<C> \\<Longrightarrow> c \\<in> \\<C>\n 2. c \\<in> \\<C> \\<Longrightarrow>\n    \\<forall>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> \\<C> \\<Longrightarrow> c \\<in> \\<C>\n 2. c \\<in> \\<C> \\<Longrightarrow>\n    \\<forall>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "assume \"c \\<in> \\<C>\""], ["proof (state)\nthis:\n  c \\<in> \\<C>\n\ngoal (2 subgoals):\n 1. c \\<in> \\<C> \\<Longrightarrow> c \\<in> \\<C>\n 2. c \\<in> \\<C> \\<Longrightarrow>\n    \\<forall>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "hence \"[c] \\<in> lists \\<C>\""], ["proof (prove)\nusing this:\n  c \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. [c] \\<in> lists \\<C>", "by simp"], ["proof (state)\nthis:\n  [c] \\<in> lists \\<C>\n\ngoal (2 subgoals):\n 1. c \\<in> \\<C> \\<Longrightarrow> c \\<in> \\<C>\n 2. c \\<in> \\<C> \\<Longrightarrow>\n    \\<forall>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "show \"\\<forall>us. us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow> \\<^bold>|us\\<^bold>| = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "fix us"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "assume \"us \\<in> lists \\<C>\\<^sub>+\" \"concat us = c\""], ["proof (state)\nthis:\n  us \\<in> lists \\<C>\\<^sub>+\n  concat us = c\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "hence \"us \\<in> lists \\<C>\""], ["proof (prove)\nusing this:\n  us \\<in> lists \\<C>\\<^sub>+\n  concat us = c\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<C>", "by blast"], ["proof (state)\nthis:\n  us \\<in> lists \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "hence  \"us = [c]\""], ["proof (prove)\nusing this:\n  us \\<in> lists \\<C>\n\ngoal (1 subgoal):\n 1. us = [c]", "using \\<open>concat us = c\\<close> \\<open>c \\<in> \\<C>\\<close> \\<C>_is_code[of \"[c]\", OF \\<open>[c] \\<in> lists \\<C>\\<close> \\<open>us \\<in> lists \\<C>\\<close>] emp_not_in_code"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<C>\n  concat us = c\n  c \\<in> \\<C>\n  concat [c] = concat us \\<Longrightarrow> [c] = us\n  \\<epsilon> \\<notin> \\<C>\n\ngoal (1 subgoal):\n 1. us = [c]", "by auto"], ["proof (state)\nthis:\n  us = [c]\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>us \\<in> lists \\<C>\\<^sub>+; concat us = c\\<rbrakk>\n  \\<Longrightarrow> us = [c]\n\ngoal (1 subgoal):\n 1. \\<And>us.\n       us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n       \\<^bold>|us\\<^bold>| = 1", "thus \"us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow> \\<^bold>|us\\<^bold>| = 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>us \\<in> lists \\<C>\\<^sub>+; concat us = c\\<rbrakk>\n  \\<Longrightarrow> us = [c]\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n    \\<^bold>|us\\<^bold>| = 1", "using sing_len[of c]"], ["proof (prove)\nusing this:\n  \\<lbrakk>us \\<in> lists \\<C>\\<^sub>+; concat us = c\\<rbrakk>\n  \\<Longrightarrow> us = [c]\n  \\<^bold>|[c]\\<^bold>| = 1\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n    \\<^bold>|us\\<^bold>| = 1", "by fastforce"], ["proof (state)\nthis:\n  us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n  \\<^bold>|us\\<^bold>| = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>us.\n     us \\<in> lists \\<C>\\<^sub>+ \\<and> concat us = c \\<longrightarrow>\n     \\<^bold>|us\\<^bold>| = 1\n\ngoal (1 subgoal):\n 1. c \\<in> \\<C> \\<Longrightarrow> c \\<in> \\<C>", "qed"], ["", "lemma code_is_basis: \"\\<BB> \\<C> = \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<BB> \\<C> = \\<C>", "using code_simple basisdef[of \\<C>] basis_sub"], ["proof (prove)\nusing this:\n  ?c \\<in> \\<C> \\<Longrightarrow>  ?c \\<in>B \\<C> \n  \\<BB> \\<C> = {x.  x \\<in>B \\<C> }\n  \\<BB> ?G \\<subseteq> ?G\n\ngoal (1 subgoal):\n 1. \\<BB> \\<C> = \\<C>", "by blast"], ["", "lemma code_unique_dec: \"us \\<in> lists \\<C> \\<Longrightarrow> Dec \\<C> (concat us) = us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<C> \\<Longrightarrow> Dec \\<C> concat us = us", "using dec_dom'[of \"concat us\" \\<C>, THEN \\<C>_is_code, of us] \n    decI[of \"concat us\" \\<C>] hull_concat_lists[of \\<C>] image_eqI[of \"concat us\" concat us \"lists \\<C>\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>concat us \\<in> \\<langle>\\<C>\\<rangle>; us \\<in> lists \\<C>;\n   concat (Dec \\<C> concat us) = concat us\\<rbrakk>\n  \\<Longrightarrow> Dec \\<C> concat us = us\n  concat us \\<in> \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n  concat (Dec \\<C> concat us) = concat us\n  \\<langle>\\<C>\\<rangle> = concat ` lists \\<C>\n  \\<lbrakk>concat us = concat us; us \\<in> lists \\<C>\\<rbrakk>\n  \\<Longrightarrow> concat us \\<in> concat ` lists \\<C>\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<C> \\<Longrightarrow> Dec \\<C> concat us = us", "by argo"], ["", "lemma code_unique_ref: \"us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow> refine \\<C> us = decompose \\<C> (concat us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "assume \"us \\<in> lists \\<langle>\\<C>\\<rangle>\""], ["proof (state)\nthis:\n  us \\<in> lists \\<langle>\\<C>\\<rangle>\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "hence \"concat (refine \\<C> us) = concat us\""], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>\\<C>\\<rangle>\n\ngoal (1 subgoal):\n 1. concat (Ref \\<C> us) = concat us", "using ref"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>\\<C>\\<rangle>\n  ?us \\<in> lists \\<langle>?G\\<rangle> \\<Longrightarrow>\n  concat (Ref ?G ?us) = concat ?us\n\ngoal (1 subgoal):\n 1. concat (Ref \\<C> us) = concat us", "by fastforce"], ["proof (state)\nthis:\n  concat (Ref \\<C> us) = concat us\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "hence eq: \"concat (refine \\<C> us) = concat (decompose \\<C> (concat us))\""], ["proof (prove)\nusing this:\n  concat (Ref \\<C> us) = concat us\n\ngoal (1 subgoal):\n 1. concat (Ref \\<C> us) = concat (Dec \\<C> concat us)", "using  decI[OF hull_closed_lists[OF \\<open>us \\<in> lists \\<langle>\\<C>\\<rangle>\\<close>]]"], ["proof (prove)\nusing this:\n  concat (Ref \\<C> us) = concat us\n  concat (Dec \\<C> concat us) = concat us\n\ngoal (1 subgoal):\n 1. concat (Ref \\<C> us) = concat (Dec \\<C> concat us)", "by auto"], ["proof (state)\nthis:\n  concat (Ref \\<C> us) = concat (Dec \\<C> concat us)\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "have dec: \"Dec \\<C> (concat us) \\<in> lists \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec \\<C> concat us \\<in> lists \\<C>", "using \\<open>us \\<in> lists \\<langle>\\<C>\\<rangle>\\<close> dec_dom' hull_closed_lists"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<langle>\\<C>\\<rangle>\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow> Dec ?G ?u \\<in> lists ?G\n  ?us \\<in> lists \\<langle>?G\\<rangle> \\<Longrightarrow>\n  concat ?us \\<in> \\<langle>?G\\<rangle>\n\ngoal (1 subgoal):\n 1. Dec \\<C> concat us \\<in> lists \\<C>", "by blast"], ["proof (state)\nthis:\n  Dec \\<C> concat us \\<in> lists \\<C>\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "have ref: \"Ref \\<C> us \\<in> lists \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref \\<C> us \\<in> lists \\<C>", "using lists_drop_emp[OF ref_in[OF \\<open>us \\<in> lists \\<langle>\\<C>\\<rangle>\\<close>]]"], ["proof (prove)\nusing this:\n  Ref \\<C> us \\<in> lists \\<C>\n\ngoal (1 subgoal):\n 1. Ref \\<C> us \\<in> lists \\<C>", "."], ["proof (state)\nthis:\n  Ref \\<C> us \\<in> lists \\<C>\n\ngoal (1 subgoal):\n 1. us \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n    Ref \\<C> us = Dec \\<C> concat us", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref \\<C> us = Dec \\<C> concat us", "using \\<C>_is_code[OF ref dec eq]"], ["proof (prove)\nusing this:\n  Ref \\<C> us = Dec \\<C> concat us\n\ngoal (1 subgoal):\n 1. Ref \\<C> us = Dec \\<C> concat us", "."], ["proof (state)\nthis:\n  Ref \\<C> us = Dec \\<C> concat us\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma code_dec_morph: assumes \"x \\<in> \\<langle>\\<C>\\<rangle>\" \"y \\<in> \\<langle>\\<C>\\<rangle>\" \n  shows \"(Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> (x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y", "have eq: \"(Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> (concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n    Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))", "using dec_dom'[OF \\<open>x \\<in> \\<langle>\\<C>\\<rangle>\\<close>] dec_dom'[OF \\<open>y \\<in> \\<langle>\\<C>\\<rangle>\\<close>]\n      code.code_unique_dec[OF code_axioms, of \"(Dec \\<C> x) \\<cdot> (Dec \\<C> y)\", unfolded append_in_lists_conv, symmetric]"], ["proof (prove)\nusing this:\n  Dec \\<C> x \\<in> lists \\<C>\n  Dec \\<C> y \\<in> lists \\<C>\n  Dec \\<C> x \\<in> lists \\<C> \\<and>\n  Dec \\<C> y \\<in> lists \\<C> \\<Longrightarrow>\n  (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n  Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))\n\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n    Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))", "by blast"], ["proof (state)\nthis:\n  (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n  Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))\n\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y", "moreover"], ["proof (state)\nthis:\n  (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n  Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))\n\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y", "have \"concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y", "using concat_morph[of \"Dec \\<C> x\" \"Dec \\<C> y\", symmetric]"], ["proof (prove)\nusing this:\n  concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) =\n  concat (Dec \\<C> x) \\<cdot> concat (Dec \\<C> y)\n\ngoal (1 subgoal):\n 1. concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y", "unfolding decI[OF \\<open>x \\<in> \\<langle>\\<C>\\<rangle>\\<close>] decI[OF \\<open>y \\<in> \\<langle>\\<C>\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y\n\ngoal (1 subgoal):\n 1. concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y", "."], ["proof (state)\nthis:\n  concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y\n\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y", "ultimately"], ["proof (chain)\npicking this:\n  (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n  Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))\n  concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y", "show \"(Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> (x\\<cdot>y)\""], ["proof (prove)\nusing this:\n  (Dec \\<C> x) \\<cdot> (Dec \\<C> y) =\n  Dec \\<C> concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y))\n  concat ((Dec \\<C> x) \\<cdot> (Dec \\<C> y)) = x \\<cdot> y\n\ngoal (1 subgoal):\n 1. (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y", "by argo"], ["proof (state)\nthis:\n  (Dec \\<C> x) \\<cdot> (Dec \\<C> y) = Dec \\<C> x \\<cdot> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma code_el_dec: \"c \\<in> \\<C> \\<Longrightarrow> decompose \\<C> c = [c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> \\<C> \\<Longrightarrow> Dec \\<C> c = [c]", "using code_unique_dec[of \"[c]\"]"], ["proof (prove)\nusing this:\n  [c] \\<in> lists \\<C> \\<Longrightarrow> Dec \\<C> concat [c] = [c]\n\ngoal (1 subgoal):\n 1. c \\<in> \\<C> \\<Longrightarrow> Dec \\<C> c = [c]", "by auto"], ["", "lemma code_ref_list: \"us \\<in> lists \\<C> \\<Longrightarrow> refine \\<C> us = us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us", "proof (induct us)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<epsilon> \\<in> lists \\<C> \\<Longrightarrow>\n    Ref \\<C> \\<epsilon> = \\<epsilon>\n 2. \\<And>a us.\n       \\<lbrakk>us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us;\n        a # us \\<in> lists \\<C>\\<rbrakk>\n       \\<Longrightarrow> Ref \\<C> a # us = a # us", "case (Cons a us)"], ["proof (state)\nthis:\n  us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us\n  a # us \\<in> lists \\<C>\n\ngoal (2 subgoals):\n 1. \\<epsilon> \\<in> lists \\<C> \\<Longrightarrow>\n    Ref \\<C> \\<epsilon> = \\<epsilon>\n 2. \\<And>a us.\n       \\<lbrakk>us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us;\n        a # us \\<in> lists \\<C>\\<rbrakk>\n       \\<Longrightarrow> Ref \\<C> a # us = a # us", "then"], ["proof (chain)\npicking this:\n  us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us\n  a # us \\<in> lists \\<C>", "show ?case"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us\n  a # us \\<in> lists \\<C>\n\ngoal (1 subgoal):\n 1. Ref \\<C> a # us = a # us", "using code_el_dec"], ["proof (prove)\nusing this:\n  us \\<in> lists \\<C> \\<Longrightarrow> Ref \\<C> us = us\n  a # us \\<in> lists \\<C>\n  ?c \\<in> \\<C> \\<Longrightarrow> Dec \\<C> ?c = [?c]\n\ngoal (1 subgoal):\n 1. Ref \\<C> a # us = a # us", "by simp"], ["proof (state)\nthis:\n  Ref \\<C> a # us = a # us\n\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> lists \\<C> \\<Longrightarrow>\n    Ref \\<C> \\<epsilon> = \\<epsilon>", "qed simp"], ["", "lemma code_ref_gen: assumes \"G \\<subseteq> \\<langle>\\<C>\\<rangle>\" \"u \\<in> \\<langle>G\\<rangle>\" \n  shows \"Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>", "have \"refine \\<C> (Dec G u) = Dec \\<C> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref \\<C> Dec G u = Dec \\<C> u", "using  dec_dom'[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>]  \\<open>G \\<subseteq> \\<langle>\\<C>\\<rangle>\\<close> code_unique_ref[of \"Dec G u\", unfolded decI[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>]]"], ["proof (prove)\nusing this:\n  Dec G u \\<in> lists G\n  G \\<subseteq> \\<langle>\\<C>\\<rangle>\n  Dec G u \\<in> lists \\<langle>\\<C>\\<rangle> \\<Longrightarrow>\n  Ref \\<C> Dec G u = Dec \\<C> u\n\ngoal (1 subgoal):\n 1. Ref \\<C> Dec G u = Dec \\<C> u", "by blast"], ["proof (state)\nthis:\n  Ref \\<C> Dec G u = Dec \\<C> u\n\ngoal (1 subgoal):\n 1. Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>", "from ref_gen[of \"Dec G u\" G, OF dec_dom'[OF \\<open>u \\<in> \\<langle>G\\<rangle>\\<close>], of \\<C>, unfolded this, OF \\<open>G \\<subseteq> \\<langle>\\<C>\\<rangle>\\<close>]"], ["proof (chain)\npicking this:\n  Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>\n\ngoal (1 subgoal):\n 1. Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>", "."], ["proof (state)\nthis:\n  Dec \\<C> u \\<in> \\<langle>decompose \\<C> ` G\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>end context code\\<close>"], ["", "section \\<open>Binary code\\<close>"], ["", "text\\<open>We pay a special attention to two element codes. \nIn particular, we show that two words form a code if and only if they do not commute. This means that two \nwords either commute, or do not satisfy any nontrivial relation.\n\\<close>"], ["", "locale binary_code = \n  fixes u\\<^sub>0 u\\<^sub>1\n  assumes non_comm: \"u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\" \n\nbegin"], ["", "lemma bin_fst_nemp: \"u\\<^sub>0 \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u\\<^sub>0 \\<noteq> \\<epsilon>", "using non_comm"], ["proof (prove)\nusing this:\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. u\\<^sub>0 \\<noteq> \\<epsilon>", "by auto"], ["", "text\\<open>A crucial property of two element codes is the constant decoding delay given by the word $\\alpha$, \nwhich is a prefix of any generating word (sufficiently long), while the letter \nimmediately after this common prefix indicates the first element of the decomposition.\n\\<close>"], ["", "definition  \\<alpha> where bin_lcp_def [simp]: \"\\<alpha> =  u\\<^sub>0\\<cdot>u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1\\<cdot>u\\<^sub>0\""], ["", "definition  c\\<^sub>0 where fst_mismatch_def: \"c\\<^sub>0 =  (u\\<^sub>0\\<cdot>u\\<^sub>1)!\\<^bold>|\\<alpha>\\<^bold>|\""], ["", "definition  c\\<^sub>1 where snd_mismatch_def: \"c\\<^sub>1 =  (u\\<^sub>1\\<cdot>u\\<^sub>0)!\\<^bold>|\\<alpha>\\<^bold>|\""], ["", "lemma bin_mismatch_neq: \"c\\<^sub>0 \\<noteq> c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>0 \\<noteq> c\\<^sub>1", "unfolding fst_mismatch_def snd_mismatch_def bin_lcp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u\\<^sub>0 \\<cdot> u\\<^sub>1) !\n    \\<^bold>|u\\<^sub>0 \\<cdot>\n             u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot>\nu\\<^sub>0\\<^bold>| \\<noteq>\n    (u\\<^sub>1 \\<cdot> u\\<^sub>0) !\n    \\<^bold>|u\\<^sub>0 \\<cdot>\n             u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0\\<^bold>|", "using non_comm lcp_mismatch' pref_comp_eq[of \"u\\<^sub>0 \\<cdot> u\\<^sub>1\" \"u\\<^sub>1 \\<cdot> u\\<^sub>0\", OF _ swap_len]"], ["proof (prove)\nusing this:\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\n  \\<not> ?u \\<bowtie> ?v \\<Longrightarrow>\n  ?u ! \\<^bold>|?u \\<and>\\<^sub>p ?v\\<^bold>| \\<noteq>\n  ?v ! \\<^bold>|?u \\<and>\\<^sub>p ?v\\<^bold>|\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<bowtie>\n  u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<Longrightarrow>\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 = u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. (u\\<^sub>0 \\<cdot> u\\<^sub>1) !\n    \\<^bold>|u\\<^sub>0 \\<cdot>\n             u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot>\nu\\<^sub>0\\<^bold>| \\<noteq>\n    (u\\<^sub>1 \\<cdot> u\\<^sub>0) !\n    \\<^bold>|u\\<^sub>0 \\<cdot>\n             u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0\\<^bold>|", "unfolding prefix_comparable_def"], ["proof (prove)\nusing this:\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\n  \\<not> (?u \\<le>p ?v \\<or> ?v \\<le>p ?u) \\<Longrightarrow>\n  ?u ! \\<^bold>|?u \\<and>\\<^sub>p ?v\\<^bold>| \\<noteq>\n  ?v ! \\<^bold>|?u \\<and>\\<^sub>p ?v\\<^bold>|\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<or>\n  u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<le>p\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<Longrightarrow>\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 = u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. (u\\<^sub>0 \\<cdot> u\\<^sub>1) !\n    \\<^bold>|u\\<^sub>0 \\<cdot>\n             u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot>\nu\\<^sub>0\\<^bold>| \\<noteq>\n    (u\\<^sub>1 \\<cdot> u\\<^sub>0) !\n    \\<^bold>|u\\<^sub>0 \\<cdot>\n             u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0\\<^bold>|", "by blast"], ["", "lemma bin_lcp_pref_fst_snd: \"\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\" and bin_lcp_pref_snd_fst: \"\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1 &&&\n    \\<alpha> \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0", "unfolding bin_lcp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u\\<^sub>0 \\<cdot>\n    u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<le>p\n    u\\<^sub>0 \\<cdot> u\\<^sub>1 &&&\n    u\\<^sub>0 \\<cdot>\n    u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<le>p\n    u\\<^sub>1 \\<cdot> u\\<^sub>0", "using longest_common_prefix_prefix1 longest_common_prefix_prefix2"], ["proof (prove)\nusing this:\n  ?xs \\<and>\\<^sub>p ?ys \\<le>p ?xs\n  ?xs \\<and>\\<^sub>p ?ys \\<le>p ?ys\n\ngoal (1 subgoal):\n 1. u\\<^sub>0 \\<cdot>\n    u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<le>p\n    u\\<^sub>0 \\<cdot> u\\<^sub>1 &&&\n    u\\<^sub>0 \\<cdot>\n    u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<le>p\n    u\\<^sub>1 \\<cdot> u\\<^sub>0", "."], ["", "lemma bin_lcp_short: \"\\<^bold>|\\<alpha>\\<^bold>| < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|\\<alpha>\\<^bold>|\n    < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>|\\<alpha>\\<^bold>|\n    < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|", "have \"\\<not> u\\<^sub>0\\<cdot>u\\<^sub>1 \\<le>p u\\<^sub>1\\<cdot>u\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0", "using comm_ruler non_comm"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<cdot> ?s \\<le>p ?w1.0; ?s \\<cdot> ?r \\<le>p ?w2.0;\n   ?w1.0 \\<bowtie> ?w2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<cdot> ?s = ?s \\<cdot> ?r\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  \\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<^bold>|\\<alpha>\\<^bold>|\n    < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|", "from lcp_len'[OF this, folded bin_lcp_def, unfolded length_append]"], ["proof (chain)\npicking this:\n  \\<^bold>|\\<alpha>\\<^bold>|\n  < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|", "show  \"\\<^bold>|\\<alpha>\\<^bold>| < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|\""], ["proof (prove)\nusing this:\n  \\<^bold>|\\<alpha>\\<^bold>|\n  < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|\\<alpha>\\<^bold>|\n    < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|", "."], ["proof (state)\nthis:\n  \\<^bold>|\\<alpha>\\<^bold>|\n  < \\<^bold>|u\\<^sub>0\\<^bold>| + \\<^bold>|u\\<^sub>1\\<^bold>|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_lcp_fst_mismatch_pref:  \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "have \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1", "using  append_one_prefix[of \\<alpha> \"u\\<^sub>0 \\<cdot> u\\<^sub>1\", folded fst_mismatch_def, OF bin_lcp_pref_fst_snd, unfolded length_append, OF bin_lcp_short]"], ["proof (prove)\nusing this:\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1", "."], ["proof (state)\nthis:\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "hence \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> (u\\<^sub>1 \\<cdot> u\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p\n    u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<cdot> u\\<^sub>0", "using pref_prolong"], ["proof (prove)\nusing this:\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\n  \\<lbrakk>?w \\<le>p ?z \\<cdot> ?r; ?r \\<le>p ?s\\<rbrakk>\n  \\<Longrightarrow> ?w \\<le>p ?z \\<cdot> ?s\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p\n    u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<cdot> u\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "from pref_prod_pref_short[OF this bin_lcp_pref_snd_fst, unfolded length_append sing_len]"], ["proof (chain)\npicking this:\n  \\<^bold>|\\<alpha>\\<^bold>| + 1\n  \\<le> \\<^bold>|u\\<^sub>0\\<^bold>| +\n        \\<^bold>|\\<alpha>\\<^bold>| \\<Longrightarrow>\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "show \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<^bold>|\\<alpha>\\<^bold>| + 1\n  \\<le> \\<^bold>|u\\<^sub>0\\<^bold>| +\n        \\<^bold>|\\<alpha>\\<^bold>| \\<Longrightarrow>\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "using  nemp_len[OF bin_fst_nemp]"], ["proof (prove)\nusing this:\n  \\<^bold>|\\<alpha>\\<^bold>| + 1\n  \\<le> \\<^bold>|u\\<^sub>0\\<^bold>| +\n        \\<^bold>|\\<alpha>\\<^bold>| \\<Longrightarrow>\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\n  \\<^bold>|u\\<^sub>0\\<^bold>| \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>", "by linarith"], ["proof (state)\nthis:\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_fst_snd_pref:  \"\\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p \\<alpha>", "using bin_lcp_short[folded length_append[of u\\<^sub>0 u\\<^sub>1]]  prefix_order.order.antisym[OF bin_lcp_pref_fst_snd]"], ["proof (prove)\nusing this:\n  \\<^bold>|\\<alpha>\\<^bold>| < \\<^bold>|u\\<^sub>0 \\<cdot> u\\<^sub>1\\<^bold>|\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p \\<alpha> \\<Longrightarrow>\n  \\<alpha> = u\\<^sub>0 \\<cdot> u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p \\<alpha>", "by fastforce"], ["", "lemma bin_lcp_fst_mismatch_pref':  \"\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1", "using strict_prefixI[OF bin_lcp_pref_fst_snd, THEN add_nth_pref, folded fst_mismatch_def] not_fst_snd_pref\n  self_pref[of \\<alpha>]"], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<Longrightarrow>\n  \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1\n  \\<not> u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<le>p \\<alpha>\n  \\<alpha> \\<le>p \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p u\\<^sub>0 \\<cdot> u\\<^sub>1", "by fastforce"], ["", "interpretation symcode: binary_code u\\<^sub>1 u\\<^sub>0\n  rewrites  \"symcode.c\\<^sub>0 = c\\<^sub>1\" and  \"symcode.c\\<^sub>1 = c\\<^sub>0\" and \"symcode.\\<alpha> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (binary_code u\\<^sub>1 u\\<^sub>0 &&&\n     binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1) &&&\n    binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0 &&&\n    binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>", "proof-"], ["proof (state)\ngoal (4 subgoals):\n 1. binary_code u\\<^sub>1 u\\<^sub>0\n 2. binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1\n 3. binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0\n 4. binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>", "show \"binary_code u\\<^sub>1 u\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_code u\\<^sub>1 u\\<^sub>0", "unfolding  binary_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<noteq> u\\<^sub>0 \\<cdot> u\\<^sub>1", "using non_comm"], ["proof (prove)\nusing this:\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\n\ngoal (1 subgoal):\n 1. u\\<^sub>1 \\<cdot> u\\<^sub>0 \\<noteq> u\\<^sub>0 \\<cdot> u\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  binary_code u\\<^sub>1 u\\<^sub>0\n\ngoal (3 subgoals):\n 1. binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1\n 2. binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0\n 3. binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>", "show \"binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>", "by (simp add: \\<open>binary_code u\\<^sub>1 u\\<^sub>0\\<close> binary_code.bin_lcp_def lcp_sym)"], ["proof (state)\nthis:\n  binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>\n\ngoal (2 subgoals):\n 1. binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1\n 2. binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0", "show \"binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1", "by (simp add: \\<open>binary_code u\\<^sub>1 u\\<^sub>0\\<close> \\<open>binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>\\<close> binary_code.fst_mismatch_def snd_mismatch_def)"], ["proof (state)\nthis:\n  binary_code.c\\<^sub>0 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>1\n\ngoal (1 subgoal):\n 1. binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0", "show \"binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0", "by (simp add: \\<open>binary_code u\\<^sub>1 u\\<^sub>0\\<close> \\<open>binary_code.\\<alpha> u\\<^sub>1 u\\<^sub>0 = \\<alpha>\\<close> binary_code.snd_mismatch_def fst_mismatch_def)"], ["proof (state)\nthis:\n  binary_code.c\\<^sub>1 u\\<^sub>1 u\\<^sub>0 = c\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas bin_snd_nemp = symcode.bin_fst_nemp and\n       bin_snd_mismatch = symcode.bin_lcp_fst_mismatch_pref"], ["", "lemma bin_lcp_fst_lcp: \"\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> \\<alpha>\" and bin_lcp_snd_lcp: \"\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symcode.\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> symcode.\\<alpha> &&&\n    symcode.\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> symcode.\\<alpha>", "using bin_lcp_fst_mismatch_pref  bin_snd_mismatch"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<cdot> [c\\<^sub>0] \\<le>p\n  u\\<^sub>0 \\<cdot> symcode.\\<alpha>\n  symcode.\\<alpha> \\<cdot> [c\\<^sub>1] \\<le>p\n  u\\<^sub>1 \\<cdot> symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. symcode.\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> symcode.\\<alpha> &&&\n    symcode.\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> symcode.\\<alpha>", "by auto"], ["", "lemma bin_all_nemp: \"ws \\<in> lists {u\\<^sub>0,u\\<^sub>1} \\<Longrightarrow> concat ws = \\<epsilon> \\<Longrightarrow> ws = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ws \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat ws = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> ws = \\<epsilon>", "using bin_fst_nemp bin_snd_nemp"], ["proof (prove)\nusing this:\n  u\\<^sub>0 \\<noteq> \\<epsilon>\n  u\\<^sub>1 \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ws \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat ws = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> ws = \\<epsilon>", "by(induct ws, simp, auto)"], ["", "lemma bin_lcp_all_lcp: \"ws \\<in> lists {u\\<^sub>0,u\\<^sub>1} \\<Longrightarrow> \\<alpha> \\<le>p concat ws \\<cdot> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws \\<in> lists {u\\<^sub>0, u\\<^sub>1} \\<Longrightarrow>\n    symcode.\\<alpha> \\<le>p concat ws \\<cdot> symcode.\\<alpha>", "proof(induct ws rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1} \\<Longrightarrow>\n                symcode.\\<alpha> \\<le>p concat xs \\<cdot> symcode.\\<alpha>;\n        xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> symcode.\\<alpha> \\<le>p\n                         concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>", "case (snoc x xs)"], ["proof (state)\nthis:\n  xs \\<in> lists {u\\<^sub>0, u\\<^sub>1} \\<Longrightarrow>\n  symcode.\\<alpha> \\<le>p concat xs \\<cdot> symcode.\\<alpha>\n  xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1} \\<Longrightarrow>\n                symcode.\\<alpha> \\<le>p concat xs \\<cdot> symcode.\\<alpha>;\n        xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> symcode.\\<alpha> \\<le>p\n                         concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>", "have x_or: \"x = u\\<^sub>0 \\<or> x = u\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = u\\<^sub>0 \\<or> x = u\\<^sub>1", "using \\<open>xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>"], ["proof (prove)\nusing this:\n  xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n\ngoal (1 subgoal):\n 1. x = u\\<^sub>0 \\<or> x = u\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  x = u\\<^sub>0 \\<or> x = u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1} \\<Longrightarrow>\n                symcode.\\<alpha> \\<le>p concat xs \\<cdot> symcode.\\<alpha>;\n        xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> symcode.\\<alpha> \\<le>p\n                         concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>", "have \"xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}", "using \\<open>xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>"], ["proof (prove)\nusing this:\n  xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n\ngoal (1 subgoal):\n 1. xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}", "by auto"], ["proof (state)\nthis:\n  xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1} \\<Longrightarrow>\n                symcode.\\<alpha> \\<le>p concat xs \\<cdot> symcode.\\<alpha>;\n        xs \\<cdot> [x] \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> symcode.\\<alpha> \\<le>p\n                         concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>", "from pref_prolong[OF snoc.hyps, OF this, of \"x\\<cdot>\\<alpha>\", unfolded lassoc]"], ["proof (chain)\npicking this:\n  symcode.\\<alpha> \\<le>p x \\<cdot> symcode.\\<alpha> \\<Longrightarrow>\n  symcode.\\<alpha> \\<le>p (concat xs \\<cdot> x) \\<cdot> symcode.\\<alpha>", "show ?case"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<le>p x \\<cdot> symcode.\\<alpha> \\<Longrightarrow>\n  symcode.\\<alpha> \\<le>p (concat xs \\<cdot> x) \\<cdot> symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. symcode.\\<alpha> \\<le>p concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>", "using bin_lcp_fst_lcp bin_lcp_snd_lcp disjE[OF x_or]"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<le>p x \\<cdot> symcode.\\<alpha> \\<Longrightarrow>\n  symcode.\\<alpha> \\<le>p (concat xs \\<cdot> x) \\<cdot> symcode.\\<alpha>\n  symcode.\\<alpha> \\<le>p u\\<^sub>0 \\<cdot> symcode.\\<alpha>\n  symcode.\\<alpha> \\<le>p u\\<^sub>1 \\<cdot> symcode.\\<alpha>\n  \\<lbrakk>x = u\\<^sub>0 \\<Longrightarrow> ?R;\n   x = u\\<^sub>1 \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. symcode.\\<alpha> \\<le>p concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>", "by auto"], ["proof (state)\nthis:\n  symcode.\\<alpha> \\<le>p concat (xs \\<cdot> [x]) \\<cdot> symcode.\\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_code_alpha: assumes \"us \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"vs \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"hd us  \\<noteq> hd vs\" \n  shows \"concat us \\<cdot> \\<alpha> \\<and>\\<^sub>p concat vs \\<cdot> \\<alpha> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat us \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat vs \\<cdot> symcode.\\<alpha> =\n    symcode.\\<alpha>", "using assms"], ["proof (prove)\nusing this:\n  us \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  vs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  hd us \\<noteq> hd vs\n\ngoal (1 subgoal):\n 1. concat us \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat vs \\<cdot> symcode.\\<alpha> =\n    symcode.\\<alpha>", "proof (induct us vs rule: list_induct2', simp)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    \\<epsilon> \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 2. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd \\<epsilon> \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat \\<epsilon> \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "case (2 x xs)"], ["proof (state)\nthis:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  hd (x # xs) \\<noteq> hd \\<epsilon>\n\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    \\<epsilon> \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 2. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd \\<epsilon> \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat \\<epsilon> \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (x # xs) \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat \\<epsilon> \\<cdot>\n                                    symcode.\\<alpha> =\n    symcode.\\<alpha>", "using bin_lcp_all_lcp[OF \\<open>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>, folded lcp_pref_conv, unfolded lcp_sym[of \\<alpha>]]"], ["proof (prove)\nusing this:\n  concat (x # xs) \\<cdot> symcode.\\<alpha> \\<and>\\<^sub>p symcode.\\<alpha> =\n  symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. concat (x # xs) \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat \\<epsilon> \\<cdot>\n                                    symcode.\\<alpha> =\n    symcode.\\<alpha>", "by simp"], ["proof (state)\nthis:\n  concat (x # xs) \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p concat \\<epsilon> \\<cdot>\n                                  symcode.\\<alpha> =\n  symcode.\\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd \\<epsilon> \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat \\<epsilon> \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd \\<epsilon> \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat \\<epsilon> \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "case (3 y ys)"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  hd \\<epsilon> \\<noteq> hd (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd \\<epsilon> \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat \\<epsilon> \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat \\<epsilon> \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot>\n                                    symcode.\\<alpha> =\n    symcode.\\<alpha>", "using bin_lcp_all_lcp[OF \\<open>y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>, folded lcp_pref_conv]"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot> symcode.\\<alpha> =\n  symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. concat \\<epsilon> \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot>\n                                    symcode.\\<alpha> =\n    symcode.\\<alpha>", "by simp"], ["proof (state)\nthis:\n  concat \\<epsilon> \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot> symcode.\\<alpha> =\n  symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "case (4 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n   ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}; hd xs \\<noteq> hd ys\\<rbrakk>\n  \\<Longrightarrow> concat xs \\<cdot>\n                    symcode.\\<alpha> \\<and>\\<^sub>p concat ys \\<cdot>\n              symcode.\\<alpha> =\n                    symcode.\\<alpha>\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  hd (x # xs) \\<noteq> hd (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "interpret i: binary_code x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_code x y", "using \"4.prems\"(1) \"4.prems\"(2) \"4.prems\"(3) non_comm binary_code.intro"], ["proof (prove)\nusing this:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  hd (x # xs) \\<noteq> hd (y # ys)\n  u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<noteq> u\\<^sub>1 \\<cdot> u\\<^sub>0\n  ?u\\<^sub>0 \\<cdot> ?u\\<^sub>1 \\<noteq>\n  ?u\\<^sub>1 \\<cdot> ?u\\<^sub>0 \\<Longrightarrow>\n  binary_code ?u\\<^sub>0 ?u\\<^sub>1\n\ngoal (1 subgoal):\n 1. binary_code x y", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "have alph: \"{u\\<^sub>0,u\\<^sub>1} = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u\\<^sub>0, u\\<^sub>1} = {x, y}", "using \"4.prems\"(1) \"4.prems\"(2) \"4.prems\"(3)"], ["proof (prove)\nusing this:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  hd (x # xs) \\<noteq> hd (y # ys)\n\ngoal (1 subgoal):\n 1. {u\\<^sub>0, u\\<^sub>1} = {x, y}", "by auto"], ["proof (state)\nthis:\n  {u\\<^sub>0, u\\<^sub>1} = {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "from disjE[OF this[unfolded doubleton_eq_iff]]"], ["proof (chain)\npicking this:\n  \\<lbrakk>u\\<^sub>0 = x \\<and> u\\<^sub>1 = y \\<Longrightarrow> ?R;\n   u\\<^sub>0 = y \\<and> u\\<^sub>1 = x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R", "have \\<alpha>id: \"i.\\<alpha> = \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>u\\<^sub>0 = x \\<and> u\\<^sub>1 = y \\<Longrightarrow> ?R;\n   u\\<^sub>0 = y \\<and> u\\<^sub>1 = x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. i.\\<alpha> = symcode.\\<alpha>", "unfolding bin_lcp_def i.bin_lcp_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>u\\<^sub>0 = x \\<and> u\\<^sub>1 = y \\<Longrightarrow> ?R;\n   u\\<^sub>0 = y \\<and> u\\<^sub>1 = x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<and>\\<^sub>p y \\<cdot> x =\n    u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0", "using lcp_sym"], ["proof (prove)\nusing this:\n  \\<lbrakk>u\\<^sub>0 = x \\<and> u\\<^sub>1 = y \\<Longrightarrow> ?R;\n   u\\<^sub>0 = y \\<and> u\\<^sub>1 = x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  ?u \\<and>\\<^sub>p ?v = ?v \\<and>\\<^sub>p ?u\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<and>\\<^sub>p y \\<cdot> x =\n    u\\<^sub>0 \\<cdot> u\\<^sub>1 \\<and>\\<^sub>p u\\<^sub>1 \\<cdot> u\\<^sub>0", "by auto"], ["proof (state)\nthis:\n  i.\\<alpha> = symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "have c0: \"i.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<le>p x \\<cdot> concat xs \\<cdot> i.\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<le>p\n    x \\<cdot> concat xs \\<cdot> i.\\<alpha>", "using  i.bin_lcp_all_lcp[of xs] \\<open>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>[unfolded Cons_in_lists_iff alph] \n      pref_prolong[OF i.bin_lcp_fst_mismatch_pref]"], ["proof (prove)\nusing this:\n  xs \\<in> lists {x, y} \\<Longrightarrow>\n  i.\\<alpha> \\<le>p concat xs \\<cdot> i.\\<alpha>\n  x \\<in> {x, y} \\<and> xs \\<in> lists {x, y}\n  i.\\<alpha> \\<le>p ?s \\<Longrightarrow>\n  i.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<le>p x \\<cdot> ?s\n\ngoal (1 subgoal):\n 1. i.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<le>p\n    x \\<cdot> concat xs \\<cdot> i.\\<alpha>", "by blast"], ["proof (state)\nthis:\n  i.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<le>p\n  x \\<cdot> concat xs \\<cdot> i.\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "have c1: \"i.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<le>p y \\<cdot> concat ys \\<cdot> i.\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<le>p\n    y \\<cdot> concat ys \\<cdot> i.\\<alpha>", "using  i.bin_lcp_all_lcp[of ys] \\<open>y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>[unfolded Cons_in_lists_iff alph] \n      pref_prolong[OF i.bin_snd_mismatch]"], ["proof (prove)\nusing this:\n  ys \\<in> lists {x, y} \\<Longrightarrow>\n  i.\\<alpha> \\<le>p concat ys \\<cdot> i.\\<alpha>\n  y \\<in> {x, y} \\<and> ys \\<in> lists {x, y}\n  i.\\<alpha> \\<le>p ?s \\<Longrightarrow>\n  i.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<le>p y \\<cdot> ?s\n\ngoal (1 subgoal):\n 1. i.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<le>p\n    y \\<cdot> concat ys \\<cdot> i.\\<alpha>", "by blast"], ["proof (state)\nthis:\n  i.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<le>p\n  y \\<cdot> concat ys \\<cdot> i.\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "have \"i.\\<alpha>\\<cdot>[i.c\\<^sub>0] \\<and>\\<^sub>p i.\\<alpha>\\<cdot>[i.c\\<^sub>1] = i.\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.\\<alpha> \\<cdot>\n    [i.c\\<^sub>0] \\<and>\\<^sub>p i.\\<alpha> \\<cdot> [i.c\\<^sub>1] =\n    i.\\<alpha>", "by (simp add: i.bin_mismatch_neq lcp_first_mismatch')"], ["proof (state)\nthis:\n  i.\\<alpha> \\<cdot>\n  [i.c\\<^sub>0] \\<and>\\<^sub>p i.\\<alpha> \\<cdot> [i.c\\<^sub>1] =\n  i.\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 hd xs \\<noteq> hd ys\\<rbrakk>\n                \\<Longrightarrow> concat xs \\<cdot>\n                                  symcode.\\<alpha> \\<and>\\<^sub>p concat\n                             ys \\<cdot>\n                            symcode.\\<alpha> =\n                                  symcode.\\<alpha>;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        hd (x # xs) \\<noteq> hd (y # ys)\\<rbrakk>\n       \\<Longrightarrow> concat (x # xs) \\<cdot>\n                         symcode.\\<alpha> \\<and>\\<^sub>p concat\n                    (y # ys) \\<cdot>\n                   symcode.\\<alpha> =\n                         symcode.\\<alpha>", "from lcp_rulers[OF c0 c1, unfolded this, unfolded \\<alpha>id]"], ["proof (chain)\npicking this:\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<bowtie>\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<or>\n  symcode.\\<alpha> =\n  x \\<cdot>\n  concat xs \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p y \\<cdot>\n                                  concat ys \\<cdot> symcode.\\<alpha>", "show ?case"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<bowtie>\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<or>\n  symcode.\\<alpha> =\n  x \\<cdot>\n  concat xs \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p y \\<cdot>\n                                  concat ys \\<cdot> symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. concat (x # xs) \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot>\n                                    symcode.\\<alpha> =\n    symcode.\\<alpha>", "unfolding concat.simps(2) rassoc pref_cancel_conv"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<bowtie>\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<or>\n  symcode.\\<alpha> =\n  x \\<cdot>\n  concat xs \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p y \\<cdot>\n                                  concat ys \\<cdot> symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. x \\<cdot>\n    concat xs \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p y \\<cdot>\n                                    concat ys \\<cdot> symcode.\\<alpha> =\n    symcode.\\<alpha>", "using i.bin_mismatch_neq"], ["proof (prove)\nusing this:\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>0] \\<bowtie>\n  symcode.\\<alpha> \\<cdot> [i.c\\<^sub>1] \\<or>\n  symcode.\\<alpha> =\n  x \\<cdot>\n  concat xs \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p y \\<cdot>\n                                  concat ys \\<cdot> symcode.\\<alpha>\n  i.c\\<^sub>0 \\<noteq> i.c\\<^sub>1\n\ngoal (1 subgoal):\n 1. x \\<cdot>\n    concat xs \\<cdot>\n    symcode.\\<alpha> \\<and>\\<^sub>p y \\<cdot>\n                                    concat ys \\<cdot> symcode.\\<alpha> =\n    symcode.\\<alpha>", "by simp"], ["proof (state)\nthis:\n  concat (x # xs) \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot> symcode.\\<alpha> =\n  symcode.\\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bin_code: assumes \"us \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"vs \\<in> lists {u\\<^sub>0,u\\<^sub>1}\" and \"concat us = concat vs\"\n  shows \"us = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us = vs", "using assms"], ["proof (prove)\nusing this:\n  us \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  vs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat us = concat vs\n\ngoal (1 subgoal):\n 1. us = vs", "proof (induct us vs rule: list_induct2', simp)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> x # xs = \\<epsilon>\n 2. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (2 x xs)"], ["proof (state)\nthis:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat \\<epsilon>\n\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> x # xs = \\<epsilon>\n 2. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "then"], ["proof (chain)\npicking this:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat \\<epsilon>", "show ?case"], ["proof (prove)\nusing this:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat \\<epsilon>\n\ngoal (1 subgoal):\n 1. x # xs = \\<epsilon>", "using bin_fst_nemp bin_snd_nemp"], ["proof (prove)\nusing this:\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat \\<epsilon>\n  u\\<^sub>0 \\<noteq> \\<epsilon>\n  u\\<^sub>1 \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. x # xs = \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  x # xs = \\<epsilon>\n\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (3 y ys)"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat \\<epsilon> = concat (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "then"], ["proof (chain)\npicking this:\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat \\<epsilon> = concat (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat \\<epsilon> = concat (y # ys)\n\ngoal (1 subgoal):\n 1. \\<epsilon> = y # ys", "using bin_fst_nemp bin_snd_nemp"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat \\<epsilon> = concat (y # ys)\n  u\\<^sub>0 \\<noteq> \\<epsilon>\n  u\\<^sub>1 \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<epsilon> = y # ys", "by auto"], ["proof (state)\nthis:\n  \\<epsilon> = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (4 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n   ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}; concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n   ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}; concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n   ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}; concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  concat (x # xs) = concat (y # ys)\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "proof(cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x = y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys\n 2. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x = y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys\n 2. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "thus \"x # xs = y # ys\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "using \"4.hyps\" \\<open>concat (x # xs) = concat (y # ys)\\<close>[unfolded  concat.simps(2) \\<open>x = y\\<close>, unfolded cancel]  \n      \\<open>y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>[unfolded Cons_in_lists_iff] \\<open>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>[unfolded Cons_in_lists_iff]"], ["proof (prove)\nusing this:\n  x = y\n  \\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n   ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}; concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  concat xs = concat ys\n  y \\<in> {u\\<^sub>0, u\\<^sub>1} \\<and>\n  ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n  x \\<in> {u\\<^sub>0, u\\<^sub>1} \\<and>\n  xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by simp"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "have \"concat(y # ys) = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (y # ys) = \\<epsilon>", "using bin_code_alpha[OF \\<open>x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close> \\<open>y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close>, unfolded list.sel(1) \\<open>concat (x # xs) = concat (y # ys)\\<close>, OF \\<open>x \\<noteq> y\\<close>]"], ["proof (prove)\nusing this:\n  concat (y # ys) \\<cdot>\n  symcode.\\<alpha> \\<and>\\<^sub>p concat (y # ys) \\<cdot> symcode.\\<alpha> =\n  symcode.\\<alpha>\n\ngoal (1 subgoal):\n 1. concat (y # ys) = \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  concat (y # ys) = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "from bin_all_nemp[OF \\<open>y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1}\\<close> this]"], ["proof (chain)\npicking this:\n  y # ys = \\<epsilon>", "have False"], ["proof (prove)\nusing this:\n  y # ys = \\<epsilon>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n              concat xs = concat ys\\<rbrakk>\n             \\<Longrightarrow> xs = ys;\n     x # xs \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     y # ys \\<in> lists {u\\<^sub>0, u\\<^sub>1};\n     concat (x # xs) = concat (y # ys); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x # xs = y # ys", "thus \"x # xs = y # ys\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by blast"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas no_comm_bin_code = binary_code.bin_code[unfolded binary_code_def]"], ["", "theorem bin_code_code: assumes \"u \\<cdot> v \\<noteq> v \\<cdot> u\" shows \"code {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code {u, v}", "unfolding code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       xs \\<in> lists {u, v} \\<longrightarrow>\n       ys \\<in> lists {u, v} \\<longrightarrow>\n       concat xs = concat ys \\<longrightarrow> xs = ys", "using no_comm_bin_code[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?us \\<in> lists {u, v}; ?vs \\<in> lists {u, v};\n   concat ?us = concat ?vs\\<rbrakk>\n  \\<Longrightarrow> ?us = ?vs\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       xs \\<in> lists {u, v} \\<longrightarrow>\n       ys \\<in> lists {u, v} \\<longrightarrow>\n       concat xs = concat ys \\<longrightarrow> xs = ys", "by blast"], ["", "section \\<open>Free hull\\<close>"], ["", "text\\<open>While not every set $G$ of generators is a code, there is a unique minimal free monoid containing it, called the \\emph{free hull} of $G$.\nIt can be defined inductively using the property known as the \\emph{stability condition}.\n\\<close>"], ["", "inductive_set free_hull :: \"'a list set \\<Rightarrow> 'a list set\" (\"\\<langle>_\\<rangle>\\<^sub>F\")\n  for G where\n    \"\\<epsilon> \\<in> \\<langle>G\\<rangle>\\<^sub>F\"\n  | free_gen_in: \"w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\\<^sub>F\"\n  | \"w1 \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F\"\n  | \"p \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> q \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> p \\<cdot> w \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w \\<cdot> q \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\\<^sub>F\" \\<comment> \\<open>the stability condition\\<close>"], ["", "lemmas [intro] = free_hull.intros"], ["", "text\\<open>The defined set indeed is a hull.\\<close>"], ["", "lemma free_hull_hull: \"\\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> = \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> =\n    \\<langle>G\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n 2. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>", "show \"\\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>", "by (simp add: genset_sub)"], ["proof (state)\nthis:\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "show \"\\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "assume \"x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "thus \"x \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "proof (rule hull.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<epsilon> \\<in> \\<langle>G\\<rangle>\\<^sub>F\n 2. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w2 \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>;\n        w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F", "show \" \\<epsilon> \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> \\<langle>G\\<rangle>\\<^sub>F", "by (simp add: free_hull.intros(1))"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w2 \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>;\n        w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F", "show \"\\<And>w1 w2. w1 \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w2 \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle> \\<Longrightarrow> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w1 w2.\n       \\<lbrakk>w1 \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w2 \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>;\n        w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w1 \\<cdot> w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F", "by (simp add: free_hull.intros(3))"], ["proof (state)\nthis:\n  \\<lbrakk>?w1.0 \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n   ?w2.0 \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>;\n   ?w2.0 \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<cdot> ?w2.0 \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n  \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The free hull is always (non-strictly) larger than the hull.\\<close>"], ["", "lemma hull_in_free_hull: \"\\<langle>G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle> \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "assume \"x \\<in> \\<langle>G\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>G\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<langle>G\\<rangle>", "show \"x \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>G\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "using free_hull.intros(3) \n      hull_induct[of x G \"\\<lambda> x. x \\<in> \\<langle>G\\<rangle>\\<^sub>F\", OF \\<open>x \\<in> \\<langle>G\\<rangle>\\<close> free_hull.intros(1)[of G] free_hull.intros(2)]"], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>G\\<rangle>\n  \\<lbrakk>?w1.0 \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?w2.0 \\<in> \\<langle>?G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w1.0 \\<cdot> ?w2.0 \\<in> \\<langle>?G\\<rangle>\\<^sub>F\n  \\<lbrakk>\\<And>w. w \\<in> G \\<Longrightarrow> w \\<in> G;\n   \\<And>w1 w2.\n      \\<lbrakk>w1 \\<in> \\<langle>G\\<rangle>;\n       w1 \\<in> \\<langle>G\\<rangle>\\<^sub>F; w2 \\<in> \\<langle>G\\<rangle>;\n       w2 \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n      \\<Longrightarrow> w1 \\<cdot> w2\n                        \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>On the other hand, it can be proved that the \\emph{free basis}, defined as the basis of the free hull,  has a (non-strictly) smaller cardinality than the ordinary basis.\\<close>"], ["", "definition free_basis ::  \"'a list set \\<Rightarrow> 'a list set\" (\"\\<BB>\\<^sub>F _\" [54] 55)\n  where  \"free_basis G \\<equiv> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\""], ["", "lemma basis_gen_hull_free: \"\\<langle>\\<BB>\\<^sub>F G\\<rangle> = \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<BB>\\<^sub>F G\\<rangle> = \\<langle>G\\<rangle>\\<^sub>F", "unfolding free_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<BB> \\<langle>G\\<rangle>\\<^sub>F\\<rangle> =\n    \\<langle>G\\<rangle>\\<^sub>F", "using basis_gen_hull free_hull_hull"], ["proof (prove)\nusing this:\n  \\<langle>\\<BB> ?G\\<rangle> = \\<langle>?G\\<rangle>\n  \\<langle>\\<langle>?G\\<rangle>\\<^sub>F\\<rangle> =\n  \\<langle>?G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>\\<BB> \\<langle>G\\<rangle>\\<^sub>F\\<rangle> =\n    \\<langle>G\\<rangle>\\<^sub>F", "by blast"], ["", "lemma genset_sub_free: \"G \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "by (simp add: free_hull.free_gen_in subsetI)"], ["", "text\n\\<open>We have developed two points of view on freeness: \n\\<^item> being a free hull, that is, to satisfy the stability condition;\n\\<^item> being generated by a code.\\<close>"], ["", "text\\<open>We now show their equivalence\\<close>"], ["", "text\\<open>First, basis of a free hull is a code.\\<close>"], ["", "lemma free_basis_code: \"code (\\<BB>\\<^sub>F G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code (\\<BB>\\<^sub>F G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n        ys \\<in> lists (\\<BB>\\<^sub>F G); concat xs = concat ys\\<rbrakk>\n       \\<Longrightarrow> xs = ys", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n        ys \\<in> lists (\\<BB>\\<^sub>F G); concat xs = concat ys\\<rbrakk>\n       \\<Longrightarrow> xs = ys", "show \"xs \\<in> lists (\\<BB>\\<^sub>F G) \\<Longrightarrow> ys \\<in> lists (\\<BB>\\<^sub>F G) \\<Longrightarrow> concat xs = concat ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n     ys \\<in> lists (\\<BB>\\<^sub>F G); concat xs = concat ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "proof(induction xs ys rule: list_induct2', simp)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        \\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> x # xs = \\<epsilon>\n 2. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (2 x xs)"], ["proof (state)\nthis:\n  x # xs \\<in> lists (\\<BB>\\<^sub>F G)\n  \\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G)\n  concat (x # xs) = concat \\<epsilon>\n\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        \\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> x # xs = \\<epsilon>\n 2. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs = \\<epsilon>", "using listsE[OF \\<open>x # xs \\<in> lists (\\<BB>\\<^sub>F G)\\<close>, of \"x \\<in> \\<BB>\\<^sub>F G\", unfolded free_basis_def, THEN emp_not_basis]    \n      concat.simps(2)[of x xs, unfolded \\<open>concat (x # xs) = concat \\<epsilon>\\<close>[unfolded concat.simps(1)], symmetric, unfolded append_is_Nil_conv[of x \"concat xs\"]]"], ["proof (prove)\nusing this:\n  (\\<lbrakk>x \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F;\n    xs \\<in> lists \\<BB> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n   \\<Longrightarrow> x \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F) \\<Longrightarrow>\n  x \\<noteq> \\<epsilon>\n  x = \\<epsilon> \\<and> concat xs = \\<epsilon>\n\ngoal (1 subgoal):\n 1. x # xs = \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  x # xs = \\<epsilon>\n\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (3 y ys)"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G)\n  y # ys \\<in> lists (\\<BB>\\<^sub>F G)\n  concat \\<epsilon> = concat (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>\\<epsilon> \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat \\<epsilon> = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> \\<epsilon> = y # ys\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> = y # ys", "using  listsE[OF \\<open>y # ys \\<in> lists (\\<BB>\\<^sub>F G)\\<close>, of \"y \\<in> \\<BB>\\<^sub>F G\", unfolded free_basis_def, THEN emp_not_basis]    \n      concat.simps(2)[of y ys, unfolded \\<open>concat \\<epsilon> = concat (y # ys)\\<close>[unfolded concat.simps(1),symmetric],symmetric, unfolded append_is_Nil_conv[of y \"concat ys\"]]"], ["proof (prove)\nusing this:\n  (\\<lbrakk>y \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F;\n    ys \\<in> lists \\<BB> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n   \\<Longrightarrow> y \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F) \\<Longrightarrow>\n  y \\<noteq> \\<epsilon>\n  y = \\<epsilon> \\<and> concat ys = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<epsilon> = y # ys", "by blast"], ["proof (state)\nthis:\n  \\<epsilon> = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (4 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n   ys \\<in> lists (\\<BB>\\<^sub>F G); concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  x # xs \\<in> lists (\\<BB>\\<^sub>F G)\n  y # ys \\<in> lists (\\<BB>\\<^sub>F G)\n  concat (x # xs) = concat (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have \"\\<^bold>|x\\<^bold>| = \\<^bold>|y\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| = \\<^bold>|y\\<^bold>|", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "assume \"\\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>|\""], ["proof (state)\nthis:\n  \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "have \"x \\<cdot> concat xs = y \\<cdot> concat ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> concat xs = y \\<cdot> concat ys", "using \\<open>concat (x # xs) = concat (y # ys)\\<close>"], ["proof (prove)\nusing this:\n  concat (x # xs) = concat (y # ys)\n\ngoal (1 subgoal):\n 1. x \\<cdot> concat xs = y \\<cdot> concat ys", "by simp"], ["proof (state)\nthis:\n  x \\<cdot> concat xs = y \\<cdot> concat ys\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<cdot> concat xs = y \\<cdot> concat ys", "obtain t where or: \"x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or> x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\""], ["proof (prove)\nusing this:\n  x \\<cdot> concat xs = y \\<cdot> concat ys\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n        x \\<cdot> t = y \\<and>\n        concat xs = t \\<cdot> concat ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using append_eq_append_conv2[of x \"concat xs\" y \"concat ys\"]"], ["proof (prove)\nusing this:\n  x \\<cdot> concat xs = y \\<cdot> concat ys\n  (x \\<cdot> concat xs = y \\<cdot> concat ys) =\n  (\\<exists>us.\n      x = y \\<cdot> us \\<and> us \\<cdot> concat xs = concat ys \\<or>\n      x \\<cdot> us = y \\<and> concat xs = us \\<cdot> concat ys)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n        x \\<cdot> t = y \\<and>\n        concat xs = t \\<cdot> concat ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "hence \"t \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<epsilon>", "using \\<open>\\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>|\\<close>"], ["proof (prove)\nusing this:\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n  \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>|\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "have \"x \\<in> \\<BB>\\<^sub>F G\" and \"y \\<in> \\<BB>\\<^sub>F G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<BB>\\<^sub>F G &&& y \\<in> \\<BB>\\<^sub>F G", "using  listsE[OF \\<open>x # xs \\<in> lists (\\<BB>\\<^sub>F G)\\<close>, of \"x \\<in> \\<BB>\\<^sub>F G\" ] listsE[OF \\<open>y # ys \\<in> lists (\\<BB>\\<^sub>F G)\\<close>, of \"y \\<in> \\<BB>\\<^sub>F G\" ]"], ["proof (prove)\nusing this:\n  (\\<lbrakk>x \\<in> \\<BB>\\<^sub>F G;\n    xs \\<in> lists (\\<BB>\\<^sub>F G)\\<rbrakk>\n   \\<Longrightarrow> x \\<in> \\<BB>\\<^sub>F G) \\<Longrightarrow>\n  x \\<in> \\<BB>\\<^sub>F G\n  (\\<lbrakk>y \\<in> \\<BB>\\<^sub>F G;\n    ys \\<in> lists (\\<BB>\\<^sub>F G)\\<rbrakk>\n   \\<Longrightarrow> y \\<in> \\<BB>\\<^sub>F G) \\<Longrightarrow>\n  y \\<in> \\<BB>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. x \\<in> \\<BB>\\<^sub>F G &&& y \\<in> \\<BB>\\<^sub>F G", "by blast+"], ["proof (state)\nthis:\n  x \\<in> \\<BB>\\<^sub>F G\n  y \\<in> \\<BB>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "hence \"x \\<noteq> \\<epsilon>\" and \"y \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  x \\<in> \\<BB>\\<^sub>F G\n  y \\<in> \\<BB>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. x \\<noteq> \\<epsilon> &&& y \\<noteq> \\<epsilon>", "unfolding free_basis_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\n  y \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. x \\<noteq> \\<epsilon> &&& y \\<noteq> \\<epsilon>", "using emp_not_basis"], ["proof (prove)\nusing this:\n  x \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\n  y \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\n  ?x \\<in> \\<BB> ?G \\<Longrightarrow> ?x \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. x \\<noteq> \\<epsilon> &&& y \\<noteq> \\<epsilon>", "by blast+"], ["proof (state)\nthis:\n  x \\<noteq> \\<epsilon>\n  y \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "have  \"x \\<in> \\<langle>G\\<rangle>\\<^sub>F\" and \"y \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>\\<^sub>F &&&\n    y \\<in> \\<langle>G\\<rangle>\\<^sub>F", "using basis_sub[of \"\\<langle>G\\<rangle>\\<^sub>F\", unfolded free_basis_def[symmetric] ] \\<open>x # xs \\<in> lists (\\<BB>\\<^sub>F G)\\<close> \n          \\<open>y # ys \\<in> lists (\\<BB>\\<^sub>F G)\\<close>"], ["proof (prove)\nusing this:\n  \\<BB>\\<^sub>F G \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n  x # xs \\<in> lists (\\<BB>\\<^sub>F G)\n  y # ys \\<in> lists (\\<BB>\\<^sub>F G)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>\\<^sub>F &&&\n    y \\<in> \\<langle>G\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  y \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "have \"concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F\" and \"concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F &&&\n    concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F", "using concat_tl_basis[OF \\<open>x # xs \\<in> lists (\\<BB>\\<^sub>F G)\\<close>[unfolded free_basis_def]] \n              concat_tl_basis[OF \\<open>y # ys \\<in> lists (\\<BB>\\<^sub>F G)\\<close>[unfolded free_basis_def]]"], ["proof (prove)\nusing this:\n  concat xs \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n  concat ys \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\n\ngoal (1 subgoal):\n 1. concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F &&&\n    concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F", "unfolding free_hull_hull"], ["proof (prove)\nusing this:\n  concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F &&&\n    concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F", "."], ["proof (state)\nthis:\n  concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "have \"t \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> \\<langle>G\\<rangle>\\<^sub>F", "using or free_hull.intros(4) \\<open>x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close> \\<open>y \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close> \\<open>concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close> \\<open>concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close>"], ["proof (prove)\nusing this:\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n  \\<lbrakk>?p \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?q \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?p \\<cdot> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?w \\<cdot> ?q \\<in> \\<langle>?G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F\n  x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  y \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  concat xs \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  concat ys \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. t \\<in> \\<langle>G\\<rangle>\\<^sub>F", "by metis"], ["proof (state)\nthis:\n  t \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<^bold>|x\\<^bold>| \\<noteq> \\<^bold>|y\\<^bold>| \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  t \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. False", "using or basis_dec[of x \"\\<langle>G\\<rangle>\\<^sub>F\" t, unfolded free_hull_hull, OF \\<open>x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close> \\<open>t \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close>] \n          basis_dec[of y \"\\<langle>G\\<rangle>\\<^sub>F\" t, unfolded free_hull_hull, OF \\<open>y \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close> \\<open>t \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close>]"], ["proof (prove)\nusing this:\n  t \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n  x \\<cdot> t \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>\n  x = \\<epsilon> \\<or> t = \\<epsilon>\n  y \\<cdot> t \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>\n  y = \\<epsilon> \\<or> t = \\<epsilon>\n\ngoal (1 subgoal):\n 1. False", "using  \\<open>t \\<noteq> \\<epsilon>\\<close> \\<open>x \\<noteq> \\<epsilon>\\<close> \\<open>y \\<noteq> \\<epsilon>\\<close> \\<open>x \\<in> \\<BB>\\<^sub>F G\\<close> \\<open>y \\<in> \\<BB>\\<^sub>F G\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n  x \\<cdot> t \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>\n  x = \\<epsilon> \\<or> t = \\<epsilon>\n  y \\<cdot> t \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>\n  y = \\<epsilon> \\<or> t = \\<epsilon>\n  t \\<noteq> \\<epsilon>\n  x \\<noteq> \\<epsilon>\n  y \\<noteq> \\<epsilon>\n  x \\<in> \\<BB>\\<^sub>F G\n  y \\<in> \\<BB>\\<^sub>F G\n\ngoal (1 subgoal):\n 1. False", "unfolding free_basis_def"], ["proof (prove)\nusing this:\n  t \\<in> \\<langle>G\\<rangle>\\<^sub>F\n  x = y \\<cdot> t \\<and> t \\<cdot> concat xs = concat ys \\<or>\n  x \\<cdot> t = y \\<and> concat xs = t \\<cdot> concat ys\n  x \\<cdot> t \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>\n  x = \\<epsilon> \\<or> t = \\<epsilon>\n  y \\<cdot> t \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>\n  y = \\<epsilon> \\<or> t = \\<epsilon>\n  t \\<noteq> \\<epsilon>\n  x \\<noteq> \\<epsilon>\n  y \\<noteq> \\<epsilon>\n  x \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\n  y \\<in> \\<BB> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>|x\\<^bold>| = \\<^bold>|y\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n                 ys \\<in> lists (\\<BB>\\<^sub>F G);\n                 concat xs = concat ys\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        x # xs \\<in> lists (\\<BB>\\<^sub>F G);\n        y # ys \\<in> lists (\\<BB>\\<^sub>F G);\n        concat (x # xs) = concat (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "thus \"x # xs = y # ys\""], ["proof (prove)\nusing this:\n  \\<^bold>|x\\<^bold>| = \\<^bold>|y\\<^bold>|\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "using \"4.IH\" \\<open>x # xs \\<in> lists (\\<BB>\\<^sub>F G)\\<close> \\<open>y # ys \\<in> lists (\\<BB>\\<^sub>F G)\\<close> \\<open>concat (x # xs) = concat (y # ys)\\<close>"], ["proof (prove)\nusing this:\n  \\<^bold>|x\\<^bold>| = \\<^bold>|y\\<^bold>|\n  \\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n   ys \\<in> lists (\\<BB>\\<^sub>F G); concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  x # xs \\<in> lists (\\<BB>\\<^sub>F G)\n  y # ys \\<in> lists (\\<BB>\\<^sub>F G)\n  concat (x # xs) = concat (y # ys)\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by auto"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal:\nNo subgoals!", "next"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<in> lists (\\<BB>\\<^sub>F G);\n   ys \\<in> lists (\\<BB>\\<^sub>F G); concat xs = concat ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Second, a code generates its free hull.\\<close>"], ["", "lemma code_gen_free_hull: \"code C \\<Longrightarrow> \\<langle>C\\<rangle>\\<^sub>F = \\<langle>C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code C \\<Longrightarrow>\n    \\<langle>C\\<rangle>\\<^sub>F = \\<langle>C\\<rangle>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. code C \\<Longrightarrow>\n    \\<langle>C\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\n 2. code C \\<Longrightarrow>\n    \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F", "assume \"code C\""], ["proof (state)\nthis:\n  code C\n\ngoal (2 subgoals):\n 1. code C \\<Longrightarrow>\n    \\<langle>C\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\n 2. code C \\<Longrightarrow>\n    \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F", "show \"\\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F", "using hull_mon[of C \"\\<langle>C\\<rangle>\\<^sub>F\"] \n          free_hull.free_gen_in[of _ C]  subsetI[of C \"\\<langle>C\\<rangle>\\<^sub>F\"]"], ["proof (prove)\nusing this:\n  C \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F \\<Longrightarrow>\n  \\<langle>C\\<rangle>\n  \\<subseteq> \\<langle>\\<langle>C\\<rangle>\\<^sub>F\\<rangle>\n  ?w \\<in> C \\<Longrightarrow> ?w \\<in> \\<langle>C\\<rangle>\\<^sub>F\n  (\\<And>x.\n      x \\<in> C \\<Longrightarrow>\n      x \\<in> \\<langle>C\\<rangle>\\<^sub>F) \\<Longrightarrow>\n  C \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F", "unfolding free_hull_hull[of C]"], ["proof (prove)\nusing this:\n  C \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F \\<Longrightarrow>\n  \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F\n  ?w \\<in> C \\<Longrightarrow> ?w \\<in> \\<langle>C\\<rangle>\\<^sub>F\n  (\\<And>x.\n      x \\<in> C \\<Longrightarrow>\n      x \\<in> \\<langle>C\\<rangle>\\<^sub>F) \\<Longrightarrow>\n  C \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  \\<langle>C\\<rangle> \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. code C \\<Longrightarrow>\n    \\<langle>C\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>", "show \"\\<langle>C\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>C\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>C\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>C\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>C\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>C\\<rangle>", "assume \"x \\<in> \\<langle>C\\<rangle>\\<^sub>F\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>C\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>C\\<rangle>", "have \"\\<epsilon> \\<in> \\<langle>C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> \\<in> \\<langle>C\\<rangle>", "by (simp add: hull.intros(1))"], ["proof (state)\nthis:\n  \\<epsilon> \\<in> \\<langle>C\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>C\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>C\\<rangle>", "show \"x \\<in> \\<langle>C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>C\\<rangle>", "proof(rule free_hull.induct[of x C],simp add: \\<open>x \\<in> \\<langle>C\\<rangle>\\<^sub>F\\<close>, (simp add: hull.intros hull_closed)+, \n        simp add: gen_in, simp add: hull_closed)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "fix p q w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "assume \"p \\<in> \\<langle>C\\<rangle>\" \"q \\<in> \\<langle>C\\<rangle>\" \"p \\<cdot> w \\<in> \\<langle>C\\<rangle>\" \"w \\<cdot> q \\<in> \\<langle>C\\<rangle>\""], ["proof (state)\nthis:\n  p \\<in> \\<langle>C\\<rangle>\n  q \\<in> \\<langle>C\\<rangle>\n  p \\<cdot> w \\<in> \\<langle>C\\<rangle>\n  w \\<cdot> q \\<in> \\<langle>C\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "have eq: \"(Dec C p) \\<cdot> (Dec C w \\<cdot> q) = (Dec C p \\<cdot> w) \\<cdot> (Dec C q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Dec C p) \\<cdot> (Dec C w \\<cdot> q) =\n    (Dec C p \\<cdot> w) \\<cdot> (Dec C q)", "using code.code_dec_morph[OF \\<open>code C\\<close> \\<open>p \\<in> \\<langle>C\\<rangle>\\<close> \\<open>w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<close>, unfolded lassoc]"], ["proof (prove)\nusing this:\n  (Dec C p) \\<cdot> (Dec C w \\<cdot> q) = Dec C (p \\<cdot> w) \\<cdot> q\n\ngoal (1 subgoal):\n 1. (Dec C p) \\<cdot> (Dec C w \\<cdot> q) =\n    (Dec C p \\<cdot> w) \\<cdot> (Dec C q)", "unfolding code.code_dec_morph[OF \\<open>code C\\<close> \\<open>p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<close> \\<open>q \\<in> \\<langle>C\\<rangle>\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  (Dec C p) \\<cdot> (Dec C w \\<cdot> q) =\n  (Dec C p \\<cdot> w) \\<cdot> (Dec C q)\n\ngoal (1 subgoal):\n 1. (Dec C p) \\<cdot> (Dec C w \\<cdot> q) =\n    (Dec C p \\<cdot> w) \\<cdot> (Dec C q)", "."], ["proof (state)\nthis:\n  (Dec C p) \\<cdot> (Dec C w \\<cdot> q) =\n  (Dec C p \\<cdot> w) \\<cdot> (Dec C q)\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "have \"Dec C p \\<bowtie>  Dec C p \\<cdot> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dec C p \\<bowtie> Dec C p \\<cdot> w", "using eqd_comp[OF eq]"], ["proof (prove)\nusing this:\n  Dec C p \\<bowtie> Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. Dec C p \\<bowtie> Dec C p \\<cdot> w", "."], ["proof (state)\nthis:\n  Dec C p \\<bowtie> Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "hence \"Dec C p \\<le>p  Dec C p \\<cdot> w\""], ["proof (prove)\nusing this:\n  Dec C p \\<bowtie> Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. Dec C p \\<le>p Dec C p \\<cdot> w", "using \\<open>p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<close> \\<open>p \\<in> \\<langle>C\\<rangle>\\<close> concat_morph decI prefD pref_antisym triv_pref"], ["proof (prove)\nusing this:\n  Dec C p \\<bowtie> Dec C p \\<cdot> w\n  p \\<cdot> w \\<in> \\<langle>C\\<rangle>\n  p \\<in> \\<langle>C\\<rangle>\n  concat ?xs \\<cdot> concat ?ys = concat (?xs \\<cdot> ?ys)\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow> concat (Dec ?G ?u) = ?u\n  ?u \\<le>p ?v \\<Longrightarrow> \\<exists>z. ?v = ?u \\<cdot> z\n  \\<lbrakk>?a \\<le>p ?b; ?b \\<le>p ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?r \\<le>p ?r \\<cdot> ?s\n\ngoal (1 subgoal):\n 1. Dec C p \\<le>p Dec C p \\<cdot> w", "unfolding prefix_comparable_def"], ["proof (prove)\nusing this:\n  Dec C p \\<le>p Dec C p \\<cdot> w \\<or> Dec C p \\<cdot> w \\<le>p Dec C p\n  p \\<cdot> w \\<in> \\<langle>C\\<rangle>\n  p \\<in> \\<langle>C\\<rangle>\n  concat ?xs \\<cdot> concat ?ys = concat (?xs \\<cdot> ?ys)\n  ?u \\<in> \\<langle>?G\\<rangle> \\<Longrightarrow> concat (Dec ?G ?u) = ?u\n  ?u \\<le>p ?v \\<Longrightarrow> \\<exists>z. ?v = ?u \\<cdot> z\n  \\<lbrakk>?a \\<le>p ?b; ?b \\<le>p ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?r \\<le>p ?r \\<cdot> ?s\n\ngoal (1 subgoal):\n 1. Dec C p \\<le>p Dec C p \\<cdot> w", "by metis"], ["proof (state)\nthis:\n  Dec C p \\<le>p Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "then"], ["proof (chain)\npicking this:\n  Dec C p \\<le>p Dec C p \\<cdot> w", "obtain ts where \"(Dec C p) \\<cdot> ts =  Dec C p \\<cdot> w\""], ["proof (prove)\nusing this:\n  Dec C p \\<le>p Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        (Dec C p) \\<cdot> ts = Dec C p \\<cdot> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using lq_pref"], ["proof (prove)\nusing this:\n  Dec C p \\<le>p Dec C p \\<cdot> w\n  ?u \\<le>p ?v \\<Longrightarrow> ?u \\<cdot> ?u\\<inverse>\\<^sup>>?v = ?v\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        (Dec C p) \\<cdot> ts = Dec C p \\<cdot> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (Dec C p) \\<cdot> ts = Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "hence  \"ts \\<in> lists C\""], ["proof (prove)\nusing this:\n  (Dec C p) \\<cdot> ts = Dec C p \\<cdot> w\n\ngoal (1 subgoal):\n 1. ts \\<in> lists C", "using  append_in_lists_conv[of \"Dec C p\" ts C] dec_dom'[OF \\<open>p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  (Dec C p) \\<cdot> ts = Dec C p \\<cdot> w\n  ((Dec C p) \\<cdot> ts \\<in> lists C) =\n  (Dec C p \\<in> lists C \\<and> ts \\<in> lists C)\n  Dec C p \\<cdot> w \\<in> lists C\n\ngoal (1 subgoal):\n 1. ts \\<in> lists C", "unfolding \\<open>(Dec C p) \\<cdot> ts =  Dec C p \\<cdot> w\\<close>"], ["proof (prove)\nusing this:\n  Dec C p \\<cdot> w = Dec C p \\<cdot> w\n  (Dec C p \\<cdot> w \\<in> lists C) =\n  (Dec C p \\<in> lists C \\<and> ts \\<in> lists C)\n  Dec C p \\<cdot> w \\<in> lists C\n\ngoal (1 subgoal):\n 1. ts \\<in> lists C", "by blast"], ["proof (state)\nthis:\n  ts \\<in> lists C\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "hence \"concat ts = w\""], ["proof (prove)\nusing this:\n  ts \\<in> lists C\n\ngoal (1 subgoal):\n 1. concat ts = w", "using  concat_morph[of \"Dec C p\" ts]"], ["proof (prove)\nusing this:\n  ts \\<in> lists C\n  concat (Dec C p) \\<cdot> concat ts = concat ((Dec C p) \\<cdot> ts)\n\ngoal (1 subgoal):\n 1. concat ts = w", "unfolding \\<open>(Dec C p) \\<cdot> ts =  Dec C p \\<cdot> w\\<close> decI[OF \\<open>p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<close>]  decI[OF \\<open>p \\<in> \\<langle>C\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  ts \\<in> lists C\n  p \\<cdot> concat ts = p \\<cdot> w\n\ngoal (1 subgoal):\n 1. concat ts = w", "by auto"], ["proof (state)\nthis:\n  concat ts = w\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>C\\<rangle>; q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>C\\<rangle>;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>C\\<rangle>;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>C\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>C\\<rangle>", "thus \"w \\<in> \\<langle>C\\<rangle>\""], ["proof (prove)\nusing this:\n  concat ts = w\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>C\\<rangle>", "using \\<open>ts \\<in> lists C\\<close>"], ["proof (prove)\nusing this:\n  concat ts = w\n  ts \\<in> lists C\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>C\\<rangle>", "by auto"], ["proof (state)\nthis:\n  w \\<in> \\<langle>C\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<langle>C\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>C\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>That is, a code is its own free basis\\<close>"], ["", "lemma code_free_basis: assumes \"code C\" shows \"C = \\<BB>\\<^sub>F C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = \\<BB>\\<^sub>F C", "using basis_of_hull[of C, unfolded code_gen_free_hull[OF assms, symmetric] \n      code.code_is_basis[OF assms]]"], ["proof (prove)\nusing this:\n  C = \\<BB> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. C = \\<BB>\\<^sub>F C", "unfolding free_basis_def"], ["proof (prove)\nusing this:\n  C = \\<BB> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. C = \\<BB> \\<langle>C\\<rangle>\\<^sub>F", "."], ["", "text\\<open>Moreover, the free hull of G is the smallest code-generated hull containing G. \nIn other words, the term free hull is appropriate.\\<close>"], ["", "text\\<open>First, several intuitive monotonicity and closure results.\\<close>"], ["", "lemma free_hull_mono: \"G \\<subseteq> H \\<Longrightarrow> \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>H\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow>\n    \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>H\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H;\n        x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>H\\<rangle>\\<^sub>F", "assume \"G \\<subseteq> H\""], ["proof (state)\nthis:\n  G \\<subseteq> H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H;\n        x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>H\\<rangle>\\<^sub>F", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H;\n        x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>H\\<rangle>\\<^sub>F", "assume \"x \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H;\n        x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>H\\<rangle>\\<^sub>F", "have el: \"\\<And> w. w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F", "using \\<open>G \\<subseteq> H\\<close> free_hull.free_gen_in"], ["proof (prove)\nusing this:\n  G \\<subseteq> H\n  ?w \\<in> ?G \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>w. w \\<in> G \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  ?w \\<in> G \\<Longrightarrow> ?w \\<in> \\<langle>H\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H;\n        x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<langle>H\\<rangle>\\<^sub>F", "show \"x \\<in> \\<langle>H\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>H\\<rangle>\\<^sub>F", "proof (rule free_hull.induct[of x G], simp add: \\<open>x \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<close>, simp add: free_hull.intros(1), \n      simp add: el, simp add: free_hull.intros(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>H\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F", "show \"\\<And>p q w. p \\<in> \\<langle>H\\<rangle>\\<^sub>F \\<Longrightarrow>  q \\<in> \\<langle>H\\<rangle>\\<^sub>F \\<Longrightarrow>  p \\<cdot> w \\<in> \\<langle>H\\<rangle>\\<^sub>F \\<Longrightarrow>  w \\<cdot> q \\<in> \\<langle>H\\<rangle>\\<^sub>F \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>H\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F", "using free_hull.intros(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?q \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?p \\<cdot> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?w \\<cdot> ?q \\<in> \\<langle>?G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>H\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>H\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n   ?q \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n   ?p \\<cdot> ?w \\<in> \\<langle>H\\<rangle>\\<^sub>F;\n   ?w \\<cdot> ?q \\<in> \\<langle>H\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> \\<langle>H\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<langle>H\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma free_hull_idem: \"\\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F = \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F =\n    \\<langle>G\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n 2. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F", "show \"\\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "assume \"x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F \\<Longrightarrow>\n       x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "show \"x \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>G\\<rangle>\\<^sub>F", "proof (rule free_hull.induct[of x \"\\<langle>G\\<rangle>\\<^sub>F\"], simp add: \\<open>x \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\\<close>, \n        simp add: free_hull.intros(1), simp add: free_hull.intros(2), simp add: free_hull.intros(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F;\n        p \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        p \\<cdot> w\n        \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w \\<cdot> q\n        \\<in> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\\<^sub>F", "show \"\\<And>p q w. p \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>  q \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>  p \\<cdot> w \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>  w \\<cdot> q \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\\<^sub>F", "using free_hull.intros(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?q \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?p \\<cdot> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F;\n   ?w \\<cdot> ?q \\<in> \\<langle>?G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> \\<langle>?G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<And>p q w.\n       \\<lbrakk>p \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        q \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        p \\<cdot> w \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n        w \\<cdot> q \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n       \\<Longrightarrow> w \\<in> \\<langle>G\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n   ?q \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n   ?p \\<cdot> ?w \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n   ?w \\<cdot> ?q \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\n  \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F", "show \"\\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F", "using free_hull_hull hull_in_free_hull"], ["proof (prove)\nusing this:\n  \\<langle>\\<langle>?G\\<rangle>\\<^sub>F\\<rangle> =\n  \\<langle>?G\\<rangle>\\<^sub>F\n  \\<langle>?G\\<rangle> \\<subseteq> \\<langle>?G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hull_gen_free_hull: \"\\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F = \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F =\n    \\<langle>G\\<rangle>\\<^sub>F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n 2. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F", "show \" \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "using free_hull_idem free_hull_mono hull_in_free_hull"], ["proof (prove)\nusing this:\n  \\<langle>\\<langle>?G\\<rangle>\\<^sub>F\\<rangle>\\<^sub>F =\n  \\<langle>?G\\<rangle>\\<^sub>F\n  ?G \\<subseteq> ?H \\<Longrightarrow>\n  \\<langle>?G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>?H\\<rangle>\\<^sub>F\n  \\<langle>?G\\<rangle> \\<subseteq> \\<langle>?G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "by metis"], ["proof (state)\nthis:\n  \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F\n  \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F", "show \"\\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F", "by (simp add: free_hull_mono genset_sub)"], ["proof (state)\nthis:\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<langle>\\<langle>G\\<rangle>\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Code is also the free basis of its hull.\\<close>"], ["", "lemma code_free_basis_hull: \"code C \\<Longrightarrow> C = \\<BB>\\<^sub>F \\<langle>C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code C \\<Longrightarrow> C = \\<BB>\\<^sub>F \\<langle>C\\<rangle>", "unfolding free_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. code C \\<Longrightarrow>\n    C = \\<BB> \\<langle>\\<langle>C\\<rangle>\\<rangle>\\<^sub>F", "using code_free_basis[unfolded free_basis_def]"], ["proof (prove)\nusing this:\n  code ?C \\<Longrightarrow> ?C = \\<BB> \\<langle>?C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. code C \\<Longrightarrow>\n    C = \\<BB> \\<langle>\\<langle>C\\<rangle>\\<rangle>\\<^sub>F", "unfolding  hull_gen_free_hull"], ["proof (prove)\nusing this:\n  code ?C \\<Longrightarrow> ?C = \\<BB> \\<langle>?C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. code C \\<Longrightarrow> C = \\<BB> \\<langle>C\\<rangle>\\<^sub>F", "."], ["", "text\\<open>The minimality of the free hull easily follows.\\<close>"], ["", "theorem free_hull_min: assumes \"code C\" and \"G \\<subseteq> \\<langle>C\\<rangle>\" shows \"\\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>", "using free_hull_mono[OF \\<open>G \\<subseteq> \\<langle>C\\<rangle>\\<close>]"], ["proof (prove)\nusing this:\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<langle>\\<langle>C\\<rangle>\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>", "unfolding hull_gen_free_hull"], ["proof (prove)\nusing this:\n  \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>", "unfolding code_gen_free_hull[OF \\<open>code C\\<close>]"], ["proof (prove)\nusing this:\n  \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>C\\<rangle>", "."], ["", "theorem free_hull_inter: \"\\<langle>G\\<rangle>\\<^sub>F = \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F =\n    \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<Inter>\n                 {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n 2. \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "have \"X \\<in> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F} \\<Longrightarrow> \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> X\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> {M. G \\<subseteq> M \\<and>\n                M = \\<langle>M\\<rangle>\\<^sub>F} \\<Longrightarrow>\n    \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> X", "unfolding mem_Collect_eq[of _ \"\\<lambda> M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> X \\<and> X = \\<langle>X\\<rangle>\\<^sub>F \\<Longrightarrow>\n    \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> X", "using free_hull_mono[of G X]"], ["proof (prove)\nusing this:\n  G \\<subseteq> X \\<Longrightarrow>\n  \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<langle>X\\<rangle>\\<^sub>F\n\ngoal (1 subgoal):\n 1. G \\<subseteq> X \\<and> X = \\<langle>X\\<rangle>\\<^sub>F \\<Longrightarrow>\n    \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> X", "by simp"], ["proof (state)\nthis:\n  ?X \\<in> {M. G \\<subseteq> M \\<and>\n               M = \\<langle>M\\<rangle>\\<^sub>F} \\<Longrightarrow>\n  \\<langle>G\\<rangle>\\<^sub>F \\<subseteq> ?X\n\ngoal (2 subgoals):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<Inter>\n                 {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n 2. \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "from Inter_greatest[of \"{M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\", OF this]"], ["proof (chain)\npicking this:\n  (\\<And>X.\n      X \\<in> {M. G \\<subseteq> M \\<and>\n                  M = \\<langle>M\\<rangle>\\<^sub>F} \\<Longrightarrow>\n      X \\<in> {M. G \\<subseteq> M \\<and>\n                  M = \\<langle>M\\<rangle>\\<^sub>F}) \\<Longrightarrow>\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<Inter>\n               {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}", "show \"\\<langle>G\\<rangle>\\<^sub>F \\<subseteq> \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\""], ["proof (prove)\nusing this:\n  (\\<And>X.\n      X \\<in> {M. G \\<subseteq> M \\<and>\n                  M = \\<langle>M\\<rangle>\\<^sub>F} \\<Longrightarrow>\n      X \\<in> {M. G \\<subseteq> M \\<and>\n                  M = \\<langle>M\\<rangle>\\<^sub>F}) \\<Longrightarrow>\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<Inter>\n               {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n\ngoal (1 subgoal):\n 1. \\<langle>G\\<rangle>\\<^sub>F\n    \\<subseteq> \\<Inter>\n                 {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}", "by blast"], ["proof (state)\nthis:\n  \\<langle>G\\<rangle>\\<^sub>F\n  \\<subseteq> \\<Inter>\n               {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n\ngoal (1 subgoal):\n 1. \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "show \" \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F} \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n    \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F", "by (simp add: Inter_lower free_hull_idem genset_sub_free)"], ["proof (state)\nthis:\n  \\<Inter> {M. G \\<subseteq> M \\<and> M = \\<langle>M\\<rangle>\\<^sub>F}\n  \\<subseteq> \\<langle>G\\<rangle>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Decomposition into the free basis is a morphism.\\<close>"], ["", "lemma free_basis_dec_morph: \"u \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow> v \\<in> \\<langle>G\\<rangle>\\<^sub>F \\<Longrightarrow>  \n    Dec (\\<BB>\\<^sub>F G) (u \\<cdot> v) = (Dec (\\<BB>\\<^sub>F G) u) \\<cdot> (Dec (\\<BB>\\<^sub>F G) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n     v \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n    \\<Longrightarrow> Dec \\<BB>\\<^sub>F G u \\<cdot> v =\n                      (Dec \\<BB>\\<^sub>F G u) \\<cdot>\n                      (Dec \\<BB>\\<^sub>F G v)", "using code.code_dec_morph[OF free_basis_code, of u G v, symmetric, \n        unfolded  basis_gen_hull_free[of G]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n   v \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n  \\<Longrightarrow> Dec \\<BB>\\<^sub>F G u \\<cdot> v =\n                    (Dec \\<BB>\\<^sub>F G u) \\<cdot> (Dec \\<BB>\\<^sub>F G v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> \\<langle>G\\<rangle>\\<^sub>F;\n     v \\<in> \\<langle>G\\<rangle>\\<^sub>F\\<rbrakk>\n    \\<Longrightarrow> Dec \\<BB>\\<^sub>F G u \\<cdot> v =\n                      (Dec \\<BB>\\<^sub>F G u) \\<cdot>\n                      (Dec \\<BB>\\<^sub>F G v)", "."], ["", "section \\<open>Lists as the free hull of singletons\\<close>"], ["", "text\\<open>A crucial property of free monoids of words is that they can be seen as lists over the free basis, \ninstead as lists over the original alphabet.\\<close>"], ["", "abbreviation sings where \"sings B \\<equiv> {[b] | b. b \\<in> B}\""], ["", "lemma sings_image: \"sings B =  (\\<lambda> x. [x]) ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sings B = (\\<lambda>x. [x]) ` B", "using Setcompr_eq_image"], ["proof (prove)\nusing this:\n  {?f x |x. x \\<in> ?A} = ?f ` ?A\n\ngoal (1 subgoal):\n 1. sings B = (\\<lambda>x. [x]) ` B", "."], ["", "lemma lists_sing_map_concat_ident: \"xs \\<in> lists (sings B) \\<Longrightarrow> xs = map (\\<lambda> x. [x]) (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> lists (sings B) \\<Longrightarrow>\n    xs = map (\\<lambda>x. [x]) (concat xs)", "by (induct xs, simp, auto)"], ["", "lemma code_sings: \"code (sings B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code (sings B)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> lists (sings B); ys \\<in> lists (sings B);\n        concat xs = concat ys\\<rbrakk>\n       \\<Longrightarrow> xs = ys", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> lists (sings B); ys \\<in> lists (sings B);\n        concat xs = concat ys\\<rbrakk>\n       \\<Longrightarrow> xs = ys", "assume xs: \"xs \\<in> lists (sings B)\" and ys: \"ys \\<in> lists (sings B)\" \n     and eq: \"concat xs = concat ys\""], ["proof (state)\nthis:\n  xs \\<in> lists (sings B)\n  ys \\<in> lists (sings B)\n  concat xs = concat ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> lists (sings B); ys \\<in> lists (sings B);\n        concat xs = concat ys\\<rbrakk>\n       \\<Longrightarrow> xs = ys", "from lists_sing_map_concat_ident[OF xs, unfolded eq]"], ["proof (chain)\npicking this:\n  xs = map (\\<lambda>x. [x]) (concat ys)", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  xs = map (\\<lambda>x. [x]) (concat ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "unfolding  lists_sing_map_concat_ident[OF ys, symmetric]"], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. xs = ys", "."], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sings_gen_lists: \"\\<langle>sings B\\<rangle> = lists B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>sings B\\<rangle> = lists B", "unfolding hull_concat_lists"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ` lists (sings B) = lists B", "proof(intro equalityI subsetI, standard)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> concat ` lists (sings B) \\<Longrightarrow>\n       \\<forall>x\\<in>set x. x \\<in> B\n 2. \\<And>x.\n       x \\<in> lists B \\<Longrightarrow> x \\<in> concat ` lists (sings B)", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> concat ` lists (sings B) \\<Longrightarrow>\n       \\<forall>x\\<in>set x. x \\<in> B\n 2. \\<And>x.\n       x \\<in> lists B \\<Longrightarrow> x \\<in> concat ` lists (sings B)", "show \"xs \\<in> concat ` lists (sings B) \\<Longrightarrow> \\<forall>x\\<in>set xs. x \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> concat ` lists (sings B) \\<Longrightarrow>\n    \\<forall>x\\<in>set xs. x \\<in> B", "by force"], ["proof (state)\nthis:\n  xs \\<in> concat ` lists (sings B) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. x \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lists B \\<Longrightarrow> x \\<in> concat ` lists (sings B)", "assume \"xs \\<in> lists B\""], ["proof (state)\nthis:\n  xs \\<in> lists B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lists B \\<Longrightarrow> x \\<in> concat ` lists (sings B)", "hence \"map (\\<lambda>x. x # \\<epsilon>) xs \\<in> lists (sings B)\""], ["proof (prove)\nusing this:\n  xs \\<in> lists B\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. [x]) xs \\<in> lists (sings B)", "by force"], ["proof (state)\nthis:\n  map (\\<lambda>x. [x]) xs \\<in> lists (sings B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lists B \\<Longrightarrow> x \\<in> concat ` lists (sings B)", "from imageI[OF this, of concat]"], ["proof (chain)\npicking this:\n  concat (map (\\<lambda>x. [x]) xs) \\<in> concat ` lists (sings B)", "show \"xs \\<in> concat ` lists (sings B)\""], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>x. [x]) xs) \\<in> concat ` lists (sings B)\n\ngoal (1 subgoal):\n 1. xs \\<in> concat ` lists (sings B)", "unfolding concat_map_sing_ident[of xs]"], ["proof (prove)\nusing this:\n  xs \\<in> concat ` lists (sings B)\n\ngoal (1 subgoal):\n 1. xs \\<in> concat ` lists (sings B)", "."], ["proof (state)\nthis:\n  xs \\<in> concat ` lists (sings B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"sings B = \\<BB>\\<^sub>F (lists B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sings B = \\<BB>\\<^sub>F lists B", "using code_free_basis_hull[OF code_sings, of B, unfolded sings_gen_lists]"], ["proof (prove)\nusing this:\n  sings B = \\<BB>\\<^sub>F lists B\n\ngoal (1 subgoal):\n 1. sings B = \\<BB>\\<^sub>F lists B", "."], ["", "lemma map_sings: \"xs \\<in> lists B \\<Longrightarrow> map (\\<lambda>x. x # \\<epsilon>) xs \\<in> lists (sings B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> lists B \\<Longrightarrow>\n    map (\\<lambda>x. [x]) xs \\<in> lists (sings B)", "by (induct xs) auto"], ["", "lemma dec_sings: \"xs \\<in> lists B \\<Longrightarrow> Dec (sings B) xs = map (\\<lambda> x. [x]) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> lists B \\<Longrightarrow>\n    Dec sings B xs = map (\\<lambda>x. [x]) xs", "using code.code_unique_dec[OF code_sings, of \"map (\\<lambda> x. [x]) xs\" B, OF map_sings]"], ["proof (prove)\nusing this:\n  xs \\<in> lists B \\<Longrightarrow>\n  Dec sings B concat (map (\\<lambda>x. [x]) xs) = map (\\<lambda>x. [x]) xs\n\ngoal (1 subgoal):\n 1. xs \\<in> lists B \\<Longrightarrow>\n    Dec sings B xs = map (\\<lambda>x. [x]) xs", "unfolding concat_map_sing_ident"], ["proof (prove)\nusing this:\n  xs \\<in> lists B \\<Longrightarrow>\n  Dec sings B xs = map (\\<lambda>x. [x]) xs\n\ngoal (1 subgoal):\n 1. xs \\<in> lists B \\<Longrightarrow>\n    Dec sings B xs = map (\\<lambda>x. [x]) xs", "."], ["", "end"]]}