{"file_name": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words/Arithmetical_Hints.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words", "problem_names": ["lemma zero_diff_eq: \"i \\<le> j \\<Longrightarrow> (0::nat) = j - i  \\<Longrightarrow> j = i\"", "lemma zero_less_diff': \"i < j \\<Longrightarrow> j - i \\<noteq> (0::nat)\"", "lemma nat_prod_le: \"m \\<noteq> (0 :: nat) \\<Longrightarrow> m*n \\<le> k \\<Longrightarrow> n \\<le> k\"", "lemma get_div: \"(p :: nat) < a \\<Longrightarrow> m = (m * a + p) div a\"", "lemma get_mod: \"(p :: nat) < a \\<Longrightarrow> p = (m * a + p) mod a\"", "lemma plus_one_between:  \"(a :: nat) < b \\<Longrightarrow> \\<not> b < a + 1\"", "lemma quotient_smaller: \"a \\<noteq> 0 \\<Longrightarrow> a = k * b \\<Longrightarrow> b \\<le> (a::nat)\"", "lemma mult_cancel_le: \"b \\<noteq> 0 \\<Longrightarrow> a*b \\<le> c*b \\<Longrightarrow> a \\<le> (c::nat)\"", "lemma add_lessD2: assumes \"k + m < (n::nat)\" shows \"m < n\"", "lemma mod_offset:  assumes \"M \\<noteq> (0 :: nat)\"\n  obtains k where \"n mod M = (l + k) mod M\"", "lemma assumes \"q \\<noteq> (0::nat)\" shows \"p \\<le> p + q - gcd p q\"", "lemma less_mult_one: assumes \"(m-1)*k < k\" obtains \"m = 0\" | \"m = (1::nat)\""], "translations": [["", "lemma zero_diff_eq: \"i \\<le> j \\<Longrightarrow> (0::nat) = j - i  \\<Longrightarrow> j = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; 0 = j - i\\<rbrakk> \\<Longrightarrow> j = i", "by simp"], ["", "lemma zero_less_diff': \"i < j \\<Longrightarrow> j - i \\<noteq> (0::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> j - i \\<noteq> 0", "by simp"], ["", "lemma nat_prod_le: \"m \\<noteq> (0 :: nat) \\<Longrightarrow> m*n \\<le> k \\<Longrightarrow> n \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; m * n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> n \\<le> k", "using le_trans[of n \"m*n\" k]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> m * n; m * n \\<le> k\\<rbrakk> \\<Longrightarrow> n \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> 0; m * n \\<le> k\\<rbrakk>\n    \\<Longrightarrow> n \\<le> k", "by auto"], ["", "lemma get_div: \"(p :: nat) < a \\<Longrightarrow> m = (m * a + p) div a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < a \\<Longrightarrow> m = (m * a + p) div a", "by simp"], ["", "lemma get_mod: \"(p :: nat) < a \\<Longrightarrow> p = (m * a + p) mod a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < a \\<Longrightarrow> p = (m * a + p) mod a", "by simp"], ["", "lemma plus_one_between:  \"(a :: nat) < b \\<Longrightarrow> \\<not> b < a + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> \\<not> b < a + 1", "by auto"], ["", "lemma quotient_smaller: \"a \\<noteq> 0 \\<Longrightarrow> a = k * b \\<Longrightarrow> b \\<le> (a::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; a = k * b\\<rbrakk> \\<Longrightarrow> b \\<le> a", "by simp"], ["", "lemma mult_cancel_le: \"b \\<noteq> 0 \\<Longrightarrow> a*b \\<le> c*b \\<Longrightarrow> a \\<le> (c::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<noteq> 0; a * b \\<le> c * b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> c", "by simp"], ["", "lemma add_lessD2: assumes \"k + m < (n::nat)\" shows \"m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n", "using add_lessD1[OF assms[unfolded add.commute[of k m]]]"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. m < n", "."], ["", "lemma mod_offset:  assumes \"M \\<noteq> (0 :: nat)\"\n  obtains k where \"n mod M = (l + k) mod M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        n mod M = (l + k) mod M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        n mod M = (l + k) mod M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(l + (M - l mod M)) mod M = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + (M - l mod M)) mod M = 0", "using mod_add_left_eq[of l M \"(M - l mod M)\", unfolded le_add_diff_inverse[OF mod_le_divisor[OF assms[unfolded neq0_conv]], of l] mod_self, symmetric]"], ["proof (prove)\nusing this:\n  (l + (M - l mod M)) mod M = 0\n\ngoal (1 subgoal):\n 1. (l + (M - l mod M)) mod M = 0", "."], ["proof (state)\nthis:\n  (l + (M - l mod M)) mod M = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        n mod M = (l + k) mod M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from mod_add_left_eq[of \"(l + (M - l mod M))\" M n, symmetric, unfolded this add.commute[of 0] add.comm_neutral]"], ["proof (chain)\npicking this:\n  (l + (M - l mod M) + n) mod M = n mod M", "have \"((l + (M - l mod M)) + n) mod M = n mod M\""], ["proof (prove)\nusing this:\n  (l + (M - l mod M) + n) mod M = n mod M\n\ngoal (1 subgoal):\n 1. (l + (M - l mod M) + n) mod M = n mod M", "."], ["proof (state)\nthis:\n  (l + (M - l mod M) + n) mod M = n mod M\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        n mod M = (l + k) mod M \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[OF this[unfolded add.assoc, symmetric]]"], ["proof (chain)\npicking this:\n  thesis", "show thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"q \\<noteq> (0::nat)\" shows \"p \\<le> p + q - gcd p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> p + q - gcd p q", "using gcd_le2_nat[OF \\<open>q \\<noteq> 0\\<close>, of p]"], ["proof (prove)\nusing this:\n  gcd p q \\<le> q\n\ngoal (1 subgoal):\n 1. p \\<le> p + q - gcd p q", "by linarith"], ["", "lemma less_mult_one: assumes \"(m-1)*k < k\" obtains \"m = 0\" | \"m = (1::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 0 \\<Longrightarrow> thesis;\n     m = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (m - 1) * k < k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 0 \\<Longrightarrow> thesis;\n     m = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["", "end"]]}