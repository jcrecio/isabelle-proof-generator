{"file_name": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words/Reverse_Symmetry.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words", "problem_names": ["lemma all_surj_conv: assumes \"surj f\" shows \"(\\<And>x. PROP P (f x)) \\<equiv> (\\<And>y. PROP P y)\"", "lemma All_surj_conv: assumes \"surj f\" shows \"(\\<forall>x. P (f x)) \\<longleftrightarrow> (\\<forall>y. P y)\"", "lemma Ex_surj_conv: assumes \"surj f\" shows \"(\\<exists>x. P (f x)) \\<longleftrightarrow> (\\<exists>y. P y)\"", "lemma Ex1_bij_conv: assumes \"bij f\" shows \"(\\<exists>!x. P (f x)) \\<longleftrightarrow> (\\<exists>!y. P y)\"", "lemma Ball_inj_conv: assumes \"inj f\" shows \"(\\<forall>y\\<in>f ` A. P (inv f y)) \\<longleftrightarrow> (\\<forall>x\\<in>A. P x)\"", "lemma Bex_inj_conv: assumes \"inj f\" shows \"(\\<exists>y\\<in>f ` A. P (inv f y)) \\<longleftrightarrow> (\\<exists>x\\<in>A. P x)\"", "lemma rev_involution: \"rev \\<circ> rev = id\"", "lemma rev_bij: \"bij rev\"", "lemma rev_inv: \"inv rev = rev\"", "lemmas all_rev_conv = all_surj_conv[OF bij_is_surj[OF rev_bij]]\n   and All_rev_conv = All_surj_conv[OF bij_is_surj[OF rev_bij]]\n   and Ex_rev_conv = Ex_surj_conv[OF bij_is_surj[OF rev_bij]]\n   and Ex1_rev_conv = Ex1_bij_conv[OF rev_bij]\n   and Ball_rev_conv = Ball_inj_conv[OF bij_is_inj[OF rev_bij], unfolded rev_inv]\n   and Bex_rev_conv = Bex_inj_conv[OF bij_is_inj[OF rev_bij], unfolded rev_inv]", "lemma rev_Nil: \"rev Nil = Nil\"", "lemmas init_rev_wrap =\n  eq_reflection[OF trans[OF rev_Nil[symmetric] rev_Nil_wrap_def[symmetric]]]\n  transitive[OF all_rev_conv[symmetric] all_rev_wrap_def[symmetric], of P P for P]\n  eq_reflection[OF trans[OF All_rev_conv[symmetric] All_rev_wrap_def[symmetric], of P P for P]]\n  eq_reflection[OF trans[OF Ex_rev_conv[symmetric] Ex_rev_wrap_def[symmetric], of P P for P]] (* Ex_rev_wrapI *)\n  eq_reflection[OF trans[OF Ex1_rev_conv[symmetric] Ex1_rev_wrap_def[symmetric], of P P for P]]\n  eq_reflection[OF trans[OF Ball_rev_conv[symmetric] Ball_rev_wrap_def[symmetric], of P P for P]]\n  eq_reflection[OF trans[OF Bex_rev_conv[symmetric] Bex_rev_wrap_def[symmetric], of P P for P]]", "lemma all_rev_unwrap: \"all_rev_wrap (\\<lambda>x. PROP P x) \\<equiv> (\\<And>x. PROP P (rev x))\"", "lemma All_rev_unwrap: \"All_rev_wrap (\\<lambda>x. P x) = (\\<forall>x. P (rev x))\"", "lemma Ex_rev_unwrap: \"Ex_rev_wrap (\\<lambda>x. P x) = (\\<exists>x. P (rev x))\"", "lemma Ex1_rev_unwrap: \"Ex1_rev_wrap (\\<lambda>x. P x) = (\\<exists>!x. P (rev x))\"", "lemma Ball_rev_unwrap: \"Ball_rev_wrap A (\\<lambda>x. P x) = (\\<forall>x \\<in> rev ` A. P (rev x))\"", "lemma Bex_rev_unwrap: \"Bex_rev_wrap A (\\<lambda>x. P x) = (\\<exists>x \\<in> rev ` A. P (rev x))\"", "lemmas init_rev_unwrap =\n  eq_reflection[OF rev_Nil_wrap_def]\n  all_rev_unwrap\n  eq_reflection[OF All_rev_unwrap]\n  eq_reflection[OF Ex_rev_unwrap]\n  eq_reflection[OF Ex1_rev_unwrap]\n  eq_reflection[OF Ball_rev_unwrap]\n  eq_reflection[OF Bex_rev_unwrap]", "lemma Cons_rev: \"a # rev u = rev (snocs u [a])\"", "lemma snocs_snocs: \"snocs (snocs xs (y # ys)) zs = snocs xs (y # snocs ys zs)\"", "lemma snocs_Nil: \"snocs [] xs = xs\"", "lemma snocs_is_append: \"snocs xs ys = xs @ ys\"", "lemmas final_correct1 =\n  snocs_Nil", "lemmas final_correct2 =\n  snocs_is_append", "lemma hd_last_Nil: \"hd [] = last []\"", "lemma last_rev_hd: \"last(rev xs) = hd xs\"", "lemma hd_rev_last: \"hd(rev xs) = last xs\"", "lemma tl_rev: \"tl (rev xs) = rev (butlast xs)\"", "lemma if_rev: \"(if P then rev u else rev v) = rev (if P then u else v)\"", "lemma rev_in_conv: \"rev u \\<in> A \\<longleftrightarrow> u \\<in> rev ` A\"", "lemma in_lists_rev: \"u \\<in> lists A \\<Longrightarrow> rev u \\<in> lists A\"", "lemma rev_in_lists: \"rev u \\<in> lists A \\<Longrightarrow> u \\<in> lists A\"", "lemma rev_lists_conv: \"rev ` lists A = lists A\"", "lemma coset_rev: \"List.coset (rev xs) = List.coset xs\"", "lemmas [reversal_rule] =\n  Cons_rev\n  snocs_snocs\n  rev_append[symmetric]\n  last_rev_hd hd_rev_last\n  tl_rev butlast_rev\n  rev_is_rev_conv\n  length_rev\n  take_rev\n  drop_rev\n  rotate_rev\n  if_rev\n  rev_in_conv\n  rev_lists_conv\n  set_rev\n  coset_rev", "lemma example_Cons_append:\n  assumes \"xs = [a, b]\" and \"ys = [b, a, b]\"\n  shows \"xs @ xs @ xs = a # b # a # ys\"", "lemma rotate1_hd_tl': \"xs \\<noteq> [] \\<Longrightarrow> rotate 1 xs = tl xs @ [hd xs]\""], "translations": [["", "lemma all_surj_conv: assumes \"surj f\" shows \"(\\<And>x. PROP P (f x)) \\<equiv> (\\<And>y. PROP P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. PROP P (f x)) \\<equiv> (\\<And>y. PROP P y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. (\\<And>x. PROP P (f x)) \\<Longrightarrow> PROP P y\n 2. \\<And>x. (\\<And>y. PROP P y) \\<Longrightarrow> PROP P (f x)", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. (\\<And>x. PROP P (f x)) \\<Longrightarrow> PROP P y\n 2. \\<And>x. (\\<And>y. PROP P y) \\<Longrightarrow> PROP P (f x)", "assume \"\\<And>x. PROP P (f x)\""], ["proof (state)\nthis:\n  PROP P (f ?x)\n\ngoal (2 subgoals):\n 1. \\<And>y. (\\<And>x. PROP P (f x)) \\<Longrightarrow> PROP P y\n 2. \\<And>x. (\\<And>y. PROP P y) \\<Longrightarrow> PROP P (f x)", "then"], ["proof (chain)\npicking this:\n  PROP P (f ?x)", "have \"PROP P (f (inv f y))\""], ["proof (prove)\nusing this:\n  PROP P (f ?x)\n\ngoal (1 subgoal):\n 1. PROP P (f (inv f y))", "."], ["proof (state)\nthis:\n  PROP P (f (inv f y))\n\ngoal (2 subgoals):\n 1. \\<And>y. (\\<And>x. PROP P (f x)) \\<Longrightarrow> PROP P y\n 2. \\<And>x. (\\<And>y. PROP P y) \\<Longrightarrow> PROP P (f x)", "then"], ["proof (chain)\npicking this:\n  PROP P (f (inv f y))", "show \"PROP P y\""], ["proof (prove)\nusing this:\n  PROP P (f (inv f y))\n\ngoal (1 subgoal):\n 1. PROP P y", "unfolding surj_f_inv_f[OF assms]"], ["proof (prove)\nusing this:\n  PROP P y\n\ngoal (1 subgoal):\n 1. PROP P y", "."], ["proof (state)\nthis:\n  PROP P y\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y. PROP P y) \\<Longrightarrow> PROP P (f x)", "qed"], ["", "lemma All_surj_conv: assumes \"surj f\" shows \"(\\<forall>x. P (f x)) \\<longleftrightarrow> (\\<forall>y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P (f x)) = (\\<forall>y. P y)", "proof (intro iffI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. \\<forall>x. P (f x) \\<Longrightarrow> P y\n 2. \\<And>x. \\<forall>y. P y \\<Longrightarrow> P (f x)", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. \\<forall>x. P (f x) \\<Longrightarrow> P y\n 2. \\<And>x. \\<forall>y. P y \\<Longrightarrow> P (f x)", "assume \"\\<forall>x. P (f x)\""], ["proof (state)\nthis:\n  \\<forall>x. P (f x)\n\ngoal (2 subgoals):\n 1. \\<And>y. \\<forall>x. P (f x) \\<Longrightarrow> P y\n 2. \\<And>x. \\<forall>y. P y \\<Longrightarrow> P (f x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. P (f x)", "have \"P (f (inv f y))\""], ["proof (prove)\nusing this:\n  \\<forall>x. P (f x)\n\ngoal (1 subgoal):\n 1. P (f (inv f y))", ".."], ["proof (state)\nthis:\n  P (f (inv f y))\n\ngoal (2 subgoals):\n 1. \\<And>y. \\<forall>x. P (f x) \\<Longrightarrow> P y\n 2. \\<And>x. \\<forall>y. P y \\<Longrightarrow> P (f x)", "then"], ["proof (chain)\npicking this:\n  P (f (inv f y))", "show \"P y\""], ["proof (prove)\nusing this:\n  P (f (inv f y))\n\ngoal (1 subgoal):\n 1. P y", "unfolding surj_f_inv_f[OF assms]"], ["proof (prove)\nusing this:\n  P y\n\ngoal (1 subgoal):\n 1. P y", "."], ["proof (state)\nthis:\n  P y\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y. P y \\<Longrightarrow> P (f x)", "qed simp"], ["", "lemma Ex_surj_conv: assumes \"surj f\" shows \"(\\<exists>x. P (f x)) \\<longleftrightarrow> (\\<exists>y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P (f x)) = (\\<exists>y. P y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. P (f x) \\<Longrightarrow> \\<exists>y. P y\n 2. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "assume \"\\<exists>x. P (f x)\""], ["proof (state)\nthis:\n  \\<exists>x. P (f x)\n\ngoal (2 subgoals):\n 1. \\<exists>x. P (f x) \\<Longrightarrow> \\<exists>y. P y\n 2. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. P (f x)", "obtain x where \"P (f x)\""], ["proof (prove)\nusing this:\n  \\<exists>x. P (f x)\n\ngoal (1 subgoal):\n 1. (\\<And>x. P (f x) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  P (f x)\n\ngoal (2 subgoals):\n 1. \\<exists>x. P (f x) \\<Longrightarrow> \\<exists>y. P y\n 2. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "then"], ["proof (chain)\npicking this:\n  P (f x)", "show \"\\<exists>x. P x\""], ["proof (prove)\nusing this:\n  P (f x)\n\ngoal (1 subgoal):\n 1. \\<exists>x. P x", ".."], ["proof (state)\nthis:\n  \\<exists>x. P x\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "assume \"\\<exists>y. P y\""], ["proof (state)\nthis:\n  \\<exists>y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. P y", "obtain y where \"P y\""], ["proof (prove)\nusing this:\n  \\<exists>y. P y\n\ngoal (1 subgoal):\n 1. (\\<And>y. P y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  P y\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "then"], ["proof (chain)\npicking this:\n  P y", "have \"P (f (inv f y))\""], ["proof (prove)\nusing this:\n  P y\n\ngoal (1 subgoal):\n 1. P (f (inv f y))", "unfolding surj_f_inv_f[OF assms]"], ["proof (prove)\nusing this:\n  P y\n\ngoal (1 subgoal):\n 1. P y", "."], ["proof (state)\nthis:\n  P (f (inv f y))\n\ngoal (1 subgoal):\n 1. \\<exists>y. P y \\<Longrightarrow> \\<exists>x. P (f x)", "then"], ["proof (chain)\npicking this:\n  P (f (inv f y))", "show \"\\<exists>x. P (f x)\""], ["proof (prove)\nusing this:\n  P (f (inv f y))\n\ngoal (1 subgoal):\n 1. \\<exists>x. P (f x)", ".."], ["proof (state)\nthis:\n  \\<exists>x. P (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ex1_bij_conv: assumes \"bij f\" shows \"(\\<exists>!x. P (f x)) \\<longleftrightarrow> (\\<exists>!y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. P (f x)) = (\\<exists>!y. P y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "have imp: \"\\<exists>!y. Q y\" if bij: \"bij g\" and ex1: \"\\<exists>!x. Q (g x)\" for g Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "from ex1E[OF ex1, rule_format]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<lbrakk>Q (g x); \\<And>y. Q (g y) \\<Longrightarrow> y = x\\<rbrakk>\n      \\<Longrightarrow> ?R) \\<Longrightarrow>\n  ?R", "obtain x where ex: \"Q (g x)\" and uniq: \"\\<And>x'. Q (g x') \\<Longrightarrow> x' = x\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>Q (g x); \\<And>y. Q (g y) \\<Longrightarrow> y = x\\<rbrakk>\n      \\<Longrightarrow> ?R) \\<Longrightarrow>\n  ?R\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>Q (g x);\n         \\<And>x'. Q (g x') \\<Longrightarrow> x' = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Q (g x)\n  Q (g ?x') \\<Longrightarrow> ?x' = x\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "{"], ["proof (state)\nthis:\n  Q (g x)\n  Q (g ?x') \\<Longrightarrow> ?x' = x\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "assume \"Q y\""], ["proof (state)\nthis:\n  Q y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "then"], ["proof (chain)\npicking this:\n  Q y", "have \"Q (g (inv g y))\""], ["proof (prove)\nusing this:\n  Q y\n\ngoal (1 subgoal):\n 1. Q (g (inv g y))", "unfolding surj_f_inv_f[OF bij_is_surj[OF bij]]"], ["proof (prove)\nusing this:\n  Q y\n\ngoal (1 subgoal):\n 1. Q y", "."], ["proof (state)\nthis:\n  Q (g (inv g y))\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "from uniq[OF this]"], ["proof (chain)\npicking this:\n  inv g y = x", "have \"x = inv g y\""], ["proof (prove)\nusing this:\n  inv g y = x\n\ngoal (1 subgoal):\n 1. x = inv g y", ".."], ["proof (state)\nthis:\n  x = inv g y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "then"], ["proof (chain)\npicking this:\n  x = inv g y", "have \"y = g x\""], ["proof (prove)\nusing this:\n  x = inv g y\n\ngoal (1 subgoal):\n 1. y = g x", "unfolding bij_inv_eq_iff[OF bij]"], ["proof (prove)\nusing this:\n  g x = y\n\ngoal (1 subgoal):\n 1. y = g x", ".."], ["proof (state)\nthis:\n  y = g x\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "}"], ["proof (state)\nthis:\n  Q ?y2 \\<Longrightarrow> ?y2 = g x\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", "with ex"], ["proof (chain)\npicking this:\n  Q (g x)\n  Q ?y2 \\<Longrightarrow> ?y2 = g x", "show \"\\<exists>!y. Q y\""], ["proof (prove)\nusing this:\n  Q (g x)\n  Q ?y2 \\<Longrightarrow> ?y2 = g x\n\ngoal (1 subgoal):\n 1. \\<exists>!y. Q y", ".."], ["proof (state)\nthis:\n  \\<exists>!y. Q y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>bij ?g1; \\<exists>!x. ?Q1 (?g1 x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!y. ?Q1 y\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "show \"\\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y", "using imp[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>!x. ?Q1 (f x) \\<Longrightarrow> \\<exists>!y. ?Q1 y\n\ngoal (1 subgoal):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y", "."], ["proof (state)\nthis:\n  \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "assume \"\\<exists>!y. P y\""], ["proof (state)\nthis:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>!y. P y", "have \"\\<exists>!y. P (f (inv f y))\""], ["proof (prove)\nusing this:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P (f (inv f y))", "unfolding surj_f_inv_f[OF bij_is_surj[OF assms]]"], ["proof (prove)\nusing this:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y", "."], ["proof (state)\nthis:\n  \\<exists>!y. P (f (inv f y))\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "from imp[OF bij_imp_bij_inv[OF assms] this]"], ["proof (chain)\npicking this:\n  \\<exists>!y. P (f y)", "show \"\\<exists>!x. P (f x)\""], ["proof (prove)\nusing this:\n  \\<exists>!y. P (f y)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. P (f x)", "."], ["proof (state)\nthis:\n  \\<exists>!x. P (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ball_inj_conv: assumes \"inj f\" shows \"(\\<forall>y\\<in>f ` A. P (inv f y)) \\<longleftrightarrow> (\\<forall>x\\<in>A. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>f ` A. P (inv f y)) = (\\<forall>x\\<in>A. P x)", "using ball_simps(9)[of f A \"\\<lambda>y. P (inv f y)\"]"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>f ` A. P (inv f x)) = (\\<forall>x\\<in>A. P (inv f (f x)))\n\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>f ` A. P (inv f y)) = (\\<forall>x\\<in>A. P x)", "unfolding inv_f_f[OF assms]"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>f ` A. P (inv f x)) = (\\<forall>x\\<in>A. P x)\n\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>f ` A. P (inv f y)) = (\\<forall>x\\<in>A. P x)", "."], ["", "lemma Bex_inj_conv: assumes \"inj f\" shows \"(\\<exists>y\\<in>f ` A. P (inv f y)) \\<longleftrightarrow> (\\<exists>x\\<in>A. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y\\<in>f ` A. P (inv f y)) = (\\<exists>x\\<in>A. P x)", "using bex_simps(7)[of f A \"\\<lambda>y. P (inv f y)\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x\\<in>f ` A. P (inv f x)) = (\\<exists>x\\<in>A. P (inv f (f x)))\n\ngoal (1 subgoal):\n 1. (\\<exists>y\\<in>f ` A. P (inv f y)) = (\\<exists>x\\<in>A. P x)", "unfolding inv_f_f[OF assms]"], ["proof (prove)\nusing this:\n  (\\<exists>x\\<in>f ` A. P (inv f x)) = (\\<exists>x\\<in>A. P x)\n\ngoal (1 subgoal):\n 1. (\\<exists>y\\<in>f ` A. P (inv f y)) = (\\<exists>x\\<in>A. P x)", "."], ["", "subsection \\<open>Quantifications and reverse\\<close>"], ["", "lemma rev_involution: \"rev \\<circ> rev = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev \\<circ> rev = id", "by auto"], ["", "lemma rev_bij: \"bij rev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij rev", "using o_bij[OF rev_involution rev_involution]"], ["proof (prove)\nusing this:\n  bij rev\n\ngoal (1 subgoal):\n 1. bij rev", "."], ["", "lemma rev_inv: \"inv rev = rev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv rev = rev", "using inv_unique_comp[OF rev_involution rev_involution]"], ["proof (prove)\nusing this:\n  inv rev = rev\n\ngoal (1 subgoal):\n 1. inv rev = rev", "."], ["", "lemmas all_rev_conv = all_surj_conv[OF bij_is_surj[OF rev_bij]]\n   and All_rev_conv = All_surj_conv[OF bij_is_surj[OF rev_bij]]\n   and Ex_rev_conv = Ex_surj_conv[OF bij_is_surj[OF rev_bij]]\n   and Ex1_rev_conv = Ex1_bij_conv[OF rev_bij]\n   and Ball_rev_conv = Ball_inj_conv[OF bij_is_inj[OF rev_bij], unfolded rev_inv]\n   and Bex_rev_conv = Bex_inj_conv[OF bij_is_inj[OF rev_bij], unfolded rev_inv]"], ["", "section \\<open>Attributes\\<close>"], ["", "context\nbegin"], ["", "subsection \\<open>Definitons of reverse wrapers\\<close>"], ["", "private"], ["", "definition rev_Nil_wrap :: \"'a list\"\n  where \"rev_Nil_wrap = rev Nil\""], ["", "private"], ["", "definition all_rev_wrap :: \"('a list \\<Rightarrow> prop) \\<Rightarrow> prop\"\n  where \"all_rev_wrap P \\<equiv> (\\<And>x. PROP P (rev x))\""], ["", "private"], ["", "definition All_rev_wrap :: \"('a list \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"All_rev_wrap P = (\\<forall>x. P (rev x))\""], ["", "private"], ["", "definition Ex_rev_wrap :: \"('a list \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"Ex_rev_wrap P = (\\<exists>x. P (rev x))\""], ["", "private"], ["", "definition Ex1_rev_wrap :: \"('a list \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"Ex1_rev_wrap P = (\\<exists>!x. P (rev x))\""], ["", "private"], ["", "definition Ball_rev_wrap :: \"'a list set \\<Rightarrow> ('a list \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"Ball_rev_wrap A P = (\\<forall>x \\<in> rev ` A. P (rev x))\""], ["", "private"], ["", "definition Bex_rev_wrap :: \"'a list set \\<Rightarrow> ('a list \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"Bex_rev_wrap A P = (\\<exists>x \\<in> rev ` A. P (rev x))\""], ["", "subsection \\<open>Initial reversal rules\\<close>"], ["", "private"], ["", "lemma rev_Nil: \"rev Nil = Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [] = []", "by simp"], ["", "private"], ["", "lemmas init_rev_wrap =\n  eq_reflection[OF trans[OF rev_Nil[symmetric] rev_Nil_wrap_def[symmetric]]]\n  transitive[OF all_rev_conv[symmetric] all_rev_wrap_def[symmetric], of P P for P]\n  eq_reflection[OF trans[OF All_rev_conv[symmetric] All_rev_wrap_def[symmetric], of P P for P]]\n  eq_reflection[OF trans[OF Ex_rev_conv[symmetric] Ex_rev_wrap_def[symmetric], of P P for P]] (* Ex_rev_wrapI *)\n  eq_reflection[OF trans[OF Ex1_rev_conv[symmetric] Ex1_rev_wrap_def[symmetric], of P P for P]]\n  eq_reflection[OF trans[OF Ball_rev_conv[symmetric] Ball_rev_wrap_def[symmetric], of P P for P]]\n  eq_reflection[OF trans[OF Bex_rev_conv[symmetric] Bex_rev_wrap_def[symmetric], of P P for P]]"], ["", "private"], ["", "lemma all_rev_unwrap: \"all_rev_wrap (\\<lambda>x. PROP P x) \\<equiv> (\\<And>x. PROP P (rev x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_rev_wrap (\\<lambda>x. PROP P x) \\<equiv> (\\<And>x. PROP P (rev x))", "using all_rev_wrap_def"], ["proof (prove)\nusing this:\n  all_rev_wrap ?P \\<equiv> (\\<And>x. PROP ?P (rev x))\n\ngoal (1 subgoal):\n 1. all_rev_wrap (\\<lambda>x. PROP P x) \\<equiv> (\\<And>x. PROP P (rev x))", "."], ["", "private"], ["", "lemma All_rev_unwrap: \"All_rev_wrap (\\<lambda>x. P x) = (\\<forall>x. P (rev x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All_rev_wrap P = (\\<forall>x. P (rev x))", "using All_rev_wrap_def"], ["proof (prove)\nusing this:\n  All_rev_wrap ?P = (\\<forall>x. ?P (rev x))\n\ngoal (1 subgoal):\n 1. All_rev_wrap P = (\\<forall>x. P (rev x))", "."], ["", "private"], ["", "lemma Ex_rev_unwrap: \"Ex_rev_wrap (\\<lambda>x. P x) = (\\<exists>x. P (rev x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex_rev_wrap P = (\\<exists>x. P (rev x))", "using Ex_rev_wrap_def"], ["proof (prove)\nusing this:\n  Ex_rev_wrap ?P = (\\<exists>x. ?P (rev x))\n\ngoal (1 subgoal):\n 1. Ex_rev_wrap P = (\\<exists>x. P (rev x))", "."], ["", "private"], ["", "lemma Ex1_rev_unwrap: \"Ex1_rev_wrap (\\<lambda>x. P x) = (\\<exists>!x. P (rev x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex1_rev_wrap P = (\\<exists>!x. P (rev x))", "using Ex1_rev_wrap_def"], ["proof (prove)\nusing this:\n  Ex1_rev_wrap ?P = (\\<exists>!x. ?P (rev x))\n\ngoal (1 subgoal):\n 1. Ex1_rev_wrap P = (\\<exists>!x. P (rev x))", "."], ["", "private"], ["", "lemma Ball_rev_unwrap: \"Ball_rev_wrap A (\\<lambda>x. P x) = (\\<forall>x \\<in> rev ` A. P (rev x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball_rev_wrap A P = (\\<forall>x\\<in>rev ` A. P (rev x))", "using Ball_rev_wrap_def"], ["proof (prove)\nusing this:\n  Ball_rev_wrap ?A ?P = (\\<forall>x\\<in>rev ` ?A. ?P (rev x))\n\ngoal (1 subgoal):\n 1. Ball_rev_wrap A P = (\\<forall>x\\<in>rev ` A. P (rev x))", "."], ["", "private"], ["", "lemma Bex_rev_unwrap: \"Bex_rev_wrap A (\\<lambda>x. P x) = (\\<exists>x \\<in> rev ` A. P (rev x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex_rev_wrap A P = (\\<exists>x\\<in>rev ` A. P (rev x))", "using Bex_rev_wrap_def"], ["proof (prove)\nusing this:\n  Bex_rev_wrap ?A ?P = (\\<exists>x\\<in>rev ` ?A. ?P (rev x))\n\ngoal (1 subgoal):\n 1. Bex_rev_wrap A P = (\\<exists>x\\<in>rev ` A. P (rev x))", "."], ["", "private"], ["", "lemmas init_rev_unwrap =\n  eq_reflection[OF rev_Nil_wrap_def]\n  all_rev_unwrap\n  eq_reflection[OF All_rev_unwrap]\n  eq_reflection[OF Ex_rev_unwrap]\n  eq_reflection[OF Ex1_rev_unwrap]\n  eq_reflection[OF Ball_rev_unwrap]\n  eq_reflection[OF Bex_rev_unwrap]"], ["", "subsection \\<open>Cons reversion\\<close>"], ["", "definition snocs :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n  where \"snocs xs ys  = xs @ ys\""], ["", "lemma Cons_rev: \"a # rev u = rev (snocs u [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # rev u = rev (snocs u [a])", "unfolding snocs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # rev u = rev (u @ [a])", "by simp"], ["", "lemma snocs_snocs: \"snocs (snocs xs (y # ys)) zs = snocs xs (y # snocs ys zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snocs (snocs xs (y # ys)) zs = snocs xs (y # snocs ys zs)", "unfolding snocs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ys) @ zs = xs @ y # ys @ zs", "by simp"], ["", "subsection \\<open>Final corrections\\<close>"], ["", "lemma snocs_Nil: \"snocs [] xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snocs [] xs = xs", "unfolding snocs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] @ xs = xs", "by simp"], ["", "lemma snocs_is_append: \"snocs xs ys = xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snocs xs ys = xs @ ys", "unfolding snocs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ys = xs @ ys", ".."], ["", "private"], ["", "lemmas final_correct1 =\n  snocs_Nil"], ["", "private"], ["", "lemmas final_correct2 =\n  snocs_is_append"], ["", "subsection \\<open>Declaration attribute \\<open>reversal_rule\\<close>\\<close>"], ["", "ML \\<open>\nstructure Reversal_Rules = \n  Named_Thms(\n    val name = @{binding \"reversal_rule\"}\n    val description = \"Rules performing reverse-symmetry transformation on theorems on lists\"\n  )\n\\<close>"], ["", "attribute_setup reversal_rule = \n  \\<open>Attrib.add_del\n    (Thm.declaration_attribute Reversal_Rules.add_thm)\n    (Thm.declaration_attribute Reversal_Rules.del_thm)\\<close>\n  \"maintaining a list of reversal rules\""], ["", "subsection \\<open>Rule attribute \\<open>reversed\\<close>\\<close>"], ["", "ML \\<open>\nval eq_refl = @{thm eq_reflection}\n\nfun pure_eq_of th =\n  case Thm.prop_of th of\n    Const (\\<^const_name>\\<open>Pure.eq\\<close>, _) $ _ $ _\n      => SOME (th)\n  | Const (\\<^const_name>\\<open>Trueprop\\<close>, _) $ (Const (\\<^const_name>\\<open>HOL.eq\\<close>, _) $ _ $ _ )\n      => SOME (th RS eq_refl)\n  | _ => NONE\n\nval init_rev_wrap = @{thms init_rev_wrap}\nval init_unwrap = @{thms init_rev_unwrap}\nval final_correct1 = map_filter pure_eq_of @{thms final_correct1}\nval final_correct2 = map_filter pure_eq_of @{thms final_correct2}\n\nfun reverse ths context th =\n  let\n    val ctxt = Context.proof_of context\n    val rules = map_filter pure_eq_of (ths @ Reversal_Rules.get ctxt)\n    val vars = Term.add_vars (Thm.full_prop_of th) []\n    fun add_inst_vars [] inst_vars = inst_vars\n      | add_inst_vars ( ((v, i), T) :: vars ) inst_vars =\n          case T of\n            Type(\\<^type_name>\\<open>list\\<close>, _) =>\n              add_inst_vars vars (\n                (\n                  ((v, i), T),\n                  Thm.cterm_of ctxt \n                    ( Const(\\<^const_name>\\<open>rev\\<close>, Type(\\<^type_name>\\<open>fun\\<close>, [T, T])) $ Var((v, i), T) )\n                ) :: inst_vars\n              )\n          | _ => add_inst_vars vars inst_vars\n  in\n    th\n    |> Drule.instantiate_normalize\n       ([], add_inst_vars vars [])\n    |> Simplifier.rewrite_rule ctxt init_rev_wrap\n    |> Simplifier.rewrite_rule ctxt init_unwrap\n    |> Simplifier.rewrite_rule ctxt rules\n    |> Simplifier.rewrite_rule ctxt final_correct1\n    |> Simplifier.rewrite_rule ctxt final_correct2\n  end\n\nval reversed = Scan.optional (Scan.lift (Args.add -- Args.colon) |-- Attrib.thms) []\n  >> (fn ths => Thm.rule_attribute [] (reverse ths))\n\\<close>"], ["", "attribute_setup reversed =\n  \\<open>reversed\\<close>\n  \"Transforms the theorem on lists to reverse-symmetric version\""], ["", "end"], ["", "section \\<open>Declaration of basic reversal rules\\<close>"], ["", "lemma hd_last_Nil: \"hd [] = last []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd [] = last []", "unfolding hd_def last_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case [] of x21 # x22 \\<Rightarrow> x21) =\n    rec_list undefined (\\<lambda>x xs. If (xs = []) x) []", "by simp"], ["", "lemma last_rev_hd: \"last(rev xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (rev xs) = hd xs", "by (induct xs, simp add: hd_last_Nil, simp)"], ["", "lemma hd_rev_last: \"hd(rev xs) = last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (rev xs) = last xs", "by (induct xs, simp add: hd_last_Nil, simp)"], ["", "lemma tl_rev: \"tl (rev xs) = rev (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (rev xs) = rev (butlast xs)", "unfolding rev_swap[symmetric] butlast_rev[of \"rev xs\", symmetric] rev_rev_ident"], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast xs = butlast xs", ".."], ["", "lemma if_rev: \"(if P then rev u else rev v) = rev (if P then u else v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P then rev u else rev v) = rev (if P then u else v)", "by simp"], ["", "lemma rev_in_conv: \"rev u \\<in> A \\<longleftrightarrow> u \\<in> rev ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev u \\<in> A) = (u \\<in> rev ` A)", "using image_iff"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. (rev u \\<in> A) = (u \\<in> rev ` A)", "by fastforce"], ["", "lemma in_lists_rev: \"u \\<in> lists A \\<Longrightarrow> rev u \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> lists A \\<Longrightarrow> rev u \\<in> lists A", "by auto"], ["", "lemma rev_in_lists: \"rev u \\<in> lists A \\<Longrightarrow> u \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev u \\<in> lists A \\<Longrightarrow> u \\<in> lists A", "by auto"], ["", "lemma rev_lists_conv: \"rev ` lists A = lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` lists A = lists A", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> rev ` lists A \\<Longrightarrow> x \\<in> lists A\n 2. \\<And>x. x \\<in> lists A \\<Longrightarrow> x \\<in> rev ` lists A", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> rev ` lists A \\<Longrightarrow> x \\<in> lists A\n 2. \\<And>x. x \\<in> lists A \\<Longrightarrow> x \\<in> rev ` lists A", "show \"x \\<in> rev ` lists A \\<Longrightarrow> x \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rev ` lists A \\<Longrightarrow> x \\<in> lists A", "unfolding rev_in_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev x \\<in> lists A \\<Longrightarrow> x \\<in> lists A", "using rev_in_lists"], ["proof (prove)\nusing this:\n  rev ?u \\<in> lists ?A \\<Longrightarrow> ?u \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. rev x \\<in> lists A \\<Longrightarrow> x \\<in> lists A", "."], ["proof (state)\nthis:\n  x \\<in> rev ` lists A \\<Longrightarrow> x \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lists A \\<Longrightarrow> x \\<in> rev ` lists A", "show \"x \\<in> lists A \\<Longrightarrow> x \\<in> rev ` lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lists A \\<Longrightarrow> x \\<in> rev ` lists A", "unfolding rev_in_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lists A \\<Longrightarrow> rev x \\<in> lists A", "using in_lists_rev"], ["proof (prove)\nusing this:\n  ?u \\<in> lists ?A \\<Longrightarrow> rev ?u \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. x \\<in> lists A \\<Longrightarrow> rev x \\<in> lists A", "."], ["proof (state)\nthis:\n  x \\<in> lists A \\<Longrightarrow> x \\<in> rev ` lists A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coset_rev: \"List.coset (rev xs) = List.coset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.coset (rev xs) = List.coset xs", "by simp"], ["", "lemmas [reversal_rule] =\n  Cons_rev\n  snocs_snocs\n  rev_append[symmetric]\n  last_rev_hd hd_rev_last\n  tl_rev butlast_rev\n  rev_is_rev_conv\n  length_rev\n  take_rev\n  drop_rev\n  rotate_rev\n  if_rev\n  rev_in_conv\n  rev_lists_conv\n  set_rev\n  coset_rev"], ["", "section \\<open>Examples\\<close>"], ["", "context\nbegin"], ["", "subsection \\<open>Cons and append\\<close>"], ["", "private"], ["", "lemma example_Cons_append:\n  assumes \"xs = [a, b]\" and \"ys = [b, a, b]\"\n  shows \"xs @ xs @ xs = a # b # a # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ xs @ xs = a # b # a # ys", "using assms"], ["proof (prove)\nusing this:\n  xs = [a, b]\n  ys = [b, a, b]\n\ngoal (1 subgoal):\n 1. xs @ xs @ xs = a # b # a # ys", "by simp"], ["", "thm\n  example_Cons_append\n  example_Cons_append[reversed]\n  example_Cons_append[reversed, reversed]"], ["", "thm\n  not_Cons_self\n  not_Cons_self[reversed]"], ["", "thm\n  neq_Nil_conv\n  neq_Nil_conv[reversed]"], ["", "subsection \\<open>Induction rules\\<close>"], ["", "thm\n  list_nonempty_induct\n  list_nonempty_induct[reversed] (* needs work *)\n  list_nonempty_induct[reversed, where P=\"\\<lambda>x. P (rev x)\" for P, unfolded rev_rev_ident]"], ["", "thm\n  list_induct2\n  list_induct2[reversed] (* needs work *)\n  list_induct2[reversed, where P=\"\\<lambda>x y. P (rev x) (rev y)\" for P, unfolded rev_rev_ident]"], ["", "subsection \\<open>hd, tl, last, butlast\\<close>"], ["", "thm\n  hd_append\n  hd_append[reversed]\n  last_append"], ["", "thm\n  length_tl\n  length_tl[reversed]\n  length_butlast"], ["", "thm\n  hd_Cons_tl\n  hd_Cons_tl[reversed]\n  append_butlast_last_id\n  append_butlast_last_id[reversed]"], ["", "subsection \\<open>set\\<close>"], ["", "thm\n  hd_in_set\n  hd_in_set[reversed]\n  last_in_set"], ["", "thm\n  set_ConsD\n  set_ConsD[reversed]"], ["", "thm\n  split_list_first\n  split_list_first[reversed]"], ["", "thm\n  split_list_first_prop\n  split_list_first_prop[reversed]\n  split_list_first_prop[reversed, unfolded append_assoc append_Cons append_Nil]\n  split_list_last_prop"], ["", "thm\n  split_list_first_propE\n  split_list_first_propE[reversed]\n  split_list_first_propE[reversed, unfolded append_assoc append_Cons append_Nil]\n  split_list_last_propE"], ["", "subsection \\<open>rotate\\<close>"], ["", "private"], ["", "lemma rotate1_hd_tl': \"xs \\<noteq> [] \\<Longrightarrow> rotate 1 xs = tl xs @ [hd xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> rotate 1 xs = tl xs @ [hd xs]", "by (cases xs) simp_all"], ["", "thm\n  rotate1_hd_tl'\n  rotate1_hd_tl'[reversed]"], ["", "end"], ["", "end"]]}