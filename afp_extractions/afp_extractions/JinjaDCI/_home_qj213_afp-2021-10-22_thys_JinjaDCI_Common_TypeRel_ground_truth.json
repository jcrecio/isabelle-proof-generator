{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/Common/TypeRel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma subcls1D: \"P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = Some (D,fs,ms))\"", "lemma [iff]: \"\\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C\"", "lemma [iff]: \"(P \\<turnstile> Object \\<preceq>\\<^sup>* C) = (C = Object)\"", "lemma subcls1_def2:\n  \"subcls1 P =\n     (SIGMA C:{C. is_class P C}. {D. C\\<noteq>Object \\<and> fst (the (class P C))=D})\"", "lemma finite_subcls1: \"finite (subcls1 P)\"", "lemma supercls_lst_app:\n \"\\<lbrakk> supercls_lst P (C#Cs); P \\<turnstile> C \\<preceq>\\<^sup>* C' \\<rbrakk> \\<Longrightarrow> supercls_lst P (C'#C#Cs)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Void) = (T = Void)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Boolean) = (T = Boolean)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Integer) = (T = Integer)\"", "lemma [iff]: \"(P \\<turnstile> Void \\<le> T) = (T = Void)\"", "lemma [iff]: \"(P \\<turnstile> Boolean \\<le> T) = (T = Boolean)\"", "lemma [iff]: \"(P \\<turnstile> Integer \\<le> T) = (T = Integer)\"", "lemma Class_widen: \"P \\<turnstile> Class C \\<le> T  \\<Longrightarrow>  \\<exists>D. T = Class D\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> NT) = (T = NT)\"", "lemma Class_widen_Class [iff]: \"(P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> C \\<preceq>\\<^sup>* D)\"", "lemma widen_Class: \"(P \\<turnstile> T \\<le> Class C) = (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))\"", "lemma widen_trans[trans]: \"\\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk> \\<Longrightarrow> P \\<turnstile> S \\<le> T\"", "lemma widens_trans [trans]: \"\\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Us\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us\"", "lemmas widens_refl [iff] = list_all2_refl [of \"widen P\", OF widen_refl] for P", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P", "lemma sees_methods_fun:\nassumes 1: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm\"", "lemma visible_methods_exist:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> Mm M = Some(m,D) \\<Longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some m)\"", "lemma sees_methods_decl_above:\nassumes Csees: \"P \\<turnstile> C sees_methods Mm\"\nshows \"Mm M = Some(m,D) \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma sees_methods_idemp:\nassumes Cmethods: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>m D. Mm M = Some(m,D) \\<Longrightarrow>\n              \\<exists>Mm'. (P \\<turnstile> D sees_methods Mm') \\<and> Mm' M = Some(m,D)\"", "lemma sees_methods_decl_mono:\nassumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n       \\<exists>Mm' Mm\\<^sub>2. P \\<turnstile> C' sees_methods Mm' \\<and> Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                 (\\<forall>M m D. Mm\\<^sub>2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n(*<*)\n      (is \"_ \\<Longrightarrow> \\<exists>Mm' Mm2. ?Q C' C Mm' Mm2\")", "lemma sees_methods_is_class_Object:\n \"P \\<turnstile> D sees_methods Mm \\<Longrightarrow> is_class P Object\"", "lemma sees_methods_sub_Obj: \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object\"", "lemma sees_method_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees M,b:TS\\<rightarrow>T = m in D; P \\<turnstile> C sees M,b':TS'\\<rightarrow>T' = m' in D' \\<rbrakk>\n   \\<Longrightarrow> b = b' \\<and> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D\"", "lemma sees_method_decl_above:\n  \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma visible_method_exists:\n  \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  \\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some(b,Ts,T,m)\"", "lemma sees_method_idemp:\n  \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D \\<Longrightarrow> P \\<turnstile> D sees M,b:Ts\\<rightarrow>T=m in D\"", "lemma sees_method_decl_mono:\nassumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\" and\n        C_sees: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D\" and\n        C'_sees: \"P \\<turnstile> C' sees M,b':Ts'\\<rightarrow>T'=m' in D'\"\nshows   \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\"", "lemma sees_methods_is_class: \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> is_class P C\"", "lemma sees_method_is_class:\n  \"\\<lbrakk> P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma sees_method_is_class':\n  \"\\<lbrakk> P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D \\<rbrakk> \\<Longrightarrow> is_class P D\"", "lemma sees_method_sub_Obj: \"P \\<turnstile> C sees M,b:  Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object\"", "lemma has_fields_is_class:\n \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C\"", "lemma has_fields_fun:\nassumes 1: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<And>FDTs'. P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs\"", "lemma all_fields_in_has_fields:\nassumes sub: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; class P D = Some(D',fs,ms); (F,b,T) \\<in> set fs \\<rbrakk>\n       \\<Longrightarrow> ((F,D),b,T) \\<in> set FDTs\"", "lemma has_fields_decl_above:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),b,T) \\<in> set FDTs \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma subcls_notin_has_fields:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),b,T) \\<in> set FDTs \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>+\"", "lemma subcls_notin_has_fields2:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<lbrakk> C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D \\<rbrakk> \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>*\"", "lemma has_fields_mono_lem:\nassumes sub: \"P \\<turnstile> D \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C has_fields FDTs\n         \\<Longrightarrow> \\<exists>pre. P \\<turnstile> D has_fields pre@FDTs \\<and> dom(map_of pre) \\<inter> dom(map_of FDTs) = {}\"", "lemma has_fields_declaring_classes:\nshows \"P \\<turnstile> C has_fields FDTs\n \\<Longrightarrow> \\<exists>pre FDTs'. FDTs = pre@FDTs'\n         \\<and> (C \\<noteq> Object \\<longrightarrow> (\\<exists>D fs ms. class P C = \\<lfloor>(D,fs,ms)\\<rfloor> \\<and> P \\<turnstile> D has_fields FDTs'))\n             \\<and> set(map (\\<lambda>t. snd(fst t)) pre) \\<subseteq> {C}\n                \\<and> set(map (\\<lambda>t. snd(fst t)) FDTs') \\<subseteq> {C'. C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\"", "lemma has_fields_mono_lem2:\nassumes hf: \"P \\<turnstile> C has_fields FDTs\"\n and cls: \"class P C = Some(D,fs,ms)\" and map_of: \"map_of FDTs (F,C) = \\<lfloor>(b,T)\\<rfloor>\"\nshows \"\\<exists>FDTs'. FDTs = (map (\\<lambda>(F,b,T). ((F,C),b,T)) fs) @ FDTs' \\<and> map_of FDTs' (F,C) = None\"", "lemma has_fields_is_class_Object:\n \"P \\<turnstile> D has_fields FDTs \\<Longrightarrow> is_class P Object\"", "lemma Object_fields:\n \"\\<lbrakk> P \\<turnstile> Object has_fields FDTs; C \\<noteq> Object \\<rbrakk> \\<Longrightarrow> map_of FDTs (F,C) = None\"", "lemma has_field_mono:\nassumes has: \" P \\<turnstile> C has F,b:T in D\" and sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C' has F,b:T in D\"", "lemma has_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C has F,b:T in D; P \\<turnstile> C has F,b':T' in D\\<rbrakk> \\<Longrightarrow> b = b' \\<and> T' = T\"", "lemma has_field_idemp:\nassumes has: \"P \\<turnstile> C has F,b:T in D\"\nshows \"P \\<turnstile> D has F,b:T in D\"", "lemma visible_fields_exist:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\" and\n        FDTs:   \"map_of FDTs (F,D) = Some (b, T)\"\nshows \"\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of fs F = Some(b,T)\"", "lemma map_of_remap_SomeD:\n  \"map_of (map (\\<lambda>((k,k'),x). (k,(k',x))) t) k = Some (k',x) \\<Longrightarrow> map_of t (k, k') = Some x\"", "lemma map_of_remap_SomeD2:\n  \"map_of (map (\\<lambda>((k,k'),x,x'). (k,(k',x,x'))) t) k = Some (k',x,x') \\<Longrightarrow> map_of t (k, k') = Some (x, x')\"", "lemma has_field_decl_above:\n  \"P \\<turnstile> C has F,b:T in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma has_visible_field:\n  \"P \\<turnstile> C sees F,b:T in D \\<Longrightarrow> P \\<turnstile> C has F,b:T in D\"", "lemma sees_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees F,b:T in D; P \\<turnstile> C sees F,b':T' in D'\\<rbrakk> \\<Longrightarrow> b = b' \\<and> T' = T \\<and> D' = D\"", "lemma sees_field_decl_above:\n  \"P \\<turnstile> C sees F,b:T in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma sees_field_idemp:\nassumes sees: \"P \\<turnstile> C sees F,b:T in D\"\nshows \"P \\<turnstile> D sees F,b:T in D\"", "lemma has_field_sees_aux:\nassumes hf: \"P \\<turnstile> C has_fields FDTs\" and map: \"map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>\"\nshows \"map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F = \\<lfloor>(C, b, T)\\<rfloor>\"", "lemma has_field_sees: \"P \\<turnstile> C has F,b:T in C \\<Longrightarrow> P \\<turnstile> C sees F,b:T in C\"", "lemma has_field_is_class:\n \"P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P C\"", "lemma has_field_is_class':\n \"P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P D\"", "lemma fields_def2 [simp]: \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\"", "lemma field_def2 [simp]: \"P \\<turnstile> C sees F,b:T in D \\<Longrightarrow> field P C F = (D,b,T)\"", "lemma method_def2 [simp]: \"P \\<turnstile> C sees M,b: Ts\\<rightarrow>T = m in D \\<Longrightarrow> method P C M = (D,b,Ts,T,m)\"", "lemma ifields_def2[simp]: \"\\<lbrakk> P \\<turnstile> C has_fields FDTs \\<rbrakk> \\<Longrightarrow> ifields P C = filter (\\<lambda>((F,D),b,T). b = NonStatic) FDTs\"", "lemma isfields_def2[simp]: \"\\<lbrakk> P \\<turnstile> C has_fields FDTs \\<rbrakk> \\<Longrightarrow> isfields P C = filter (\\<lambda>((F,D),b,T). b = Static \\<and> D = C) FDTs\"", "lemma ifields_def3: \"\\<lbrakk> P \\<turnstile> C sees F,b:T in D; b = NonStatic \\<rbrakk> \\<Longrightarrow> (((F,D),b,T) \\<in> set (ifields P C))\"", "lemma isfields_def3: \"\\<lbrakk> P \\<turnstile> C sees F,b:T in D; b = Static; D = C \\<rbrakk> \\<Longrightarrow> (((F,D),b,T) \\<in> set (isfields P C))\"", "lemma seeing_class_def2[simp]:\n \"P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = m in D \\<Longrightarrow> seeing_class P C M = Some D\""], "translations": [["", "lemma subcls1D: \"P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = Some (D,fs,ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n    C \\<noteq> Object \\<and>\n    (\\<exists>fs ms. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n    C \\<noteq> Object \\<and>\n    (\\<exists>fs ms. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>)", "by(erule subcls1.induct)(fastforce simp add:is_class_def)"], ["", "(*>*)"], ["", "lemma [iff]: \"\\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Object, C) \\<notin> subcls1 P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Object, C) \\<notin> subcls1 P", "by(fastforce dest:subcls1D)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Object \\<preceq>\\<^sup>* C) = (C = Object)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C = (C = Object)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C = (C = Object)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C \\<Longrightarrow> C = Object\n 2. C = Object \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* C", "assume \"P \\<turnstile> Object \\<preceq>\\<^sup>* C\""], ["proof (state)\nthis:\n  P \\<turnstile> Object \\<preceq>\\<^sup>* C\n\ngoal (2 subgoals):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C \\<Longrightarrow> C = Object\n 2. C = Object \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* C", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object \\<preceq>\\<^sup>* C", "show \"C = Object\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Object \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. C = Object", "by(auto elim: converse_rtranclE)"], ["proof (state)\nthis:\n  C = Object\n\ngoal (1 subgoal):\n 1. C = Object \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* C", "qed simp"], ["", "(*>*)"], ["", "lemma subcls1_def2:\n  \"subcls1 P =\n     (SIGMA C:{C. is_class P C}. {D. C\\<noteq>Object \\<and> fst (the (class P C))=D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 P =\n    (SIGMA C:{C. is_class P C}.\n        {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 P =\n    (SIGMA C:{C. is_class P C}.\n        {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})", "by (fastforce simp:is_class_def dest: subcls1D elim: subcls1I)"], ["", "(*>*)"], ["", "lemma finite_subcls1: \"finite (subcls1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "let ?SIG = \"SIGMA C:{C. is_class P C}. {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "have \"subcls1 P = ?SIG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 P =\n    (SIGMA C:{C. is_class P C}.\n        {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})", "by(simp add: subcls1_def2)"], ["proof (state)\nthis:\n  subcls1 P =\n  (SIGMA C:{C. is_class P C}.\n      {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})\n\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "also"], ["proof (state)\nthis:\n  subcls1 P =\n  (SIGMA C:{C. is_class P C}.\n      {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})\n\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "have \"finite ?SIG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (SIGMA C:{C. is_class P C}.\n         {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})", "proof(rule finite_SigmaI [OF finite_is_class])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> {C. is_class P C} \\<Longrightarrow>\n       finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> {C. is_class P C} \\<Longrightarrow>\n       finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}", "assume C_in: \"C \\<in> {C. is_class P C}\""], ["proof (state)\nthis:\n  C \\<in> {C. is_class P C}\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> {C. is_class P C} \\<Longrightarrow>\n       finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}", "then"], ["proof (chain)\npicking this:\n  C \\<in> {C. is_class P C}", "show \"finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}\""], ["proof (prove)\nusing this:\n  C \\<in> {C. is_class P C}\n\ngoal (1 subgoal):\n 1. finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}", "by(rule_tac finite_subset[where B = \"{fst (the (class P C))}\"]) auto"], ["proof (state)\nthis:\n  finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   (SIGMA C:{C. is_class P C}.\n       {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})\n\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "ultimately"], ["proof (chain)\npicking this:\n  subcls1 P =\n  (SIGMA C:{C. is_class P C}.\n      {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})\n  finite\n   (SIGMA C:{C. is_class P C}.\n       {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})", "show ?thesis"], ["proof (prove)\nusing this:\n  subcls1 P =\n  (SIGMA C:{C. is_class P C}.\n      {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})\n  finite\n   (SIGMA C:{C. is_class P C}.\n       {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})\n\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "by simp"], ["proof (state)\nthis:\n  finite (subcls1 P)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "primrec supercls_lst :: \"'m prog \\<Rightarrow> cname list \\<Rightarrow> bool\" where\n\"supercls_lst P (C#Cs) = ((\\<forall>C' \\<in> set Cs. P \\<turnstile> C' \\<preceq>\\<^sup>* C) \\<and> supercls_lst P Cs)\" |\n\"supercls_lst P [] = True\""], ["", "lemma supercls_lst_app:\n \"\\<lbrakk> supercls_lst P (C#Cs); P \\<turnstile> C \\<preceq>\\<^sup>* C' \\<rbrakk> \\<Longrightarrow> supercls_lst P (C'#C#Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>supercls_lst P (C # Cs);\n     P \\<turnstile> C \\<preceq>\\<^sup>* C'\\<rbrakk>\n    \\<Longrightarrow> supercls_lst P (C' # C # Cs)", "by auto"], ["", "subsection\\<open> The subtype relations \\<close>"], ["", "inductive\n  widen   :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<le> _\"   [71,71,71] 70)\n  for P :: \"'m prog\"\nwhere\n  widen_refl[iff]: \"P \\<turnstile> T \\<le> T\"\n| widen_subcls: \"P \\<turnstile> C \\<preceq>\\<^sup>* D  \\<Longrightarrow>  P \\<turnstile> Class C \\<le> Class D\"\n| widen_null[iff]: \"P \\<turnstile> NT \\<le> Class C\""], ["", "abbreviation\n  widens :: \"'m prog \\<Rightarrow> ty list \\<Rightarrow> ty list \\<Rightarrow> bool\"\n    (\"_ \\<turnstile> _ [\\<le>] _\" [71,71,71] 70) where\n  \"widens P Ts Ts' \\<equiv> list_all2 (widen P) Ts Ts'\""], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Void) = (T = Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Void = (T = Void)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Void = (T = Void)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Boolean) = (T = Boolean)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Boolean = (T = Boolean)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Boolean = (T = Boolean)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Integer) = (T = Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Integer = (T = Integer)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Integer = (T = Integer)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Void \\<le> T) = (T = Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Void \\<le> T = (T = Void)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Void \\<le> T = (T = Void)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Boolean \\<le> T) = (T = Boolean)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Boolean \\<le> T = (T = Boolean)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Boolean \\<le> T = (T = Boolean)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Integer \\<le> T) = (T = Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Integer \\<le> T = (T = Integer)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Integer \\<le> T = (T = Integer)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma Class_widen: \"P \\<turnstile> Class C \\<le> T  \\<Longrightarrow>  \\<exists>D. T = Class D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T \\<Longrightarrow> \\<exists>D. T = Class D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T \\<Longrightarrow> \\<exists>D. T = Class D", "by (ind_cases \"P \\<turnstile> Class C \\<le> T\") auto"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> NT) = (T = NT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> NT = (T = NT)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> NT = (T = NT)", "by(cases T) (auto dest:Class_widen)"], ["", "(*>*)"], ["", "lemma Class_widen_Class [iff]: \"(P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> C \\<preceq>\\<^sup>* D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> Class D =\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> Class D =\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> Class C \\<le> Class D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> Class C \\<le> Class D", "show \"P \\<turnstile> Class C \\<le> Class D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> Class D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "proof(ind_cases \"P \\<turnstile> Class C \\<le> Class D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D = C \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "qed(auto)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> Class D \\<Longrightarrow>\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> Class C \\<le> Class D", "qed(auto elim: widen_subcls)"], ["", "(*>*)"], ["", "lemma widen_Class: \"(P \\<turnstile> T \\<le> Class C) = (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Class C =\n    (T = NT \\<or>\n     (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Class C =\n    (T = NT \\<or>\n     (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))", "by(induct T, auto)"], ["", "(*>*)"], ["", "lemma widen_trans[trans]: \"\\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk> \\<Longrightarrow> P \\<turnstile> S \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "assume \"P\\<turnstile>S \\<le> U\""], ["proof (state)\nthis:\n  P \\<turnstile> S \\<le> U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "thus \"\\<And>T. P \\<turnstile> U \\<le> T \\<Longrightarrow> P \\<turnstile> S \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> S \\<le> U\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       P \\<turnstile> U \\<le> T \\<Longrightarrow> P \\<turnstile> S \\<le> T", "proof induct"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>T Ta.\n       P \\<turnstile> T \\<le> Ta \\<Longrightarrow> P \\<turnstile> T \\<le> Ta\n 2. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 3. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "case (widen_refl T T')"], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n\ngoal (3 subgoals):\n 1. \\<And>T Ta.\n       P \\<turnstile> T \\<le> Ta \\<Longrightarrow> P \\<turnstile> T \\<le> Ta\n 2. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 3. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "thus \"P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> T'", "."], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "case (widen_subcls C D T)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T", "obtain E where \"T = Class E\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n\ngoal (1 subgoal):\n 1. (\\<And>E. T = Class E \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (blast dest: Class_widen)"], ["proof (state)\nthis:\n  T = Class E\n\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "with widen_subcls"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n  T = Class E", "show \"P \\<turnstile> Class C \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n  T = Class E\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T", "by (auto elim: rtrancl_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "case (widen_null C RT)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> RT\n\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> Class C \\<le> RT", "obtain D where \"RT = Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Class C \\<le> RT\n\ngoal (1 subgoal):\n 1. (\\<And>D. RT = Class D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: Class_widen)"], ["proof (state)\nthis:\n  RT = Class D\n\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "thus \"P \\<turnstile> NT \\<le> RT\""], ["proof (prove)\nusing this:\n  RT = Class D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> NT \\<le> RT", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> NT \\<le> RT\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> U \\<le> ?T \\<Longrightarrow> P \\<turnstile> S \\<le> ?T\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma widens_trans [trans]: \"\\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Us\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Us\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Us\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us", "by (rule list_all2_trans, rule widen_trans)"], ["", "(*>*)\n\n\n(*<*)"], ["", "lemmas widens_refl [iff] = list_all2_refl [of \"widen P\", OF widen_refl] for P"], ["", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P"], ["", "(*>*)"], ["", "subsection\\<open> Method lookup \\<close>"], ["", "inductive\n  Methods :: \"['m prog, cname, mname \\<rightharpoonup> (staticb \\<times> ty list \\<times> ty \\<times> 'm) \\<times> cname] \\<Rightarrow> bool\"\n                    (\"_ \\<turnstile> _ sees'_methods _\" [51,51,51] 50)\n  for P :: \"'m prog\"\nwhere\n  sees_methods_Object:\n \"\\<lbrakk> class P Object = Some(D,fs,ms); Mm = map_option (\\<lambda>m. (m,Object)) \\<circ> map_of ms \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees_methods Mm\"\n| sees_methods_rec:\n \"\\<lbrakk> class P C = Some(D,fs,ms); C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n    Mm' = Mm ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees_methods Mm'\""], ["", "lemma sees_methods_fun:\nassumes 1: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "using 1"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "case (sees_methods_rec C D fs ms Dres Cres Cres')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D sees_methods Dres\n  P \\<turnstile> D sees_methods ?Mm' \\<Longrightarrow> ?Mm' = Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  P \\<turnstile> C sees_methods Cres'\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "have \"class\": \"class P C = Some (D, fs, ms)\"\n   and notObj: \"C \\<noteq> Object\" and Dmethods: \"P \\<turnstile> D sees_methods Dres\"\n   and IH: \"\\<And>Dres'. P \\<turnstile> D sees_methods Dres' \\<Longrightarrow> Dres' = Dres\"\n   and Cres: \"Cres = Dres ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms)\"\n   and Cmethods': \"P \\<turnstile> C sees_methods Cres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (class P C = \\<lfloor>(D, fs, ms)\\<rfloor> &&&\n     C \\<noteq> Object &&& P \\<turnstile> D sees_methods Dres) &&&\n    (\\<And>Dres'.\n        P \\<turnstile> D sees_methods Dres' \\<Longrightarrow>\n        Dres' = Dres) &&&\n    Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms) &&&\n    P \\<turnstile> C sees_methods Cres'", "by fact+"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D sees_methods Dres\n  P \\<turnstile> D sees_methods ?Dres' \\<Longrightarrow> ?Dres' = Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  P \\<turnstile> C sees_methods Cres'\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "from Cmethods' notObj \"class\""], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees_methods Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain Dres'\n    where Dmethods': \"P \\<turnstile> D sees_methods Dres'\"\n     and Cres': \"Cres' = Dres' ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Dres'.\n        \\<lbrakk>P \\<turnstile> D sees_methods Dres';\n         Cres' =\n         Dres' ++\n         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: Methods.cases)"], ["proof (state)\nthis:\n  P \\<turnstile> D sees_methods Dres'\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "from Cres Cres' IH[OF Dmethods']"], ["proof (chain)\npicking this:\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Dres' = Dres", "show \"Cres' = Cres\""], ["proof (prove)\nusing this:\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Dres' = Dres\n\ngoal (1 subgoal):\n 1. Cres' = Cres", "by simp"], ["proof (state)\nthis:\n  Cres' = Cres\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  P \\<turnstile> Object sees_methods Mm'\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  P \\<turnstile> Object sees_methods Mm'\n\ngoal (1 subgoal):\n 1. Mm' = Mm_", "by(auto elim: Methods.cases)"], ["proof (state)\nthis:\n  Mm' = Mm_\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma visible_methods_exist:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> Mm M = Some(m,D) \\<Longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees_methods Mm;\n     Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' fs ms.\n                         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                         map_of ms M = \\<lfloor>m\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees_methods Mm;\n     Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' fs ms.\n                         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                         map_of ms M = \\<lfloor>m\\<rfloor>", "by(induct rule:Methods.induct) auto"], ["", "(*>*)"], ["", "lemma sees_methods_decl_above:\nassumes Csees: \"P \\<turnstile> C sees_methods Mm\"\nshows \"Mm M = Some(m,D) \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "using Csees"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>Da fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* D", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> Object \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "case sees_methods_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* D\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* D\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C_ \\<preceq>\\<^sup>* D", "by(fastforce simp:map_option_case split:option.splits\n                elim:converse_rtrancl_into_rtrancl[OF subcls1I])"], ["proof (state)\nthis:\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma sees_methods_idemp:\nassumes Cmethods: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>m D. Mm M = Some(m,D) \\<Longrightarrow>\n              \\<exists>Mm'. (P \\<turnstile> D sees_methods Mm') \\<and> Mm' M = Some(m,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m D.\n       Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm'.\n          P \\<turnstile> D sees_methods Mm' \\<and>\n          Mm' M = \\<lfloor>(m, D)\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m D.\n       Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm'.\n          P \\<turnstile> D sees_methods Mm' \\<and>\n          Mm' M = \\<lfloor>(m, D)\\<rfloor>", "using Cmethods"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>m D.\n       Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm'.\n          P \\<turnstile> D sees_methods Mm' \\<and>\n          Mm' M = \\<lfloor>(m, D)\\<rfloor>", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm m Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm m Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>Mm'.\n       P \\<turnstile> D sees_methods Mm' \\<and>\n       Mm' M = \\<lfloor>(m, D)\\<rfloor>", "by(fastforce dest: Methods.sees_methods_Object)"], ["proof (state)\nthis:\n  \\<exists>Mm'.\n     P \\<turnstile> D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "case sees_methods_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(?m, ?D)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm'.\n     P \\<turnstile> ?D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(?m, ?D)\\<rfloor>\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(?m, ?D)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm'.\n     P \\<turnstile> ?D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(?m, ?D)\\<rfloor>\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>Mm'.\n       P \\<turnstile> D sees_methods Mm' \\<and>\n       Mm' M = \\<lfloor>(m, D)\\<rfloor>", "by(fastforce split:option.splits dest: Methods.sees_methods_rec)"], ["proof (state)\nthis:\n  \\<exists>Mm'.\n     P \\<turnstile> D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n\n(*FIXME something wrong with induct: need to attache [consumes 1]\ndirectly to proof of thm, declare does not work. *)"], ["", "lemma sees_methods_decl_mono:\nassumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n       \\<exists>Mm' Mm\\<^sub>2. P \\<turnstile> C' sees_methods Mm' \\<and> Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                 (\\<forall>M m D. Mm\\<^sub>2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n(*<*)\n      (is \"_ \\<Longrightarrow> \\<exists>Mm' Mm2. ?Q C' C Mm' Mm2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "using sub"], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "proof (induct rule:converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "assume \"P \\<turnstile> C sees_methods Mm\""], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "hence \"?Q C C Mm Map.empty\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<and>\n    Mm = Mm ++ Map.empty \\<and>\n    (\\<forall>M m D.\n        None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Mm \\<and>\n  Mm = Mm ++ Map.empty \\<and>\n  (\\<forall>M m D.\n      None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "thus \"\\<exists>Mm' Mm2. ?Q C C Mm' Mm2\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm \\<and>\n  Mm = Mm ++ Map.empty \\<and>\n  (\\<forall>M m D.\n      None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm2 \\<and>\n       (\\<forall>M m D.\n           Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "fix C'' C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "assume sub1: \"P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\" and sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\n  and IH: \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n           \\<exists>Mm' Mm2. P \\<turnstile> C' sees_methods Mm' \\<and>\n                Mm' = Mm ++ Mm2 \\<and> (\\<forall>M m D. Mm2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n  and Csees: \"P \\<turnstile> C sees_methods Mm\""], ["proof (state)\nthis:\n  P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "from IH[OF Csees]"], ["proof (chain)\npicking this:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)", "obtain Mm' Mm2 where C'sees: \"P \\<turnstile> C' sees_methods Mm'\"\n    and Mm': \"Mm' = Mm ++ Mm2\"\n    and subC:\"\\<forall>M m D. Mm2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. (\\<And>Mm' Mm2.\n        \\<lbrakk>P \\<turnstile> C' sees_methods Mm'; Mm' = Mm ++ Mm2;\n         \\<forall>M m D.\n            Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees_methods Mm'\n  Mm' = Mm ++ Mm2\n  \\<forall>M m D.\n     Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "obtain fs ms where \"class\": \"class P C'' = Some(C',fs,ms)\" \"C'' \\<noteq> Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>;\n         C'' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subcls1D[OF sub1]"], ["proof (prove)\nusing this:\n  C'' \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>;\n         C'' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>\n  C'' \\<noteq> Object\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "let ?Mm3 = \"map_option (\\<lambda>m. (m,C'')) \\<circ> map_of ms\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "have \"P \\<turnstile> C'' sees_methods (Mm ++ Mm2) ++ ?Mm3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms)", "using sees_methods_rec[OF \"class\" C'sees refl] Mm'"], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm' ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n  Mm' = Mm ++ Mm2\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms)", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "hence \"?Q C'' C ((Mm ++ Mm2) ++ ?Mm3) (Mm2++?Mm3)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms) \\<and>\n    Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n    Mm ++\n    (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n    (\\<forall>M m D.\n        (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n        \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "using converse_rtrancl_into_rtrancl[OF sub1 sub]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n  P \\<turnstile> C'' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms) \\<and>\n    Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n    Mm ++\n    (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n    (\\<forall>M m D.\n        (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n        \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by simp (simp add:map_add_def subC split:option.split)"], ["proof (state)\nthis:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms) \\<and>\n  Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n  Mm ++\n  (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n  (\\<forall>M m D.\n      (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n      \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "thus \"\\<exists>Mm' Mm2. ?Q C'' C Mm' Mm2\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms) \\<and>\n  Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n  Mm ++\n  (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n  (\\<forall>M m D.\n      (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n      \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm2.\n       P \\<turnstile> C'' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm2 \\<and>\n       (\\<forall>M m D.\n           Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C'' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma sees_methods_is_class_Object:\n \"P \\<turnstile> D sees_methods Mm \\<Longrightarrow> is_class P Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees_methods Mm \\<Longrightarrow> is_class P Object", "by(induct rule: Methods.induct; simp add: is_class_def)"], ["", "lemma sees_methods_sub_Obj: \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* Object", "proof(induct rule: Methods.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* Object\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Object;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object", "case (sees_methods_rec C D fs ms Mm Mm')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  P \\<turnstile> D \\<preceq>\\<^sup>* Object\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* Object\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Object;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* Object", "using subcls1I[OF sees_methods_rec.hyps(1,2)] sees_methods_rec.hyps(4)"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n  P \\<turnstile> D \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* Object", "by(rule converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* Object", "qed(simp)"], ["", "definition Method :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> staticb \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'm \\<Rightarrow> cname \\<Rightarrow> bool\"\n            (\"_ \\<turnstile> _ sees _, _ :  _\\<rightarrow>_ = _ in _\" [51,51,51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C sees M, b: Ts\\<rightarrow>T = m in D  \\<equiv>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and> Mm M = Some((b,Ts,T,m),D)\""], ["", "definition has_method :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> staticb \\<Rightarrow> bool\"\n            (\"_ \\<turnstile> _ has _, _\" [51,0,0,51] 50)\nwhere\n  \"P \\<turnstile> C has M, b \\<equiv> \\<exists>Ts T m D. P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D\""], ["", "lemma sees_method_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees M,b:TS\\<rightarrow>T = m in D; P \\<turnstile> C sees M,b':TS'\\<rightarrow>T' = m' in D' \\<rbrakk>\n   \\<Longrightarrow> b = b' \\<and> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M, b :  TS\\<rightarrow>T = m in D;\n     P \\<turnstile> C sees M, b' :  TS'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> b = b' \\<and>\n                      TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M, b :  TS\\<rightarrow>T = m in D;\n     P \\<turnstile> C sees M, b' :  TS'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> b = b' \\<and>\n                      TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D", "by(fastforce dest: sees_methods_fun simp:Method_def)"], ["", "(*>*)"], ["", "lemma sees_method_decl_above:\n  \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(clarsimp simp:Method_def sees_methods_decl_above)"], ["", "(*>*)"], ["", "lemma visible_method_exists:\n  \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  \\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some(b,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(b, Ts, T, m)\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(b, Ts, T, m)\\<rfloor>", "by(fastforce simp:Method_def dest!: visible_methods_exist)"], ["", "(*>*)"], ["", "lemma sees_method_idemp:\n  \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D \\<Longrightarrow> P \\<turnstile> D sees M,b:Ts\\<rightarrow>T=m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> D sees M, b :  Ts\\<rightarrow>T = m in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> D sees M, b :  Ts\\<rightarrow>T = m in D", "by(fastforce simp: Method_def intro:sees_methods_idemp)"], ["", "(*>*)"], ["", "lemma sees_method_decl_mono:\nassumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\" and\n        C_sees: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D\" and\n        C'_sees: \"P \\<turnstile> C' sees M,b':Ts'\\<rightarrow>T'=m' in D'\"\nshows   \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "obtain Ms where Ms: \"P \\<turnstile> C sees_methods Ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ms.\n        P \\<turnstile> C sees_methods Ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using C_sees"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n\ngoal (1 subgoal):\n 1. (\\<And>Ms.\n        P \\<turnstile> C sees_methods Ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: Method_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Ms\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "obtain Ms' Ms2 where Ms': \"P \\<turnstile> C' sees_methods Ms'\" and\n     Ms'_def: \"Ms' = Ms ++ Ms2\" and\n     Ms2_imp: \"(\\<forall>M m D. Ms2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ms' Ms2.\n        \\<lbrakk>P \\<turnstile> C' sees_methods Ms'; Ms' = Ms ++ Ms2;\n         \\<forall>M m D.\n            Ms2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sees_methods_decl_mono[OF sub Ms]"], ["proof (prove)\nusing this:\n  \\<exists>Mm' Mm\\<^sub>2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Ms ++ Mm\\<^sub>2 \\<and>\n     (\\<forall>M m D.\n         Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. (\\<And>Ms' Ms2.\n        \\<lbrakk>P \\<turnstile> C' sees_methods Ms'; Ms' = Ms ++ Ms2;\n         \\<forall>M m D.\n            Ms2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees_methods Ms'\n  Ms' = Ms ++ Ms2\n  \\<forall>M m D.\n     Ms2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have \"(Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>", "using C'_sees sees_methods_fun[OF Ms'] Ms'_def"], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> C' sees_methods ?Mm' \\<Longrightarrow> ?Mm' = Ms'\n  Ms' = Ms ++ Ms2\n\ngoal (1 subgoal):\n 1. (Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>", "by(clarsimp simp: Method_def)"], ["proof (state)\nthis:\n  (Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "then"], ["proof (chain)\npicking this:\n  (Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>", "have \"Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n             Ms2 M = None \\<and> b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\""], ["proof (prove)\nusing this:\n  (Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>\n\ngoal (1 subgoal):\n 1. Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n    Ms2 M = None \\<and>\n    b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'", "using C_sees sees_methods_fun[OF Ms]"], ["proof (prove)\nusing this:\n  (Ms ++ Ms2) M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  P \\<turnstile> C sees_methods ?Mm' \\<Longrightarrow> ?Mm' = Ms\n\ngoal (1 subgoal):\n 1. Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n    Ms2 M = None \\<and>\n    b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'", "by(clarsimp simp: Method_def)"], ["proof (state)\nthis:\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n  Ms2 M = None \\<and>\n  b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "also"], ["proof (state)\nthis:\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n  Ms2 M = None \\<and>\n  b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have \"Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> D' \\<preceq>\\<^sup>* C", "using Ms2_imp"], ["proof (prove)\nusing this:\n  \\<forall>M m D.\n     Ms2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> D' \\<preceq>\\<^sup>* C", "by simp"], ["proof (state)\nthis:\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "ultimately"], ["proof (chain)\npicking this:\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n  Ms2 M = None \\<and>\n  b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* C", "show ?thesis"], ["proof (prove)\nusing this:\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n  Ms2 M = None \\<and>\n  b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "using sub sees_method_decl_above[OF C_sees]"], ["proof (prove)\nusing this:\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<or>\n  Ms2 M = None \\<and>\n  b = b' \\<and> Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\n  Ms2 M = \\<lfloor>((b', Ts', T', m'), D')\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' \\<preceq>\\<^sup>* D", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma sees_methods_is_class: \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow> is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow> is_class P C", "by (auto simp add: is_class_def elim: Methods.induct)"], ["", "(*>*)"], ["", "lemma sees_method_is_class:\n  \"\\<lbrakk> P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P C", "by (auto simp add: is_class_def Method_def dest: sees_methods_is_class)"], ["", "(*>*)"], ["", "lemma sees_method_is_class':\n  \"\\<lbrakk> P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=m in D \\<rbrakk> \\<Longrightarrow> is_class P D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P D", "by(drule sees_method_idemp, rule sees_method_is_class, assumption)"], ["", "(*>*)"], ["", "lemma sees_method_sub_Obj: \"P \\<turnstile> C sees M,b:  Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* Object", "by(auto simp: Method_def sees_methods_sub_Obj)"], ["", "subsection\\<open> Field lookup \\<close>"], ["", "inductive\n  Fields :: \"['m prog, cname, ((vname \\<times> cname) \\<times> staticb \\<times> ty) list] \\<Rightarrow> bool\"\n                  (\"_ \\<turnstile> _ has'_fields _\" [51,51,51] 50)\n  for P :: \"'m prog\"\nwhere\n  has_fields_rec:\n  \"\\<lbrakk> class P C = Some(D,fs,ms); C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n     FDTs' = map (\\<lambda>(F,b,T). ((F,C),b,T)) fs @ FDTs \\<rbrakk>\n   \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\"\n| has_fields_Object:\n  \"\\<lbrakk> class P Object = Some(D,fs,ms); FDTs = map (\\<lambda>(F,b,T). ((F,Object),b,T)) fs \\<rbrakk>\n   \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs\""], ["", "lemma has_fields_is_class:\n \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> is_class P C", "by (auto simp add: is_class_def elim: Fields.induct)"], ["", "(*>*)"], ["", "lemma has_fields_fun:\nassumes 1: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<And>FDTs'. P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs'.\n       P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs'.\n       P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs", "using 1"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>FDTs'.\n       P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "case (has_fields_rec C D fs ms Dres Cres Cres')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields Dres\n  P \\<turnstile> D has_fields ?FDTs' \\<Longrightarrow> ?FDTs' = Dres\n  Cres = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres\n  P \\<turnstile> C has_fields Cres'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "have \"class\": \"class P C = Some (D, fs, ms)\"\n   and notObj: \"C \\<noteq> Object\" and DFields: \"P \\<turnstile> D has_fields Dres\"\n   and IH: \"\\<And>Dres'. P \\<turnstile> D has_fields Dres' \\<Longrightarrow> Dres' = Dres\"\n   and Cres: \"Cres = map (\\<lambda>(F,b,T). ((F,C),b,T)) fs @ Dres\"\n   and CFields': \"P \\<turnstile> C has_fields Cres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (class P C = \\<lfloor>(D, fs, ms)\\<rfloor> &&&\n     C \\<noteq> Object &&& P \\<turnstile> D has_fields Dres) &&&\n    (\\<And>Dres'.\n        P \\<turnstile> D has_fields Dres' \\<Longrightarrow>\n        Dres' = Dres) &&&\n    Cres = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres &&&\n    P \\<turnstile> C has_fields Cres'", "by fact+"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields Dres\n  P \\<turnstile> D has_fields ?Dres' \\<Longrightarrow> ?Dres' = Dres\n  Cres = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres\n  P \\<turnstile> C has_fields Cres'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "from CFields' notObj \"class\""], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain Dres'\n    where DFields': \"P \\<turnstile> D has_fields Dres'\"\n     and Cres': \"Cres' = map (\\<lambda>(F,b,T). ((F,C),b,T)) fs @ Dres'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Dres'.\n        \\<lbrakk>P \\<turnstile> D has_fields Dres';\n         Cres' =\n         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: Fields.cases)"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields Dres'\n  Cres' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "from Cres Cres' IH[OF DFields']"], ["proof (chain)\npicking this:\n  Cres = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres\n  Cres' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres'\n  Dres' = Dres", "show \"Cres' = Cres\""], ["proof (prove)\nusing this:\n  Cres = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres\n  Cres' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ Dres'\n  Dres' = Dres\n\ngoal (1 subgoal):\n 1. Cres' = Cres", "by simp"], ["proof (state)\nthis:\n  Cres' = Cres\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs_\n  P \\<turnstile> Object has_fields FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs_\n  P \\<turnstile> Object has_fields FDTs'\n\ngoal (1 subgoal):\n 1. FDTs' = FDTs_", "by(auto elim: Fields.cases)"], ["proof (state)\nthis:\n  FDTs' = FDTs_\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma all_fields_in_has_fields:\nassumes sub: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; class P D = Some(D',fs,ms); (F,b,T) \\<in> set fs \\<rbrakk>\n       \\<Longrightarrow> ((F,D),b,T) \\<in> set FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "using sub"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        \\<lbrakk>P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n         class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n         (F, b, T) \\<in> set fs\\<rbrakk>\n        \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fsa @ FDTs;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "case (has_fields_rec C D' fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  \\<lbrakk>P \\<turnstile> D' \\<preceq>\\<^sup>* D;\n   class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n   (F, b, T) \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs\n\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        \\<lbrakk>P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n         class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n         (F, b, T) \\<in> set fs\\<rbrakk>\n        \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fsa @ FDTs;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "then"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  \\<lbrakk>P \\<turnstile> D' \\<preceq>\\<^sup>* D;\n   class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n   (F, b, T) \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs", "have C_D: \"P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  \\<lbrakk>P \\<turnstile> D' \\<preceq>\\<^sup>* D;\n   class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n   (F, b, T) \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        \\<lbrakk>P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n         class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n         (F, b, T) \\<in> set fs\\<rbrakk>\n        \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fsa @ FDTs;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs'", "proof(rule converse_rtranclE)"], ["proof (state)\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'\n 2. \\<And>y.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'", "assume \"C = D\""], ["proof (state)\nthis:\n  C = D\n\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'\n 2. \\<And>y.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'", "then"], ["proof (chain)\npicking this:\n  C = D", "show ?case"], ["proof (prove)\nusing this:\n  C = D\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs'", "using has_fields_rec"], ["proof (prove)\nusing this:\n  C = D\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  \\<lbrakk>P \\<turnstile> D' \\<preceq>\\<^sup>* D;\n   class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n   (F, b, T) \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs'", "by force"], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'", "assume sub1: \"P \\<turnstile> C \\<prec>\\<^sup>1 y\" and sub2: \"P \\<turnstile> y \\<preceq>\\<^sup>* D\""], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 y\n  P \\<turnstile> y \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs'", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 y\n  P \\<turnstile> y \\<preceq>\\<^sup>* D", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 y\n  P \\<turnstile> y \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs'", "using has_fields_rec subcls1D[OF sub1]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 y\n  P \\<turnstile> y \\<preceq>\\<^sup>* D\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  \\<lbrakk>P \\<turnstile> D' \\<preceq>\\<^sup>* D;\n   class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n   (F, b, T) \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs\n  C \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class P C = \\<lfloor>(y, fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs'", "by simp"], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "case (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  P \\<turnstile> Object \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, b, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), b, T) \\<in> set FDTs", "then"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  P \\<turnstile> Object \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  P \\<turnstile> Object \\<preceq>\\<^sup>* D\n  class P D = \\<lfloor>(D', fs, ms)\\<rfloor>\n  (F, b, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs", "by force"], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma has_fields_decl_above:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),b,T) \\<in> set FDTs \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "using fields"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        ((F, D), b, T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "case (has_fields_rec C D' fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        ((F, D), b, T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "then"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'", "have \"((F, D), b, T) \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs \\<or>\n    ((F, D), b, T) \\<in> set FDTs\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<or>\n    ((F, D), b, T) \\<in> set FDTs", "by clarsimp"], ["proof (state)\nthis:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n        set fs \\<or>\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        ((F, D), b, T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n        set fs \\<or>\n  ((F, D), b, T) \\<in> set FDTs", "show ?case"], ["proof (prove)\nusing this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n        set fs \\<or>\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "proof(rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "assume \"((F, D), b, T) \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\""], ["proof (state)\nthis:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\n\ngoal (2 subgoals):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs", "show ?case"], ["proof (prove)\nusing this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "using has_fields_rec"], ["proof (prove)\nusing this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "assume \"((F, D), b, T) \\<in> set FDTs\""], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T) \\<in> set FDTs", "show ?case"], ["proof (prove)\nusing this:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "using has_fields_rec"], ["proof (prove)\nusing this:\n  ((F, D), b, T) \\<in> set FDTs\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(blast dest:subcls1I converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "case (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "then"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  ((F, D), b, T) \\<in> set FDTs", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* D", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> Object \\<preceq>\\<^sup>* D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma subcls_notin_has_fields:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),b,T) \\<in> set FDTs \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "using fields"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        ((F, D), b, T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "case (has_fields_rec C D' fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  (D, D') \\<notin> (subcls1 P)\\<^sup>+\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        ((F, D), b, T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  (D, D') \\<notin> (subcls1 P)\\<^sup>+\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'", "have \"((F, D), b, T) \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\n               \\<or> ((F, D), b, T) \\<in> set FDTs\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  (D, D') \\<notin> (subcls1 P)\\<^sup>+\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<or>\n    ((F, D), b, T) \\<in> set FDTs", "by clarsimp"], ["proof (state)\nthis:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n        set fs \\<or>\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        ((F, D), b, T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n        set fs \\<or>\n  ((F, D), b, T) \\<in> set FDTs", "show ?case"], ["proof (prove)\nusing this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n        set fs \\<or>\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>+", "proof(rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "assume \"((F, D), b, T) \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\""], ["proof (state)\nthis:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\n\ngoal (2 subgoals):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs", "have CD[simp]: \"C = D\" and fs: \"(F, b, T) \\<in> set fs\""], ["proof (prove)\nusing this:\n  ((F, D), b, T)\n  \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) ` set fs\n\ngoal (1 subgoal):\n 1. C = D &&& (F, b, T) \\<in> set fs", "by clarsimp+"], ["proof (state)\nthis:\n  C = D\n  (F, b, T) \\<in> set fs\n\ngoal (2 subgoals):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  C = D\n  (F, b, T) \\<in> set fs", "have \"(D, D) \\<in> (subcls1 P)\\<^sup>+ \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  C = D\n  (F, b, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. (D, D) \\<in> (subcls1 P)\\<^sup>+ \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(D, D) \\<in> (subcls1 P)\\<^sup>+; C = D;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> False", "assume DD: \"(D, D) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (state)\nthis:\n  (D, D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(D, D) \\<in> (subcls1 P)\\<^sup>+; C = D;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> False", "obtain z where z1: \"P \\<turnstile> D \\<prec>\\<^sup>1 z\" and z_s: \"P \\<turnstile> z \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P \\<turnstile> D \\<prec>\\<^sup>1 z;\n         P \\<turnstile> z \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using tranclD[OF DD]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     P \\<turnstile> D \\<prec>\\<^sup>1 z \\<and>\n     P \\<turnstile> z \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>P \\<turnstile> D \\<prec>\\<^sup>1 z;\n         P \\<turnstile> z \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<prec>\\<^sup>1 z\n  P \\<turnstile> z \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(D, D) \\<in> (subcls1 P)\\<^sup>+; C = D;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> False", "have [simp]: \"z = D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = D'", "using subcls1D[OF z1] has_fields_rec.hyps(1)"], ["proof (prove)\nusing this:\n  D \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class P D = \\<lfloor>(z, fs, ms)\\<rfloor>)\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. z = D'", "by clarsimp"], ["proof (state)\nthis:\n  z = D'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(D, D) \\<in> (subcls1 P)\\<^sup>+; C = D;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z = D'", "have \"((F, D), b, T) \\<in> set FDTs\""], ["proof (prove)\nusing this:\n  z = D'\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs", "using z_s all_fields_in_has_fields[OF has_fields_rec.hyps(3) _ has_fields_rec.hyps(1) fs]"], ["proof (prove)\nusing this:\n  z = D'\n  P \\<turnstile> z \\<preceq>\\<^sup>* D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* C \\<Longrightarrow>\n  ((F, C), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs", "by simp"], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(D, D) \\<in> (subcls1 P)\\<^sup>+; C = D;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T) \\<in> set FDTs", "have \"(D, z) \\<notin> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. (D, z) \\<notin> (subcls1 P)\\<^sup>+", "using has_fields_rec.hyps(4)"], ["proof (prove)\nusing this:\n  ((F, D), b, T) \\<in> set FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  (D, D') \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (D, z) \\<notin> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (D, z) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(D, D) \\<in> (subcls1 P)\\<^sup>+; C = D;\n     (F, b, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (D, z) \\<notin> (subcls1 P)\\<^sup>+", "show False"], ["proof (prove)\nusing this:\n  (D, z) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "using z1"], ["proof (prove)\nusing this:\n  (D, z) \\<notin> (subcls1 P)\\<^sup>+\n  P \\<turnstile> D \\<prec>\\<^sup>1 z\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (D, D) \\<in> (subcls1 P)\\<^sup>+ \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. ((F, D), b, T)\n    \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n          set fs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  (D, D) \\<in> (subcls1 P)\\<^sup>+ \\<Longrightarrow> False", "show ?case"], ["proof (prove)\nusing this:\n  (D, D) \\<in> (subcls1 P)\\<^sup>+ \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>+", "by clarsimp"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "assume \"((F, D), b, T) \\<in> set FDTs\""], ["proof (state)\nthis:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  ((F, D), b, T) \\<in> set FDTs", "show ?case"], ["proof (prove)\nusing this:\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>+", "using has_fields_rec"], ["proof (prove)\nusing this:\n  ((F, D), b, T) \\<in> set FDTs\n  class P C = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  ((F, D), b, T) \\<in> set FDTs \\<Longrightarrow>\n  (D, D') \\<notin> (subcls1 P)\\<^sup>+\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  ((F, D), b, T) \\<in> set FDTs'\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>+", "by(blast dest:subcls1I trancl_into_trancl)"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "case (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        ((F, D), b, T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  ((F, D), b, T) \\<in> set FDTs", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  ((F, D), b, T) \\<in> set FDTs\n\ngoal (1 subgoal):\n 1. (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "by(fastforce dest: tranclD)"], ["proof (state)\nthis:\n  (D, Object) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma subcls_notin_has_fields2:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<lbrakk> C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D \\<rbrakk> \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n    \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>*", "using fields"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 D\\<rbrakk>\n    \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>*", "proof(induct arbitrary: D)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>Da.\n           \\<lbrakk>D \\<noteq> Object;\n            P \\<turnstile> D \\<prec>\\<^sup>1 Da\\<rbrakk>\n           \\<Longrightarrow> (Da, D) \\<notin> (subcls1 P)\\<^sup>*;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, C) \\<notin> (subcls1 P)\\<^sup>*\n 2. \\<And>D fs ms FDTs Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        Object \\<noteq> Object;\n        P \\<turnstile> Object \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, Object) \\<notin> (subcls1 P)\\<^sup>*", "case has_fields_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  \\<lbrakk>D_ \\<noteq> Object; P \\<turnstile> D_ \\<prec>\\<^sup>1 ?D\\<rbrakk>\n  \\<Longrightarrow> (?D, D_) \\<notin> (subcls1 P)\\<^sup>*\n  FDTs'_ = map (\\<lambda>(F, b, T). ((F, C_), b, T)) fs_ @ FDTs_\n  C_ \\<noteq> Object\n  P \\<turnstile> C_ \\<prec>\\<^sup>1 D\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>Da.\n           \\<lbrakk>D \\<noteq> Object;\n            P \\<turnstile> D \\<prec>\\<^sup>1 Da\\<rbrakk>\n           \\<Longrightarrow> (Da, D) \\<notin> (subcls1 P)\\<^sup>*;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, C) \\<notin> (subcls1 P)\\<^sup>*\n 2. \\<And>D fs ms FDTs Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        Object \\<noteq> Object;\n        P \\<turnstile> Object \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, Object) \\<notin> (subcls1 P)\\<^sup>*", "have \"\\<forall>C C' P. (C, C') \\<notin> subcls1 P \\<or> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = \\<lfloor>(C', fs, ms)\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C C' P.\n       (C, C') \\<notin> subcls1 P \\<or>\n       C \\<noteq> Object \\<and>\n       (\\<exists>fs ms. class P C = \\<lfloor>(C', fs, ms)\\<rfloor>)", "using subcls1D"], ["proof (prove)\nusing this:\n  ?P \\<turnstile> ?C \\<prec>\\<^sup>1 ?D \\<Longrightarrow>\n  ?C \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class ?P ?C = \\<lfloor>(?D, fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<forall>C C' P.\n       (C, C') \\<notin> subcls1 P \\<or>\n       C \\<noteq> Object \\<and>\n       (\\<exists>fs ms. class P C = \\<lfloor>(C', fs, ms)\\<rfloor>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>C C' P.\n     (C, C') \\<notin> subcls1 P \\<or>\n     C \\<noteq> Object \\<and>\n     (\\<exists>fs ms. class P C = \\<lfloor>(C', fs, ms)\\<rfloor>)\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>Da.\n           \\<lbrakk>D \\<noteq> Object;\n            P \\<turnstile> D \\<prec>\\<^sup>1 Da\\<rbrakk>\n           \\<Longrightarrow> (Da, D) \\<notin> (subcls1 P)\\<^sup>*;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, C) \\<notin> (subcls1 P)\\<^sup>*\n 2. \\<And>D fs ms FDTs Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        Object \\<noteq> Object;\n        P \\<turnstile> Object \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, Object) \\<notin> (subcls1 P)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  \\<forall>C C' P.\n     (C, C') \\<notin> subcls1 P \\<or>\n     C \\<noteq> Object \\<and>\n     (\\<exists>fs ms. class P C = \\<lfloor>(C', fs, ms)\\<rfloor>)", "have \"(D, D) \\<notin> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<forall>C C' P.\n     (C, C') \\<notin> subcls1 P \\<or>\n     C \\<noteq> Object \\<and>\n     (\\<exists>fs ms. class P C = \\<lfloor>(C', fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (D, D) \\<notin> (subcls1 P)\\<^sup>+", "by (metis (no_types) Pair_inject has_fields_rec.hyps(1) has_fields_rec.hyps(4)\n     has_fields_rec.prems(2) option.inject tranclD)"], ["proof (state)\nthis:\n  (D, D) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>Da.\n           \\<lbrakk>D \\<noteq> Object;\n            P \\<turnstile> D \\<prec>\\<^sup>1 Da\\<rbrakk>\n           \\<Longrightarrow> (Da, D) \\<notin> (subcls1 P)\\<^sup>*;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs;\n        C \\<noteq> Object; P \\<turnstile> C \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, C) \\<notin> (subcls1 P)\\<^sup>*\n 2. \\<And>D fs ms FDTs Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        Object \\<noteq> Object;\n        P \\<turnstile> Object \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, Object) \\<notin> (subcls1 P)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (D, D) \\<notin> (subcls1 P)\\<^sup>+", "show ?case"], ["proof (prove)\nusing this:\n  (D, D) \\<notin> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (D, C_) \\<notin> (subcls1 P)\\<^sup>*", "by (meson has_fields_rec.prems(2) rtrancl_into_trancl1)"], ["proof (state)\nthis:\n  (D, C_) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        Object \\<noteq> Object;\n        P \\<turnstile> Object \\<prec>\\<^sup>1 Da\\<rbrakk>\n       \\<Longrightarrow> (Da, Object) \\<notin> (subcls1 P)\\<^sup>*", "qed(fastforce dest: tranclD)"], ["", "lemma has_fields_mono_lem:\nassumes sub: \"P \\<turnstile> D \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C has_fields FDTs\n         \\<Longrightarrow> \\<exists>pre. P \\<turnstile> D has_fields pre@FDTs \\<and> dom(map_of pre) \\<inter> dom(map_of FDTs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "using sub"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "proof(induct rule:converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> C has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "case base"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> C has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<exists>pre.\n       P \\<turnstile> C has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "by(rule_tac x = \"[]\" in exI) simp"], ["proof (state)\nthis:\n  \\<exists>pre.\n     P \\<turnstile> C has_fields pre @ FDTs \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "case (step D' D)"], ["proof (state)\nthis:\n  P \\<turnstile> D' \\<prec>\\<^sup>1 D\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n  \\<exists>pre.\n     P \\<turnstile> D has_fields pre @ FDTs \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' \\<prec>\\<^sup>1 D\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n  \\<exists>pre.\n     P \\<turnstile> D has_fields pre @ FDTs \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n  P \\<turnstile> C has_fields FDTs", "obtain pre where D_flds: \"P \\<turnstile> D has_fields pre @ FDTs\" and\n    dom: \"dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' \\<prec>\\<^sup>1 D\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n  \\<exists>pre.\n     P \\<turnstile> D has_fields pre @ FDTs \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. (\\<And>pre.\n        \\<lbrakk>P \\<turnstile> D has_fields pre @ FDTs;\n         dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields pre @ FDTs\n  dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "have \"(D',C) \\<in> (subcls1 P)^+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D', C) \\<in> (subcls1 P)\\<^sup>+", "by (rule rtrancl_into_trancl2[OF step.hyps(1,2)])"], ["proof (state)\nthis:\n  (D', C) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "obtain fs ms where D'_cls: \"class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>\" \"D' \\<noteq> Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         D' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subcls1D[OF step.hyps(1)]"], ["proof (prove)\nusing this:\n  D' \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>;\n         D' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp+"], ["proof (state)\nthis:\n  class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>\n  D' \\<noteq> Object\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "have \"P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre @ FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                                 pre @ FDTs", "using has_fields_rec[OF D'_cls D_flds]"], ["proof (prove)\nusing this:\n  ?FDTs' =\n  map (\\<lambda>(F, b, T). ((F, D'), b, T)) fs @\n  pre @ FDTs \\<Longrightarrow>\n  P \\<turnstile> D' has_fields ?FDTs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                                 pre @ FDTs", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                               pre @ FDTs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "also"], ["proof (state)\nthis:\n  P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                               pre @ FDTs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "have \"dom (map_of (map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre))\n                 \\<inter> dom (map_of FDTs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre)) \\<inter>\n    dom (map_of FDTs) =\n    {}", "using dom subcls_notin_has_fields[OF D_flds, where D=D'] step.hyps(1)"], ["proof (prove)\nusing this:\n  dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n  ((?F, D'), ?b, ?T) \\<in> set (pre @ FDTs) \\<Longrightarrow>\n  (D', D) \\<notin> (subcls1 P)\\<^sup>+\n  P \\<turnstile> D' \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre)) \\<inter>\n    dom (map_of FDTs) =\n    {}", "by(auto simp:dom_map_of_conv_image_fst) fast"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre)) \\<inter>\n  dom (map_of FDTs) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                               pre @ FDTs\n  dom (map_of (map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre)) \\<inter>\n  dom (map_of FDTs) =\n  {}", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                               pre @ FDTs\n  dom (map_of (map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre)) \\<inter>\n  dom (map_of FDTs) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>pre.\n       P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "by(rule_tac x = \"map (\\<lambda>(F,b,T). ((F,D'),b,T)) fs @ pre\" in exI) simp"], ["proof (state)\nthis:\n  \\<exists>pre.\n     P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma has_fields_declaring_classes:\nshows \"P \\<turnstile> C has_fields FDTs\n \\<Longrightarrow> \\<exists>pre FDTs'. FDTs = pre@FDTs'\n         \\<and> (C \\<noteq> Object \\<longrightarrow> (\\<exists>D fs ms. class P C = \\<lfloor>(D,fs,ms)\\<rfloor> \\<and> P \\<turnstile> D has_fields FDTs'))\n             \\<and> set(map (\\<lambda>t. snd(fst t)) pre) \\<subseteq> {C}\n                \\<and> set(map (\\<lambda>t. snd(fst t)) FDTs') \\<subseteq> {C'. C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre FDTs'.\n       FDTs = pre @ FDTs' \\<and>\n       (C \\<noteq> Object \\<longrightarrow>\n        (\\<exists>D fs ms.\n            class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n            P \\<turnstile> D has_fields FDTs')) \\<and>\n       set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {C} \\<and>\n       set (map (\\<lambda>t. snd (fst t)) FDTs')\n       \\<subseteq> {C'.\n                    C' \\<noteq> C \\<and>\n                    P \\<turnstile> C \\<preceq>\\<^sup>* C'}", "proof(induct rule:Fields.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<exists>pre FDTs'.\n           FDTs = pre @ FDTs' \\<and>\n           (D \\<noteq> Object \\<longrightarrow>\n            (\\<exists>Da fs ms.\n                class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n                P \\<turnstile> Da has_fields FDTs')) \\<and>\n           set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n           set (map (\\<lambda>t. snd (fst t)) FDTs')\n           \\<subseteq> {C'.\n                        C' \\<noteq> D \\<and>\n                        P \\<turnstile> D \\<preceq>\\<^sup>* C'};\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'a.\n                            FDTs' = pre @ FDTs'a \\<and>\n                            (C \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P C =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs'a)) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {C} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n                            \\<subseteq> {C'.\n   C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "case (has_fields_rec C D fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<exists>pre FDTs'.\n     FDTs = pre @ FDTs' \\<and>\n     (D \\<noteq> Object \\<longrightarrow>\n      (\\<exists>Da fs ms.\n          class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n          P \\<turnstile> Da has_fields FDTs')) \\<and>\n     set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n     set (map (\\<lambda>t. snd (fst t)) FDTs')\n     \\<subseteq> {C'.\n                  C' \\<noteq> D \\<and>\n                  P \\<turnstile> D \\<preceq>\\<^sup>* C'}\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<exists>pre FDTs'.\n           FDTs = pre @ FDTs' \\<and>\n           (D \\<noteq> Object \\<longrightarrow>\n            (\\<exists>Da fs ms.\n                class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n                P \\<turnstile> Da has_fields FDTs')) \\<and>\n           set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n           set (map (\\<lambda>t. snd (fst t)) FDTs')\n           \\<subseteq> {C'.\n                        C' \\<noteq> D \\<and>\n                        P \\<turnstile> D \\<preceq>\\<^sup>* C'};\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'a.\n                            FDTs' = pre @ FDTs'a \\<and>\n                            (C \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P C =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs'a)) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {C} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n                            \\<subseteq> {C'.\n   C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "have sup1: \"P \\<turnstile> C \\<prec>\\<^sup>1 D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D", "using has_fields_rec.hyps(1,2)"], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D", "by (simp add: subcls1.subcls1I)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<exists>pre FDTs'.\n           FDTs = pre @ FDTs' \\<and>\n           (D \\<noteq> Object \\<longrightarrow>\n            (\\<exists>Da fs ms.\n                class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n                P \\<turnstile> Da has_fields FDTs')) \\<and>\n           set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n           set (map (\\<lambda>t. snd (fst t)) FDTs')\n           \\<subseteq> {C'.\n                        C' \\<noteq> D \\<and>\n                        P \\<turnstile> D \\<preceq>\\<^sup>* C'};\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'a.\n                            FDTs' = pre @ FDTs'a \\<and>\n                            (C \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P C =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs'a)) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {C} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n                            \\<subseteq> {C'.\n   C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "have \"P \\<turnstile> C has_fields FDTs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs'", "using Fields.has_fields_rec[OF has_fields_rec.hyps(1-3)] has_fields_rec"], ["proof (prove)\nusing this:\n  ?FDTs' =\n  map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs \\<Longrightarrow>\n  P \\<turnstile> C has_fields ?FDTs'\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<exists>pre FDTs'.\n     FDTs = pre @ FDTs' \\<and>\n     (D \\<noteq> Object \\<longrightarrow>\n      (\\<exists>Da fs ms.\n          class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n          P \\<turnstile> Da has_fields FDTs')) \\<and>\n     set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n     set (map (\\<lambda>t. snd (fst t)) FDTs')\n     \\<subseteq> {C'.\n                  C' \\<noteq> D \\<and>\n                  P \\<turnstile> D \\<preceq>\\<^sup>* C'}\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs'", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<exists>pre FDTs'.\n           FDTs = pre @ FDTs' \\<and>\n           (D \\<noteq> Object \\<longrightarrow>\n            (\\<exists>Da fs ms.\n                class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n                P \\<turnstile> Da has_fields FDTs')) \\<and>\n           set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n           set (map (\\<lambda>t. snd (fst t)) FDTs')\n           \\<subseteq> {C'.\n                        C' \\<noteq> D \\<and>\n                        P \\<turnstile> D \\<preceq>\\<^sup>* C'};\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'a.\n                            FDTs' = pre @ FDTs'a \\<and>\n                            (C \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P C =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs'a)) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {C} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n                            \\<subseteq> {C'.\n   C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs'", "have nsup: \"(D, C) \\<notin> (subcls1 P)\\<^sup>*\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs'\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>*", "using subcls_notin_has_fields2 sup1"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs'\n  \\<lbrakk>?P \\<turnstile> ?C has_fields ?FDTs; ?C \\<noteq> Object;\n   ?P \\<turnstile> ?C \\<prec>\\<^sup>1 ?D\\<rbrakk>\n  \\<Longrightarrow> (?D, ?C) \\<notin> (subcls1 ?P)\\<^sup>*\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<exists>pre FDTs'.\n           FDTs = pre @ FDTs' \\<and>\n           (D \\<noteq> Object \\<longrightarrow>\n            (\\<exists>Da fs ms.\n                class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n                P \\<turnstile> Da has_fields FDTs')) \\<and>\n           set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n           set (map (\\<lambda>t. snd (fst t)) FDTs')\n           \\<subseteq> {C'.\n                        C' \\<noteq> D \\<and>\n                        P \\<turnstile> D \\<preceq>\\<^sup>* C'};\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'a.\n                            FDTs' = pre @ FDTs'a \\<and>\n                            (C \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P C =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs'a)) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {C} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n                            \\<subseteq> {C'.\n   C' \\<noteq> C \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre FDTs'a.\n       FDTs' = pre @ FDTs'a \\<and>\n       (C \\<noteq> Object \\<longrightarrow>\n        (\\<exists>D fs ms.\n            class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n            P \\<turnstile> D has_fields FDTs'a)) \\<and>\n       set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {C} \\<and>\n       set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n       \\<subseteq> {C'.\n                    C' \\<noteq> C \\<and>\n                    P \\<turnstile> C \\<preceq>\\<^sup>* C'}", "using has_fields_rec sup1 nsup"], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<exists>pre FDTs'.\n     FDTs = pre @ FDTs' \\<and>\n     (D \\<noteq> Object \\<longrightarrow>\n      (\\<exists>Da fs ms.\n          class P D = \\<lfloor>(Da, fs, ms)\\<rfloor> \\<and>\n          P \\<turnstile> Da has_fields FDTs')) \\<and>\n     set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {D} \\<and>\n     set (map (\\<lambda>t. snd (fst t)) FDTs')\n     \\<subseteq> {C'.\n                  C' \\<noteq> D \\<and>\n                  P \\<turnstile> D \\<preceq>\\<^sup>* C'}\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>pre FDTs'a.\n       FDTs' = pre @ FDTs'a \\<and>\n       (C \\<noteq> Object \\<longrightarrow>\n        (\\<exists>D fs ms.\n            class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n            P \\<turnstile> D has_fields FDTs'a)) \\<and>\n       set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {C} \\<and>\n       set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n       \\<subseteq> {C'.\n                    C' \\<noteq> C \\<and>\n                    P \\<turnstile> C \\<preceq>\\<^sup>* C'}", "by(rule_tac x = \"map (\\<lambda>(F, y). ((F, C), y)) fs\" in exI, clarsimp) auto"], ["proof (state)\nthis:\n  \\<exists>pre FDTs'a.\n     FDTs' = pre @ FDTs'a \\<and>\n     (C \\<noteq> Object \\<longrightarrow>\n      (\\<exists>D fs ms.\n          class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n          P \\<turnstile> D has_fields FDTs'a)) \\<and>\n     set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {C} \\<and>\n     set (map (\\<lambda>t. snd (fst t)) FDTs'a)\n     \\<subseteq> {C'.\n                  C' \\<noteq> C \\<and>\n                  P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs_\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre FDTs'.\n                            FDTs = pre @ FDTs' \\<and>\n                            (Object \\<noteq> Object \\<longrightarrow>\n                             (\\<exists>D fs ms.\n                                 class P Object =\n                                 \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n                                 P \\<turnstile> D has_fields FDTs')) \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) pre)\n                            \\<subseteq> {Object} \\<and>\n                            set (map (\\<lambda>t. snd (fst t)) FDTs')\n                            \\<subseteq> {C'.\n   C' \\<noteq> Object \\<and> P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "then"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs_", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs_\n\ngoal (1 subgoal):\n 1. \\<exists>pre FDTs'.\n       FDTs_ = pre @ FDTs' \\<and>\n       (Object \\<noteq> Object \\<longrightarrow>\n        (\\<exists>D fs ms.\n            class P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n            P \\<turnstile> D has_fields FDTs')) \\<and>\n       set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {Object} \\<and>\n       set (map (\\<lambda>t. snd (fst t)) FDTs')\n       \\<subseteq> {C'.\n                    C' \\<noteq> Object \\<and>\n                    P \\<turnstile> Object \\<preceq>\\<^sup>* C'}", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>pre FDTs'.\n     FDTs_ = pre @ FDTs' \\<and>\n     (Object \\<noteq> Object \\<longrightarrow>\n      (\\<exists>D fs ms.\n          class P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n          P \\<turnstile> D has_fields FDTs')) \\<and>\n     set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {Object} \\<and>\n     set (map (\\<lambda>t. snd (fst t)) FDTs')\n     \\<subseteq> {C'.\n                  C' \\<noteq> Object \\<and>\n                  P \\<turnstile> Object \\<preceq>\\<^sup>* C'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_fields_mono_lem2:\nassumes hf: \"P \\<turnstile> C has_fields FDTs\"\n and cls: \"class P C = Some(D,fs,ms)\" and map_of: \"map_of FDTs (F,C) = \\<lfloor>(b,T)\\<rfloor>\"\nshows \"\\<exists>FDTs'. FDTs = (map (\\<lambda>(F,b,T). ((F,C),b,T)) fs) @ FDTs' \\<and> map_of FDTs' (F,C) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>FDTs'.\n       FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n       map_of FDTs' (F, C) = None", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>FDTs'.\n       FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n       map_of FDTs' (F, C) = None", "proof(cases \"C = Object\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "case False"], ["proof (state)\nthis:\n  C \\<noteq> Object\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "let ?pre = \"map (\\<lambda>(F,b,T). ((F,C),b,T)) fs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "have sub: \"P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "using cls False"], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "by (simp add: r_into_rtrancl subcls1.subcls1I)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "obtain FDTs' where fdts': \"P \\<turnstile> D has_fields FDTs'\" \"FDTs = ?pre @ FDTs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>FDTs'.\n        \\<lbrakk>P \\<turnstile> D has_fields FDTs';\n         FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False assms(1,2) Fields.simps[of P C FDTs]"], ["proof (prove)\nusing this:\n  C \\<noteq> Object\n  P \\<turnstile> C has_fields FDTs\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  (P \\<turnstile> C has_fields FDTs) =\n  ((\\<exists>Ca D fs ms FDTsa FDTs'.\n       C = Ca \\<and>\n       FDTs = FDTs' \\<and>\n       class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n       Ca \\<noteq> Object \\<and>\n       P \\<turnstile> D has_fields FDTsa \\<and>\n       FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTsa) \\<or>\n   (\\<exists>D fs ms FDTsa.\n       C = Object \\<and>\n       FDTs = FDTsa \\<and>\n       class P Object = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n       FDTsa = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs))\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs'.\n        \\<lbrakk>P \\<turnstile> D has_fields FDTs';\n         FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields FDTs'\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has_fields FDTs'\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'", "have int: \"dom (map_of ?pre) \\<inter> dom (map_of FDTs') = {}\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs'\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>(F, b, T). ((F, C), b, T)) fs)) \\<inter>\n    dom (map_of FDTs') =\n    {}", "using has_fields_mono_lem[OF sub, of FDTs'] has_fields_fun[OF hf]"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs'\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\n  P \\<turnstile> D has_fields FDTs' \\<Longrightarrow>\n  \\<exists>pre.\n     P \\<turnstile> C has_fields pre @ FDTs' \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs') = {}\n  P \\<turnstile> C has_fields ?FDTs' \\<Longrightarrow> ?FDTs' = FDTs\n\ngoal (1 subgoal):\n 1. dom (map_of (map (\\<lambda>(F, b, T). ((F, C), b, T)) fs)) \\<inter>\n    dom (map_of FDTs') =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  dom (map_of (map (\\<lambda>(F, b, T). ((F, C), b, T)) fs)) \\<inter>\n  dom (map_of FDTs') =\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "have \"C \\<notin> (\\<lambda>t. snd (fst t)) ` set FDTs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<notin> (\\<lambda>t. snd (fst t)) ` set FDTs'", "using has_fields_declaring_classes[OF hf] cls False\n          has_fields_fun[OF fdts'(1)] fdts'(2)"], ["proof (prove)\nusing this:\n  \\<exists>pre FDTs'.\n     FDTs = pre @ FDTs' \\<and>\n     (C \\<noteq> Object \\<longrightarrow>\n      (\\<exists>D fs ms.\n          class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n          P \\<turnstile> D has_fields FDTs')) \\<and>\n     set (map (\\<lambda>t. snd (fst t)) pre) \\<subseteq> {C} \\<and>\n     set (map (\\<lambda>t. snd (fst t)) FDTs')\n     \\<subseteq> {C'.\n                  C' \\<noteq> C \\<and>\n                  P \\<turnstile> C \\<preceq>\\<^sup>* C'}\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields ?FDTs' \\<Longrightarrow> ?FDTs' = FDTs'\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. C \\<notin> (\\<lambda>t. snd (fst t)) ` set FDTs'", "by clarify auto"], ["proof (state)\nthis:\n  C \\<notin> (\\<lambda>t. snd (fst t)) ` set FDTs'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "then"], ["proof (chain)\npicking this:\n  C \\<notin> (\\<lambda>t. snd (fst t)) ` set FDTs'", "have \"map_of FDTs' (F,C) = None\""], ["proof (prove)\nusing this:\n  C \\<notin> (\\<lambda>t. snd (fst t)) ` set FDTs'\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, C) = None", "by(rule map_of_set_pcs_notin)"], ["proof (state)\nthis:\n  map_of FDTs' (F, C) = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "then"], ["proof (chain)\npicking this:\n  map_of FDTs' (F, C) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of FDTs' (F, C) = None\n\ngoal (1 subgoal):\n 1. \\<exists>FDTs'.\n       FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n       map_of FDTs' (F, C) = None", "using fdts' int"], ["proof (prove)\nusing this:\n  map_of FDTs' (F, C) = None\n  P \\<turnstile> D has_fields FDTs'\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs'\n  dom (map_of (map (\\<lambda>(F, b, T). ((F, C), b, T)) fs)) \\<inter>\n  dom (map_of FDTs') =\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>FDTs'.\n       FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n       map_of FDTs' (F, C) = None", "by simp"], ["proof (state)\nthis:\n  \\<exists>FDTs'.\n     FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n     map_of FDTs' (F, C) = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n     map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>; C = Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>FDTs'.\n                         FDTs =\n                         map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @\n                         FDTs' \\<and>\n                         map_of FDTs' (F, C) = None", "qed(auto dest: has_fields_Object has_fields_fun)"], ["", "lemma has_fields_is_class_Object:\n \"P \\<turnstile> D has_fields FDTs \\<Longrightarrow> is_class P Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has_fields FDTs \\<Longrightarrow> is_class P Object", "by(induct rule: Fields.induct; simp add: is_class_def)"], ["", "lemma Object_fields:\n \"\\<lbrakk> P \\<turnstile> Object has_fields FDTs; C \\<noteq> Object \\<rbrakk> \\<Longrightarrow> map_of FDTs (F,C) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Object has_fields FDTs;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> map_of FDTs (F, C) = None", "by(drule Fields.cases, auto simp: map_of_reinsert_neq_None)"], ["", "definition has_field :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> staticb \\<Rightarrow> ty \\<Rightarrow> cname \\<Rightarrow> bool\"\n                   (\"_ \\<turnstile> _ has _,_:_ in _\" [51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C has F,b:T in D  \\<equiv>\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs \\<and> map_of FDTs (F,D) = Some (b,T)\""], ["", "lemma has_field_mono:\nassumes has: \" P \\<turnstile> C has F,b:T in D\" and sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C' has F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "obtain FDTs where FDTs:\"P \\<turnstile> C has_fields FDTs\" and \"map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has F,b:T in D\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: has_field_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "also"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "obtain pre where \"P \\<turnstile> C' has_fields pre @ FDTs\"\n     and \"dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pre.\n        \\<lbrakk>P \\<turnstile> C' has_fields pre @ FDTs;\n         dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_fields_mono_lem[OF sub FDTs]"], ["proof (prove)\nusing this:\n  \\<exists>pre.\n     P \\<turnstile> C' has_fields pre @ FDTs \\<and>\n     dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>pre.\n        \\<lbrakk>P \\<turnstile> C' has_fields pre @ FDTs;\n         dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify"], ["proof (state)\nthis:\n  P \\<turnstile> C' has_fields pre @ FDTs\n  dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n  P \\<turnstile> C' has_fields pre @ FDTs\n  dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n  P \\<turnstile> C' has_fields pre @ FDTs\n  dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,b:T in D", "by(fastforce simp: has_field_def map_add_def split:option.splits)"], ["proof (state)\nthis:\n  P \\<turnstile> C' has F,b:T in D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma has_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C has F,b:T in D; P \\<turnstile> C has F,b':T' in D\\<rbrakk> \\<Longrightarrow> b = b' \\<and> T' = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F,b:T in D;\n     P \\<turnstile> C has F,b':T' in D\\<rbrakk>\n    \\<Longrightarrow> b = b' \\<and> T' = T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F,b:T in D;\n     P \\<turnstile> C has F,b':T' in D\\<rbrakk>\n    \\<Longrightarrow> b = b' \\<and> T' = T", "by(fastforce simp:has_field_def dest:has_fields_fun)"], ["", "(*>*)"], ["", "lemma has_field_idemp:\nassumes has: \"P \\<turnstile> C has F,b:T in D\"\nshows \"P \\<turnstile> D has F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "obtain FDTs where C_flds: \"P \\<turnstile> C has_fields FDTs\"\n     and FDTs: \"map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\" (is \"?FDTs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has F,b:T in D\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: has_field_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "have map: \"\\<And>C' fs. map_of (map (\\<lambda>(F, y). ((F, C'), y)) fs) (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<Longrightarrow> D = C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C' fs.\n       map_of (map (\\<lambda>(F, y). ((F, C'), y)) fs) (F, D) =\n       \\<lfloor>(b, T)\\<rfloor> \\<Longrightarrow>\n       D = C'", "by(frule map_of_SomeD) clarsimp"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>(F, y). ((F, ?C'), y)) ?fs) (F, D) =\n  \\<lfloor>(b, T)\\<rfloor> \\<Longrightarrow>\n  D = ?C'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "have \"?FDTs \\<longrightarrow> P \\<turnstile> D has F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    P \\<turnstile> D has F,b:T in D", "using C_flds"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    P \\<turnstile> D has F,b:T in D", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D has F,b:T in D;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs' (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D", "case NObj: (has_fields_rec C' D' fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D has F,b:T in D;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs' (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D", "then"], ["proof (chain)\npicking this:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs", "show ?case"], ["proof (prove)\nusing this:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    P \\<turnstile> D has F,b:T in D", "using map"], ["proof (prove)\nusing this:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs\n  map_of (map (\\<lambda>(F, y). ((F, ?C'), y)) ?fs) (F, D) =\n  \\<lfloor>(b, T)\\<rfloor> \\<Longrightarrow>\n  D = ?C'\n\ngoal (1 subgoal):\n 1. map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    P \\<turnstile> D has F,b:T in D", "by (fastforce intro: has_fields_rec simp: has_field_def)"], ["proof (state)\nthis:\n  map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D", "case Obj: (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         P \\<turnstile> D has F,b:T in D", "then"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    P \\<turnstile> D has F,b:T in D", "using map"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  map_of (map (\\<lambda>(F, y). ((F, ?C'), y)) ?fs) (F, D) =\n  \\<lfloor>(b, T)\\<rfloor> \\<Longrightarrow>\n  D = ?C'\n\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    P \\<turnstile> D has F,b:T in D", "by(fastforce intro: has_fields_Object simp: has_field_def)"], ["proof (state)\nthis:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "then"], ["proof (chain)\npicking this:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "using FDTs"], ["proof (prove)\nusing this:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  P \\<turnstile> D has F,b:T in D\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,b:T in D", "by(rule_tac mp)"], ["proof (state)\nthis:\n  P \\<turnstile> D has F,b:T in D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma visible_fields_exist:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\" and\n        FDTs:   \"map_of FDTs (F,D) = Some (b, T)\"\nshows \"\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of fs F = Some(b,T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of fs F = \\<lfloor>(b, T)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of fs F = \\<lfloor>(b, T)\\<rfloor>", "have \"map_of FDTs (F,D) = Some (b, T) \\<longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of fs F = Some(b,T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>D' fs ms.\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n        map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "using fields"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>D' fs ms.\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n        map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n        (\\<exists>D' fs ms.\n            class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n            map_of fs F = \\<lfloor>(b, T)\\<rfloor>);\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs' (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "case (has_fields_rec C' D' fs ms FDTs')"], ["proof (state)\nthis:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs'\n  map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n  FDTs'_ = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs'\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n        (\\<exists>D' fs ms.\n            class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n            map_of fs F = \\<lfloor>(b, T)\\<rfloor>);\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs' (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "with assms map_of_reinsert_SomeD map_of_reinsert_neq_None[where D=D and F=F and fs=fs]"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n  map_of (map (\\<lambda>(F, y). ((F, ?D), y)) ?fs) (?F, ?D) =\n  \\<lfloor>?T\\<rfloor> \\<Longrightarrow>\n  map_of ?fs ?F = \\<lfloor>?T\\<rfloor>\n  ?Ca \\<noteq> D \\<Longrightarrow>\n  map_of (map (\\<lambda>(F, y). ((F, ?Ca), y)) fs) (F, D) = None\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs'\n  map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n  FDTs'_ = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs'", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n  map_of (map (\\<lambda>(F, y). ((F, ?D), y)) ?fs) (?F, ?D) =\n  \\<lfloor>?T\\<rfloor> \\<Longrightarrow>\n  map_of ?fs ?F = \\<lfloor>?T\\<rfloor>\n  ?Ca \\<noteq> D \\<Longrightarrow>\n  map_of (map (\\<lambda>(F, y). ((F, ?Ca), y)) fs) (F, D) = None\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs'\n  map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n  FDTs'_ = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs'\n\ngoal (1 subgoal):\n 1. map_of FDTs'_ (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>D' fs ms.\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n        map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "proof(cases \"C' = D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>;\n     \\<And>D fs F T.\n        map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) =\n        \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n     \\<And>Ca.\n        Ca \\<noteq> D \\<Longrightarrow>\n        map_of (map (\\<lambda>(F, y). ((F, Ca), y)) fs) (F, D) = None;\n     class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>; C' \\<noteq> Object;\n     P \\<turnstile> D' has_fields FDTs';\n     map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n     (\\<exists>D' fs ms.\n         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n         map_of fs F = \\<lfloor>(b, T)\\<rfloor>);\n     FDTs'_ = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs';\n     C' = D\\<rbrakk>\n    \\<Longrightarrow> map_of FDTs'_ (F, D) =\n                      \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                      (\\<exists>D' fs ms.\n                          class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                          map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>;\n     \\<And>D fs F T.\n        map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) =\n        \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n     \\<And>Ca.\n        Ca \\<noteq> D \\<Longrightarrow>\n        map_of (map (\\<lambda>(F, y). ((F, Ca), y)) fs) (F, D) = None;\n     class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>; C' \\<noteq> Object;\n     P \\<turnstile> D' has_fields FDTs';\n     map_of FDTs' (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n     (\\<exists>D' fs ms.\n         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n         map_of fs F = \\<lfloor>(b, T)\\<rfloor>);\n     FDTs'_ = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs';\n     C' \\<noteq> D\\<rbrakk>\n    \\<Longrightarrow> map_of FDTs'_ (F, D) =\n                      \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                      (\\<exists>D' fs ms.\n                          class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                          map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "qed auto"], ["proof (state)\nthis:\n  map_of FDTs'_ (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "case (has_fields_Object D' fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of FDTs (F, D) =\n                         \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>D' fs ms.\n                             class P D =\n                             \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                             map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "with assms map_of_reinsert_SomeD map_of_reinsert_neq_None[where D=D and F=F and fs=fs]"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n  map_of (map (\\<lambda>(F, y). ((F, ?D), y)) ?fs) (?F, ?D) =\n  \\<lfloor>?T\\<rfloor> \\<Longrightarrow>\n  map_of ?fs ?F = \\<lfloor>?T\\<rfloor>\n  ?Ca \\<noteq> D \\<Longrightarrow>\n  map_of (map (\\<lambda>(F, y). ((F, ?Ca), y)) fs) (F, D) = None\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n  map_of (map (\\<lambda>(F, y). ((F, ?D), y)) ?fs) (?F, ?D) =\n  \\<lfloor>?T\\<rfloor> \\<Longrightarrow>\n  map_of ?fs ?F = \\<lfloor>?T\\<rfloor>\n  ?Ca \\<noteq> D \\<Longrightarrow>\n  map_of (map (\\<lambda>(F, y). ((F, ?Ca), y)) fs) (F, D) = None\n  class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n\ngoal (1 subgoal):\n 1. map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>D' fs ms.\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n        map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "proof(cases \"Object = D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>;\n     \\<And>D fs F T.\n        map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) =\n        \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n     \\<And>Ca.\n        Ca \\<noteq> D \\<Longrightarrow>\n        map_of (map (\\<lambda>(F, y). ((F, Ca), y)) fs) (F, D) = None;\n     class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n     Object = D\\<rbrakk>\n    \\<Longrightarrow> map_of FDTs (F, D) =\n                      \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                      (\\<exists>D' fs ms.\n                          class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                          map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n 2. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>;\n     \\<And>D fs F T.\n        map_of (map (\\<lambda>(F, y). ((F, D), y)) fs) (F, D) =\n        \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n     \\<And>Ca.\n        Ca \\<noteq> D \\<Longrightarrow>\n        map_of (map (\\<lambda>(F, y). ((F, Ca), y)) fs) (F, D) = None;\n     class P Object = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n     Object \\<noteq> D\\<rbrakk>\n    \\<Longrightarrow> map_of FDTs (F, D) =\n                      \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n                      (\\<exists>D' fs ms.\n                          class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                          map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "qed auto"], ["proof (state)\nthis:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of fs F = \\<lfloor>(b, T)\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of fs F = \\<lfloor>(b, T)\\<rfloor>", "using FDTs"], ["proof (prove)\nusing this:\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>D' fs ms.\n      class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n      map_of fs F = \\<lfloor>(b, T)\\<rfloor>)\n  map_of FDTs (F, D) = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of fs F = \\<lfloor>(b, T)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<exists>D' fs ms.\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n     map_of fs F = \\<lfloor>(b, T)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_remap_SomeD:\n  \"map_of (map (\\<lambda>((k,k'),x). (k,(k',x))) t) k = Some (k',x) \\<Longrightarrow> map_of t (k, k') = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x). (k, k', x)) t) k =\n    \\<lfloor>(k', x)\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>x\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x). (k, k', x)) t) k =\n    \\<lfloor>(k', x)\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>x\\<rfloor>", "by (induct t) (auto simp:fun_upd_apply split: if_split_asm)"], ["", "(*>*)"], ["", "lemma map_of_remap_SomeD2:\n  \"map_of (map (\\<lambda>((k,k'),x,x'). (k,(k',x,x'))) t) k = Some (k',x,x') \\<Longrightarrow> map_of t (k, k') = Some (x, x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x, x'). (k, k', x, x')) t) k =\n    \\<lfloor>(k', x, x')\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>(x, x')\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x, x'). (k, k', x, x')) t) k =\n    \\<lfloor>(k', x, x')\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>(x, x')\\<rfloor>", "by (induct t) (auto simp:fun_upd_apply split: if_split_asm)"], ["", "(*>*)"], ["", "lemma has_field_decl_above:\n  \"P \\<turnstile> C has F,b:T in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(auto simp: has_field_def\n        intro: has_fields_decl_above map_of_SomeD map_of_remap_SomeD2)"], ["", "(*>*)"], ["", "definition sees_field :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> staticb \\<Rightarrow> ty \\<Rightarrow> cname \\<Rightarrow> bool\"\n                  (\"_ \\<turnstile> _ sees _,_:_ in _\" [51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C sees F,b:T in D \\<equiv>\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs \\<and>\n            map_of (map (\\<lambda>((F,D),b,T). (F,(D,b,T))) FDTs) F = Some(D,b,T)\""], ["", "lemma has_visible_field:\n  \"P \\<turnstile> C sees F,b:T in D \\<Longrightarrow> P \\<turnstile> C has F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F,b:T in D \\<Longrightarrow>\n    P \\<turnstile> C has F,b:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F,b:T in D \\<Longrightarrow>\n    P \\<turnstile> C has F,b:T in D", "by(auto simp add:has_field_def sees_field_def map_of_remap_SomeD2)"], ["", "(*>*)"], ["", "lemma sees_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees F,b:T in D; P \\<turnstile> C sees F,b':T' in D'\\<rbrakk> \\<Longrightarrow> b = b' \\<and> T' = T \\<and> D' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F,b:T in D;\n     P \\<turnstile> C sees F,b':T' in D'\\<rbrakk>\n    \\<Longrightarrow> b = b' \\<and> T' = T \\<and> D' = D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F,b:T in D;\n     P \\<turnstile> C sees F,b':T' in D'\\<rbrakk>\n    \\<Longrightarrow> b = b' \\<and> T' = T \\<and> D' = D", "by(fastforce simp:sees_field_def dest:has_fields_fun)"], ["", "(*>*)"], ["", "lemma sees_field_decl_above:\n  \"P \\<turnstile> C sees F,b:T in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F,b:T in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F,b:T in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(auto simp:sees_field_def\n        intro: has_fields_decl_above map_of_SomeD map_of_remap_SomeD2)"], ["", "(*>*)"], ["", "lemma sees_field_idemp:\nassumes sees: \"P \\<turnstile> C sees F,b:T in D\"\nshows \"P \\<turnstile> D sees F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "obtain FDTs where C_flds: \"P \\<turnstile> C has_fields FDTs\"\n     and FDTs: \"map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F = \\<lfloor>(D, b, T)\\<rfloor>\"\n     (is \"?FDTs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n         \\<lfloor>(D, b, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sees"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees F,b:T in D\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n         map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n         \\<lfloor>(D, b, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: sees_field_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(D, b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "have map: \"\\<And>C' fs. map_of (map ((\\<lambda>((F, D), a). (F, D, a)) \\<circ> (\\<lambda>(F, y). ((F, C'), y))) fs) F \n              = \\<lfloor>(D, b, T)\\<rfloor>\n         \\<Longrightarrow> D = C' \\<and> (F, b, T) \\<in> set fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C' fs.\n       map_of\n        (map ((\\<lambda>((F, D), a). (F, D, a)) \\<circ>\n              (\\<lambda>(F, y). ((F, C'), y)))\n          fs)\n        F =\n       \\<lfloor>(D, b, T)\\<rfloor> \\<Longrightarrow>\n       D = C' \\<and> (F, b, T) \\<in> set fs", "by(frule map_of_SomeD) clarsimp\n\\<comment>\\<open> ?FDTs \\<longrightarrow> P \\<turnstile> D sees F,b:T in D \\<close>"], ["proof (state)\nthis:\n  map_of\n   (map ((\\<lambda>((F, D), a). (F, D, a)) \\<circ>\n         (\\<lambda>(F, y). ((F, ?C'), y)))\n     ?fs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<Longrightarrow>\n  D = ?C' \\<and> (F, b, T) \\<in> set ?fs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "have \"?FDTs \\<longrightarrow> (\\<exists>FDTs. P \\<turnstile> D has_fields FDTs\n                           \\<and> map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F = \\<lfloor>(D, b, T)\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>FDTs.\n        P \\<turnstile> D has_fields FDTs \\<and>\n        map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F =\n        \\<lfloor>(D, b, T)\\<rfloor>)", "using C_flds"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>FDTs.\n        P \\<turnstile> D has_fields FDTs \\<and>\n        map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F =\n        \\<lfloor>(D, b, T)\\<rfloor>)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of\n                     (F, D) \\<Rightarrow>\n                       \\<lambda>a.\n                          case a of (b, T) \\<Rightarrow> (F, D, b, T))\n                     b)\n           FDTs)\n         F =\n        \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n        (\\<exists>FDTs.\n            P \\<turnstile> D has_fields FDTs \\<and>\n            map_of\n             (map (\\<lambda>a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a))\n                         b)\n               FDTs)\n             F =\n            \\<lfloor>(D, b, T)\\<rfloor>);\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs')\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs)\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)", "case NObj: (has_fields_rec C' D' fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (F, D) \\<Rightarrow>\n                 \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n               b)\n     FDTs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of\n       (map (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n         FDTs)\n       F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs\n\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of\n                     (F, D) \\<Rightarrow>\n                       \\<lambda>a.\n                          case a of (b, T) \\<Rightarrow> (F, D, b, T))\n                     b)\n           FDTs)\n         F =\n        \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n        (\\<exists>FDTs.\n            P \\<turnstile> D has_fields FDTs \\<and>\n            map_of\n             (map (\\<lambda>a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a))\n                         b)\n               FDTs)\n             F =\n            \\<lfloor>(D, b, T)\\<rfloor>);\n        FDTs' = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs')\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs)\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)", "then"], ["proof (chain)\npicking this:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (F, D) \\<Rightarrow>\n                 \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n               b)\n     FDTs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of\n       (map (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n         FDTs)\n       F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs", "show ?case"], ["proof (prove)\nusing this:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (F, D) \\<Rightarrow>\n                 \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n               b)\n     FDTs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of\n       (map (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n         FDTs)\n       F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>a.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (F, D) \\<Rightarrow>\n                   \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n                 b)\n       FDTs')\n     F =\n    \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>FDTs.\n        P \\<turnstile> D has_fields FDTs \\<and>\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a))\n                     b)\n           FDTs)\n         F =\n        \\<lfloor>(D, b, T)\\<rfloor>)", "using map"], ["proof (prove)\nusing this:\n  class P C' = \\<lfloor>(D', fs, ms)\\<rfloor>\n  C' \\<noteq> Object\n  P \\<turnstile> D' has_fields FDTs\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (F, D) \\<Rightarrow>\n                 \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n               b)\n     FDTs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of\n       (map (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n         FDTs)\n       F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C'), b, T)) fs @ FDTs\n  map_of\n   (map ((\\<lambda>((F, D), a). (F, D, a)) \\<circ>\n         (\\<lambda>(F, y). ((F, ?C'), y)))\n     ?fs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<Longrightarrow>\n  D = ?C' \\<and> (F, b, T) \\<in> set ?fs\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>a.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (F, D) \\<Rightarrow>\n                   \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n                 b)\n       FDTs')\n     F =\n    \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>FDTs.\n        P \\<turnstile> D has_fields FDTs \\<and>\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a))\n                     b)\n           FDTs)\n         F =\n        \\<lfloor>(D, b, T)\\<rfloor>)", "by (fastforce intro: has_fields_rec)"], ["proof (state)\nthis:\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (F, D) \\<Rightarrow>\n                 \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n               b)\n     FDTs')\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of\n       (map (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n         FDTs)\n       F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs)\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs)\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)", "case Obj: (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n\ngoal (1 subgoal):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow>\n  \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\nb)\n                            FDTs)\n                          F =\n                         \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, b, T)\\<rfloor>)", "then"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>a.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (F, D) \\<Rightarrow>\n                   \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n                 b)\n       FDTs)\n     F =\n    \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>FDTs.\n        P \\<turnstile> D has_fields FDTs \\<and>\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a))\n                     b)\n           FDTs)\n         F =\n        \\<lfloor>(D, b, T)\\<rfloor>)", "using map"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  map_of\n   (map ((\\<lambda>((F, D), a). (F, D, a)) \\<circ>\n         (\\<lambda>(F, y). ((F, ?C'), y)))\n     ?fs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<Longrightarrow>\n  D = ?C' \\<and> (F, b, T) \\<in> set ?fs\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>a.\n              case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (F, D) \\<Rightarrow>\n                   \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n                 b)\n       FDTs)\n     F =\n    \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n    (\\<exists>FDTs.\n        P \\<turnstile> D has_fields FDTs \\<and>\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a))\n                     b)\n           FDTs)\n         F =\n        \\<lfloor>(D, b, T)\\<rfloor>)", "by(fastforce intro: has_fields_Object)"], ["proof (state)\nthis:\n  map_of\n   (map (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (F, D) \\<Rightarrow>\n                 \\<lambda>a. case a of (b, T) \\<Rightarrow> (F, D, b, T))\n               b)\n     FDTs)\n   F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of\n       (map (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of (F, D) \\<Rightarrow> \\<lambda>a. (F, D, a)) b)\n         FDTs)\n       F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "then"], ["proof (chain)\npicking this:\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F =\n      \\<lfloor>(D, b, T)\\<rfloor>)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "using FDTs"], ["proof (prove)\nusing this:\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(D, b, T)\\<rfloor> \\<longrightarrow>\n  (\\<exists>FDTs.\n      P \\<turnstile> D has_fields FDTs \\<and>\n      map_of (map (\\<lambda>((F, D), a). (F, D, a)) FDTs) F =\n      \\<lfloor>(D, b, T)\\<rfloor>)\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(D, b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees F,b:T in D", "by (smt map_eq_conv old.prod.case prod_cases3 sees_field_def split_cong)"], ["proof (state)\nthis:\n  P \\<turnstile> D sees F,b:T in D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma has_field_sees_aux:\nassumes hf: \"P \\<turnstile> C has_fields FDTs\" and map: \"map_of FDTs (F, C) = \\<lfloor>(b, T)\\<rfloor>\"\nshows \"map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F = \\<lfloor>(C, b, T)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(C, b, T)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(C, b, T)\\<rfloor>", "obtain D fs ms where fs: \"class P C = Some(D,fs,ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D fs ms.\n        class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using visible_fields_exist[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>D' fs ms.\n     class P C = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n     map_of fs F = \\<lfloor>(b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms.\n        class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(C, b, T)\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain FDTs' where\n     \"FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and> map_of FDTs' (F, C) = None\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs'.\n        FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n        map_of FDTs' (F, C) = None \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using has_fields_mono_lem2[OF hf fs map]"], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  \\<exists>FDTs'.\n     FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n     map_of FDTs' (F, C) = None\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs'.\n        FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n        map_of FDTs' (F, C) = None \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n  map_of FDTs' (F, C) = None\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(C, b, T)\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n  map_of FDTs' (F, C) = None", "show ?thesis"], ["proof (prove)\nusing this:\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n  map_of FDTs' (F, C) = None\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(C, b, T)\\<rfloor>", "using map_of_Some_None_split[OF _ _ map]"], ["proof (prove)\nusing this:\n  FDTs = map (\\<lambda>(F, b, T). ((F, C), b, T)) fs @ FDTs' \\<and>\n  map_of FDTs' (F, C) = None\n  \\<lbrakk>FDTs = map (\\<lambda>(F, y). ((F, C), y)) ?fs @ ?t';\n   map_of ?t' (F, C) = None\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n                    \\<lfloor>(C, b, T)\\<rfloor>\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n    \\<lfloor>(C, b, T)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>((F, D), b, T). (F, D, b, T)) FDTs) F =\n  \\<lfloor>(C, b, T)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_field_sees: \"P \\<turnstile> C has F,b:T in C \\<Longrightarrow> P \\<turnstile> C sees F,b:T in C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in C \\<Longrightarrow>\n    P \\<turnstile> C sees F,b:T in C", "by(auto simp:has_field_def sees_field_def has_field_sees_aux)"], ["", "lemma has_field_is_class:\n \"P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P C", "by (auto simp add: is_class_def has_field_def elim: Fields.induct)"], ["", "(*>*)"], ["", "lemma has_field_is_class':\n \"P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has F,b:T in D \\<Longrightarrow> is_class P D", "by(drule has_field_idemp, rule has_field_is_class, assumption)"], ["", "(*>*)"], ["", "subsection \"Functional lookup\""], ["", "definition \"method\" :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> cname \\<times> staticb \\<times> ty list \\<times> ty \\<times> 'm\"\nwhere\n  \"method P C M \\<equiv>  THE (D,b,Ts,T,m). P \\<turnstile> C sees M,b:Ts \\<rightarrow> T = m in D\""], ["", "definition field  :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> cname \\<times> staticb \\<times> ty\"\nwhere\n  \"field P C F  \\<equiv>  THE (D,b,T). P \\<turnstile> C sees F,b:T in D\""], ["", "definition fields :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> staticb \\<times> ty) list\" \nwhere\n  \"fields P C  \\<equiv>  THE FDTs. P \\<turnstile> C has_fields FDTs\""], ["", "lemma fields_def2 [simp]: \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs", "by (unfold fields_def) (auto dest: has_fields_fun)"], ["", "(*>*)"], ["", "lemma field_def2 [simp]: \"P \\<turnstile> C sees F,b:T in D \\<Longrightarrow> field P C F = (D,b,T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F,b:T in D \\<Longrightarrow>\n    field P C F = (D, b, T)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F,b:T in D \\<Longrightarrow>\n    field P C F = (D, b, T)", "by (unfold field_def) (auto dest: sees_field_fun)"], ["", "(*>*)"], ["", "lemma method_def2 [simp]: \"P \\<turnstile> C sees M,b: Ts\\<rightarrow>T = m in D \\<Longrightarrow> method P C M = (D,b,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method P C M = (D, b, Ts, T, m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method P C M = (D, b, Ts, T, m)", "by (unfold method_def) (auto dest: sees_method_fun)"], ["", "(*>*)"], ["", "text \\<open> The following are the fields for initializing an object (non-static fields)\n and a class (just that class's static fields), respectively. \\<close>"], ["", "definition ifields :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> staticb \\<times> ty) list\" \nwhere\n  \"ifields P C  \\<equiv>  filter (\\<lambda>((F,D),b,T). b = NonStatic) (fields P C)\""], ["", "definition isfields :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> staticb \\<times> ty) list\" \nwhere\n  \"isfields P C  \\<equiv>  filter (\\<lambda>((F,D),b,T). b = Static \\<and> D = C) (fields P C)\""], ["", "lemma ifields_def2[simp]: \"\\<lbrakk> P \\<turnstile> C has_fields FDTs \\<rbrakk> \\<Longrightarrow> ifields P C = filter (\\<lambda>((F,D),b,T). b = NonStatic) FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    ifields P C = filter (\\<lambda>((F, D), b, T). b = NonStatic) FDTs", "by (simp add: ifields_def)"], ["", "lemma isfields_def2[simp]: \"\\<lbrakk> P \\<turnstile> C has_fields FDTs \\<rbrakk> \\<Longrightarrow> isfields P C = filter (\\<lambda>((F,D),b,T). b = Static \\<and> D = C) FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    isfields P C =\n    filter (\\<lambda>((F, D), b, T). b = Static \\<and> D = C) FDTs", "by (simp add: isfields_def)"], ["", "lemma ifields_def3: \"\\<lbrakk> P \\<turnstile> C sees F,b:T in D; b = NonStatic \\<rbrakk> \\<Longrightarrow> (((F,D),b,T) \\<in> set (ifields P C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F,b:T in D; b = NonStatic\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set (ifields P C)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F,b:T in D; b = NonStatic\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set (ifields P C)", "by (unfold ifields_def) (auto simp: sees_field_def map_of_SomeD map_of_remap_SomeD2)"], ["", "(*>*)"], ["", "lemma isfields_def3: \"\\<lbrakk> P \\<turnstile> C sees F,b:T in D; b = Static; D = C \\<rbrakk> \\<Longrightarrow> (((F,D),b,T) \\<in> set (isfields P C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F,b:T in D; b = Static; D = C\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set (isfields P C)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F,b:T in D; b = Static; D = C\\<rbrakk>\n    \\<Longrightarrow> ((F, D), b, T) \\<in> set (isfields P C)", "by (unfold isfields_def) (auto simp: sees_field_def map_of_SomeD map_of_remap_SomeD2)"], ["", "(*>*)"], ["", "definition seeing_class :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> cname option\" where\n\"seeing_class P C M =\n  (if \\<exists>Ts T m D. P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = m in D\n then Some (fst(method P C M))\n else None)\""], ["", "lemma seeing_class_def2[simp]:\n \"P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = m in D \\<Longrightarrow> seeing_class P C M = Some D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    seeing_class P C M = \\<lfloor>D\\<rfloor>", "by(fastforce simp: seeing_class_def)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}