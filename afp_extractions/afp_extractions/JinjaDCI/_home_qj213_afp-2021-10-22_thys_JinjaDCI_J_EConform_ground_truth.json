{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/J/EConform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma cons_to_append: \"list \\<noteq> [] \\<longrightarrow> (\\<exists>ls. a # list = ls @ [last list])\"", "lemma icheck_init_class: \"icheck P C e \\<Longrightarrow> init_class P e = \\<lfloor>C\\<rfloor>\"", "lemmas ss_exp_ss_exps_induct = ss_exp_ss_exps.induct\n [ case_names New Cast Val BinOp Var LAss FAcc SFAcc FAss SFAss Call SCall\n  Block Seq Cond While Throw Try Init RI Nil Cons ]", "lemma icheck_ss_exp:\nassumes \"icheck P C e\" shows \"ss_exp e = e\"", "lemma ss_exps_Vals_None[simp]:\n \"ss_exps (map Val vs) = None\"", "lemma ss_exps_Vals_NoneI:\n \"ss_exps es = None \\<Longrightarrow> \\<exists>vs. es = map Val vs\"", "lemma ss_exps_throw_nVal:\n \"\\<lbrakk> val_of e = None; ss_exps (map Val vs @ throw e # es') = \\<lfloor>e'\\<rfloor> \\<rbrakk>\n   \\<Longrightarrow> e' = ss_exp e\"", "lemma ss_exps_throw_Val:\n \"\\<lbrakk> val_of e = \\<lfloor>a\\<rfloor>; ss_exps (map Val vs @ throw e # es') = \\<lfloor>e'\\<rfloor> \\<rbrakk>\n   \\<Longrightarrow> e' = throw e\"", "lemma icheck_curr_init': \"\\<And>e'. ss_exp e = e' \\<Longrightarrow> icheck P C e' \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\"\n and icheck_curr_inits': \"\\<And>e. ss_exps es = \\<lfloor>e\\<rfloor> \\<Longrightarrow> icheck P C e \\<Longrightarrow> curr_inits P es = \\<lfloor>C\\<rfloor>\"", "lemma icheck_curr_init: \"icheck P C e' \\<Longrightarrow> ss_exp e = e' \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\"", "lemma icheck_curr_inits: \"icheck P C e \\<Longrightarrow> ss_exps es = \\<lfloor>e\\<rfloor> \\<Longrightarrow> curr_inits P es = \\<lfloor>C\\<rfloor>\"", "lemma iconfs_map_throw: \"iconfs sh (map Val vs @ throw e # es') \\<Longrightarrow> iconf sh e\"", "lemma nsub_RI_iconf_aux:\n \"(\\<not>sub_RI (e::'a exp) \\<longrightarrow> (\\<forall>e'. e' \\<in> subexp e \\<longrightarrow> \\<not>sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow> iconf sh e)\n \\<and> (\\<not>sub_RIs (es::'a exp list) \\<longrightarrow> (\\<forall>e'. e' \\<in> subexps es \\<longrightarrow> \\<not>sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow> iconfs sh es)\"", "lemma nsub_RI_iconf_aux':\n \"(\\<And>e'. subexp_of e' e \\<Longrightarrow> \\<not>sub_RI e' \\<longrightarrow> iconf sh e') \\<Longrightarrow> (\\<not>sub_RI e \\<Longrightarrow> iconf sh e)\"", "lemma nsub_RI_iconf: \"\\<not>sub_RI e \\<Longrightarrow> iconf sh e\"", "lemma nsub_RIs_iconfs: \"\\<not>sub_RIs es \\<Longrightarrow> iconfs sh es\"", "lemma lass_val_of_iconf: \"lass_val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow> iconf sh e\"", "lemma icheck_iconf:\nassumes \"icheck P C e\" shows \"iconf sh e\"", "lemma bconf_nonVal[simp]:\n \"P,sh \\<turnstile>\\<^sub>b (e,True) \\<surd> \\<Longrightarrow> val_of e = None\"", "lemma bconfs_nonVals[simp]:\n \"P,sh \\<turnstile>\\<^sub>b (es,True) \\<surd> \\<Longrightarrow> map_vals_of es = None\"", "lemma bconf_Cast[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (Cast C e,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\"", "lemma bconf_BinOp[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e1 \\<guillemotleft>bop\\<guillemotright> e2,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e1 of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>)\"", "lemma bconf_LAss[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (LAss V e,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\"", "lemma bconf_FAcc[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e\\<bullet>F{D},b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\"", "lemma bconf_FAss[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (FAss e1 F D e2,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e1 of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>)\"", "lemma bconf_SFAss[iff]:\n\"val_of e2 = None \\<Longrightarrow> P,sh \\<turnstile>\\<^sub>b (SFAss C F D e2,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\"", "lemma bconfs_Vals[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (map Val vs, b) \\<surd> \\<longleftrightarrow> \\<not> b\"", "lemma bconf_Call[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>\n   \\<longleftrightarrow> (case val_of e of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)\"", "lemma bconf_SCall[iff]:\nassumes mvn: \"map_vals_of es = None\"\nshows \"P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>\"", "lemma bconf_Cons[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e#es,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)\"", "lemma bconf_InitBlock[iff]:\n \"P,sh \\<turnstile>\\<^sub>b ({V:T; V:=Val v;; e\\<^sub>2},b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e\\<^sub>2,b) \\<surd>\"", "lemma bconf_Block[iff]:\n \"P,sh \\<turnstile>\\<^sub>b ({V:T; e},b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\"", "lemma bconf_Seq[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e1;;e2,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e1 of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\n                             | _ \\<Rightarrow> (case lass_val_of e1 of Some p \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\n                                                          | None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>))\"", "lemma bconf_Cond[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (if (b) e\\<^sub>1 else e\\<^sub>2,b') \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (b,b') \\<surd>\"", "lemma bconf_While[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (while (b) e,b') \\<surd> \\<longleftrightarrow> \\<not>b'\"", "lemma bconf_Throw[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (throw e,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\"", "lemma bconf_Try[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (try e\\<^sub>1 catch(C V) e\\<^sub>2,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e\\<^sub>1,b) \\<surd>\"", "lemma bconf_INIT[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (INIT C (Cs,b') \\<leftarrow> e,b) \\<surd> \\<longleftrightarrow> \\<not>b\"", "lemma bconf_RI[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (RI(C,e);Cs \\<leftarrow> e',b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\"", "lemma bconfs_map_throw[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (map Val vs @ throw e # es',b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], "translations": [["", "lemma cons_to_append: \"list \\<noteq> [] \\<longrightarrow> (\\<exists>ls. a # list = ls @ [last list])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list \\<noteq> [] \\<longrightarrow>\n    (\\<exists>ls. a # list = ls @ [last list])", "by (metis append_butlast_last_id last_ConsR list.simps(3))"], ["", "subsection \"Initialization conformance\"\n\n\\<comment> \\<open> returns class that can be initialized (if any) by top-level expression \\<close>"], ["", "fun init_class :: \"'m prog \\<Rightarrow> 'a exp \\<Rightarrow> cname option\" where\n\"init_class P (new C) = Some C\" |\n\"init_class P (C\\<bullet>\\<^sub>sF{D}) = Some D\" |\n\"init_class P (C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2) = Some D\" |\n\"init_class P (C\\<bullet>\\<^sub>sM(es)) = seeing_class P C M\" |\n\"init_class _ _ = None\""], ["", "lemma icheck_init_class: \"icheck P C e \\<Longrightarrow> init_class P e = \\<lfloor>C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. icheck P C e \\<Longrightarrow> init_class P e = \\<lfloor>C\\<rfloor>", "apply(induct e, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3a e.\n       \\<lbrakk>icheck P C e \\<Longrightarrow>\n                init_class P e = \\<lfloor>C\\<rfloor>;\n        icheck P C (x1a\\<bullet>\\<^sub>sx2{x3a} := e)\\<rbrakk>\n       \\<Longrightarrow> x3a = C", "apply(rename_tac x1 x2 x3 x4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>icheck P C x4 \\<Longrightarrow>\n                init_class P x4 = \\<lfloor>C\\<rfloor>;\n        icheck P C (x1\\<bullet>\\<^sub>sx2{x3} := x4)\\<rbrakk>\n       \\<Longrightarrow> x3 = C", "apply(case_tac x4, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open> exp to take next small step (in particular, subexp that may contain initialization) \\<close>"], ["", "fun ss_exp :: \"'a exp \\<Rightarrow> 'a exp\" and ss_exps :: \"'a exp list \\<Rightarrow> 'a exp option\" where\n  \"ss_exp (new C) = new C\"\n| \"ss_exp (Cast C e) = (case val_of e of Some v \\<Rightarrow> Cast C e | _ \\<Rightarrow> ss_exp e)\"\n| \"ss_exp (Val v) = Val v\"\n| \"ss_exp (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> (case val_of e\\<^sub>2 of Some v \\<Rightarrow> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 | _ \\<Rightarrow> ss_exp e\\<^sub>2)\n                                    | _ \\<Rightarrow> ss_exp e\\<^sub>1)\"\n| \"ss_exp (Var V) = Var V\"\n| \"ss_exp (LAss V e) = (case val_of e of Some v \\<Rightarrow> LAss V e | _ \\<Rightarrow> ss_exp e)\"\n| \"ss_exp (e\\<bullet>F{D}) = (case val_of e of Some v \\<Rightarrow> e\\<bullet>F{D} | _ \\<Rightarrow> ss_exp e)\"\n| \"ss_exp (C\\<bullet>\\<^sub>sF{D}) = C\\<bullet>\\<^sub>sF{D}\"\n| \"ss_exp (e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> (case val_of e\\<^sub>2 of Some v \\<Rightarrow> e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2 | _ \\<Rightarrow> ss_exp e\\<^sub>2)\n                                    | _ \\<Rightarrow> ss_exp e\\<^sub>1)\"\n| \"ss_exp (C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2) = (case val_of e\\<^sub>2 of Some v \\<Rightarrow> C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2 | _ \\<Rightarrow> ss_exp e\\<^sub>2)\"\n| \"ss_exp (e\\<bullet>M(es)) = (case val_of e of Some v \\<Rightarrow> (case map_vals_of es of Some t \\<Rightarrow> e\\<bullet>M(es) | _ \\<Rightarrow> the(ss_exps es))\n                                    | _ \\<Rightarrow> ss_exp e)\"\n| \"ss_exp (C\\<bullet>\\<^sub>sM(es)) = (case map_vals_of es of Some t \\<Rightarrow> C\\<bullet>\\<^sub>sM(es) | _ \\<Rightarrow> the(ss_exps es))\"\n| \"ss_exp ({V:T; e}) = ss_exp e\"\n| \"ss_exp (e\\<^sub>1;;e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> ss_exp e\\<^sub>2\n           | None \\<Rightarrow> (case lass_val_of e\\<^sub>1 of Some p \\<Rightarrow> ss_exp e\\<^sub>2\n                                           | None \\<Rightarrow> ss_exp e\\<^sub>1))\"\n| \"ss_exp (if (b) e\\<^sub>1 else e\\<^sub>2) = (case bool_of b of Some True \\<Rightarrow> if (b) e\\<^sub>1 else e\\<^sub>2\n                                        | Some False \\<Rightarrow> if (b) e\\<^sub>1 else e\\<^sub>2\n                                        | _ \\<Rightarrow> ss_exp b)\"\n| \"ss_exp (while (b) e) = while (b) e\"\n| \"ss_exp (throw e) = (case val_of e of Some v \\<Rightarrow> throw e | _ \\<Rightarrow> ss_exp e)\"\n| \"ss_exp (try e\\<^sub>1 catch(C V) e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> try e\\<^sub>1 catch(C V) e\\<^sub>2\n                                            | _ \\<Rightarrow> ss_exp e\\<^sub>1)\"\n| \"ss_exp (INIT C (Cs,b) \\<leftarrow> e) = INIT C (Cs,b) \\<leftarrow> e\"\n| \"ss_exp (RI (C,e);Cs \\<leftarrow> e') = (case val_of e of Some v \\<Rightarrow> RI (C,e);Cs \\<leftarrow> e | _ \\<Rightarrow> ss_exp e)\"\n| \"ss_exps([]) = None\"\n| \"ss_exps(e#es) = (case val_of e of Some v \\<Rightarrow> ss_exps es | _ \\<Rightarrow> Some (ss_exp e))\""], ["", "(*<*)"], ["", "lemmas ss_exp_ss_exps_induct = ss_exp_ss_exps.induct\n [ case_names New Cast Val BinOp Var LAss FAcc SFAcc FAss SFAss Call SCall\n  Block Seq Cond While Throw Try Init RI Nil Cons ]"], ["", "(*>*)"], ["", "lemma icheck_ss_exp:\nassumes \"icheck P C e\" shows \"ss_exp e = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss_exp e = e", "using assms"], ["proof (prove)\nusing this:\n  icheck P C e\n\ngoal (1 subgoal):\n 1. ss_exp e = e", "proof(cases e)"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 10. \\<And>x101 x102 x103 x104.\n        \\<lbrakk>icheck P C e;\n         e = x101\\<bullet>\\<^sub>sx102{x103} := x104\\<rbrakk>\n        \\<Longrightarrow> ss_exp e = e\nA total of 20 subgoals...", "case (SFAss C F D e)"], ["proof (state)\nthis:\n  e = C\\<bullet>\\<^sub>sF{D} := e\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 10. \\<And>x101 x102 x103 x104.\n        \\<lbrakk>icheck P C e;\n         e = x101\\<bullet>\\<^sub>sx102{x103} := x104\\<rbrakk>\n        \\<Longrightarrow> ss_exp e = e\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  e = C\\<bullet>\\<^sub>sF{D} := e", "show ?thesis"], ["proof (prove)\nusing this:\n  e = C\\<bullet>\\<^sub>sF{D} := e\n\ngoal (1 subgoal):\n 1. ss_exp e = e", "using assms"], ["proof (prove)\nusing this:\n  e = C\\<bullet>\\<^sub>sF{D} := e\n  icheck P C e\n\ngoal (1 subgoal):\n 1. ss_exp e = e", "proof(cases e)"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = new x1\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 2. \\<And>x21 x22.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 3. \\<And>x3.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = Val x3\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 5. \\<And>x5.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = Var x5\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 6. \\<And>x61 x62.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 10. \\<And>x101 x102 x103 x104.\n        \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n         e = x101\\<bullet>\\<^sub>sx102{x103} := x104\\<rbrakk>\n        \\<Longrightarrow> ss_exp e = e\nA total of 20 subgoals...", "qed(auto)"], ["proof (state)\nthis:\n  ss_exp e = e\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> ss_exp e = e\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>icheck P C e; e = x111\\<bullet>x112(x113)\\<rbrakk>\n        \\<Longrightarrow> ss_exp e = e\nA total of 19 subgoals...", "qed(auto)"], ["", "lemma ss_exps_Vals_None[simp]:\n \"ss_exps (map Val vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss_exps (map Val vs) = None", "by(induct vs, auto)"], ["", "lemma ss_exps_Vals_NoneI:\n \"ss_exps es = None \\<Longrightarrow> \\<exists>vs. es = map Val vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss_exps es = None \\<Longrightarrow> \\<exists>vs. es = map Val vs", "using val_of_spec"], ["proof (prove)\nusing this:\n  val_of ?e = \\<lfloor>?v\\<rfloor> \\<Longrightarrow> ?e = Val ?v\n\ngoal (1 subgoal):\n 1. ss_exps es = None \\<Longrightarrow> \\<exists>vs. es = map Val vs", "by(induct es, auto)"], ["", "lemma ss_exps_throw_nVal:\n \"\\<lbrakk> val_of e = None; ss_exps (map Val vs @ throw e # es') = \\<lfloor>e'\\<rfloor> \\<rbrakk>\n   \\<Longrightarrow> e' = ss_exp e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>val_of e = None;\n     ss_exps (map Val vs @ throw e # es') = \\<lfloor>e'\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> e' = ss_exp e", "by(induct vs, auto)"], ["", "lemma ss_exps_throw_Val:\n \"\\<lbrakk> val_of e = \\<lfloor>a\\<rfloor>; ss_exps (map Val vs @ throw e # es') = \\<lfloor>e'\\<rfloor> \\<rbrakk>\n   \\<Longrightarrow> e' = throw e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>val_of e = \\<lfloor>a\\<rfloor>;\n     ss_exps (map Val vs @ throw e # es') = \\<lfloor>e'\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> e' = throw e", "by(induct vs, auto)"], ["", "abbreviation curr_init :: \"'m prog \\<Rightarrow> 'a exp \\<Rightarrow> cname option\" where\n\"curr_init P e \\<equiv> init_class P (ss_exp e)\""], ["", "abbreviation curr_inits :: \"'m prog \\<Rightarrow> 'a exp list \\<Rightarrow> cname option\" where\n\"curr_inits P es \\<equiv> case ss_exps es of Some e \\<Rightarrow> init_class P e | _ \\<Rightarrow> None\""], ["", "lemma icheck_curr_init': \"\\<And>e'. ss_exp e = e' \\<Longrightarrow> icheck P C e' \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\"\n and icheck_curr_inits': \"\\<And>e. ss_exps es = \\<lfloor>e\\<rfloor> \\<Longrightarrow> icheck P C e \\<Longrightarrow> curr_inits P es = \\<lfloor>C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>ss_exp e = e'; icheck P C e'\\<rbrakk>\n        \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>) &&&\n    (\\<And>e.\n        \\<lbrakk>ss_exps es = \\<lfloor>e\\<rfloor>; icheck P C e\\<rbrakk>\n        \\<Longrightarrow> curr_inits P es = \\<lfloor>C\\<rfloor>)", "proof(induct rule: ss_exp_ss_exps_induct)"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>Ca e'.\n       \\<lbrakk>ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 2. \\<And>Ca ea e'.\n       \\<lbrakk>\\<And>e'.\n                   \\<lbrakk>val_of ea = None; ss_exp e = e';\n                    icheck P C e'\\<rbrakk>\n                   \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 3. \\<And>v e'.\n       \\<lbrakk>ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 4. \\<And>e\\<^sub>1 bop e\\<^sub>2 e'.\n       \\<lbrakk>\\<And>e'.\n                   \\<lbrakk>val_of e\\<^sub>1 = None; ss_exp e = e';\n                    icheck P C e'\\<rbrakk>\n                   \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        \\<And>x2 e'.\n           \\<lbrakk>val_of e\\<^sub>1 = \\<lfloor>x2\\<rfloor>;\n            val_of e\\<^sub>2 = None; ss_exp e = e'; icheck P C e'\\<rbrakk>\n           \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 5. \\<And>V e'.\n       \\<lbrakk>ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 6. \\<And>V ea e'.\n       \\<lbrakk>\\<And>e'.\n                   \\<lbrakk>val_of ea = None; ss_exp e = e';\n                    icheck P C e'\\<rbrakk>\n                   \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 7. \\<And>ea F D e'.\n       \\<lbrakk>\\<And>e'.\n                   \\<lbrakk>val_of ea = None; ss_exp e = e';\n                    icheck P C e'\\<rbrakk>\n                   \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 8. \\<And>Ca F D e'.\n       \\<lbrakk>ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 9. \\<And>e\\<^sub>1 F D e\\<^sub>2 e'.\n       \\<lbrakk>\\<And>e'.\n                   \\<lbrakk>val_of e\\<^sub>1 = None; ss_exp e = e';\n                    icheck P C e'\\<rbrakk>\n                   \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        \\<And>x2 e'.\n           \\<lbrakk>val_of e\\<^sub>1 = \\<lfloor>x2\\<rfloor>;\n            val_of e\\<^sub>2 = None; ss_exp e = e'; icheck P C e'\\<rbrakk>\n           \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n        ss_exp e = e'; icheck P C e'\\<rbrakk>\n       \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\n 10. \\<And>Ca F D e\\<^sub>2 e'.\n        \\<lbrakk>\\<And>e'.\n                    \\<lbrakk>val_of e\\<^sub>2 = None; ss_exp e = e';\n                     icheck P C e'\\<rbrakk>\n                    \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>;\n         ss_exp e = e'; icheck P C e'\\<rbrakk>\n        \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\nA total of 22 subgoals...", "qed(simp_all add: icheck_init_class)"], ["", "lemma icheck_curr_init: \"icheck P C e' \\<Longrightarrow> ss_exp e = e' \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>icheck P C e'; ss_exp e = e'\\<rbrakk>\n    \\<Longrightarrow> curr_init P e = \\<lfloor>C\\<rfloor>", "by(rule icheck_curr_init')"], ["", "lemma icheck_curr_inits: \"icheck P C e \\<Longrightarrow> ss_exps es = \\<lfloor>e\\<rfloor> \\<Longrightarrow> curr_inits P es = \\<lfloor>C\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>icheck P C e; ss_exps es = \\<lfloor>e\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> curr_inits P es = \\<lfloor>C\\<rfloor>", "by(rule icheck_curr_inits')"], ["", "definition initPD :: \"sheap \\<Rightarrow> cname \\<Rightarrow> bool\" where\n\"initPD sh C \\<equiv> \\<exists>sfs i. sh C = Some (sfs, i) \\<and> (i = Done \\<or> i = Processing)\"\n\n\\<comment> \\<open> checks that @{text INIT} and @{text RI} conform and are only in the main computation \\<close>"], ["", "fun iconf :: \"sheap \\<Rightarrow> 'a exp \\<Rightarrow> bool\" and iconfs :: \" sheap \\<Rightarrow> 'a exp list \\<Rightarrow> bool\" where\n  \"iconf sh (new C) = True\"\n| \"iconf sh (Cast C e) = iconf sh e\"\n| \"iconf sh (Val v) = True\"\n| \"iconf sh (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> iconf sh e\\<^sub>2 | _ \\<Rightarrow> iconf sh e\\<^sub>1 \\<and> \\<not>sub_RI e\\<^sub>2)\"\n| \"iconf sh (Var V) = True\"\n| \"iconf sh (LAss V e) = iconf sh e\"\n| \"iconf sh (e\\<bullet>F{D}) = iconf sh e\"\n| \"iconf sh (C\\<bullet>\\<^sub>sF{D}) = True\"\n| \"iconf sh (e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> iconf sh e\\<^sub>2 | _ \\<Rightarrow> iconf sh e\\<^sub>1 \\<and> \\<not>sub_RI e\\<^sub>2)\"\n| \"iconf sh (C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2) = iconf sh e\\<^sub>2\"\n| \"iconf sh (e\\<bullet>M(es)) = (case val_of e of Some v \\<Rightarrow> iconfs sh es | _ \\<Rightarrow> iconf sh e \\<and> \\<not>sub_RIs es)\"\n| \"iconf sh (C\\<bullet>\\<^sub>sM(es)) = iconfs sh es\"\n| \"iconf sh ({V:T; e}) = iconf sh e\"\n| \"iconf sh (e\\<^sub>1;;e\\<^sub>2) = (case val_of e\\<^sub>1 of Some v \\<Rightarrow> iconf sh e\\<^sub>2\n           | None \\<Rightarrow> (case lass_val_of e\\<^sub>1 of Some p \\<Rightarrow> iconf sh e\\<^sub>2\n                                           | None \\<Rightarrow> iconf sh e\\<^sub>1 \\<and> \\<not>sub_RI e\\<^sub>2))\"\n| \"iconf sh (if (b) e\\<^sub>1 else e\\<^sub>2) = (iconf sh b \\<and> \\<not>sub_RI e\\<^sub>1 \\<and> \\<not>sub_RI e\\<^sub>2)\"\n| \"iconf sh (while (b) e) = (\\<not>sub_RI b \\<and> \\<not>sub_RI e)\"\n| \"iconf sh (throw e) = iconf sh e\"\n| \"iconf sh (try e\\<^sub>1 catch(C V) e\\<^sub>2) = (iconf sh e\\<^sub>1 \\<and> \\<not>sub_RI e\\<^sub>2)\"\n| \"iconf sh (INIT C (Cs,b) \\<leftarrow> e) = ((case Cs of Nil \\<Rightarrow> initPD sh C | C'#Cs' \\<Rightarrow> last Cs = C) \\<and> \\<not>sub_RI e)\"\n| \"iconf sh (RI (C,e);Cs \\<leftarrow> e') = (iconf sh e \\<and> \\<not>sub_RI e')\"\n| \"iconfs sh ([]) = True\"\n| \"iconfs sh (e#es) = (case val_of e of Some v \\<Rightarrow> iconfs sh es | _ \\<Rightarrow> iconf sh e \\<and> \\<not>sub_RIs es)\""], ["", "lemma iconfs_map_throw: \"iconfs sh (map Val vs @ throw e # es') \\<Longrightarrow> iconf sh e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iconfs sh (map Val vs @ throw e # es') \\<Longrightarrow> iconf sh e", "by(induct vs,auto)"], ["", "lemma nsub_RI_iconf_aux:\n \"(\\<not>sub_RI (e::'a exp) \\<longrightarrow> (\\<forall>e'. e' \\<in> subexp e \\<longrightarrow> \\<not>sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow> iconf sh e)\n \\<and> (\\<not>sub_RIs (es::'a exp list) \\<longrightarrow> (\\<forall>e'. e' \\<in> subexps es \\<longrightarrow> \\<not>sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow> iconfs sh es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> sub_RI e \\<longrightarrow>\n     (\\<forall>e'.\n         subexp_of e' e \\<longrightarrow>\n         \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n     iconf sh e) \\<and>\n    (\\<not> sub_RIs es \\<longrightarrow>\n     (\\<forall>e'.\n         e' \\<in> subexps es \\<longrightarrow>\n         \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n     iconfs sh es)", "proof(induct rule: sub_RI_sub_RIs.induct)"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>x.\n       \\<not> sub_RI (new x) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (new x) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (new x)\n 2. \\<And>x1 x2.\n       \\<not> sub_RI x2 \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' x2 \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh x2 \\<Longrightarrow>\n       \\<not> sub_RI (Cast x1 x2) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (Cast x1 x2) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (Cast x1 x2)\n 3. \\<And>x.\n       \\<not> sub_RI (Val x) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (Val x) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (Val x)\n 4. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<not> sub_RI x1 \\<longrightarrow>\n                (\\<forall>e'.\n                    subexp_of e' x1 \\<longrightarrow>\n                    \\<not> sub_RI e' \\<longrightarrow>\n                    iconf sh e') \\<longrightarrow>\n                iconf sh x1;\n        \\<not> sub_RI x3 \\<longrightarrow>\n        (\\<forall>e'.\n            subexp_of e' x3 \\<longrightarrow>\n            \\<not> sub_RI e' \\<longrightarrow>\n            iconf sh e') \\<longrightarrow>\n        iconf sh x3\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI\n                                 (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<longrightarrow>\n                         (\\<forall>e'.\n                             subexp_of e'\n                              (x1 \\<guillemotleft>x2\\<guillemotright> x3) \\<longrightarrow>\n                             \\<not> sub_RI e' \\<longrightarrow>\n                             iconf sh e') \\<longrightarrow>\n                         iconf sh\n                          (x1 \\<guillemotleft>x2\\<guillemotright> x3)\n 5. \\<And>x.\n       \\<not> sub_RI (Var x) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (Var x) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (Var x)\n 6. \\<And>x1 x2.\n       \\<not> sub_RI x2 \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' x2 \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh x2 \\<Longrightarrow>\n       \\<not> sub_RI (x1:=x2) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (x1:=x2) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (x1:=x2)\n 7. \\<And>x1 x2 x3.\n       \\<not> sub_RI x1 \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' x1 \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh x1 \\<Longrightarrow>\n       \\<not> sub_RI (x1\\<bullet>x2{x3}) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (x1\\<bullet>x2{x3}) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (x1\\<bullet>x2{x3})\n 8. \\<And>x1 x2 x3.\n       \\<not> sub_RI (x1\\<bullet>\\<^sub>sx2{x3}) \\<longrightarrow>\n       (\\<forall>e'.\n           subexp_of e' (x1\\<bullet>\\<^sub>sx2{x3}) \\<longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<longrightarrow>\n       iconf sh (x1\\<bullet>\\<^sub>sx2{x3})\n 9. \\<And>x1 x2 x3 x4.\n       \\<lbrakk>\\<not> sub_RI x1 \\<longrightarrow>\n                (\\<forall>e'.\n                    subexp_of e' x1 \\<longrightarrow>\n                    \\<not> sub_RI e' \\<longrightarrow>\n                    iconf sh e') \\<longrightarrow>\n                iconf sh x1;\n        \\<not> sub_RI x4 \\<longrightarrow>\n        (\\<forall>e'.\n            subexp_of e' x4 \\<longrightarrow>\n            \\<not> sub_RI e' \\<longrightarrow>\n            iconf sh e') \\<longrightarrow>\n        iconf sh x4\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI\n                                 (x1\\<bullet>x2{x3} := x4) \\<longrightarrow>\n                         (\\<forall>e'.\n                             subexp_of e'\n                              (x1\\<bullet>x2{x3} := x4) \\<longrightarrow>\n                             \\<not> sub_RI e' \\<longrightarrow>\n                             iconf sh e') \\<longrightarrow>\n                         iconf sh (x1\\<bullet>x2{x3} := x4)\n 10. \\<And>x1 x2 x3 x4.\n        \\<not> sub_RI x4 \\<longrightarrow>\n        (\\<forall>e'.\n            subexp_of e' x4 \\<longrightarrow>\n            \\<not> sub_RI e' \\<longrightarrow>\n            iconf sh e') \\<longrightarrow>\n        iconf sh x4 \\<Longrightarrow>\n        \\<not> sub_RI (x1\\<bullet>\\<^sub>sx2{x3} := x4) \\<longrightarrow>\n        (\\<forall>e'.\n            subexp_of e' (x1\\<bullet>\\<^sub>sx2{x3} := x4) \\<longrightarrow>\n            \\<not> sub_RI e' \\<longrightarrow>\n            iconf sh e') \\<longrightarrow>\n        iconf sh (x1\\<bullet>\\<^sub>sx2{x3} := x4)\nA total of 22 subgoals...", "qed(auto)"], ["", "lemma nsub_RI_iconf_aux':\n \"(\\<And>e'. subexp_of e' e \\<Longrightarrow> \\<not>sub_RI e' \\<longrightarrow> iconf sh e') \\<Longrightarrow> (\\<not>sub_RI e \\<Longrightarrow> iconf sh e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e'.\n                subexp_of e' e \\<Longrightarrow>\n                \\<not> sub_RI e' \\<longrightarrow> iconf sh e';\n     \\<not> sub_RI e\\<rbrakk>\n    \\<Longrightarrow> iconf sh e", "by(simp add: nsub_RI_iconf_aux)"], ["", "lemma nsub_RI_iconf: \"\\<not>sub_RI e \\<Longrightarrow> iconf sh e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sub_RI e \\<Longrightarrow> iconf sh e", "apply(cut_tac e = e and R = \"\\<lambda>e. \\<not>sub_RI e \\<longrightarrow> iconf sh e\" in subexp_induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>\\<not> sub_RI e; subexp ea = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI ea \\<longrightarrow> iconf sh ea\n 2. \\<And>ea.\n       \\<lbrakk>\\<not> sub_RI e;\n        \\<And>e'.\n           subexp_of e' ea \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI ea \\<longrightarrow> iconf sh ea\n 3. \\<And>es.\n       \\<lbrakk>\\<not> sub_RI e;\n        \\<And>e'.\n           e' \\<in> subexps es \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> ?Rs es\n 4. \\<lbrakk>\\<not> sub_RI e;\n     (\\<forall>e'.\n         subexp_of e' e \\<longrightarrow>\n         \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<and>\n     (\\<not> sub_RI e \\<longrightarrow> iconf sh e)\\<rbrakk>\n    \\<Longrightarrow> iconf sh e", "apply(rename_tac ea)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>\\<not> sub_RI e; subexp ea = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI ea \\<longrightarrow> iconf sh ea\n 2. \\<And>ea.\n       \\<lbrakk>\\<not> sub_RI e;\n        \\<And>e'.\n           subexp_of e' ea \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI ea \\<longrightarrow> iconf sh ea\n 3. \\<And>es.\n       \\<lbrakk>\\<not> sub_RI e;\n        \\<And>e'.\n           e' \\<in> subexps es \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> ?Rs es\n 4. \\<lbrakk>\\<not> sub_RI e;\n     (\\<forall>e'.\n         subexp_of e' e \\<longrightarrow>\n         \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<and>\n     (\\<not> sub_RI e \\<longrightarrow> iconf sh e)\\<rbrakk>\n    \\<Longrightarrow> iconf sh e", "apply(case_tac ea, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ea.\n       \\<lbrakk>\\<not> sub_RI e;\n        \\<And>e'.\n           subexp_of e' ea \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI ea \\<longrightarrow> iconf sh ea", "apply(clarsimp simp: nsub_RI_iconf_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nsub_RIs_iconfs: \"\\<not>sub_RIs es \\<Longrightarrow> iconfs sh es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sub_RIs es \\<Longrightarrow> iconfs sh es", "apply(cut_tac es = es and R = \"\\<lambda>e. \\<not>sub_RI e \\<longrightarrow> iconf sh e\"\n  and Rs = \"\\<lambda>es. \\<not>sub_RIs es \\<longrightarrow> iconfs sh es\" in subexps_induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>esa.\n       \\<lbrakk>\\<not> sub_RIs es; subexps esa = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RIs esa \\<longrightarrow> iconfs sh esa\n 2. \\<And>e.\n       \\<lbrakk>\\<not> sub_RIs es;\n        \\<And>e'.\n           subexp_of e' e \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI e \\<longrightarrow> iconf sh e\n 3. \\<And>esa.\n       \\<lbrakk>\\<not> sub_RIs es;\n        \\<And>e'.\n           e' \\<in> subexps esa \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RIs esa \\<longrightarrow> iconfs sh esa\n 4. \\<lbrakk>\\<not> sub_RIs es;\n     (\\<forall>e'.\n         e' \\<in> subexps es \\<longrightarrow>\n         \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<and>\n     (\\<not> sub_RIs es \\<longrightarrow> iconfs sh es)\\<rbrakk>\n    \\<Longrightarrow> iconfs sh es", "apply(rename_tac esa)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>esa.\n       \\<lbrakk>\\<not> sub_RIs es; subexps esa = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RIs esa \\<longrightarrow> iconfs sh esa\n 2. \\<And>e.\n       \\<lbrakk>\\<not> sub_RIs es;\n        \\<And>e'.\n           subexp_of e' e \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI e \\<longrightarrow> iconf sh e\n 3. \\<And>esa.\n       \\<lbrakk>\\<not> sub_RIs es;\n        \\<And>e'.\n           e' \\<in> subexps esa \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RIs esa \\<longrightarrow> iconfs sh esa\n 4. \\<lbrakk>\\<not> sub_RIs es;\n     (\\<forall>e'.\n         e' \\<in> subexps es \\<longrightarrow>\n         \\<not> sub_RI e' \\<longrightarrow> iconf sh e') \\<and>\n     (\\<not> sub_RIs es \\<longrightarrow> iconfs sh es)\\<rbrakk>\n    \\<Longrightarrow> iconfs sh es", "apply(case_tac esa, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>\\<not> sub_RIs es;\n        \\<And>e'.\n           subexp_of e' e \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI e \\<longrightarrow> iconf sh e\n 2. \\<And>esa.\n       \\<lbrakk>\\<not> sub_RIs es;\n        \\<And>e'.\n           e' \\<in> subexps esa \\<Longrightarrow>\n           \\<not> sub_RI e' \\<longrightarrow> iconf sh e'\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RIs esa \\<longrightarrow> iconfs sh esa", "apply(clarsimp simp: nsub_RI_iconf_aux)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lass_val_of_iconf: \"lass_val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow> iconf sh e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lass_val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow> iconf sh e", "by(drule lass_val_of_nsub_RI, erule nsub_RI_iconf)"], ["", "lemma icheck_iconf:\nassumes \"icheck P C e\" shows \"iconf sh e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iconf sh e", "using assms"], ["proof (prove)\nusing this:\n  icheck P C e\n\ngoal (1 subgoal):\n 1. iconf sh e", "proof(cases e)"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x101 x102 x103 x104.\n        \\<lbrakk>icheck P C e;\n         e = x101\\<bullet>\\<^sub>sx102{x103} := x104\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 20 subgoals...", "case (SFAss C F D e)"], ["proof (state)\nthis:\n  e = C\\<bullet>\\<^sub>sF{D} := e\n\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x101 x102 x103 x104.\n        \\<lbrakk>icheck P C e;\n         e = x101\\<bullet>\\<^sub>sx102{x103} := x104\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  e = C\\<bullet>\\<^sub>sF{D} := e", "show ?thesis"], ["proof (prove)\nusing this:\n  e = C\\<bullet>\\<^sub>sF{D} := e\n\ngoal (1 subgoal):\n 1. iconf sh e", "using assms"], ["proof (prove)\nusing this:\n  e = C\\<bullet>\\<^sub>sF{D} := e\n  icheck P C e\n\ngoal (1 subgoal):\n 1. iconf sh e", "proof(cases e)"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n        e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x101 x102 x103 x104.\n        \\<lbrakk>e = C\\<bullet>\\<^sub>sF{D} := e; icheck P C e;\n         e = x101\\<bullet>\\<^sub>sx102{x103} := x104\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 20 subgoals...", "qed(auto)"], ["proof (state)\nthis:\n  iconf sh e\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>icheck P C e; e = x111\\<bullet>x112(x113)\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>icheck P C e; e = x111\\<bullet>x112(x113)\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 19 subgoals...", "case (SCall C M es)"], ["proof (state)\nthis:\n  e = C\\<bullet>\\<^sub>sM(es)\n\ngoal (19 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>icheck P C e; e = x111\\<bullet>x112(x113)\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  e = C\\<bullet>\\<^sub>sM(es)", "show ?thesis"], ["proof (prove)\nusing this:\n  e = C\\<bullet>\\<^sub>sM(es)\n\ngoal (1 subgoal):\n 1. iconf sh e", "using assms"], ["proof (prove)\nusing this:\n  e = C\\<bullet>\\<^sub>sM(es)\n  icheck P C e\n\ngoal (1 subgoal):\n 1. iconf sh e", "by (auto simp: nsub_RIs_iconfs)"], ["proof (state)\nthis:\n  iconf sh e\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>icheck P C e; e = x111\\<bullet>x112(x113)\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>icheck P C e; e = new x1\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 2. \\<And>x21 x22.\n       \\<lbrakk>icheck P C e; e = Cast x21 x22\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 3. \\<And>x3.\n       \\<lbrakk>icheck P C e; e = Val x3\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>icheck P C e;\n        e = x41 \\<guillemotleft>x42\\<guillemotright> x43\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 5. \\<And>x5.\n       \\<lbrakk>icheck P C e; e = Var x5\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 6. \\<And>x61 x62.\n       \\<lbrakk>icheck P C e; e = x61:=x62\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 7. \\<And>x71 x72 x73.\n       \\<lbrakk>icheck P C e; e = x71\\<bullet>x72{x73}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>icheck P C e; e = x81\\<bullet>\\<^sub>sx82{x83}\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 9. \\<And>x91 x92 x93 x94.\n       \\<lbrakk>icheck P C e; e = x91\\<bullet>x92{x93} := x94\\<rbrakk>\n       \\<Longrightarrow> iconf sh e\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>icheck P C e; e = x111\\<bullet>x112(x113)\\<rbrakk>\n        \\<Longrightarrow> iconf sh e\nA total of 18 subgoals...", "qed(auto)"], ["", "subsection \"Indicator boolean conformance\"\n\n\\<comment> \\<open> checks that the given expression, indicator boolean pair is allowed in small-step\n  (i.e., if @{term b} is True, then @{term e} is an initialization-calling expression to\n  a class that is marked either @{term Processing} or @{term Done}) \\<close>"], ["", "definition bconf :: \"'m prog \\<Rightarrow> sheap \\<Rightarrow> 'a exp \\<Rightarrow> bool \\<Rightarrow> bool\"  (\"_,_ \\<turnstile>\\<^sub>b '(_,_') \\<surd>\" [51,51,0,0] 50)\nwhere\n  \"P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>  \\<equiv> b \\<longrightarrow> (\\<exists>C. icheck P C (ss_exp e) \\<and> initPD sh C)\""], ["", "definition bconfs :: \"'m prog \\<Rightarrow> sheap \\<Rightarrow> 'a exp list \\<Rightarrow> bool \\<Rightarrow> bool\"  (\"_,_ \\<turnstile>\\<^sub>b '(_,_') \\<surd>\" [51,51,0,0] 50)\nwhere\n  \"P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>  \\<equiv> b \\<longrightarrow> (\\<exists>C. (icheck P C (the(ss_exps es))\n                           \\<and> (curr_inits P es = Some C) \\<and> initPD sh C))\"\n\n\n\\<comment> \\<open> bconf helper lemmas \\<close>"], ["", "lemma bconf_nonVal[simp]:\n \"P,sh \\<turnstile>\\<^sub>b (e,True) \\<surd> \\<Longrightarrow> val_of e = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,sh \\<turnstile>\\<^sub>b (e,True) \\<surd> \\<Longrightarrow>\n    val_of e = None", "by(cases e, auto simp: bconf_def)"], ["", "lemma bconfs_nonVals[simp]:\n \"P,sh \\<turnstile>\\<^sub>b (es,True) \\<surd> \\<Longrightarrow> map_vals_of es = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,sh \\<turnstile>\\<^sub>b (es,True) \\<surd> \\<Longrightarrow>\n    map_vals_of es = None", "by(induct es, auto simp: bconfs_def)"], ["", "lemma bconf_Cast[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (Cast C e,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (Cast C e,b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 C.\n       \\<lbrakk>b; val_of e = \\<lfloor>x2\\<rfloor>; icheck P C (ss_exp e);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_BinOp[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e1 \\<guillemotleft>bop\\<guillemotright> e2,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e1 of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e1 \\<guillemotleft>bop\\<guillemotright> e2,b) \\<surd>) =\n    (case val_of e1 of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a C.\n       \\<lbrakk>b; val_of e2 = \\<lfloor>x2\\<rfloor>;\n        val_of e1 = \\<lfloor>x2a\\<rfloor>; icheck P C (ss_exp e2);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_LAss[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (LAss V e,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (V:=e,b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 C.\n       \\<lbrakk>b; val_of e = \\<lfloor>x2\\<rfloor>; icheck P C (ss_exp e);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_FAcc[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e\\<bullet>F{D},b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>F{D},b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 C.\n       \\<lbrakk>b; val_of e = \\<lfloor>x2\\<rfloor>; icheck P C (ss_exp e);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_FAss[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (FAss e1 F D e2,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e1 of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e1\\<bullet>F{D} := e2,b) \\<surd>) =\n    (case val_of e1 of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a C.\n       \\<lbrakk>b; val_of e2 = \\<lfloor>x2\\<rfloor>;\n        val_of e1 = \\<lfloor>x2a\\<rfloor>; icheck P C (ss_exp e2);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_SFAss[iff]:\n\"val_of e2 = None \\<Longrightarrow> P,sh \\<turnstile>\\<^sub>b (SFAss C F D e2,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of e2 = None \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sF{D} := e2,b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>)", "by(unfold bconf_def, cases b, auto)"], ["", "lemma bconfs_Vals[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (map Val vs, b) \\<surd> \\<longleftrightarrow> \\<not> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (map Val vs,b) \\<surd>) = (\\<not> b)", "by(unfold bconfs_def, simp)"], ["", "lemma bconf_Call[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>\n   \\<longleftrightarrow> (case val_of e of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case True"], ["proof (state)\nthis:\n  b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  b\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "proof(cases \"ss_exps es\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case None"], ["proof (state)\nthis:\n  ss_exps es = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  ss_exps es = None", "obtain vs where \"es = map Val vs\""], ["proof (prove)\nusing this:\n  ss_exps es = None\n\ngoal (1 subgoal):\n 1. (\\<And>vs. es = map Val vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ss_exps_Vals_NoneI"], ["proof (prove)\nusing this:\n  ss_exps es = None\n  ss_exps ?es = None \\<Longrightarrow> \\<exists>vs. ?es = map Val vs\n\ngoal (1 subgoal):\n 1. (\\<And>vs. es = map Val vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  es = map Val vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  es = map Val vs", "have mv: \"map_vals_of es = \\<lfloor>vs\\<rfloor>\""], ["proof (prove)\nusing this:\n  es = map Val vs\n\ngoal (1 subgoal):\n 1. map_vals_of es = \\<lfloor>vs\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  map_vals_of es = \\<lfloor>vs\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  map_vals_of es = \\<lfloor>vs\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  map_vals_of es = \\<lfloor>vs\\<rfloor>\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "by(auto simp: bconf_def) (simp add: bconfs_def)"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n  (case val_of e of\n   None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n   | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n       P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case (Some a)"], ["proof (state)\nthis:\n  ss_exps es = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  ss_exps es = \\<lfloor>a\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ss_exps es = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "by(auto simp: bconf_def, auto simp: bconfs_def icheck_init_class)"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n  (case val_of e of\n   None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n   | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n       P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n  (case val_of e of\n   None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n   | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n       P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e\\<bullet>M(es),b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "qed(simp add: bconf_def bconfs_def)"], ["", "lemma bconf_SCall[iff]:\nassumes mvn: \"map_vals_of es = None\"\nshows \"P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case True"], ["proof (state)\nthis:\n  b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  b\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "proof(cases \"ss_exps es\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                      (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                         (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case None"], ["proof (state)\nthis:\n  ss_exps es = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                      (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                         (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  ss_exps es = None", "have \"\\<exists>vs. es = map Val vs\""], ["proof (prove)\nusing this:\n  ss_exps es = None\n\ngoal (1 subgoal):\n 1. \\<exists>vs. es = map Val vs", "using ss_exps_Vals_NoneI"], ["proof (prove)\nusing this:\n  ss_exps es = None\n  ss_exps ?es = None \\<Longrightarrow> \\<exists>vs. ?es = map Val vs\n\ngoal (1 subgoal):\n 1. \\<exists>vs. es = map Val vs", "by auto"], ["proof (state)\nthis:\n  \\<exists>vs. es = map Val vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                      (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                         (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>vs. es = map Val vs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>vs. es = map Val vs\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "using mvn finals_def"], ["proof (prove)\nusing this:\n  \\<exists>vs. es = map Val vs\n  map_vals_of es = None\n  finals ?es \\<equiv>\n  (\\<exists>vs. ?es = map Val vs) \\<or>\n  (\\<exists>vs a es'. ?es = map Val vs @ Throw a # es')\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "by clarsimp"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n  (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                         (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                         (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case (Some a)"], ["proof (state)\nthis:\n  ss_exps es = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n                         (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  ss_exps es = \\<lfloor>a\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ss_exps es = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "by(auto simp: bconf_def, auto simp: bconfs_def icheck_init_class)"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n  (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n  (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (C\\<bullet>\\<^sub>sM(es),b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "qed(simp add: bconf_def bconfs_def)"], ["", "lemma bconf_Cons[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e#es,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd> | _ \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case True"], ["proof (state)\nthis:\n  b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  b", "show ?thesis"], ["proof (prove)\nusing this:\n  b\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "proof(cases \"ss_exps es\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case None"], ["proof (state)\nthis:\n  ss_exps es = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  ss_exps es = None", "have \"\\<exists>vs. es = map Val vs\""], ["proof (prove)\nusing this:\n  ss_exps es = None\n\ngoal (1 subgoal):\n 1. \\<exists>vs. es = map Val vs", "using ss_exps_Vals_NoneI"], ["proof (prove)\nusing this:\n  ss_exps es = None\n  ss_exps ?es = None \\<Longrightarrow> \\<exists>vs. ?es = map Val vs\n\ngoal (1 subgoal):\n 1. \\<exists>vs. es = map Val vs", "by auto"], ["proof (state)\nthis:\n  \\<exists>vs. es = map Val vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b; ss_exps es = None\\<rbrakk>\n    \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                      (case val_of e of\n                       None \\<Rightarrow>\n                         P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                       | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                           P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n 2. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>vs. es = map Val vs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>vs. es = map Val vs\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "using None"], ["proof (prove)\nusing this:\n  \\<exists>vs. es = map Val vs\n  ss_exps es = None\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "by(auto simp: bconf_def bconfs_def icheck_init_class)"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n  (case val_of e of\n   None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n   | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n       P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "case (Some a)"], ["proof (state)\nthis:\n  ss_exps es = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b; ss_exps es = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n                         (case val_of e of\n                          None \\<Rightarrow>\n                            P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n                          | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n                              P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "then"], ["proof (chain)\npicking this:\n  ss_exps es = \\<lfloor>a\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ss_exps es = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "by(auto simp: bconf_def bconfs_def icheck_init_class)"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n  (case val_of e of\n   None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n   | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n       P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n  (case val_of e of\n   None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n   | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n       P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    (P,sh \\<turnstile>\\<^sub>b (e # es,b) \\<surd>) =\n    (case val_of e of\n     None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (es,b) \\<surd>)", "qed(simp add: bconf_def bconfs_def)"], ["", "lemma bconf_InitBlock[iff]:\n \"P,sh \\<turnstile>\\<^sub>b ({V:T; V:=Val v;; e\\<^sub>2},b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e\\<^sub>2,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b ({V:T; V:=Val v;; e\\<^sub>2},b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e\\<^sub>2,b) \\<surd>)", "by(unfold bconf_def, cases b, auto simp: assigned_def)"], ["", "lemma bconf_Block[iff]:\n \"P,sh \\<turnstile>\\<^sub>b ({V:T; e},b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b ({V:T; e},b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "by(unfold bconf_def, cases b, auto)"], ["", "lemma bconf_Seq[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (e1;;e2,b) \\<surd>\n   \\<longleftrightarrow> (case val_of e1 of Some v \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\n                             | _ \\<Rightarrow> (case lass_val_of e1 of Some p \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\n                                                          | None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e1;; e2,b) \\<surd>) =\n    (case val_of e1 of\n     None \\<Rightarrow>\n       case lass_val_of e1 of\n       None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>\n       | \\<lfloor>p\\<rfloor> \\<Rightarrow>\n           P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>)", "(* \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>\"*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (e1;; e2,b) \\<surd>) =\n    (case val_of e1 of\n     None \\<Rightarrow>\n       case lass_val_of e1 of\n       None \\<Rightarrow> P,sh \\<turnstile>\\<^sub>b (e1,b) \\<surd>\n       | \\<lfloor>p\\<rfloor> \\<Rightarrow>\n           P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>\n     | \\<lfloor>v\\<rfloor> \\<Rightarrow>\n         P,sh \\<turnstile>\\<^sub>b (e2,b) \\<surd>)", "by(unfold bconf_def, cases b, auto dest: val_of_spec lass_val_of_spec)"], ["", "lemma bconf_Cond[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (if (b) e\\<^sub>1 else e\\<^sub>2,b') \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (b,b') \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (if (b) e\\<^sub>1\n     else e\\<^sub>2,b') \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (b,b') \\<surd>)", "apply(unfold bconf_def, cases \"bool_of b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. bool_of b = None \\<Longrightarrow>\n    (b' \\<longrightarrow>\n     (\\<exists>C.\n         icheck P C (ss_exp (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n         initPD sh C)) =\n    (b' \\<longrightarrow>\n     (\\<exists>C. icheck P C (ss_exp b) \\<and> initPD sh C))\n 2. \\<And>a.\n       bool_of b = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (b' \\<longrightarrow>\n        (\\<exists>C.\n            icheck P C (ss_exp (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n            initPD sh C)) =\n       (b' \\<longrightarrow>\n        (\\<exists>C. icheck P C (ss_exp b) \\<and> initPD sh C))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bool_of b = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (b' \\<longrightarrow>\n        (\\<exists>C.\n            icheck P C (ss_exp (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n            initPD sh C)) =\n       (b' \\<longrightarrow>\n        (\\<exists>C. icheck P C (ss_exp b) \\<and> initPD sh C))", "apply(rename_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bool_of b = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (b' \\<longrightarrow>\n        (\\<exists>C.\n            icheck P C (ss_exp (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n            initPD sh C)) =\n       (b' \\<longrightarrow>\n        (\\<exists>C. icheck P C (ss_exp b) \\<and> initPD sh C))", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>bool_of b = \\<lfloor>a\\<rfloor>; a\\<rbrakk>\n       \\<Longrightarrow> (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C\n                               (ss_exp\n                                 (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n                              initPD sh C)) =\n                         (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C (ss_exp b) \\<and> initPD sh C))\n 2. \\<And>a.\n       \\<lbrakk>bool_of b = \\<lfloor>a\\<rfloor>; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C\n                               (ss_exp\n                                 (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n                              initPD sh C)) =\n                         (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C (ss_exp b) \\<and> initPD sh C))", "apply(simp, drule bool_of_specT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a; b = true\\<rbrakk>\n       \\<Longrightarrow> (\\<not> b') =\n                         (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C (ss_exp b) \\<and> initPD sh C))\n 2. \\<And>a.\n       \\<lbrakk>bool_of b = \\<lfloor>a\\<rfloor>; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C\n                               (ss_exp\n                                 (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n                              initPD sh C)) =\n                         (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C (ss_exp b) \\<and> initPD sh C))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>bool_of b = \\<lfloor>a\\<rfloor>; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C\n                               (ss_exp\n                                 (if (b) e\\<^sub>1 else e\\<^sub>2)) \\<and>\n                              initPD sh C)) =\n                         (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C (ss_exp b) \\<and> initPD sh C))", "apply(simp, drule bool_of_specF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<not> a; b = false\\<rbrakk>\n       \\<Longrightarrow> (\\<not> b') =\n                         (b' \\<longrightarrow>\n                          (\\<exists>C.\n                              icheck P C (ss_exp b) \\<and> initPD sh C))", "apply auto[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_While[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (while (b) e,b') \\<surd> \\<longleftrightarrow> \\<not>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (while (b) e,b') \\<surd>) = (\\<not> b')", "by(unfold bconf_def, cases b, auto)"], ["", "lemma bconf_Throw[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (throw e,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (throw e,b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 C.\n       \\<lbrakk>b; val_of e = \\<lfloor>x2\\<rfloor>; icheck P C (ss_exp e);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_Try[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (try e\\<^sub>1 catch(C V) e\\<^sub>2,b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e\\<^sub>1,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (try e\\<^sub>1\n     catch(C V) e\\<^sub>2,b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e\\<^sub>1,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 C.\n       \\<lbrakk>b; val_of e\\<^sub>1 = \\<lfloor>x2\\<rfloor>;\n        icheck P C (ss_exp e\\<^sub>1); initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconf_INIT[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (INIT C (Cs,b') \\<leftarrow> e,b) \\<surd> \\<longleftrightarrow> \\<not>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (INIT C (Cs,b') \\<leftarrow> e,b) \\<surd>) =\n    (\\<not> b)", "by(unfold bconf_def, cases b, auto)"], ["", "lemma bconf_RI[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (RI(C,e);Cs \\<leftarrow> e',b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (RI (C,e) ; Cs \\<leftarrow> e',b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "apply(unfold bconf_def, cases b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 C.\n       \\<lbrakk>b; val_of e = \\<lfloor>x2\\<rfloor>; icheck P C (ss_exp e);\n        initPD sh C\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule val_of_spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bconfs_map_throw[iff]:\n \"P,sh \\<turnstile>\\<^sub>b (map Val vs @ throw e # es',b) \\<surd> \\<longleftrightarrow> P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,sh \\<turnstile>\\<^sub>b (map Val vs @ throw e # es',b) \\<surd>) =\n    (P,sh \\<turnstile>\\<^sub>b (e,b) \\<surd>)", "by(induct vs, auto)"], ["", "end"]]}