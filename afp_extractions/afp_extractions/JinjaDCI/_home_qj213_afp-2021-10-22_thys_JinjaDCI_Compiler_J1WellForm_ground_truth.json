{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/Compiler/J1WellForm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemmas WT\\<^sub>1_WTs\\<^sub>1_induct = WT\\<^sub>1_WTs\\<^sub>1.induct [split_format (complete)]\n  and WT\\<^sub>1_WTs\\<^sub>1_inducts = WT\\<^sub>1_WTs\\<^sub>1.inducts [split_format (complete)]", "lemma init_nWT\\<^sub>1 [simp]:\"\\<not>P,E \\<turnstile>\\<^sub>1 INIT C (Cs,b) \\<leftarrow> e :: T\"", "lemma rinit_nWT\\<^sub>1 [simp]:\"\\<not>P,E \\<turnstile>\\<^sub>1 RI(C,e);Cs \\<leftarrow> e' :: T\"", "lemma WTs\\<^sub>1_same_size: \"\\<And>Ts. P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> size es = size Ts\"", "lemma WT\\<^sub>1_unique:\n  \"P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>1 \\<Longrightarrow> (\\<And>T\\<^sub>2. P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow> T\\<^sub>1 = T\\<^sub>2)\" and\n  WTs\\<^sub>1_unique: \"P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>1 \\<Longrightarrow> (\\<And>Ts\\<^sub>2. P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow> Ts\\<^sub>1 = Ts\\<^sub>2)\"", "lemma assumes wf: \"wf_prog p P\"\nshows WT\\<^sub>1_is_type: \"P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> set E \\<subseteq> types P \\<Longrightarrow> is_type P T\"\nand \"P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> True\"", "lemma WT\\<^sub>1_nsub_RI: \"P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> \\<not>sub_RI e\"\n and WTs\\<^sub>1_nsub_RIs: \"P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> \\<not>sub_RIs es\"", "lemmas WTrt\\<^sub>1_induct = WTrt\\<^sub>1_WTrts\\<^sub>1.induct [split_format (complete)]\n  and WTrt\\<^sub>1_inducts = WTrt\\<^sub>1_WTrts\\<^sub>1.inducts [split_format (complete)]", "lemma WT\\<^sub>1_implies_WTrt\\<^sub>1: \"P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e : T\"\nand WTs\\<^sub>1_implies_WTrts\\<^sub>1: \"P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\"", "lemma wf_J\\<^sub>1_mdecl_NonStatic[simp]:\n  \"wf_J\\<^sub>1_mdecl P C (M,NonStatic,Ts,T,body) \\<equiv>\n    (\\<not>sub_RI body \\<and>\n    (\\<exists>T'. P,Class C#Ts \\<turnstile>\\<^sub>1 body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n     \\<D> body \\<lfloor>{..size Ts}\\<rfloor> \\<and> \\<B> body (size Ts + 1))\"", "lemma wf_J\\<^sub>1_mdecl_Static[simp]:\n  \"wf_J\\<^sub>1_mdecl P C (M,Static,Ts,T,body) \\<equiv>\n    (\\<not>sub_RI body \\<and>\n    (\\<exists>T'. P,Ts \\<turnstile>\\<^sub>1 body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n     \\<D> body \\<lfloor>{..<size Ts}\\<rfloor> \\<and> \\<B> body (size Ts))\"", "lemma sees_wf\\<^sub>1_nsub_RI:\n \"\\<lbrakk> wf_J\\<^sub>1_prog P; P \\<turnstile> C sees M,b : Ts\\<rightarrow>T = body in D \\<rbrakk> \\<Longrightarrow> \\<not>sub_RI body\"", "lemma wf\\<^sub>1_types_clinit:\nassumes wf:\"wf_prog wf_md P\" and ex: \"class P C = Some a\" and proc: \"sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\"\nshows \"P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void\"", "lemma assumes wf: \"wf_J\\<^sub>1_prog P\"\nshows eval\\<^sub>1_proc_pres: \"P \\<turnstile>\\<^sub>1 \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_init C e \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\"\n  and evals\\<^sub>1_proc_pres: \"P \\<turnstile>\\<^sub>1 \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_inits C es \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\"", "lemma clinit\\<^sub>1_proc_pres:\n  \"\\<lbrakk> wf_J\\<^sub>1_prog P; P \\<turnstile>\\<^sub>1 \\<langle>C\\<^sub>0\\<bullet>\\<^sub>sclinit([]),(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>;\n     sh C' = \\<lfloor>(sfs,Processing)\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs. sh' C' = \\<lfloor>(sfs,Processing)\\<rfloor>\""], "translations": [["", "lemmas WT\\<^sub>1_WTs\\<^sub>1_induct = WT\\<^sub>1_WTs\\<^sub>1.induct [split_format (complete)]\n  and WT\\<^sub>1_WTs\\<^sub>1_inducts = WT\\<^sub>1_WTs\\<^sub>1.inducts [split_format (complete)]"], ["", "inductive_cases eee[elim!]:\n  \"P,E \\<turnstile>\\<^sub>1 Val v :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 Var i :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 Cast D e :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 i:=e :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 {i:U; e} :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;e\\<^sub>2 :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1 else e\\<^sub>2 :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 while (e) c :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 throw e :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1 catch(C i) e\\<^sub>2 :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2 :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2 :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 new C :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) :: T\"\n  \"P,E \\<turnstile>\\<^sub>1 [] [::] Ts\"\n  \"P,E \\<turnstile>\\<^sub>1 e#es [::] Ts\""], ["", "(*>*)"], ["", "lemma init_nWT\\<^sub>1 [simp]:\"\\<not>P,E \\<turnstile>\\<^sub>1 INIT C (Cs,b) \\<leftarrow> e :: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P,E \\<turnstile>\\<^sub>1 INIT C (Cs,b) \\<leftarrow> e :: T", "by(auto elim:WT\\<^sub>1.cases)"], ["", "lemma rinit_nWT\\<^sub>1 [simp]:\"\\<not>P,E \\<turnstile>\\<^sub>1 RI(C,e);Cs \\<leftarrow> e' :: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P,E \\<turnstile>\\<^sub>1 RI (C,e) ; Cs \\<leftarrow> e' :: T", "by(auto elim:WT\\<^sub>1.cases)"], ["", "lemma WTs\\<^sub>1_same_size: \"\\<And>Ts. P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> size es = size Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts.\n       P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow>\n       length es = length Ts", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts.\n       P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow>\n       length es = length Ts", "by (induct es type:list) auto"], ["", "(*>*)"], ["", "lemma WT\\<^sub>1_unique:\n  \"P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>1 \\<Longrightarrow> (\\<And>T\\<^sub>2. P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow> T\\<^sub>1 = T\\<^sub>2)\" and\n  WTs\\<^sub>1_unique: \"P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>1 \\<Longrightarrow> (\\<And>Ts\\<^sub>2. P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow> Ts\\<^sub>1 = Ts\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>1 \\<Longrightarrow>\n     (\\<And>T\\<^sub>2.\n         P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n         T\\<^sub>1 = T\\<^sub>2)) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>1 \\<Longrightarrow>\n     (\\<And>Ts\\<^sub>2.\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n         Ts\\<^sub>1 = Ts\\<^sub>2))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>1 \\<Longrightarrow>\n     (\\<And>T\\<^sub>2.\n         P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n         T\\<^sub>1 = T\\<^sub>2)) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>1 \\<Longrightarrow>\n     (\\<And>Ts\\<^sub>2.\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n         Ts\\<^sub>1 = Ts\\<^sub>2))", "apply(induct rule:WT\\<^sub>1_WTs\\<^sub>1.inducts)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>C E T\\<^sub>2.\n       \\<lbrakk>is_class P C;\n        P,E \\<turnstile>\\<^sub>1 new C :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Class C = T\\<^sub>2\n 2. \\<And>E e D C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class D = T\\<^sub>2;\n        is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P,E \\<turnstile>\\<^sub>1 Cast C e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Class C = T\\<^sub>2\n 3. \\<And>v T E T\\<^sub>2.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile>\\<^sub>1 Val v :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>E i T T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E;\n        P,E \\<turnstile>\\<^sub>1 Var i :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 6. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 10. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n        \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n            T' = T\\<^sub>2;\n         P \\<turnstile> T' \\<le> T;\n         P,E \\<turnstile>\\<^sub>1\n         C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Void = T\\<^sub>2\nA total of 20 subgoals...", "apply blast"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>E e D C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class D = T\\<^sub>2;\n        is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P,E \\<turnstile>\\<^sub>1 Cast C e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Class C = T\\<^sub>2\n 2. \\<And>v T E T\\<^sub>2.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile>\\<^sub>1 Val v :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>E i T T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E;\n        P,E \\<turnstile>\\<^sub>1 Var i :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 5. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 7. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 9. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 10. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            Class C = T\\<^sub>2;\n         P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n         \\<And>Ts\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n            Ts = Ts\\<^sub>2;\n         P \\<turnstile> Ts [\\<le>] Ts';\n         P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> T = T\\<^sub>2\nA total of 19 subgoals...", "apply blast"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>v T E T\\<^sub>2.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile>\\<^sub>1 Val v :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>E i T T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E;\n        P,E \\<turnstile>\\<^sub>1 Var i :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 4. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 5. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 6. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 7. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 8. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 9. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 10. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n        \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n         \\<And>Ts\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n            Ts' = Ts\\<^sub>2;\n         P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n         P,E \\<turnstile>\\<^sub>1\n         C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> T = T\\<^sub>2\nA total of 18 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>E i T T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E;\n        P,E \\<turnstile>\\<^sub>1 Var i :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 3. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 4. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 6. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 8. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 10. \\<And>T E e T' i T\\<^sub>2.\n        \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n         \\<And>T\\<^sub>2.\n            P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            T' = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> T' = T\\<^sub>2\nA total of 17 subgoals...", "apply blast"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 2. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n            T\\<^sub>1 = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T\\<^sub>2'.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n            T\\<^sub>2 = T\\<^sub>2';\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n         e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\nA total of 16 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'\n       T\\<^sub>1' T\\<^sub>2''.\n       \\<lbrakk>\\<And>T\\<^sub>2.\n                   P,E \\<turnstile>\\<^sub>1\n                   e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n                   T\\<^sub>1 = T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2'';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1' \\<le> T\\<^sub>2'' \\<or>\n           P \\<turnstile> T\\<^sub>2'' \\<le> T\\<^sub>1') \\<and>\n          T\\<^sub>2' = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1' = Integer \\<and>\n            T\\<^sub>2'' = Integer \\<and> T\\<^sub>2' = Integer\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 2. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n            T\\<^sub>1 = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T\\<^sub>2'.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n            T\\<^sub>2 = T\\<^sub>2';\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n         e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\nA total of 16 subgoals...", "apply(case_tac bop)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'\n       T\\<^sub>1' T\\<^sub>2''.\n       \\<lbrakk>\\<And>T\\<^sub>2.\n                   P,E \\<turnstile>\\<^sub>1\n                   e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n                   T\\<^sub>1 = T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2'';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1' \\<le> T\\<^sub>2'' \\<or>\n           P \\<turnstile> T\\<^sub>2'' \\<le> T\\<^sub>1') \\<and>\n          T\\<^sub>2' = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1' = Integer \\<and>\n            T\\<^sub>2'' = Integer \\<and> T\\<^sub>2' = Integer;\n        bop = Eq\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'\n       T\\<^sub>1' T\\<^sub>2''.\n       \\<lbrakk>\\<And>T\\<^sub>2.\n                   P,E \\<turnstile>\\<^sub>1\n                   e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n                   T\\<^sub>1 = T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2'';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1' \\<le> T\\<^sub>2'' \\<or>\n           P \\<turnstile> T\\<^sub>2'' \\<le> T\\<^sub>1') \\<and>\n          T\\<^sub>2' = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1' = Integer \\<and>\n            T\\<^sub>2'' = Integer \\<and> T\\<^sub>2' = Integer;\n        bop = Add\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 3. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 4. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 6. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 8. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 10. \\<And>T E e T' i T\\<^sub>2.\n        \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n         \\<And>T\\<^sub>2.\n            P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            T' = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> T' = T\\<^sub>2\nA total of 17 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T\\<^sub>2'\n       T\\<^sub>1' T\\<^sub>2''.\n       \\<lbrakk>\\<And>T\\<^sub>2.\n                   P,E \\<turnstile>\\<^sub>1\n                   e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n                   T\\<^sub>1 = T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2'';\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1' \\<le> T\\<^sub>2'' \\<or>\n           P \\<turnstile> T\\<^sub>2'' \\<le> T\\<^sub>1') \\<and>\n          T\\<^sub>2' = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1' = Integer \\<and>\n            T\\<^sub>2'' = Integer \\<and> T\\<^sub>2' = Integer;\n        bop = Add\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 2. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n            T\\<^sub>1 = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T\\<^sub>2'.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n            T\\<^sub>2 = T\\<^sub>2';\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n         e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\nA total of 16 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>E i T e T' T\\<^sub>2.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1 i:=e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 2. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 5. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 7. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 10. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            Boolean = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n            T\\<^sub>1 = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T\\<^sub>2'.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n            T\\<^sub>2 = T\\<^sub>2';\n         P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n         P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n         P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n         T = T\\<^sub>2;\n         P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n         T = T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n         else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> T = T\\<^sub>2'\nA total of 15 subgoals...", "apply blast"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>E e C F T D T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>F{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 4. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 5. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 6. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 7. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 9. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 10. \\<And>E e c T T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            Boolean = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 c :: T;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n            T = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Void = T\\<^sub>2\nA total of 14 subgoals...", "apply (blast dest:sees_field_idemp sees_field_fun)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>C F T D E T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 4. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 6. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 8. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 9. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 10. \\<And>E e C T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            Class C = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Void = T\\<^sub>2\nA total of 13 subgoals...", "apply (blast dest:sees_field_fun)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 2. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 7. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 8. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 9. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 10. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1\n            e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n            T = T\\<^sub>2;\n         P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n         \\<And>T\\<^sub>2.\n            P,E @ [Class C] \\<turnstile>\\<^sub>1\n            e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n            T = T\\<^sub>2;\n         is_class P C;\n         P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n         catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> T = T\\<^sub>2\nA total of 12 subgoals...", "apply blast"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>C F T D E e\\<^sub>2 T' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 2. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 6. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 7. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 8. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 9. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 10. \\<And>E Ts\\<^sub>2.\n        P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n        [] = Ts\\<^sub>2\nA total of 11 subgoals...", "apply (blast dest:sees_field_fun)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>E e C M Ts' T m D es Ts T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P \\<turnstile> Ts [\\<le>] Ts';\n        P,E \\<turnstile>\\<^sub>1 e\\<bullet>M(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 5. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 6. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 8. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 9. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 10. \\<And>E e T es Ts Ts\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n         \\<And>T\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n            T = T\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n         \\<And>Ts\\<^sub>2.\n            P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n            Ts = Ts\\<^sub>2;\n         P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply (blast dest:sees_method_idemp sees_method_fun)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>C M Ts T m D E es Ts' T\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts' = Ts\\<^sub>2;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        P,E \\<turnstile>\\<^sub>1\n        C\\<bullet>\\<^sub>sM(es) :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 3. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 4. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 5. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 7. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 8. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 9. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply (blast dest:sees_method_fun)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>T E e T' i T\\<^sub>2.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        \\<And>T\\<^sub>2.\n           P,E @ [T] \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T' = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 {i:T; e} :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T' = T\\<^sub>2\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 3. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 4. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 5. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 6. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 7. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 8. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n        e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T\\<^sub>2'\n 2. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 3. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 4. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 5. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 6. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 7. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T T\\<^sub>2'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T\\<^sub>1 = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T\\<^sub>2'.\n           P,E \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2' \\<Longrightarrow>\n           T\\<^sub>2 = T\\<^sub>2';\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n        else e\\<^sub>2 :: T\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2'\n 2. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 4. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 5. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 6. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>E e c T T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Boolean = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 c :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 while (e) c :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 2. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 3. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 4. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 5. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>E e C T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           Class C = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 throw e :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Void = T\\<^sub>2\n 2. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 3. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 4. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        \\<And>T\\<^sub>2.\n           P,E @ [Class C] \\<turnstile>\\<^sub>1\n           e\\<^sub>2 :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        is_class P C;\n        P,E \\<turnstile>\\<^sub>1 try e\\<^sub>1\n        catch(C i) e\\<^sub>2 :: T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T = T\\<^sub>2\n 2. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 3. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>E Ts\\<^sub>2.\n       P,E \\<turnstile>\\<^sub>1 [] [::] Ts\\<^sub>2 \\<Longrightarrow>\n       [] = Ts\\<^sub>2\n 2. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>E e T es Ts Ts\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        \\<And>T\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 e :: T\\<^sub>2 \\<Longrightarrow>\n           T = T\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        \\<And>Ts\\<^sub>2.\n           P,E \\<turnstile>\\<^sub>1 es [::] Ts\\<^sub>2 \\<Longrightarrow>\n           Ts = Ts\\<^sub>2;\n        P,E \\<turnstile>\\<^sub>1 e # es [::] Ts\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts\\<^sub>2", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma assumes wf: \"wf_prog p P\"\nshows WT\\<^sub>1_is_type: \"P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> set E \\<subseteq> types P \\<Longrightarrow> is_type P T\"\nand \"P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n      set E \\<subseteq> types P\\<rbrakk>\n     \\<Longrightarrow> is_type P T) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> True)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n      set E \\<subseteq> types P\\<rbrakk>\n     \\<Longrightarrow> is_type P T) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> True)", "apply(induct rule:WT\\<^sub>1_WTs\\<^sub>1.inducts)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>C E.\n       \\<lbrakk>is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P (Class C)\n 2. \\<And>E e D C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class D);\n        is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P (Class C)\n 3. \\<And>v T E.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 7. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 8. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 9. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 10. \\<And>C F T D E e\\<^sub>2 T'.\n        \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n         P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P Void\nA total of 20 subgoals...", "apply simp"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>E e D C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class D);\n        is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P (Class C)\n 2. \\<And>v T E.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 6. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 7. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 8. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 9. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 10. \\<And>E e C M Ts' T m D es Ts.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n         P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n         P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P T\nA total of 19 subgoals...", "apply simp"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>v T E.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 5. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 7. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 8. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 9. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 10. \\<And>C M Ts T m D E es Ts'.\n        \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n         P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n         set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P T\nA total of 18 subgoals...", "apply (simp add:typeof_lit_is_type)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 4. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 7. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 8. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 9. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 10. \\<And>T E e T' i.\n        \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n         set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n         set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P T'\nA total of 17 subgoals...", "apply (blast intro:nth_mem)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 3. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 6. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 7. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 8. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 9. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n         set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P T\\<^sub>2\nA total of 16 subgoals...", "apply(simp split:bop.splits)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 2. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 5. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 6. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 7. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 8. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 10. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n         P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n         P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n         P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n         T = T\\<^sub>2;\n         P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n         T = T\\<^sub>1;\n         set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P T\nA total of 15 subgoals...", "apply simp"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 4. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 5. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 7. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 9. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 10. \\<And>E e c T.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n         P,E \\<turnstile>\\<^sub>1 c :: T;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n         set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P Void\nA total of 14 subgoals...", "apply (simp add:sees_field_is_type[OF _ wf])"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>C F T D E.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 3. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 4. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 8. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 9. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 10. \\<And>E e C.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n         set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P Void\nA total of 13 subgoals...", "apply (simp add:sees_field_is_type[OF _ wf])"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 2. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 3. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 7. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 8. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 9. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 10. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n         P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n         set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n         is_type P T;\n         is_class P C; set E \\<subseteq> types P\\<rbrakk>\n        \\<Longrightarrow> is_type P T\nA total of 12 subgoals...", "apply simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        P \\<turnstile> T' \\<le> T; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 2. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 6. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 7. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 8. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 9. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 10. \\<And>E. True\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True;\n        P \\<turnstile> Ts [\\<le>] Ts'; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 5. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 7. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 8. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 9. \\<And>E. True\n 10. \\<And>E e T es Ts.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n         set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n        \\<Longrightarrow> True", "apply(fastforce dest!: sees_wf_mdecl[OF wf] simp:wf_mdecl_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts'; True;\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 3. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 4. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 6. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 7. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 8. \\<And>E. True\n 9. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply(fastforce dest!: sees_wf_mdecl[OF wf] simp:wf_mdecl_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        set (E @ [T]) \\<subseteq> types P \\<Longrightarrow> is_type P T';\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T'\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 3. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 5. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 6. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 7. \\<And>E. True\n 8. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\\<^sub>2\n 2. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 4. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 5. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 6. \\<And>E. True\n 7. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 3. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 4. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 5. \\<And>E. True\n 6. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 2. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 3. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 4. \\<And>E. True\n 5. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P (Class C);\n        set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P Void\n 2. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 3. \\<And>E. True\n 4. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        set (E @ [Class C]) \\<subseteq> types P \\<Longrightarrow>\n        is_type P T;\n        is_class P C; set E \\<subseteq> types P\\<rbrakk>\n       \\<Longrightarrow> is_type P T\n 2. \\<And>E. True\n 3. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>E. True\n 2. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        set E \\<subseteq> types P \\<Longrightarrow> is_type P T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts; True\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma WT\\<^sub>1_nsub_RI: \"P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> \\<not>sub_RI e\"\n and WTs\\<^sub>1_nsub_RIs: \"P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> \\<not>sub_RIs es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> \\<not> sub_RI e) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow>\n     \\<not> sub_RIs es)", "proof(induct rule: WT\\<^sub>1_WTs\\<^sub>1.inducts)"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>C E. is_class P C \\<Longrightarrow> \\<not> sub_RI (new C)\n 2. \\<And>E e D C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D; \\<not> sub_RI e;\n        is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI (Cast C e)\n 3. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       \\<not> sub_RI (Val v)\n 4. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI (Var i)\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        \\<not> sub_RI e\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        \\<not> sub_RI e\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI\n                                 (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2)\n 6. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        \\<not> sub_RI e; P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI (i:=e)\n 7. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C; \\<not> sub_RI e;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI (e\\<bullet>F{D})\n 8. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       \\<not> sub_RI (C\\<bullet>\\<^sub>sF{D})\n 9. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        \\<not> sub_RI e\\<^sub>1; P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T'; \\<not> sub_RI e\\<^sub>2;\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<not> sub_RI (e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2)\n 10. \\<And>C F T D E e\\<^sub>2 T'.\n        \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T'; \\<not> sub_RI e\\<^sub>2;\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> \\<not> sub_RI\n                                  (C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2)\nA total of 20 subgoals...", "qed(simp_all)"], ["", "subsection\\<open> Runtime Well-Typedness \\<close>"], ["", "inductive\n  WTrt\\<^sub>1 :: \"J\\<^sub>1_prog \\<Rightarrow> heap \\<Rightarrow> sheap \\<Rightarrow> env\\<^sub>1 \\<Rightarrow> expr\\<^sub>1 \\<Rightarrow> ty \\<Rightarrow> bool\"\n  and WTrts\\<^sub>1 :: \"J\\<^sub>1_prog \\<Rightarrow> heap \\<Rightarrow> sheap \\<Rightarrow> env\\<^sub>1 \\<Rightarrow> expr\\<^sub>1 list \\<Rightarrow> ty list \\<Rightarrow> bool\"\n  and WTrt2\\<^sub>1 :: \"[J\\<^sub>1_prog,env\\<^sub>1,heap,sheap,expr\\<^sub>1,ty] \\<Rightarrow> bool\"\n        (\"_,_,_,_ \\<turnstile>\\<^sub>1 _ : _\"   [51,51,51,51]50)\n  and WTrts2\\<^sub>1 :: \"[J\\<^sub>1_prog,env\\<^sub>1,heap,sheap,expr\\<^sub>1 list, ty list] \\<Rightarrow> bool\"\n        (\"_,_,_,_ \\<turnstile>\\<^sub>1 _ [:] _\" [51,51,51,51]50)\n  for P :: J\\<^sub>1_prog and h :: heap and sh :: sheap\nwhere\n  \n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e : T \\<equiv> WTrt\\<^sub>1 P h sh E e T\"\n| \"P,E,h,sh \\<turnstile>\\<^sub>1 es[:]Ts \\<equiv> WTrts\\<^sub>1 P h sh E es Ts\"\n\n| WTrtNew\\<^sub>1:\n  \"is_class P C  \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 new C : Class C\"\n\n| WTrtCast\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : T; is_refT T; is_class P C \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Cast C e : Class C\"\n\n| WTrtVal\\<^sub>1:\n  \"typeof\\<^bsub>h\\<^esub> v = Some T \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 Val v : T\"\n\n| WTrtVar\\<^sub>1:\n  \"\\<lbrakk> E!i = T; i < size E \\<rbrakk>  \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 Var i : T\"\n\n| WTrtBinOpEq\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2 \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>Eq\\<guillemotright> e\\<^sub>2 : Boolean\"\n\n| WTrtBinOpAdd\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Integer;  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : Integer \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>Add\\<guillemotright> e\\<^sub>2 : Integer\"\n\n| WTrtLAss\\<^sub>1:\n  \"\\<lbrakk> E!i = T; i < size E; P,E,h,sh \\<turnstile>\\<^sub>1 e : T';  P \\<turnstile> T' \\<le> T \\<rbrakk>\n   \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\"\n\n| WTrtFAcc\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C; P \\<turnstile> C has F,NonStatic:T in D \\<rbrakk> \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\"\n\n| WTrtFAccNT\\<^sub>1:\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e : NT \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\"\n\n| WTrtSFAcc\\<^sub>1:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:T in D \\<rbrakk> \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\"\n\n| WTrtFAss\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;  P \\<turnstile> C has F,NonStatic:T in D; P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;  P \\<turnstile> T\\<^sub>2 \\<le> T \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2 : Void\"\n\n| WTrtFAssNT\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1:NT; P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2 \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2 : Void\"\n\n| WTrtSFAss\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2; P \\<turnstile> C has F,Static:T in D; P \\<turnstile> T\\<^sub>2 \\<le> T \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2 : Void\"\n\n| WTrtCall\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C; P \\<turnstile> C sees M,NonStatic:Ts \\<rightarrow> T = m in D;\n     P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts'; P \\<turnstile> Ts' [\\<le>] Ts \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\"\n\n| WTrtCallNT\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : NT; P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\"\n\n| WTrtSCall\\<^sub>1:\n  \"\\<lbrakk> P \\<turnstile> C sees M,Static:Ts \\<rightarrow> T = m in D;\n     P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts'; P \\<turnstile> Ts' [\\<le>] Ts;\n     M = clinit \\<longrightarrow> sh D = \\<lfloor>(sfs,Processing)\\<rfloor> \\<and> es = map Val vs \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\"\n\n| WTrtBlock\\<^sub>1:\n  \"P,E@[T],h,sh \\<turnstile>\\<^sub>1 e : T'  \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\"\n\n| WTrtSeq\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1:T\\<^sub>1;  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2:T\\<^sub>2 \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;e\\<^sub>2 : T\\<^sub>2\"\n\n| WTrtCond\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1:T\\<^sub>1;  P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2:T\\<^sub>2;\n     P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or> P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1; P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow> T = T\\<^sub>2; P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow> T = T\\<^sub>1 \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1 else e\\<^sub>2 : T\"\n\n| WTrtWhile\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;  P,E,h,sh \\<turnstile>\\<^sub>1 c:T \\<rbrakk>\n  \\<Longrightarrow>  P,E,h,sh \\<turnstile>\\<^sub>1 while(e) c : Void\"\n\n| WTrtThrow\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : T\\<^sub>r; is_refT T\\<^sub>r \\<rbrakk> \\<Longrightarrow>\n  P,E,h,sh \\<turnstile>\\<^sub>1 throw e : T\"\n\n| WTrtTry\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;  P,E@[Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2; P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1 catch(C i) e\\<^sub>2 : T\\<^sub>2\"\n\n| WTrtInit\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : T; \\<forall>C' \\<in> set (C#Cs). is_class P C'; \\<not>sub_RI e;\n     \\<forall>C' \\<in> set (tl Cs). \\<exists>sfs. sh C' = \\<lfloor>(sfs,Processing)\\<rfloor>;\n     b \\<longrightarrow> (\\<forall>C' \\<in> set Cs. \\<exists>sfs. sh C' = \\<lfloor>(sfs,Processing)\\<rfloor>);\n     distinct Cs; supercls_lst P Cs \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 INIT C (Cs, b) \\<leftarrow> e : T\"\n\n| WTrtRI\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : T; P,E,h,sh \\<turnstile>\\<^sub>1 e' : T'; \\<forall>C' \\<in> set (C#Cs). is_class P C'; \\<not>sub_RI e';\n     \\<forall>C' \\<in> set (C#Cs). not_init C' e;\n     \\<forall>C' \\<in> set Cs. \\<exists>sfs. sh C' = \\<lfloor>(sfs,Processing)\\<rfloor>;\n     \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<or> (sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<and> e = THROW NoClassDefFoundError);\n     distinct (C#Cs); supercls_lst P (C#Cs) \\<rbrakk>\n  \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 RI(C, e);Cs \\<leftarrow> e' : T'\"\n\n\\<comment> \\<open>well-typed expression lists\\<close>\n\n| WTrtNil\\<^sub>1:\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\"\n\n| WTrtCons\\<^sub>1:\n  \"\\<lbrakk> P,E,h,sh \\<turnstile>\\<^sub>1 e : T;  P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts \\<rbrakk>\n  \\<Longrightarrow>  P,E,h,sh \\<turnstile>\\<^sub>1 e#es [:] T#Ts\""], ["", "(*<*)"], ["", "declare WTrt\\<^sub>1_WTrts\\<^sub>1.intros[intro!] WTrtNil\\<^sub>1[iff]"], ["", "declare\n  WTrtFAcc\\<^sub>1[rule del] WTrtFAccNT\\<^sub>1[rule del] WTrtSFAcc\\<^sub>1[rule del]\n  WTrtFAss\\<^sub>1[rule del] WTrtFAssNT\\<^sub>1[rule del] WTrtSFAss\\<^sub>1[rule del]\n  WTrtCall\\<^sub>1[rule del] WTrtCallNT\\<^sub>1[rule del] WTrtSCall\\<^sub>1[rule del]"], ["", "lemmas WTrt\\<^sub>1_induct = WTrt\\<^sub>1_WTrts\\<^sub>1.induct [split_format (complete)]\n  and WTrt\\<^sub>1_inducts = WTrt\\<^sub>1_WTrts\\<^sub>1.inducts [split_format (complete)]"], ["", "(*>*)\n\n(*<*)"], ["", "inductive_cases WTrt\\<^sub>1_elim_cases[elim!]:\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 Val v : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 Var i : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 v :=e : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 {i:U; e} : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;e\\<^sub>2 : T\\<^sub>2\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1 else e\\<^sub>2 : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 while(e) c : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 throw e : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1 catch(C V) e\\<^sub>2 : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 Cast D e : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} := v : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := v : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 new C : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M{D}(es) : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM{D}(es) : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 INIT C (Cs,b) \\<leftarrow> e : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 RI(C,e);Cs \\<leftarrow> e' : T\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] Ts\"\n  \"P,E,h,sh \\<turnstile>\\<^sub>1 e#es [:] Ts\""], ["", "(*>*)"], ["", "lemma WT\\<^sub>1_implies_WTrt\\<^sub>1: \"P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e : T\"\nand WTs\\<^sub>1_implies_WTrts\\<^sub>1: \"P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow>\n     P,E,h,sh \\<turnstile>\\<^sub>1 e : T) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow>\n     P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile>\\<^sub>1 e :: T \\<Longrightarrow>\n     P,E,h,sh \\<turnstile>\\<^sub>1 e : T) &&&\n    (P,E \\<turnstile>\\<^sub>1 es [::] Ts \\<Longrightarrow>\n     P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts)", "apply(induct rule: WT\\<^sub>1_WTs\\<^sub>1_inducts)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>C E.\n       is_class P C \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 new C : Class C\n 2. \\<And>E e D C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class D; is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Cast C e : Class C\n 3. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 Val v : T\n 4. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Var i : T\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 6. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 7. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 8. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 9. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 10. \\<And>C F T D E e\\<^sub>2 T'.\n        \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n         P \\<turnstile> T' \\<le> T\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\nA total of 20 subgoals...", "apply fast"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>E e D C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class D;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class D; is_class P C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<or>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Cast C e : Class C\n 2. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 Val v : T\n 3. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Var i : T\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 5. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 6. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 7. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 8. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 9. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 10. \\<And>E e C M Ts' T m D es Ts.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n         P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n         P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n         P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\nA total of 19 subgoals...", "apply (fast)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>v T E.\n       typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 Val v : T\n 2. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Var i : T\n 3. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 4. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 5. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 6. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 7. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 8. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 9. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 10. \\<And>C M Ts T m D E es Ts'.\n        \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n         P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n         P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\nA total of 18 subgoals...", "apply(fastforce dest:typeof_lit_typeof)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>E i T.\n       \\<lbrakk>E ! i = T; i < length E\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 Var i : T\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 3. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 4. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 5. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 6. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 7. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 8. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 9. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 10. \\<And>T E e T' i.\n        \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n         P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\nA total of 17 subgoals...", "apply(fast)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 2. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 3. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 4. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 6. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 7. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 8. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 9. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                          e\\<^sub>2 : T\\<^sub>2\nA total of 16 subgoals...", "apply(rename_tac E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 2. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 3. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 4. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 6. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 7. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 8. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 9. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                          e\\<^sub>2 : T\\<^sub>2\nA total of 16 subgoals...", "apply(case_tac bop)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        bop = Eq\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        bop = Add\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 3. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 4. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 5. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 6. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 7. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 8. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 9. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 10. \\<And>T E e T' i.\n        \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n         P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\nA total of 17 subgoals...", "apply(fastforce)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        case bop of\n        Eq \\<Rightarrow>\n          (P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n           P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1) \\<and>\n          T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        bop = Add\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 2. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 3. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 4. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 5. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 6. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 7. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 8. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 9. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                          e\\<^sub>2 : T\\<^sub>2\nA total of 16 subgoals...", "apply(fastforce)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>E i T e T'.\n       \\<lbrakk>E ! i = T; i < length E; P,E \\<turnstile>\\<^sub>1 e :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 i:=e : Void\n 2. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 3. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 4. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 5. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 6. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 7. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 8. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 10. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n         P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n         P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n         P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n         P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n         T = T\\<^sub>2;\n         P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n         T = T\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                          else e\\<^sub>2 : T\nA total of 15 subgoals...", "apply(fastforce)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>E e C F T D.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>F{D} : T\n 2. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 3. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 4. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 5. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 6. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 7. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 9. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 10. \\<And>E e c T.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n         P,E \\<turnstile>\\<^sub>1 c :: T;\n         P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\nA total of 14 subgoals...", "apply(meson WTrtFAcc\\<^sub>1 has_visible_field)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>C F T D E.\n       P \\<turnstile> C sees F,Static:T in D \\<Longrightarrow>\n       P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} : T\n 2. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 3. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 4. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 5. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 6. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 8. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 9. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 10. \\<And>E e C.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\nA total of 13 subgoals...", "apply(meson WTrtSFAcc\\<^sub>1 has_visible_field)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>E e\\<^sub>1 C F T D e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : Class C;\n        P \\<turnstile> C sees F,NonStatic:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2 : Void\n 2. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 3. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 4. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 5. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 7. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 8. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 9. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 10. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n         P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n         P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n         is_class P C\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                          catch(C i) e\\<^sub>2 : T\nA total of 12 subgoals...", "apply(meson WTrtFAss\\<^sub>1 has_visible_field)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>C F T D E e\\<^sub>2 T'.\n       \\<lbrakk>P \\<turnstile> C sees F,Static:T in D;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T';\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2 : Void\n 2. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 3. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 4. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 6. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 7. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 8. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 9. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 10. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\nA total of 11 subgoals...", "apply(meson WTrtSFAss\\<^sub>1 has_visible_field)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>E e C M Ts' T m D es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C;\n        P \\<turnstile> C sees M, NonStatic :  Ts'\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<bullet>M(es) : T\n 2. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 3. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 5. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 6. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 7. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 8. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 9. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 10. \\<And>E e T es Ts.\n        \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n         P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n         P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n         P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n        \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce simp: WTrtCall\\<^sub>1)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>C M Ts T m D E es Ts'.\n       \\<lbrakk>P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts';\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; M \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sM(es) : T\n 2. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 3. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 4. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 5. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 6. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 7. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 8. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 9. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce simp: WTrtSCall\\<^sub>1)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>T E e T' i.\n       \\<lbrakk>is_type P T; P,E @ [T] \\<turnstile>\\<^sub>1 e :: T';\n        P,E @ [T],h,sh \\<turnstile>\\<^sub>1 e : T'\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 {i:T; e} : T'\n 2. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 3. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 4. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 5. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 6. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 7. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 8. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 2. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 3. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 4. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 5. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 6. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 7. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>E e e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T\\<^sub>1;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T\\<^sub>1;\n        P,E \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T\\<^sub>2;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<or>\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1;\n        P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>2 \\<longrightarrow>\n        T = T\\<^sub>2;\n        P \\<turnstile> T\\<^sub>2 \\<le> T\\<^sub>1 \\<longrightarrow>\n        T = T\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 2. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 3. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 4. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 5. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 6. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce simp: WTrtCond\\<^sub>1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>E e c T.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Boolean;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Boolean;\n        P,E \\<turnstile>\\<^sub>1 c :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 c : T\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 while (e) c : Void\n 2. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 3. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 4. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 5. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>E e C.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: Class C;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : Class C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 throw e : Void\n 2. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 3. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 4. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>E e\\<^sub>1 T C e\\<^sub>2 i.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e\\<^sub>1 :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e\\<^sub>1 : T;\n        P,E @ [Class C] \\<turnstile>\\<^sub>1 e\\<^sub>2 :: T;\n        P,E @ [Class C],h,sh \\<turnstile>\\<^sub>1 e\\<^sub>2 : T;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 try e\\<^sub>1\n                         catch(C i) e\\<^sub>2 : T\n 2. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 3. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>E. P,E,h,sh \\<turnstile>\\<^sub>1 [] [:] []\n 2. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>E e T es Ts.\n       \\<lbrakk>P,E \\<turnstile>\\<^sub>1 e :: T;\n        P,E,h,sh \\<turnstile>\\<^sub>1 e : T;\n        P,E \\<turnstile>\\<^sub>1 es [::] Ts;\n        P,E,h,sh \\<turnstile>\\<^sub>1 es [:] Ts\\<rbrakk>\n       \\<Longrightarrow> P,E,h,sh \\<turnstile>\\<^sub>1 e # es [:] T # Ts", "apply(fast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open> Well-formedness\\<close>\n\n\\<comment> \\<open>Indices in blocks increase by 1\\<close>"], ["", "primrec \\<B> :: \"expr\\<^sub>1 \\<Rightarrow> nat \\<Rightarrow> bool\"\n  and \\<B>s :: \"expr\\<^sub>1 list \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"\\<B> (new C) i = True\" |\n\"\\<B> (Cast C e) i = \\<B> e i\" |\n\"\\<B> (Val v) i = True\" |\n\"\\<B> (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) i = (\\<B> e\\<^sub>1 i \\<and> \\<B> e\\<^sub>2 i)\" |\n\"\\<B> (Var j) i = True\" |\n\"\\<B> (e\\<bullet>F{D}) i = \\<B> e i\" |\n\"\\<B> (C\\<bullet>\\<^sub>sF{D}) i = True\" |\n\"\\<B> (j:=e) i = \\<B> e i\" |\n\"\\<B> (e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2) i = (\\<B> e\\<^sub>1 i \\<and> \\<B> e\\<^sub>2 i)\" |\n\"\\<B> (C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2) i = \\<B> e\\<^sub>2 i\" |\n\"\\<B> (e\\<bullet>M(es)) i = (\\<B> e i \\<and> \\<B>s es i)\" |\n\"\\<B> (C\\<bullet>\\<^sub>sM(es)) i = \\<B>s es i\" |\n\"\\<B> ({j:T ; e}) i = (i = j \\<and> \\<B> e (i+1))\" |\n\"\\<B> (e\\<^sub>1;;e\\<^sub>2) i = (\\<B> e\\<^sub>1 i \\<and> \\<B> e\\<^sub>2 i)\" |\n\"\\<B> (if (e) e\\<^sub>1 else e\\<^sub>2) i = (\\<B> e i \\<and> \\<B> e\\<^sub>1 i \\<and> \\<B> e\\<^sub>2 i)\" |\n\"\\<B> (throw e) i = \\<B> e i\" |\n\"\\<B> (while (e) c) i = (\\<B> e i \\<and> \\<B> c i)\" |\n\"\\<B> (try e\\<^sub>1 catch(C j) e\\<^sub>2) i = (\\<B> e\\<^sub>1 i \\<and> i=j \\<and> \\<B> e\\<^sub>2 (i+1))\" |\n\"\\<B> (INIT C (Cs,b) \\<leftarrow> e) i = \\<B> e i\" |\n\"\\<B> (RI(C,e);Cs \\<leftarrow> e') i = (\\<B> e i \\<and> \\<B> e' i)\" |\n\n\"\\<B>s [] i = True\" |\n\"\\<B>s (e#es) i = (\\<B> e i \\<and> \\<B>s es i)\""], ["", "definition wf_J\\<^sub>1_mdecl :: \"J\\<^sub>1_prog \\<Rightarrow> cname \\<Rightarrow> expr\\<^sub>1 mdecl \\<Rightarrow> bool\"\nwhere\n  \"wf_J\\<^sub>1_mdecl P C  \\<equiv>  \\<lambda>(M,b,Ts,T,body).\n    \\<not>sub_RI body \\<and>\n (case b of\n    NonStatic \\<Rightarrow>\n        (\\<exists>T'. P,Class C#Ts \\<turnstile>\\<^sub>1 body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n        \\<D> body \\<lfloor>{..size Ts}\\<rfloor> \\<and> \\<B> body (size Ts + 1)\n  | Static \\<Rightarrow> (\\<exists>T'. P,Ts \\<turnstile>\\<^sub>1 body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n        \\<D> body \\<lfloor>{..<size Ts}\\<rfloor> \\<and> \\<B> body (size Ts))\""], ["", "lemma wf_J\\<^sub>1_mdecl_NonStatic[simp]:\n  \"wf_J\\<^sub>1_mdecl P C (M,NonStatic,Ts,T,body) \\<equiv>\n    (\\<not>sub_RI body \\<and>\n    (\\<exists>T'. P,Class C#Ts \\<turnstile>\\<^sub>1 body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n     \\<D> body \\<lfloor>{..size Ts}\\<rfloor> \\<and> \\<B> body (size Ts + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J\\<^sub>1_mdecl P C (M, NonStatic, Ts, T, body) \\<equiv>\n    \\<not> sub_RI body \\<and>\n    (\\<exists>T'.\n        P,Class C # Ts \\<turnstile>\\<^sub>1 body :: T' \\<and>\n        P \\<turnstile> T' \\<le> T) \\<and>\n    \\<D> body \\<lfloor>{..length Ts}\\<rfloor> \\<and>\n    \\<B> body (length Ts + 1)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J\\<^sub>1_mdecl P C (M, NonStatic, Ts, T, body) \\<equiv>\n    \\<not> sub_RI body \\<and>\n    (\\<exists>T'.\n        P,Class C # Ts \\<turnstile>\\<^sub>1 body :: T' \\<and>\n        P \\<turnstile> T' \\<le> T) \\<and>\n    \\<D> body \\<lfloor>{..length Ts}\\<rfloor> \\<and>\n    \\<B> body (length Ts + 1)", "by (simp add:wf_J\\<^sub>1_mdecl_def)"], ["", "(*>*)"], ["", "lemma wf_J\\<^sub>1_mdecl_Static[simp]:\n  \"wf_J\\<^sub>1_mdecl P C (M,Static,Ts,T,body) \\<equiv>\n    (\\<not>sub_RI body \\<and>\n    (\\<exists>T'. P,Ts \\<turnstile>\\<^sub>1 body :: T' \\<and> P \\<turnstile> T' \\<le> T) \\<and>\n     \\<D> body \\<lfloor>{..<size Ts}\\<rfloor> \\<and> \\<B> body (size Ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J\\<^sub>1_mdecl P C (M, Static, Ts, T, body) \\<equiv>\n    \\<not> sub_RI body \\<and>\n    (\\<exists>T'.\n        P,Ts \\<turnstile>\\<^sub>1 body :: T' \\<and>\n        P \\<turnstile> T' \\<le> T) \\<and>\n    \\<D> body \\<lfloor>{..<length Ts}\\<rfloor> \\<and> \\<B> body (length Ts)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_J\\<^sub>1_mdecl P C (M, Static, Ts, T, body) \\<equiv>\n    \\<not> sub_RI body \\<and>\n    (\\<exists>T'.\n        P,Ts \\<turnstile>\\<^sub>1 body :: T' \\<and>\n        P \\<turnstile> T' \\<le> T) \\<and>\n    \\<D> body \\<lfloor>{..<length Ts}\\<rfloor> \\<and> \\<B> body (length Ts)", "by (simp add:wf_J\\<^sub>1_mdecl_def)"], ["", "(*>*)"], ["", "abbreviation \"wf_J\\<^sub>1_prog == wf_prog wf_J\\<^sub>1_mdecl\""], ["", "lemma sees_wf\\<^sub>1_nsub_RI:\n \"\\<lbrakk> wf_J\\<^sub>1_prog P; P \\<turnstile> C sees M,b : Ts\\<rightarrow>T = body in D \\<rbrakk> \\<Longrightarrow> \\<not>sub_RI body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J\\<^sub>1_prog P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = body in D\\<rbrakk>\n    \\<Longrightarrow> \\<not> sub_RI body", "apply(drule sees_wf_mdecl, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = body in D;\n     wf_mdecl wf_J\\<^sub>1_mdecl P D (M, b, Ts, T, body)\\<rbrakk>\n    \\<Longrightarrow> \\<not> sub_RI body", "apply(unfold wf_J\\<^sub>1_mdecl_def wf_mdecl_def, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf\\<^sub>1_types_clinit:\nassumes wf:\"wf_prog wf_md P\" and ex: \"class P C = Some a\" and proc: \"sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\"\nshows \"P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "from ex"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>a\\<rfloor>", "obtain D fs ms where \"a = (D,fs,ms)\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D fs ms.\n        a = (D, fs, ms) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (D, fs, ms)\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "then"], ["proof (chain)\npicking this:\n  a = (D, fs, ms)", "have sP: \"(C, D, fs, ms) \\<in> set P\""], ["proof (prove)\nusing this:\n  a = (D, fs, ms)\n\ngoal (1 subgoal):\n 1. (C, D, fs, ms) \\<in> set P", "using ex map_of_SomeD[of P C a]"], ["proof (prove)\nusing this:\n  a = (D, fs, ms)\n  class P C = \\<lfloor>a\\<rfloor>\n  map_of P C = \\<lfloor>a\\<rfloor> \\<Longrightarrow> (C, a) \\<in> set P\n\ngoal (1 subgoal):\n 1. (C, D, fs, ms) \\<in> set P", "by(simp add: class_def)"], ["proof (state)\nthis:\n  (C, D, fs, ms) \\<in> set P\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "then"], ["proof (chain)\npicking this:\n  (C, D, fs, ms) \\<in> set P", "have \"wf_clinit ms\""], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set P\n\ngoal (1 subgoal):\n 1. wf_clinit ms", "using assms"], ["proof (prove)\nusing this:\n  (C, D, fs, ms) \\<in> set P\n  wf_prog wf_md P\n  class P C = \\<lfloor>a\\<rfloor>\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. wf_clinit ms", "by(unfold wf_prog_def wf_cdecl_def, auto)"], ["proof (state)\nthis:\n  wf_clinit ms\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "then"], ["proof (chain)\npicking this:\n  wf_clinit ms", "obtain m where sm: \"(clinit, Static, [], Void, m) \\<in> set ms\""], ["proof (prove)\nusing this:\n  wf_clinit ms\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        (clinit, Static, [], Void, m) \\<in> set ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(unfold wf_clinit_def) auto"], ["proof (state)\nthis:\n  (clinit, Static, [], Void, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "then"], ["proof (chain)\npicking this:\n  (clinit, Static, [], Void, m) \\<in> set ms", "have \"P \\<turnstile> C sees clinit,Static:[] \\<rightarrow> Void = m in C\""], ["proof (prove)\nusing this:\n  (clinit, Static, [], Void, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C", "using mdecl_visible[OF wf sP sm]"], ["proof (prove)\nusing this:\n  (clinit, Static, [], Void, m) \\<in> set ms\n  P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "using WTrtSCall\\<^sub>1 proc"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees clinit, Static :  []\\<rightarrow>Void = m in C\n  \\<lbrakk>?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   ?P,?E,?h,?sh \\<turnstile>\\<^sub>1 ?es [:] ?Ts';\n   ?P \\<turnstile> ?Ts' [\\<le>] ?Ts;\n   ?M = clinit \\<longrightarrow>\n   ?sh ?D = \\<lfloor>(?sfs, Processing)\\<rfloor> \\<and>\n   ?es = map Val ?vs\\<rbrakk>\n  \\<Longrightarrow> ?P,?E,?h,?sh \\<turnstile>\\<^sub>1 ?C\\<bullet>\\<^sub>s?M(?es) : ?T\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void", "by blast"], ["proof (state)\nthis:\n  P,E,h,sh \\<turnstile>\\<^sub>1 C\\<bullet>\\<^sub>sclinit([]) : Void\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes wf: \"wf_J\\<^sub>1_prog P\"\nshows eval\\<^sub>1_proc_pres: \"P \\<turnstile>\\<^sub>1 \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_init C e \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\"\n  and evals\\<^sub>1_proc_pres: \"P \\<turnstile>\\<^sub>1 \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_inits C es \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n(h, l, sh)\\<rangle> \\<Rightarrow>\n                                     \\<langle>e',(h', l', sh')\\<rangle>;\n      not_init C e;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>) &&&\n    (\\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>es,\n(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                                     \\<langle>es',(h', l', sh')\\<rangle>;\n      not_inits C es;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n(h, l, sh)\\<rangle> \\<Rightarrow>\n                                     \\<langle>e',(h', l', sh')\\<rangle>;\n      not_init C e;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>) &&&\n    (\\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>es,\n(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                                     \\<langle>es',(h', l', sh')\\<rangle>;\n      not_inits C es;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "proof(induct rule:eval\\<^sub>1_evals\\<^sub>1_inducts)"], ["proof (state)\ngoal (80 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 80 subgoals...", "case Call\\<^sub>1"], ["proof (state)\nthis:\n  P \\<turnstile>\\<^sub>1 \\<langle>e_,\n                          (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                         \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>es_,\n                          (ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C es_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = body_ in D_\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = Addr ab___ # vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(es_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (80 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 80 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e_,\n                          (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                         \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>es_,\n                          (ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C es_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = body_ in D_\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = Addr ab___ # vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(es_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e_,\n                          (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                         \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>es_,\n                          (ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C es_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = body_ in D_\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = Addr ab___ # vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(es_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using sees_wf\\<^sub>1_nsub_RI[OF wf Call\\<^sub>1.hyps(6)] nsub_RI_not_init"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e_,\n                          (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                         \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>es_,\n                          (ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C es_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = body_ in D_\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = Addr ab___ # vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(es_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body_\n  \\<not> sub_RI ?e \\<Longrightarrow> not_init ?C ?e\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (79 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 79 subgoals...", "next"], ["proof (state)\ngoal (79 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 79 subgoals...", "case (SCallInit\\<^sub>1 ps h l sh vs h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 C' M Ts T body D v' h\\<^sub>2 l\\<^sub>2 sh\\<^sub>2 l\\<^sub>2' e' h\\<^sub>3 l\\<^sub>3 sh\\<^sub>3)"], ["proof (state)\nthis:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs,\n                          (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = body in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                          (h\\<^sub>1, l\\<^sub>1,\n                           sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v',\n                          (h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length Ts\n  l\\<^sub>2' = vs @ replicate (max_vars body) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body,\n                          (h\\<^sub>2, l\\<^sub>2',\n                           sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                         \\<langle>e',\n                          (h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (79 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 79 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs,\n                          (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = body in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                          (h\\<^sub>1, l\\<^sub>1,\n                           sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v',\n                          (h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length Ts\n  l\\<^sub>2' = vs @ replicate (max_vars body) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body,\n                          (h\\<^sub>2, l\\<^sub>2',\n                           sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                         \\<langle>e',\n                          (h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs,\n                          (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = body in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                          (h\\<^sub>1, l\\<^sub>1,\n                           sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v',\n                          (h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length Ts\n  l\\<^sub>2' = vs @ replicate (max_vars body) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body,\n                          (h\\<^sub>2, l\\<^sub>2',\n                           sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                         \\<langle>e',\n                          (h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using SCallInit\\<^sub>1 sees_wf\\<^sub>1_nsub_RI[OF wf SCallInit\\<^sub>1.hyps(3)] nsub_RI_not_init[of body]"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs,\n                          (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = body in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                          (h\\<^sub>1, l\\<^sub>1,\n                           sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v',\n                          (h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length Ts\n  l\\<^sub>2' = vs @ replicate (max_vars body) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body,\n                          (h\\<^sub>2, l\\<^sub>2',\n                           sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                         \\<langle>e',\n                          (h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs,\n                          (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = body in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                          (h\\<^sub>1, l\\<^sub>1,\n                           sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v',\n                          (h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length Ts\n  l\\<^sub>2' = vs @ replicate (max_vars body) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body,\n                          (h\\<^sub>2, l\\<^sub>2',\n                           sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                         \\<langle>e',\n                          (h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body\n  \\<not> sub_RI body \\<Longrightarrow> not_init ?C body\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (78 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 78 subgoals...", "next"], ["proof (state)\ngoal (78 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 78 subgoals...", "case SCall\\<^sub>1"], ["proof (state)\nthis:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps_,\n                          (a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = body_ in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (78 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 78 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps_,\n                          (a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = body_ in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps_,\n                          (a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = body_ in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using sees_wf\\<^sub>1_nsub_RI[OF wf SCall\\<^sub>1.hyps(3)] nsub_RI_not_init"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>ps_,\n                          (a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                         \\<langle>map Val vs_,\n                          (h\\<^sub>2_, ls\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = body_ in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length Ts_\n  ls\\<^sub>2'_ = vs_ @ replicate (max_vars body_) undefined\n  P \\<turnstile>\\<^sub>1 \\<langle>body_,\n                          (h\\<^sub>2_, ls\\<^sub>2'_,\n                           sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                         \\<langle>e'_,\n                          (h\\<^sub>3_, ls\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body_\n  \\<not> sub_RI ?e \\<Longrightarrow> not_init ?C ?e\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (77 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 77 subgoals...", "next"], ["proof (state)\ngoal (77 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 77 subgoals...", "case (InitNone\\<^sub>1 sh C1 C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C1 = None\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (C1 # Cs,False) \\<leftarrow> h,\n                          (l, e', sh(C1 \\<mapsto>\n                           (sblank P C1, Prepared)))\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs.\n      (sh(C1 \\<mapsto> (sblank P C1, Prepared))) C =\n      \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (77 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 77 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = None\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (C1 # Cs,False) \\<leftarrow> h,\n                          (l, e', sh(C1 \\<mapsto>\n                           (sblank P C1, Prepared)))\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs.\n      (sh(C1 \\<mapsto> (sblank P C1, Prepared))) C =\n      \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = None\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (C1 # Cs,False) \\<leftarrow> h,\n                          (l, e', sh(C1 \\<mapsto>\n                           (sblank P C1, Prepared)))\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs.\n      (sh(C1 \\<mapsto> (sblank P C1, Prepared))) C =\n      \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (76 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 76 subgoals...", "next"], ["proof (state)\ngoal (76 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 76 subgoals...", "case (InitDone\\<^sub>1 sh C sfs C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (76 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 76 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (75 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 75 subgoals...", "next"], ["proof (state)\ngoal (75 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 75 subgoals...", "case (InitProcessing\\<^sub>1 sh C sfs C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (75 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 75 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (74 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 74 subgoals...", "next"], ["proof (state)\ngoal (74 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 74 subgoals...", "case (InitError\\<^sub>1 sh C1 sfs Cs h l e' a a b C')"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>(sfs, Error)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (C1,THROW\n    NoClassDefFoundError) ; Cs \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, C')\\<rangle>\n  \\<lbrakk>not_init C\n            (RI (C1,THROW NoClassDefFoundError) ; Cs \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C'_ (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (74 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 74 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>(sfs, Error)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (C1,THROW\n    NoClassDefFoundError) ; Cs \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, C')\\<rangle>\n  \\<lbrakk>not_init C\n            (RI (C1,THROW NoClassDefFoundError) ; Cs \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C'_ (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>(sfs, Error)\\<rfloor>\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (C1,THROW\n    NoClassDefFoundError) ; Cs \\<leftarrow> h,\n                          (l, e', sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, C')\\<rangle>\n  \\<lbrakk>not_init C\n            (RI (C1,THROW NoClassDefFoundError) ; Cs \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C'_ (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. C' C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (73 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 73 subgoals...", "next"], ["proof (state)\ngoal (73 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 73 subgoals...", "case (InitObject\\<^sub>1 sh C1 sfs sh' C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 = Object\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (C1 # Cs,True) \\<leftarrow> h,\n                          (l, e', sh')\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (73 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 73 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 = Object\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (C1 # Cs,True) \\<leftarrow> h,\n                          (l, e', sh')\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 = Object\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (C1 # Cs,True) \\<leftarrow> h,\n                          (l, e', sh')\\<rangle> \\<Rightarrow>\n                         \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (72 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 72 subgoals...", "next"], ["proof (state)\ngoal (72 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 72 subgoals...", "case (InitNonObject\\<^sub>1 sh C1 sfs D a b sh' C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 \\<noteq> Object\n  class P C1 = \\<lfloor>(D, a__, b__)\\<rfloor>\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (D #\n     C1 # Cs,False) \\<leftarrow> h,\n                          (l, e', sh')\\<rangle> \\<Rightarrow>\n                         \\<langle>aa__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (D # C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (72 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 72 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 \\<noteq> Object\n  class P C1 = \\<lfloor>(D, a__, b__)\\<rfloor>\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (D #\n     C1 # Cs,False) \\<leftarrow> h,\n                          (l, e', sh')\\<rangle> \\<Rightarrow>\n                         \\<langle>aa__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (D # C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 \\<noteq> Object\n  class P C1 = \\<lfloor>(D, a__, b__)\\<rfloor>\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (D #\n     C1 # Cs,False) \\<leftarrow> h,\n                          (l, e', sh')\\<rangle> \\<Rightarrow>\n                         \\<langle>aa__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (D # C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (71 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 71 subgoals...", "next"], ["proof (state)\ngoal (71 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 71 subgoals...", "case (RInit\\<^sub>1 e a a b v h' l' sh' C sfs i sh'' C' Cs e\\<^sub>1 a a b)"], ["proof (state)\nthis:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(a__, aa__, b__)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>ab__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C,e) ; Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (71 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 71 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(a__, aa__, b__)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>ab__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C,e) ; Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(a__, aa__, b__)\\<rangle> \\<Rightarrow>\n                         \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  P \\<turnstile>\\<^sub>1 \\<langle>INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>ab__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C,e) ; Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (70 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 70 subgoals...", "next"], ["proof (state)\ngoal (70 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 70 subgoals...", "case (RInitInitFail\\<^sub>1 e h l sh a h' l' sh' C1 sfs i sh'' D Cs e\\<^sub>1 h1 l1 sh1)"], ["proof (state)\nthis:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (D,throw\n   a) ; Cs \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (70 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 70 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (D,throw\n   a) ; Cs \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (D,throw\n   a) ; Cs \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using eval\\<^sub>1_final"], ["proof (prove)\nusing this:\n  P \\<turnstile>\\<^sub>1 \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                         \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile>\\<^sub>1 \\<langle>RI (D,throw\n   a) ; Cs \\<leftarrow> e\\<^sub>1,\n                          (h', l', sh'')\\<rangle> \\<Rightarrow>\n                         \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  ?P \\<turnstile>\\<^sub>1 \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                          \\<langle>?e',?s'\\<rangle> \\<Longrightarrow>\n  final ?e'\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (69 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile>\\<^sub>1 \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                                (h, l, sh)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile>\\<^sub>1 \\<langle>e,\n  (a, aa, b)\\<rangle> \\<Rightarrow>\n \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 69 subgoals...", "qed(auto)"], ["", "lemma clinit\\<^sub>1_proc_pres:\n  \"\\<lbrakk> wf_J\\<^sub>1_prog P; P \\<turnstile>\\<^sub>1 \\<langle>C\\<^sub>0\\<bullet>\\<^sub>sclinit([]),(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>;\n     sh C' = \\<lfloor>(sfs,Processing)\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs. sh' C' = \\<lfloor>(sfs,Processing)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_J\\<^sub>1_prog P;\n     P \\<turnstile>\\<^sub>1 \\<langle>C\\<^sub>0\\<bullet>\\<^sub>sclinit([]),\n                             (h, l, sh)\\<rangle> \\<Rightarrow>\n                            \\<langle>e',(h', l', sh')\\<rangle>;\n     sh C' = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sfs.\n                         sh' C' = \\<lfloor>(sfs, Processing)\\<rfloor>", "by(auto dest: eval\\<^sub>1_proc_pres)"], ["", "end"]]}