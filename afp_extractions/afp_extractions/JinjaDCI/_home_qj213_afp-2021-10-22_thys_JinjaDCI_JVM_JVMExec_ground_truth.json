{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/JVM/JVMExec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma exec_1_eq:\n  \"exec_1 P = {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\"", "lemma exec_1_iff:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' = (exec (P,\\<sigma>) = Some \\<sigma>')\"", "lemma exec_all_def:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' = ((\\<sigma>,\\<sigma>') \\<in> {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\\<^sup>*)\"", "lemma jvm_refl[iff]: \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>\"", "lemma jvm_trans[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\"", "lemma jvm_one_step1[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\"", "lemma jvm_one_step2[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\"", "lemma exec_all_conf:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<or> P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'\"", "lemma exec_1_exec_all_conf:\n \"\\<lbrakk> exec (P, \\<sigma>) = Some \\<sigma>'; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''; \\<sigma> \\<noteq> \\<sigma>'' \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\"", "lemma exec_all_finalD: \"P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow> \\<sigma> = (x, h, [], sh)\"", "lemma exec_all_deterministic:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x,h,[],sh); P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x,h,[],sh)\"", "lemma exec_Calling_prealloc_pres:\nassumes \"preallocated h\"\n  and \"exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh = (xp',h',frs',sh')\"\nshows \"preallocated h'\"", "lemma exec_step_prealloc_pres:\nassumes pre: \"preallocated h\"\n  and \"exec_step P h stk loc C M pc ics frs sh = (xp',h',frs',sh')\"\nshows \"preallocated h'\"", "lemma exec_prealloc_pres:\nassumes pre: \"preallocated h\"\n  and \"exec (P, xp, h, frs, sh) = Some(xp',h',frs',sh')\"\nshows \"preallocated h'\""], "translations": [["", "lemma exec_1_eq:\n  \"exec_1 P = {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_1 P =\n    {(\\<sigma>, \\<sigma>').\n     exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_1 P =\n    {(\\<sigma>, \\<sigma>').\n     exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}", "by (auto intro: exec_1I elim: exec_1.cases)"], ["", "(*>*)"], ["", "lemma exec_1_iff:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' = (exec (P,\\<sigma>) = Some \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' =\n    (exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' =\n    (exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>)", "by (simp add: exec_1_eq)"], ["", "(*>*)"], ["", "lemma exec_all_def:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' = ((\\<sigma>,\\<sigma>') \\<in> {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' =\n    ((\\<sigma>, \\<sigma>')\n     \\<in> {(\\<sigma>, \\<sigma>').\n            exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' =\n    ((\\<sigma>, \\<sigma>')\n     \\<in> {(\\<sigma>, \\<sigma>').\n            exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*)", "by (simp add: exec_all_def1 exec_1_eq)"], ["", "(*>*)"], ["", "lemma jvm_refl[iff]: \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>", "by(simp add: exec_all_def)"], ["", "(*>*)"], ["", "lemma jvm_trans[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "by(simp add: exec_all_def)"], ["", "(*>*)"], ["", "lemma jvm_one_step1[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "by (simp add: exec_all_def1)"], ["", "(*>*)"], ["", "lemma jvm_one_step2[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "by (simp add: exec_all_def1)"], ["", "(*>*)"], ["", "lemma exec_all_conf:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<or> P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      \\<sigma>'' \\<or>\n                      P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      \\<sigma>'' \\<or>\n                      P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'", "by(simp add: exec_all_def single_valued_def single_valued_confluent)"], ["", "(*>*)"], ["", "lemma exec_1_exec_all_conf:\n \"\\<lbrakk> exec (P, \\<sigma>) = Some \\<sigma>'; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''; \\<sigma> \\<noteq> \\<sigma>'' \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>;\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'';\n     \\<sigma> \\<noteq> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''", "by(auto elim: converse_rtranclE simp: exec_1_eq exec_all_def)"], ["", "lemma exec_all_finalD: \"P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow> \\<sigma> = (x, h, [], sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [], sh)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [], sh)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [], sh)", "assume \"P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma>\""], ["proof (state)\nthis:\n  P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [], sh)", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma>", "have \"((x, h, [], sh), \\<sigma>) \\<in> {(\\<sigma>, \\<sigma>'). exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma>\n\ngoal (1 subgoal):\n 1. ((x, h, [], sh), \\<sigma>)\n    \\<in> {(\\<sigma>, \\<sigma>').\n           exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*", "by(simp only: exec_all_def)"], ["proof (state)\nthis:\n  ((x, h, [], sh), \\<sigma>)\n  \\<in> {(\\<sigma>, \\<sigma>').\n         exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [], sh)", "then"], ["proof (chain)\npicking this:\n  ((x, h, [], sh), \\<sigma>)\n  \\<in> {(\\<sigma>, \\<sigma>').\n         exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  ((x, h, [], sh), \\<sigma>)\n  \\<in> {(\\<sigma>, \\<sigma>').\n         exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<sigma> = (x, h, [], sh)", "proof(rule converse_rtranclE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, h, [], sh) = \\<sigma> \\<Longrightarrow> \\<sigma> = (x, h, [], sh)\n 2. \\<And>y.\n       \\<lbrakk>((x, h, [], sh), y)\n                \\<in> {(\\<sigma>, \\<sigma>').\n                       exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>};\n        (y, \\<sigma>)\n        \\<in> {(\\<sigma>, \\<sigma>').\n               exec (P, \\<sigma>) =\n               \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (x, h, [], sh)", "qed simp+"], ["proof (state)\nthis:\n  \\<sigma> = (x, h, [], sh)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma exec_all_deterministic:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x,h,[],sh); P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x,h,[],sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, [], sh);\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      (x, h, [], sh)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, [], sh);\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      (x, h, [], sh)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, [], sh);\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      (x, h, [], sh)", "assume assms: \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x,h,[],sh)\" \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\""], ["proof (state)\nthis:\n  P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, [], sh)\n  P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, [], sh);\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      (x, h, [], sh)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [], sh)", "using exec_all_conf[OF assms]"], ["proof (prove)\nusing this:\n  P \\<turnstile> (x, h, [], sh) -jvm\\<rightarrow> \\<sigma>' \\<or>\n  P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [], sh)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [], sh)", "by(blast dest!: exec_all_finalD)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [], sh)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection \"Preservation of preallocated\""], ["", "lemma exec_Calling_prealloc_pres:\nassumes \"preallocated h\"\n  and \"exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh = (xp',h',frs',sh')\"\nshows \"preallocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preallocated h'", "using assms"], ["proof (prove)\nusing this:\n  preallocated h\n  exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n  (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "proof(cases \"sh C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     sh C = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<And>a.\n       \\<lbrakk>preallocated h;\n        exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n        (xp', h', frs', sh');\n        sh C = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> preallocated h'", "case (Some a)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     sh C = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<And>a.\n       \\<lbrakk>preallocated h;\n        exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n        (xp', h', frs', sh');\n        sh C = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>a\\<rfloor>", "obtain sfs i where sfsi:\"a = (sfs, i)\""], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i. a = (sfs, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (sfs, i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     sh C = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<And>a.\n       \\<lbrakk>preallocated h;\n        exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n        (xp', h', frs', sh');\n        sh C = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  a = (sfs, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sfs, i)\n\ngoal (1 subgoal):\n 1. preallocated h'", "using Some assms"], ["proof (prove)\nusing this:\n  a = (sfs, i)\n  sh C = \\<lfloor>a\\<rfloor>\n  preallocated h\n  exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n  (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "proof(cases i)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 3. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Prepared\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 4. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "case Prepared"], ["proof (state)\nthis:\n  i = Prepared\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 3. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Prepared\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 4. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  i = Prepared", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Prepared\n\ngoal (1 subgoal):\n 1. preallocated h'", "using sfsi Some assms"], ["proof (prove)\nusing this:\n  i = Prepared\n  a = (sfs, i)\n  sh C = \\<lfloor>a\\<rfloor>\n  preallocated h\n  exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n  (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(cases \"method P C clinit\", auto split: if_split_asm)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 3. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 3. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "case Error"], ["proof (state)\nthis:\n  i = Error\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 3. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  i = Error", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Error\n\ngoal (1 subgoal):\n 1. preallocated h'", "using sfsi Some assms"], ["proof (prove)\nusing this:\n  i = Error\n  a = (sfs, i)\n  sh C = \\<lfloor>a\\<rfloor>\n  preallocated h\n  exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n  (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(cases \"method P C clinit\", auto)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>a = (sfs, i); sh C = \\<lfloor>a\\<rfloor>; preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "qed(auto)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h;\n     exec_Calling C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh =\n     (xp', h', frs', sh');\n     sh C = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "qed(auto)"], ["", "lemma exec_step_prealloc_pres:\nassumes pre: \"preallocated h\"\n  and \"exec_step P h stk loc C M pc ics frs sh = (xp',h',frs',sh')\"\nshows \"preallocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preallocated h'", "proof(cases ics)"], ["proof (state)\ngoal (4 subgoals):\n 1. ics = No_ics \\<Longrightarrow> preallocated h'\n 2. \\<And>x21 x22. ics = Calling x21 x22 \\<Longrightarrow> preallocated h'\n 3. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 4. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "case No_ics"], ["proof (state)\nthis:\n  ics = No_ics\n\ngoal (4 subgoals):\n 1. ics = No_ics \\<Longrightarrow> preallocated h'\n 2. \\<And>x21 x22. ics = Calling x21 x22 \\<Longrightarrow> preallocated h'\n 3. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 4. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  ics = No_ics", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = No_ics\n\ngoal (1 subgoal):\n 1. preallocated h'", "using exec_instr_prealloc_pres assms"], ["proof (prove)\nusing this:\n  ics = No_ics\n  \\<lbrakk>preallocated ?h;\n   exec_instr ?i ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh =\n   (?xp', ?h', ?frs', ?sh')\\<rbrakk>\n  \\<Longrightarrow> preallocated ?h'\n  preallocated h\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "by auto"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22. ics = Calling x21 x22 \\<Longrightarrow> preallocated h'\n 2. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 3. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x21 x22. ics = Calling x21 x22 \\<Longrightarrow> preallocated h'\n 2. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 3. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "case Calling"], ["proof (state)\nthis:\n  ics = Calling x21_ x22_\n\ngoal (3 subgoals):\n 1. \\<And>x21 x22. ics = Calling x21 x22 \\<Longrightarrow> preallocated h'\n 2. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 3. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  ics = Calling x21_ x22_", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Calling x21_ x22_\n\ngoal (1 subgoal):\n 1. preallocated h'", "using exec_Calling_prealloc_pres assms"], ["proof (prove)\nusing this:\n  ics = Calling x21_ x22_\n  \\<lbrakk>preallocated ?h;\n   exec_Calling ?C ?Cs ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?frs ?sh =\n   (?xp', ?h', ?frs', ?sh')\\<rbrakk>\n  \\<Longrightarrow> preallocated ?h'\n  preallocated h\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "by auto"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (2 subgoals):\n 1. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 2. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 2. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "case (Called Cs)"], ["proof (state)\nthis:\n  ics = Called Cs\n\ngoal (2 subgoals):\n 1. \\<And>x3. ics = Called x3 \\<Longrightarrow> preallocated h'\n 2. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  ics = Called Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called Cs\n\ngoal (1 subgoal):\n 1. preallocated h'", "using exec_instr_prealloc_pres assms"], ["proof (prove)\nusing this:\n  ics = Called Cs\n  \\<lbrakk>preallocated ?h;\n   exec_instr ?i ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh =\n   (?xp', ?h', ?frs', ?sh')\\<rbrakk>\n  \\<Longrightarrow> preallocated ?h'\n  preallocated h\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "case (Throwing Cs a)"], ["proof (state)\nthis:\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42. ics = Throwing x41 x42 \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  ics = Throwing Cs a", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. preallocated h'", "using assms"], ["proof (prove)\nusing this:\n  ics = Throwing Cs a\n  preallocated h\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_prealloc_pres:\nassumes pre: \"preallocated h\"\n  and \"exec (P, xp, h, frs, sh) = Some(xp',h',frs',sh')\"\nshows \"preallocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preallocated h'", "using assms"], ["proof (prove)\nusing this:\n  preallocated h\n  exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>\n\ngoal (1 subgoal):\n 1. preallocated h'", "proof(cases \"\\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []", "obtain f1 frs1 where frs: \"frs = f1#frs1\""], ["proof (prove)\nusing this:\n  \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\n\ngoal (1 subgoal):\n 1. (\\<And>f1 frs1.\n        frs = f1 # frs1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases frs, simp+)"], ["proof (state)\nthis:\n  frs = f1 # frs1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  frs = f1 # frs1", "obtain stk1 loc1 C1 M1 pc1 ics1 where f1: \"f1 = (stk1,loc1,C1,M1,pc1,ics1)\""], ["proof (prove)\nusing this:\n  frs = f1 # frs1\n\ngoal (1 subgoal):\n 1. (\\<And>stk1 loc1 C1 M1 pc1 ics1.\n        f1 = (stk1, loc1, C1, M1, pc1, ics1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases f1)"], ["proof (state)\nthis:\n  f1 = (stk1, loc1, C1, M1, pc1, ics1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "let ?i = \"instrs_of P C1 M1 ! pc1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "obtain xp2 h2 frs2 sh2\n     where exec_step: \"exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh = (xp2,h2,frs2,sh2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xp2 h2 frs2 sh2.\n        exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh =\n        (xp2, h2, frs2, sh2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh\")"], ["proof (state)\nthis:\n  exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh = (xp2, h2, frs2, sh2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "then"], ["proof (chain)\npicking this:\n  exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh = (xp2, h2, frs2, sh2)", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh = (xp2, h2, frs2, sh2)\n\ngoal (1 subgoal):\n 1. preallocated h'", "using exec_step_prealloc_pres[OF pre exec_step] f1 frs False assms"], ["proof (prove)\nusing this:\n  exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh = (xp2, h2, frs2, sh2)\n  preallocated h2\n  f1 = (stk1, loc1, C1, M1, pc1, ics1)\n  frs = f1 # frs1\n  \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\n  preallocated h\n  exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>\n\ngoal (1 subgoal):\n 1. preallocated h'", "proof(cases xp2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh =\n             (xp2, h2, frs2, sh2);\n     preallocated h2; f1 = (stk1, loc1, C1, M1, pc1, ics1); frs = f1 # frs1;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []; preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     xp2 = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<And>a.\n       \\<lbrakk>exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh =\n                (xp2, h2, frs2, sh2);\n        preallocated h2; f1 = (stk1, loc1, C1, M1, pc1, ics1);\n        frs = f1 # frs1;\n        \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = [];\n        preallocated h;\n        exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n        xp2 = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> preallocated h'", "case (Some a)"], ["proof (state)\nthis:\n  xp2 = \\<lfloor>a\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh =\n             (xp2, h2, frs2, sh2);\n     preallocated h2; f1 = (stk1, loc1, C1, M1, pc1, ics1); frs = f1 # frs1;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []; preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     xp2 = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'\n 2. \\<And>a.\n       \\<lbrakk>exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh =\n                (xp2, h2, frs2, sh2);\n        preallocated h2; f1 = (stk1, loc1, C1, M1, pc1, ics1);\n        frs = f1 # frs1;\n        \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = [];\n        preallocated h;\n        exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n        xp2 = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> preallocated h'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. preallocated h'", "using find_handler_prealloc_pres[OF pre, where a=a]\n            exec_step_prealloc_pres[OF pre]\n            exec_step f1 frs Some False assms"], ["proof (prove)\nusing this:\n  find_handler ?P a h ?frs ?sh = (?xp', ?h', ?frs', ?sh') \\<Longrightarrow>\n  preallocated ?h'\n  exec_step ?P h ?stk ?loc ?C ?M ?pc ?ics ?frs ?sh =\n  (?xp', ?h', ?frs', ?sh') \\<Longrightarrow>\n  preallocated ?h'\n  exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh = (xp2, h2, frs2, sh2)\n  f1 = (stk1, loc1, C1, M1, pc1, ics1)\n  frs = f1 # frs1\n  xp2 = \\<lfloor>a\\<rfloor>\n  \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\n  preallocated h\n  exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>\n\ngoal (1 subgoal):\n 1. preallocated h'", "by(auto split: bool.splits init_call_status.splits list.splits)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>exec_step P h stk1 loc1 C1 M1 pc1 ics1 frs1 sh =\n             (xp2, h2, frs2, sh2);\n     preallocated h2; f1 = (stk1, loc1, C1, M1, pc1, ics1); frs = f1 # frs1;\n     \\<nexists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []; preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     xp2 = None\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "qed(auto split: init_call_status.splits)"], ["proof (state)\nthis:\n  preallocated h'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h;\n     exec (P, xp, h, frs, sh) = \\<lfloor>(xp', h', frs', sh')\\<rfloor>;\n     \\<exists>x. xp = \\<lfloor>x\\<rfloor> \\<or> frs = []\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "qed(auto)"], ["", "subsection \"Start state\""], ["", "text \\<open> The @{term Start} class is defined based on a given initial class\n and method. It has two methods: one that calls the initial method in the\n initial class, which is called by the starting program, and @{term clinit},\n as required for the class to be well-formed. \\<close>"], ["", "definition start_method :: \"cname \\<Rightarrow> mname \\<Rightarrow> jvm_method mdecl\" where\n\"start_method C M = (start_m, Static, [], Void, (1,0,[Invokestatic C M 0,Return],[]))\""], ["", "abbreviation start_clinit :: \"jvm_method mdecl\" where\n\"start_clinit \\<equiv> (clinit, Static, [], Void, (1,0,[Push Unit,Return],[]))\""], ["", "definition start_class :: \"cname \\<Rightarrow> mname \\<Rightarrow> jvm_method cdecl\" where\n\"start_class C M = (Start, Object, [], [start_method C M, start_clinit])\""], ["", "text \\<open>\n  The start configuration of the JVM in program @{text P}:\n  in the start heap, we call the ``start'' method of the\n  ``Start''; this method performs @{text Invokestatic} on the\n  class and method given to create the start program's @{term Start} class.\n  This allows the initialization procedure to be called on the\n  initial class in a natural way before the initial method is performed. \n  There is no @{text this} pointer of the frame as @{term start} is @{term Static}.\n  The start sheap has every class pre-prepared; this decision is not\n  necessary.\n  The starting program includes the added @{term Start} class, given a \n  method @{text M} of class @{text C}, added to program @{text P}.\n\\<close>"], ["", "definition start_state :: \"jvm_prog \\<Rightarrow> jvm_state\" where\n  \"start_state P = (None, start_heap P, [([], [], Start, start_m, 0, No_ics)], start_sheap)\""], ["", "abbreviation start_prog :: \"jvm_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> jvm_prog\" where\n\"start_prog P C M \\<equiv> start_class C M # P\""], ["", "end"]]}