{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/J/SmallStep.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemmas blocks_induct = blocks.induct[split_format (complete)]", "lemma [simp]:\n  \"\\<lbrakk> size vs = size Vs; size Ts = size Vs \\<rbrakk> \\<Longrightarrow> fv(blocks(Vs,Ts,vs,e)) = fv e - set Vs\"", "lemma sub_RI_blocks_body[iff]: \"length vs = length pns \\<Longrightarrow> length Ts = length pns\n \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) \\<longleftrightarrow> sub_RI body\"", "lemma nicheck_SFAss_nonVal: \"val_of e\\<^sub>2 = None \\<Longrightarrow> \\<not>icheck P C' (C\\<bullet>\\<^sub>sF{D} := (e\\<^sub>2::'a exp))\"", "lemmas red_reds_induct = red_reds.induct [split_format (complete)]\n  and red_reds_inducts = red_reds.inducts [split_format (complete)]", "lemmas converse_rtrancl_induct3 =\n  converse_rtrancl_induct [of \"(ax, ay, az)\" \"(bx, by, bz)\", split_format (complete),\n    consumes 1, case_names refl step]", "lemma converse_rtrancl_induct_red[consumes 1]:\nassumes \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow>* \\<langle>e',(h',l',sh'),b'\\<rangle>\"\nand \"\\<And>e h l sh b. R e h l sh b e h l sh b\"\nand \"\\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk> P \\<turnstile> \\<langle>e\\<^sub>0,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0),b\\<^sub>0\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1,(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1),b\\<^sub>1\\<rangle>; R e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b' \\<rbrakk>\n   \\<Longrightarrow> R e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 sh\\<^sub>0 b\\<^sub>0 e' h' l' sh' b'\"\nshows \"R e h l sh b e' h' l' sh' b'\"", "lemma [iff]: \"\\<not> P \\<turnstile> \\<langle>[],s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\"", "lemma [iff]: \"\\<not> P \\<turnstile> \\<langle>Val v,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\"", "lemma val_no_step: \"val_of e = \\<lfloor>v\\<rfloor> \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\"", "lemma [iff]: \"\\<not> P \\<turnstile> \\<langle>Throw a,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\"", "lemma map_Vals_no_step [iff]: \"\\<not> P \\<turnstile> \\<langle>map Val vs,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\"", "lemma vals_no_step: \"map_vals_of es = \\<lfloor>vs\\<rfloor> \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\"", "lemma vals_throw_no_step [iff]: \"\\<not> P \\<turnstile> \\<langle>map Val vs @ Throw a # es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\"", "lemma lass_val_of_red:\n \"\\<lbrakk> lass_val_of e = \\<lfloor>a\\<rfloor>; P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l', sh'),b'\\<rangle> \\<rbrakk>\n  \\<Longrightarrow> e' = unit \\<and> h' = h \\<and> l' = l(fst a\\<mapsto>snd a) \\<and> sh' = sh \\<and> b = b'\"", "lemma final_no_step [iff]: \"final e \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\"", "lemma finals_no_step [iff]: \"finals es \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\"", "lemma reds_final_same:\n\"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>* \\<langle>e',s',b'\\<rangle> \\<Longrightarrow> final e \\<Longrightarrow> e = e' \\<and> s = s' \\<and> b = b'\"", "lemma reds_throw:\n\"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>* \\<langle>e',s',b'\\<rangle> \\<Longrightarrow> (\\<And>e\\<^sub>t. throw_of e = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow> \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>)\"", "lemma red_hext_incr: \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l',sh'),b'\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\"\n  and reds_hext_incr: \"P \\<turnstile> \\<langle>es,(h,l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l',sh'),b'\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\"", "lemma red_lcl_incr: \"P \\<turnstile> \\<langle>e,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0),b\\<rangle> \\<rightarrow> \\<langle>e',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1),b'\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"\nand reds_lcl_incr: \"P \\<turnstile> \\<langle>es,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1),b'\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"", "lemma red_lcl_add: \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l',sh'),b'\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l\\<^sub>0++l',sh'),b'\\<rangle>)\"\nand reds_lcl_add: \"P \\<turnstile> \\<langle>es,(h,l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l',sh'),b'\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>es,(h,l\\<^sub>0++l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l\\<^sub>0++l',sh'),b'\\<rangle>)\"", "lemma Red_lcl_add:\nassumes \"P \\<turnstile> \\<langle>e,(h,l,sh), b\\<rangle> \\<rightarrow>* \\<langle>e',(h',l',sh'), b'\\<rangle>\" shows \"P \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l,sh),b\\<rangle> \\<rightarrow>* \\<langle>e',(h',l\\<^sub>0++l',sh'),b'\\<rangle>\"", "lemma assumes wf: \"wwf_J_prog P\"\nshows red_proc_pres: \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l',sh'),b'\\<rangle>\n  \\<Longrightarrow> not_init C e \\<Longrightarrow> sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> not_init C e' \\<and> (\\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)\"\n  and reds_proc_pres: \"P \\<turnstile> \\<langle>es,(h,l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l',sh'),b'\\<rangle>\n  \\<Longrightarrow> not_inits C es \\<Longrightarrow> sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> not_inits C es' \\<and> (\\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)\""], "translations": [["", "lemmas blocks_induct = blocks.induct[split_format (complete)]"], ["", "lemma [simp]:\n  \"\\<lbrakk> size vs = size Vs; size Ts = size Vs \\<rbrakk> \\<Longrightarrow> fv(blocks(Vs,Ts,vs,e)) = fv e - set Vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length Vs; length Ts = length Vs\\<rbrakk>\n    \\<Longrightarrow> fv (blocks (Vs, Ts, vs, e)) = fv e - set Vs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length Vs; length Ts = length Vs\\<rbrakk>\n    \\<Longrightarrow> fv (blocks (Vs, Ts, vs, e)) = fv e - set Vs", "by (induct rule:blocks_induct) auto"], ["", "(*>*)"], ["", "lemma sub_RI_blocks_body[iff]: \"length vs = length pns \\<Longrightarrow> length Ts = length pns\n \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) \\<longleftrightarrow> sub_RI body\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length pns; length Ts = length pns\\<rbrakk>\n    \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) = sub_RI body", "proof(induct pns arbitrary: Ts vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ts vs.\n       \\<lbrakk>length vs = length []; length Ts = length []\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks ([], Ts, vs, body)) = sub_RI body\n 2. \\<And>a pns Ts vs.\n       \\<lbrakk>\\<And>Ts vs.\n                   \\<lbrakk>length vs = length pns;\n                    length Ts = length pns\\<rbrakk>\n                   \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) =\n                                     sub_RI body;\n        length vs = length (a # pns); length Ts = length (a # pns)\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks (a # pns, Ts, vs, body)) =\n                         sub_RI body", "case Nil"], ["proof (state)\nthis:\n  length vs = length []\n  length Ts = length []\n\ngoal (2 subgoals):\n 1. \\<And>Ts vs.\n       \\<lbrakk>length vs = length []; length Ts = length []\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks ([], Ts, vs, body)) = sub_RI body\n 2. \\<And>a pns Ts vs.\n       \\<lbrakk>\\<And>Ts vs.\n                   \\<lbrakk>length vs = length pns;\n                    length Ts = length pns\\<rbrakk>\n                   \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) =\n                                     sub_RI body;\n        length vs = length (a # pns); length Ts = length (a # pns)\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks (a # pns, Ts, vs, body)) =\n                         sub_RI body", "then"], ["proof (chain)\npicking this:\n  length vs = length []\n  length Ts = length []", "show ?case"], ["proof (prove)\nusing this:\n  length vs = length []\n  length Ts = length []\n\ngoal (1 subgoal):\n 1. sub_RI (blocks ([], Ts, vs, body)) = sub_RI body", "by simp"], ["proof (state)\nthis:\n  sub_RI (blocks ([], Ts, vs, body)) = sub_RI body\n\ngoal (1 subgoal):\n 1. \\<And>a pns Ts vs.\n       \\<lbrakk>\\<And>Ts vs.\n                   \\<lbrakk>length vs = length pns;\n                    length Ts = length pns\\<rbrakk>\n                   \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) =\n                                     sub_RI body;\n        length vs = length (a # pns); length Ts = length (a # pns)\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks (a # pns, Ts, vs, body)) =\n                         sub_RI body", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a pns Ts vs.\n       \\<lbrakk>\\<And>Ts vs.\n                   \\<lbrakk>length vs = length pns;\n                    length Ts = length pns\\<rbrakk>\n                   \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) =\n                                     sub_RI body;\n        length vs = length (a # pns); length Ts = length (a # pns)\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks (a # pns, Ts, vs, body)) =\n                         sub_RI body", "case Cons"], ["proof (state)\nthis:\n  \\<lbrakk>length ?vs = length pns_; length ?Ts = length pns_\\<rbrakk>\n  \\<Longrightarrow> sub_RI (blocks (pns_, ?Ts, ?vs, body)) = sub_RI body\n  length vs = length (a_ # pns_)\n  length Ts = length (a_ # pns_)\n\ngoal (1 subgoal):\n 1. \\<And>a pns Ts vs.\n       \\<lbrakk>\\<And>Ts vs.\n                   \\<lbrakk>length vs = length pns;\n                    length Ts = length pns\\<rbrakk>\n                   \\<Longrightarrow> sub_RI (blocks (pns, Ts, vs, body)) =\n                                     sub_RI body;\n        length vs = length (a # pns); length Ts = length (a # pns)\\<rbrakk>\n       \\<Longrightarrow> sub_RI (blocks (a # pns, Ts, vs, body)) =\n                         sub_RI body", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?vs = length pns_; length ?Ts = length pns_\\<rbrakk>\n  \\<Longrightarrow> sub_RI (blocks (pns_, ?Ts, ?vs, body)) = sub_RI body\n  length vs = length (a_ # pns_)\n  length Ts = length (a_ # pns_)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?vs = length pns_; length ?Ts = length pns_\\<rbrakk>\n  \\<Longrightarrow> sub_RI (blocks (pns_, ?Ts, ?vs, body)) = sub_RI body\n  length vs = length (a_ # pns_)\n  length Ts = length (a_ # pns_)\n\ngoal (1 subgoal):\n 1. sub_RI (blocks (a_ # pns_, Ts, vs, body)) = sub_RI body", "by(cases vs; cases Ts) auto"], ["proof (state)\nthis:\n  sub_RI (blocks (a_ # pns_, Ts, vs, body)) = sub_RI body\n\ngoal:\nNo subgoals!", "qed"], ["", "definition assigned :: \"'a \\<Rightarrow> 'a exp \\<Rightarrow> bool\"\nwhere\n  \"assigned V e  \\<equiv>  \\<exists>v e'. e = (V := Val v;; e')\"\n\n\\<comment> \\<open> expression is okay to go the right side of @{text INIT} or @{text \"RI \\<leftarrow>\"}\n or to have indicator Boolean be True (in latter case, given that class is\n also verified initialized) \\<close>"], ["", "fun icheck :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> 'a exp \\<Rightarrow> bool\" where\n\"icheck P C' (new C) = (C' = C)\" |\n\"icheck P D' (C\\<bullet>\\<^sub>sF{D}) = ((D' = D) \\<and> (\\<exists>T. P \\<turnstile> C has F,Static:T in D))\" |\n\"icheck P D' (C\\<bullet>\\<^sub>sF{D}:=(Val v)) = ((D' = D) \\<and> (\\<exists>T. P \\<turnstile> C has F,Static:T in D))\" |\n\"icheck P D (C\\<bullet>\\<^sub>sM(es)) = ((\\<exists>vs. es = map Val vs) \\<and> (\\<exists>Ts T m. P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = m in D))\" |\n\"icheck P _ _ = False\""], ["", "lemma nicheck_SFAss_nonVal: \"val_of e\\<^sub>2 = None \\<Longrightarrow> \\<not>icheck P C' (C\\<bullet>\\<^sub>sF{D} := (e\\<^sub>2::'a exp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of e\\<^sub>2 = None \\<Longrightarrow>\n    \\<not> icheck P C' (C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2)", "by(rule notI, cases e\\<^sub>2, auto)"], ["", "inductive_set\n  red  :: \"J_prog \\<Rightarrow> ((expr \\<times> state \\<times> bool) \\<times> (expr \\<times> state \\<times> bool)) set\"\n  and reds  :: \"J_prog \\<Rightarrow> ((expr list \\<times> state \\<times> bool) \\<times> (expr list \\<times> state \\<times> bool)) set\"\n  and red' :: \"J_prog \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> bool\"\n          (\"_ \\<turnstile> ((1\\<langle>_,/_,/_\\<rangle>) \\<rightarrow>/ (1\\<langle>_,/_,/_\\<rangle>))\" [51,0,0,0,0,0,0] 81)\n  and reds' :: \"J_prog \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> bool\"\n          (\"_ \\<turnstile> ((1\\<langle>_,/_,/_\\<rangle>) [\\<rightarrow>]/ (1\\<langle>_,/_,/_\\<rangle>))\" [51,0,0,0,0,0,0] 81)\n  for P :: J_prog\nwhere\n\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<equiv> ((e,s,b), e',s',b') \\<in> red P\"\n| \"P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle> \\<equiv> ((es,s,b), es',s',b') \\<in> reds P\"\n\n| RedNew:\n  \"\\<lbrakk> new_Addr h = Some a; P \\<turnstile> C has_fields FDTs; h' = h(a\\<mapsto>blank P C) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>new C, (h,l,sh), True\\<rangle> \\<rightarrow> \\<langle>addr a, (h',l,sh), False\\<rangle>\"\n\n| RedNewFail:\n  \"\\<lbrakk> new_Addr h = None; is_class P C \\<rbrakk> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>new C, (h,l,sh), True\\<rangle> \\<rightarrow> \\<langle>THROW OutOfMemory, (h,l,sh), False\\<rangle>\"\n\n| NewInitDoneRed:\n  \"sh C = Some (sfs, Done) \\<Longrightarrow>\n  P \\<turnstile> \\<langle>new C, (h,l,sh), False\\<rangle> \\<rightarrow> \\<langle>new C, (h,l,sh), True\\<rangle>\"\n\n| NewInitRed:\n  \"\\<lbrakk> \\<nexists>sfs. sh C = Some (sfs, Done); is_class P C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>new C,(h,l,sh),False\\<rangle> \\<rightarrow> \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h,l,sh),False\\<rangle>\"\n\n| CastRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>Cast C e, s, b\\<rangle> \\<rightarrow> \\<langle>Cast C e', s', b'\\<rangle>\"\n\n| RedCastNull:\n  \"P \\<turnstile> \\<langle>Cast C null, s, b\\<rangle> \\<rightarrow> \\<langle>null,s,b\\<rangle>\"\n\n| RedCast:\n \"\\<lbrakk> h a = Some(D,fs); P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a), (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>addr a, (h,l,sh), b\\<rangle>\"\n\n| RedCastFail:\n  \"\\<lbrakk> h a = Some(D,fs); \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a), (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>THROW ClassCast, (h,l,sh), b\\<rangle>\"\n\n| BinOpRed1:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s', b'\\<rangle>\"\n\n| BinOpRed2:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> e, s, b\\<rangle> \\<rightarrow> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> e', s', b'\\<rangle>\"\n\n| RedBinOp:\n  \"binop(bop,v\\<^sub>1,v\\<^sub>2) = Some v \\<Longrightarrow>\n  P \\<turnstile> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> (Val v\\<^sub>2), s, b\\<rangle> \\<rightarrow> \\<langle>Val v,s,b\\<rangle>\"\n\n| RedVar:\n  \"l V = Some v \\<Longrightarrow>\n  P \\<turnstile> \\<langle>Var V,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>Val v,(h,l,sh),b\\<rangle>\"\n\n| LAssRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>V:=e,s,b\\<rangle> \\<rightarrow> \\<langle>V:=e',s',b'\\<rangle>\"\n\n| RedLAss:\n  \"P \\<turnstile> \\<langle>V:=(Val v), (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>unit, (h,l(V\\<mapsto>v),sh), b\\<rangle>\"\n\n| FAccRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>e\\<bullet>F{D}, s, b\\<rangle> \\<rightarrow> \\<langle>e'\\<bullet>F{D}, s', b'\\<rangle>\"\n\n| RedFAcc:\n  \"\\<lbrakk> h a = Some(C,fs); fs(F,D) = Some v;\n     P \\<turnstile> C has F,NonStatic:t in D \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>F{D}, (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>Val v,(h,l,sh),b\\<rangle>\"\n\n| RedFAccNull:\n  \"P \\<turnstile> \\<langle>null\\<bullet>F{D}, s, b\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer, s, b\\<rangle>\"\n\n| RedFAccNone:\n  \"\\<lbrakk> h a = Some(C,fs); \\<not>(\\<exists>b t. P \\<turnstile> C has F,b:t in D) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>F{D},(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW NoSuchFieldError,(h,l,sh),b\\<rangle>\"\n\n| RedFAccStatic:\n  \"\\<lbrakk> h a = Some(C,fs); P \\<turnstile> C has F,Static:t in D \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>F{D},(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW IncompatibleClassChangeError,(h,l,sh),b\\<rangle>\"\n\n| RedSFAcc:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:t in D;\n     sh D = Some (sfs,i);\n     sfs F = Some v \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D},(h,l,sh),True\\<rangle> \\<rightarrow> \\<langle>Val v,(h,l,sh),False\\<rangle>\"\n\n| SFAccInitDoneRed:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:t in D;\n     sh D = Some (sfs,Done) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D},(h,l,sh),False\\<rangle> \\<rightarrow> \\<langle>C\\<bullet>\\<^sub>sF{D},(h,l,sh),True\\<rangle>\"\n\n| SFAccInitRed:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:t in D;\n     \\<nexists>sfs. sh D = Some (sfs,Done) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D},(h,l,sh),False\\<rangle> \\<rightarrow> \\<langle>INIT D ([D],False) \\<leftarrow> C\\<bullet>\\<^sub>sF{D},(h,l,sh),False\\<rangle>\"\n\n| RedSFAccNone:\n  \"\\<not>(\\<exists>b t. P \\<turnstile> C has F,b:t in D)\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D},(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW NoSuchFieldError,(h,l,sh),False\\<rangle>\"\n\n| RedSFAccNonStatic:\n  \"P \\<turnstile> C has F,NonStatic:t in D\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D},(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW IncompatibleClassChangeError,(h,l,sh),False\\<rangle>\"\n\n| FAssRed1:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>e\\<bullet>F{D}:=e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>e'\\<bullet>F{D}:=e\\<^sub>2, s', b'\\<rangle>\"\n\n| FAssRed2:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>Val v\\<bullet>F{D}:=e, s, b\\<rangle> \\<rightarrow> \\<langle>Val v\\<bullet>F{D}:=e', s', b'\\<rangle>\"\n\n| RedFAss:\n  \"\\<lbrakk> P \\<turnstile> C has F,NonStatic:t in D; h a = Some(C,fs) \\<rbrakk> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>(addr a)\\<bullet>F{D}:=(Val v), (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>unit, (h(a \\<mapsto> (C,fs((F,D) \\<mapsto> v))),l,sh), b\\<rangle>\"\n\n| RedFAssNull:\n  \"P \\<turnstile> \\<langle>null\\<bullet>F{D}:=Val v, s, b\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer, s, b\\<rangle>\"\n\n| RedFAssNone:\n  \"\\<lbrakk> h a = Some(C,fs); \\<not>(\\<exists>b t. P \\<turnstile> C has F,b:t in D) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>F{D}:=(Val v),(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW NoSuchFieldError,(h,l,sh),b\\<rangle>\"\n\n| RedFAssStatic:\n  \"\\<lbrakk> h a = Some(C,fs); P \\<turnstile> C has F,Static:t in D \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>F{D}:=(Val v),(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW IncompatibleClassChangeError,(h,l,sh),b\\<rangle>\"\n\n| SFAssRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=e, s, b\\<rangle> \\<rightarrow> \\<langle>C\\<bullet>\\<^sub>sF{D}:=e', s', b'\\<rangle>\"\n\n| RedSFAss:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:t in D;\n     sh D = Some(sfs,i);\n     sfs' = sfs(F\\<mapsto>v); sh' = sh(D\\<mapsto>(sfs',i)) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(Val v),(h,l,sh),True\\<rangle> \\<rightarrow> \\<langle>unit,(h,l,sh'),False\\<rangle>\"\n\n| SFAssInitDoneRed:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:t in D;\n     sh D = Some(sfs,Done) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(Val v),(h,l,sh),False\\<rangle> \\<rightarrow> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(Val v),(h,l,sh),True\\<rangle>\"\n\n| SFAssInitRed:\n  \"\\<lbrakk> P \\<turnstile> C has F,Static:t in D;\n     \\<nexists>sfs. sh D = Some(sfs,Done) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(Val v),(h,l,sh),False\\<rangle> \\<rightarrow> \\<langle>INIT D ([D],False)\\<leftarrow> C\\<bullet>\\<^sub>sF{D}:=(Val v),(h,l,sh),False\\<rangle>\"\n\n| RedSFAssNone:\n  \"\\<not>(\\<exists>b t. P \\<turnstile> C has F,b:t in D)\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(Val v),s,b\\<rangle> \\<rightarrow> \\<langle>THROW NoSuchFieldError,s,False\\<rangle>\"\n\n| RedSFAssNonStatic:\n  \"P \\<turnstile> C has F,NonStatic:t in D\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(Val v),s,b\\<rangle> \\<rightarrow> \\<langle>THROW IncompatibleClassChangeError,s,False\\<rangle>\"\n\n| CallObj:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>e\\<bullet>M(es),s,b\\<rangle> \\<rightarrow> \\<langle>e'\\<bullet>M(es),s',b'\\<rangle>\"\n\n| CallParams:\n  \"P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>(Val v)\\<bullet>M(es),s,b\\<rangle> \\<rightarrow> \\<langle>(Val v)\\<bullet>M(es'),s',b'\\<rangle>\"\n\n| RedCall:\n  \"\\<lbrakk> h a = Some(C,fs); P \\<turnstile> C sees M,NonStatic:Ts\\<rightarrow>T = (pns,body) in D; size vs = size pns; size Ts = size pns \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>M(map Val vs), (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>blocks(this#pns, Class D#Ts, Addr a#vs, body), (h,l,sh), b\\<rangle>\"\n\n| RedCallNull:\n  \"P \\<turnstile> \\<langle>null\\<bullet>M(map Val vs),s,b\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer,s,b\\<rangle>\"\n\n| RedCallNone:\n  \"\\<lbrakk> h a = Some(C,fs); \\<not>(\\<exists>b Ts T m D. P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>M(map Val vs),(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW NoSuchMethodError,(h,l,sh),b\\<rangle>\"\n\n| RedCallStatic:\n  \"\\<lbrakk> h a = Some(C,fs); P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = m in D \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>(addr a)\\<bullet>M(map Val vs),(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>THROW IncompatibleClassChangeError,(h,l,sh),b\\<rangle>\"\n\n| SCallParams:\n  \"P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(es),s,b\\<rangle> \\<rightarrow> \\<langle>C\\<bullet>\\<^sub>sM(es'),s',b'\\<rangle>\"\n\n| RedSCall:\n  \"\\<lbrakk> P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = (pns,body) in D;\n     length vs = length pns; size Ts = size pns \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(map Val vs),s,True\\<rangle> \\<rightarrow> \\<langle>blocks(pns, Ts, vs, body), s, False\\<rangle>\"\n\n| SCallInitDoneRed:\n  \"\\<lbrakk> P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = (pns,body) in D;\n     sh D = Some(sfs,Done) \\<or> (M = clinit \\<and> sh D = Some(sfs,Processing)) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(map Val vs),(h,l,sh), False\\<rangle> \\<rightarrow> \\<langle>C\\<bullet>\\<^sub>sM(map Val vs),(h,l,sh), True\\<rangle>\"\n\n| SCallInitRed:\n  \"\\<lbrakk> P \\<turnstile> C sees M,Static:Ts\\<rightarrow>T = (pns,body) in D;\n     \\<nexists>sfs. sh D = Some(sfs,Done); M \\<noteq> clinit \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(map Val vs),(h,l,sh), False\\<rangle> \\<rightarrow> \\<langle>INIT D ([D],False) \\<leftarrow> C\\<bullet>\\<^sub>sM(map Val vs),(h,l,sh),False\\<rangle>\"\n\n| RedSCallNone:\n  \"\\<lbrakk> \\<not>(\\<exists>b Ts T m D. P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in D) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(map Val vs),s,b\\<rangle> \\<rightarrow> \\<langle>THROW NoSuchMethodError,s,False\\<rangle>\"\n\n| RedSCallNonStatic:\n  \"\\<lbrakk> P \\<turnstile> C sees M,NonStatic:Ts\\<rightarrow>T = m in D \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(map Val vs),s,b\\<rangle> \\<rightarrow> \\<langle>THROW IncompatibleClassChangeError,s,False\\<rangle>\"\n\n| BlockRedNone:\n  \"\\<lbrakk> P \\<turnstile> \\<langle>e, (h,l(V:=None),sh), b\\<rangle> \\<rightarrow> \\<langle>e', (h',l',sh'), b'\\<rangle>; l' V = None; \\<not> assigned V e \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>{V:T; e}, (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>{V:T; e'}, (h',l'(V := l V),sh'), b'\\<rangle>\"\n\n| BlockRedSome:\n  \"\\<lbrakk> P \\<turnstile> \\<langle>e, (h,l(V:=None),sh), b\\<rangle> \\<rightarrow> \\<langle>e', (h',l',sh'), b'\\<rangle>; l' V = Some v;\\<not> assigned V e \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>{V:T; e}, (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>{V:T := Val v; e'}, (h',l'(V := l V),sh'), b'\\<rangle>\"\n\n| InitBlockRed:\n  \"\\<lbrakk> P \\<turnstile> \\<langle>e, (h,l(V\\<mapsto>v),sh), b\\<rangle> \\<rightarrow> \\<langle>e', (h',l',sh'), b'\\<rangle>; l' V = Some v' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>{V:T := Val v; e}, (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>{V:T := Val v'; e'}, (h',l'(V := l V),sh'), b'\\<rangle>\"\n\n| RedBlock:\n  \"P \\<turnstile> \\<langle>{V:T; Val u}, s, b\\<rangle> \\<rightarrow> \\<langle>Val u, s, b\\<rangle>\"\n\n| RedInitBlock:\n  \"P \\<turnstile> \\<langle>{V:T := Val v; Val u}, s, b\\<rangle> \\<rightarrow> \\<langle>Val u, s, b\\<rangle>\"\n\n| SeqRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>e;;e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>e';;e\\<^sub>2, s', b'\\<rangle>\"\n\n| RedSeq:\n  \"P \\<turnstile> \\<langle>(Val v);;e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>2, s, b\\<rangle>\"\n\n| CondRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>if (e) e\\<^sub>1 else e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>if (e') e\\<^sub>1 else e\\<^sub>2, s', b'\\<rangle>\"\n\n| RedCondT:\n  \"P \\<turnstile> \\<langle>if (true) e\\<^sub>1 else e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1, s, b\\<rangle>\"\n\n| RedCondF:\n  \"P \\<turnstile> \\<langle>if (false) e\\<^sub>1 else e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>2, s, b\\<rangle>\"\n\n| RedWhile:\n  \"P \\<turnstile> \\<langle>while(b) c, s, b'\\<rangle> \\<rightarrow> \\<langle>if(b) (c;;while(b) c) else unit, s, b'\\<rangle>\"\n\n| ThrowRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>throw e, s, b\\<rangle> \\<rightarrow> \\<langle>throw e', s', b'\\<rangle>\"\n\n| RedThrowNull:\n  \"P \\<turnstile> \\<langle>throw null, s, b\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer, s, b\\<rangle>\"\n\n| TryRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>try e catch(C V) e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>try e' catch(C V) e\\<^sub>2, s', b'\\<rangle>\"\n\n| RedTry:\n  \"P \\<turnstile> \\<langle>try (Val v) catch(C V) e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>Val v, s, b\\<rangle>\"\n\n| RedTryCatch:\n  \"\\<lbrakk> hp s a = Some(D,fs); P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>try (Throw a) catch(C V) e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>{V:Class C := addr a; e\\<^sub>2}, s, b\\<rangle>\"\n\n| RedTryFail:\n  \"\\<lbrakk> hp s a = Some(D,fs); \\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>try (Throw a) catch(C V) e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>Throw a, s, b\\<rangle>\"\n\n| ListRed1:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>e#es,s,b\\<rangle> [\\<rightarrow>] \\<langle>e'#es,s',b'\\<rangle>\"\n\n| ListRed2:\n  \"P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>Val v # es,s,b\\<rangle> [\\<rightarrow>] \\<langle>Val v # es',s',b'\\<rangle>\"\n\n\\<comment> \\<open>Initialization procedure\\<close>\n\n| RedInit:\n  \"\\<not>sub_RI e \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C (Nil,b) \\<leftarrow> e,s,b'\\<rangle> \\<rightarrow> \\<langle>e,s,icheck P C e\\<rangle>\"\n\n| InitNoneRed:\n  \"sh C = None\n  \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh(C \\<mapsto> (sblank P C, Prepared))),b\\<rangle>\"\n\n| RedInitDone:\n  \"sh C = Some(sfs,Done)\n  \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>INIT C' (Cs,True) \\<leftarrow> e,(h,l,sh),b\\<rangle>\"\n\n| RedInitProcessing:\n  \"sh C = Some(sfs,Processing)\n  \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>INIT C' (Cs,True) \\<leftarrow> e,(h,l,sh),b\\<rangle>\"\n\n| RedInitError:\n  \"sh C = Some(sfs,Error)\n  \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>RI (C,THROW NoClassDefFoundError);Cs \\<leftarrow> e,(h,l,sh),b\\<rangle>\"\n\n| InitObjectRed:\n  \"\\<lbrakk> sh C = Some(sfs,Prepared);\n     C = Object;\n     sh' = sh(C \\<mapsto> (sfs,Processing)) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>INIT C' (C#Cs,True) \\<leftarrow> e,(h,l,sh'),b\\<rangle>\"\n\n| InitNonObjectSuperRed:\n  \"\\<lbrakk> sh C = Some(sfs,Prepared);\n     C \\<noteq> Object;\n     class P C = Some (D,r);\n     sh' = sh(C \\<mapsto> (sfs,Processing)) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<langle>INIT C' (C#Cs,False) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>INIT C' (D#C#Cs,False) \\<leftarrow> e,(h,l,sh'),b\\<rangle>\"\n\n| RedInitRInit:\n  \"P \\<turnstile> \\<langle>INIT C' (C#Cs,True) \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>RI (C,C\\<bullet>\\<^sub>sclinit([]));Cs \\<leftarrow> e,(h,l,sh),b\\<rangle>\"\n\n| RInitRed:\n  \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>RI (C,e);Cs \\<leftarrow> e\\<^sub>0, s, b\\<rangle> \\<rightarrow> \\<langle>RI (C,e');Cs \\<leftarrow> e\\<^sub>0, s', b'\\<rangle>\"\n\n| RedRInit:\n  \"\\<lbrakk> sh C = Some (sfs, i);\n     sh' = sh(C \\<mapsto> (sfs,Done));\n     C' = last(C#Cs) \\<rbrakk> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>RI (C, Val v);Cs \\<leftarrow> e, (h,l,sh), b\\<rangle> \\<rightarrow> \\<langle>INIT C' (Cs,True) \\<leftarrow> e, (h,l,sh'), b\\<rangle>\"\n\n\\<comment> \\<open>Exception propagation\\<close>\n\n| CastThrow: \"P \\<turnstile> \\<langle>Cast C (throw e), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| BinOpThrow1: \"P \\<turnstile> \\<langle>(throw e) \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| BinOpThrow2: \"P \\<turnstile> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> (throw e), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| LAssThrow: \"P \\<turnstile> \\<langle>V:=(throw e), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| FAccThrow: \"P \\<turnstile> \\<langle>(throw e)\\<bullet>F{D}, s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| FAssThrow1: \"P \\<turnstile> \\<langle>(throw e)\\<bullet>F{D}:=e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| FAssThrow2: \"P \\<turnstile> \\<langle>Val v\\<bullet>F{D}:=(throw e), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| SFAssThrow: \"P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=(throw e), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| CallThrowObj: \"P \\<turnstile> \\<langle>(throw e)\\<bullet>M(es), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| CallThrowParams: \"\\<lbrakk> es = map Val vs @ throw e # es' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<langle>(Val v)\\<bullet>M(es), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| SCallThrowParams: \"\\<lbrakk> es = map Val vs @ throw e # es' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(es), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| BlockThrow: \"P \\<turnstile> \\<langle>{V:T; Throw a}, s, b\\<rangle> \\<rightarrow> \\<langle>Throw a, s, b\\<rangle>\"\n| InitBlockThrow: \"P \\<turnstile> \\<langle>{V:T := Val v; Throw a}, s, b\\<rangle> \\<rightarrow> \\<langle>Throw a, s, b\\<rangle>\"\n| SeqThrow: \"P \\<turnstile> \\<langle>(throw e);;e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| CondThrow: \"P \\<turnstile> \\<langle>if (throw e) e\\<^sub>1 else e\\<^sub>2, s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| ThrowThrow: \"P \\<turnstile> \\<langle>throw(throw e), s, b\\<rangle> \\<rightarrow> \\<langle>throw e, s, b\\<rangle>\"\n| RInitInitThrow: \"\\<lbrakk> sh C = Some(sfs,i); sh' = sh(C \\<mapsto> (sfs,Error)) \\<rbrakk> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>RI (C,Throw a);D#Cs \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>RI (D,Throw a);Cs \\<leftarrow> e,(h,l,sh'),b\\<rangle>\"\n| RInitThrow: \"\\<lbrakk> sh C = Some(sfs, i); sh' = sh(C \\<mapsto> (sfs,Error)) \\<rbrakk> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>RI (C,Throw a);Nil \\<leftarrow> e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>Throw a,(h,l,sh'),b\\<rangle>\""], ["", "(*<*)"], ["", "lemmas red_reds_induct = red_reds.induct [split_format (complete)]\n  and red_reds_inducts = red_reds.inducts [split_format (complete)]"], ["", "inductive_cases [elim!]:\n \"P \\<turnstile> \\<langle>V:=e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e1;;e2,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\""], ["", "(*>*)"], ["", "subsection\\<open> The reflexive transitive closure \\<close>"], ["", "abbreviation\n  Step :: \"J_prog \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> bool\"\n          (\"_ \\<turnstile> ((1\\<langle>_,/_,/_\\<rangle>) \\<rightarrow>*/ (1\\<langle>_,/_,/_\\<rangle>))\" [51,0,0,0,0,0,0] 81)\n  where \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>* \\<langle>e',s',b'\\<rangle> \\<equiv> ((e,s,b), e',s',b') \\<in> (red P)\\<^sup>*\""], ["", "abbreviation\n  Steps :: \"J_prog \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> bool \\<Rightarrow> bool\"\n          (\"_ \\<turnstile> ((1\\<langle>_,/_,/_\\<rangle>) [\\<rightarrow>]*/ (1\\<langle>_,/_,/_\\<rangle>))\" [51,0,0,0,0,0,0] 81)\n  where \"P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>]* \\<langle>es',s',b'\\<rangle> \\<equiv> ((es,s,b), es',s',b') \\<in> (reds P)\\<^sup>*\""], ["", "lemmas converse_rtrancl_induct3 =\n  converse_rtrancl_induct [of \"(ax, ay, az)\" \"(bx, by, bz)\", split_format (complete),\n    consumes 1, case_names refl step]"], ["", "lemma converse_rtrancl_induct_red[consumes 1]:\nassumes \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow>* \\<langle>e',(h',l',sh'),b'\\<rangle>\"\nand \"\\<And>e h l sh b. R e h l sh b e h l sh b\"\nand \"\\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk> P \\<turnstile> \\<langle>e\\<^sub>0,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0),b\\<^sub>0\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1,(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1),b\\<^sub>1\\<rangle>; R e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b' \\<rbrakk>\n   \\<Longrightarrow> R e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 sh\\<^sub>0 b\\<^sub>0 e' h' l' sh' b'\"\nshows \"R e h l sh b e' h' l' sh' b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "assume reds: \"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>* \\<langle>e',s',b'\\<rangle>\"\n       and base: \"\\<And>e s b. R e (hp s) (lcl s) (shp s) b e (hp s) (lcl s) (shp s) b\"\n       and red\\<^sub>1: \"\\<And>e\\<^sub>0 s\\<^sub>0 b\\<^sub>0 e\\<^sub>1 s\\<^sub>1 b\\<^sub>1 e' s' b'.\n           \\<lbrakk> P \\<turnstile> \\<langle>e\\<^sub>0,s\\<^sub>0,b\\<^sub>0\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1,s\\<^sub>1,b\\<^sub>1\\<rangle>; R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) (shp s\\<^sub>1) b\\<^sub>1 e' (hp s') (lcl s') (shp s') b' \\<rbrakk>\n           \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) (shp s\\<^sub>0) b\\<^sub>0 e' (hp s') (lcl s') (shp s') b'\""], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  R ?e (hp ?s) (lcl ?s) (shp ?s) ?b ?e (hp ?s) (lcl ?s) (shp ?s) ?b\n  \\<lbrakk>P \\<turnstile> \\<langle>?e\\<^sub>0,?s\\<^sub>0,\n                           ?b\\<^sub>0\\<rangle> \\<rightarrow>\n                          \\<langle>?e\\<^sub>1,?s\\<^sub>1,\n                           ?b\\<^sub>1\\<rangle>;\n   R ?e\\<^sub>1 (hp ?s\\<^sub>1) (lcl ?s\\<^sub>1) (shp ?s\\<^sub>1) ?b\\<^sub>1\n    ?e' (hp ?s') (lcl ?s') (shp ?s') ?b'\\<rbrakk>\n  \\<Longrightarrow> R ?e\\<^sub>0 (hp ?s\\<^sub>0) (lcl ?s\\<^sub>0)\n                     (shp ?s\\<^sub>0) ?b\\<^sub>0 ?e' (hp ?s') (lcl ?s')\n                     (shp ?s') ?b'\n\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "from reds"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>", "have \"R e (hp s) (lcl s) (shp s) b e' (hp s') (lcl s') (shp s') b'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n\ngoal (1 subgoal):\n 1. R e (hp s) (lcl s) (shp s) b e' (hp s') (lcl s') (shp s') b'", "proof (induct rule:converse_rtrancl_induct3)"], ["proof (state)\ngoal (2 subgoals):\n 1. R e' (hp s') (lcl s') (shp s') b' e' (hp s') (lcl s') (shp s') b'\n 2. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        R ab (hp ac) (lcl ac) (shp ac) ba e' (hp s') (lcl s') (shp s')\n         b'\\<rbrakk>\n       \\<Longrightarrow> R a (hp aa) (lcl aa) (shp aa) b e' (hp s') (lcl s')\n                          (shp s') b'", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. R e' (hp s') (lcl s') (shp s') b' e' (hp s') (lcl s') (shp s') b'\n 2. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        R ab (hp ac) (lcl ac) (shp ac) ba e' (hp s') (lcl s') (shp s')\n         b'\\<rbrakk>\n       \\<Longrightarrow> R a (hp aa) (lcl aa) (shp aa) b e' (hp s') (lcl s')\n                          (shp s') b'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R e' (hp s') (lcl s') (shp s') b' e' (hp s') (lcl s') (shp s') b'", "by(rule base)"], ["proof (state)\nthis:\n  R e' (hp s') (lcl s') (shp s') b' e' (hp s') (lcl s') (shp s') b'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        R ab (hp ac) (lcl ac) (shp ac) ba e' (hp s') (lcl s') (shp s')\n         b'\\<rbrakk>\n       \\<Longrightarrow> R a (hp aa) (lcl aa) (shp aa) b e' (hp s') (lcl s')\n                          (shp s') b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        R ab (hp ac) (lcl ac) (shp ac) ba e' (hp s') (lcl s') (shp s')\n         b'\\<rbrakk>\n       \\<Longrightarrow> R a (hp aa) (lcl aa) (shp aa) b e' (hp s') (lcl s')\n                          (shp s') b'", "case step"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>a___,aa___,ba___\\<rangle> \\<rightarrow>\n                 \\<langle>ab___,a_,b_\\<rangle>\n  P \\<turnstile> \\<langle>ab___,a_,b_\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  R ab___ (hp a_) (lcl a_) (shp a_) b_ e' (hp s') (lcl s') (shp s') b'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        R ab (hp ac) (lcl ac) (shp ac) ba e' (hp s') (lcl s') (shp s')\n         b'\\<rbrakk>\n       \\<Longrightarrow> R a (hp aa) (lcl aa) (shp aa) b e' (hp s') (lcl s')\n                          (shp s') b'", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>a___,aa___,ba___\\<rangle> \\<rightarrow>\n                 \\<langle>ab___,a_,b_\\<rangle>\n  P \\<turnstile> \\<langle>ab___,a_,b_\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  R ab___ (hp a_) (lcl a_) (shp a_) b_ e' (hp s') (lcl s') (shp s') b'\n\ngoal (1 subgoal):\n 1. R a___ (hp aa___) (lcl aa___) (shp aa___) ba___ e' (hp s') (lcl s')\n     (shp s') b'", "by(blast intro:red\\<^sub>1)"], ["proof (state)\nthis:\n  R a___ (hp aa___) (lcl aa___) (shp aa___) ba___ e' (hp s') (lcl s')\n   (shp s') b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R e (hp s) (lcl s) (shp s) b e' (hp s') (lcl s') (shp s') b'\n\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<turnstile> \\<langle>e,?s2,b\\<rangle> \\<rightarrow>*\n                          \\<langle>e',?s'2,b'\\<rangle>;\n   \\<And>e s b. R e (hp s) (lcl s) (shp s) b e (hp s) (lcl s) (shp s) b;\n   \\<And>e\\<^sub>0 s\\<^sub>0 b\\<^sub>0 e\\<^sub>1 s\\<^sub>1 b\\<^sub>1 e' s'\n      b'.\n      \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,s\\<^sub>0,\n                               b\\<^sub>0\\<rangle> \\<rightarrow>\n                              \\<langle>e\\<^sub>1,s\\<^sub>1,\n                               b\\<^sub>1\\<rangle>;\n       R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) (shp s\\<^sub>1) b\\<^sub>1\n        e' (hp s') (lcl s') (shp s') b'\\<rbrakk>\n      \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0)\n                         (shp s\\<^sub>0) b\\<^sub>0 e' (hp s') (lcl s')\n                         (shp s') b'\\<rbrakk>\n  \\<Longrightarrow> R e (hp ?s2) (lcl ?s2) (shp ?s2) b e' (hp ?s'2)\n                     (lcl ?s'2) (shp ?s'2) b'\n\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "with assms"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>*\n                 \\<langle>e',(h', l', sh'),b'\\<rangle>\n  R ?e ?h ?l ?sh ?b ?e ?h ?l ?sh ?b\n  \\<lbrakk>P \\<turnstile> \\<langle>?e\\<^sub>0,\n                           (?h\\<^sub>0, ?l\\<^sub>0, ?sh\\<^sub>0),\n                           ?b\\<^sub>0\\<rangle> \\<rightarrow>\n                          \\<langle>?e\\<^sub>1,\n                           (?h\\<^sub>1, ?l\\<^sub>1, ?sh\\<^sub>1),\n                           ?b\\<^sub>1\\<rangle>;\n   R ?e\\<^sub>1 ?h\\<^sub>1 ?l\\<^sub>1 ?sh\\<^sub>1 ?b\\<^sub>1 ?e' ?h' ?l'\n    ?sh' ?b'\\<rbrakk>\n  \\<Longrightarrow> R ?e\\<^sub>0 ?h\\<^sub>0 ?l\\<^sub>0 ?sh\\<^sub>0\n                     ?b\\<^sub>0 ?e' ?h' ?l' ?sh' ?b'\n  \\<lbrakk>P \\<turnstile> \\<langle>e,?s2,b\\<rangle> \\<rightarrow>*\n                          \\<langle>e',?s'2,b'\\<rangle>;\n   \\<And>e s b. R e (hp s) (lcl s) (shp s) b e (hp s) (lcl s) (shp s) b;\n   \\<And>e\\<^sub>0 s\\<^sub>0 b\\<^sub>0 e\\<^sub>1 s\\<^sub>1 b\\<^sub>1 e' s'\n      b'.\n      \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,s\\<^sub>0,\n                               b\\<^sub>0\\<rangle> \\<rightarrow>\n                              \\<langle>e\\<^sub>1,s\\<^sub>1,\n                               b\\<^sub>1\\<rangle>;\n       R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) (shp s\\<^sub>1) b\\<^sub>1\n        e' (hp s') (lcl s') (shp s') b'\\<rbrakk>\n      \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0)\n                         (shp s\\<^sub>0) b\\<^sub>0 e' (hp s') (lcl s')\n                         (shp s') b'\\<rbrakk>\n  \\<Longrightarrow> R e (hp ?s2) (lcl ?s2) (shp ?s2) b e' (hp ?s'2)\n                     (lcl ?s'2) (shp ?s'2) b'", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>*\n                 \\<langle>e',(h', l', sh'),b'\\<rangle>\n  R ?e ?h ?l ?sh ?b ?e ?h ?l ?sh ?b\n  \\<lbrakk>P \\<turnstile> \\<langle>?e\\<^sub>0,\n                           (?h\\<^sub>0, ?l\\<^sub>0, ?sh\\<^sub>0),\n                           ?b\\<^sub>0\\<rangle> \\<rightarrow>\n                          \\<langle>?e\\<^sub>1,\n                           (?h\\<^sub>1, ?l\\<^sub>1, ?sh\\<^sub>1),\n                           ?b\\<^sub>1\\<rangle>;\n   R ?e\\<^sub>1 ?h\\<^sub>1 ?l\\<^sub>1 ?sh\\<^sub>1 ?b\\<^sub>1 ?e' ?h' ?l'\n    ?sh' ?b'\\<rbrakk>\n  \\<Longrightarrow> R ?e\\<^sub>0 ?h\\<^sub>0 ?l\\<^sub>0 ?sh\\<^sub>0\n                     ?b\\<^sub>0 ?e' ?h' ?l' ?sh' ?b'\n  \\<lbrakk>P \\<turnstile> \\<langle>e,?s2,b\\<rangle> \\<rightarrow>*\n                          \\<langle>e',?s'2,b'\\<rangle>;\n   \\<And>e s b. R e (hp s) (lcl s) (shp s) b e (hp s) (lcl s) (shp s) b;\n   \\<And>e\\<^sub>0 s\\<^sub>0 b\\<^sub>0 e\\<^sub>1 s\\<^sub>1 b\\<^sub>1 e' s'\n      b'.\n      \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,s\\<^sub>0,\n                               b\\<^sub>0\\<rangle> \\<rightarrow>\n                              \\<langle>e\\<^sub>1,s\\<^sub>1,\n                               b\\<^sub>1\\<rangle>;\n       R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) (shp s\\<^sub>1) b\\<^sub>1\n        e' (hp s') (lcl s') (shp s') b'\\<rbrakk>\n      \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0)\n                         (shp s\\<^sub>0) b\\<^sub>0 e' (hp s') (lcl s')\n                         (shp s') b'\\<rbrakk>\n  \\<Longrightarrow> R e (hp ?s2) (lcl ?s2) (shp ?s2) b e' (hp ?s'2)\n                     (lcl ?s'2) (shp ?s'2) b'\n\ngoal (1 subgoal):\n 1. R e h l sh b e' h' l' sh' b'", "by fastforce"], ["proof (state)\nthis:\n  R e h l sh b e' h' l' sh' b'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection\\<open>Some easy lemmas\\<close>"], ["", "lemma [iff]: \"\\<not> P \\<turnstile> \\<langle>[],s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([], s, b), es', s', b') \\<notin> reds P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (([], s, b), es', s', b') \\<notin> reds P", "by(blast elim: reds.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"\\<not> P \\<turnstile> \\<langle>Val v,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Val v, s, b), e', s', b') \\<notin> red P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Val v, s, b), e', s', b') \\<notin> red P", "by(fastforce elim: red.cases)"], ["", "(*>*)"], ["", "lemma val_no_step: \"val_of e = \\<lfloor>v\\<rfloor> \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of e = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n    ((e, s, b), e', s', b') \\<notin> red P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of e = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n    ((e, s, b), e', s', b') \\<notin> red P", "by(drule val_of_spec, simp)"], ["", "(*>*)"], ["", "lemma [iff]: \"\\<not> P \\<turnstile> \\<langle>Throw a,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Throw a, s, b), e', s', b') \\<notin> red P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Throw a, s, b), e', s', b') \\<notin> red P", "by(fastforce elim: red.cases)"], ["", "(*>*)"], ["", "lemma map_Vals_no_step [iff]: \"\\<not> P \\<turnstile> \\<langle>map Val vs,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map Val vs, s, b), es', s', b') \\<notin> reds P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map Val vs, s, b), es', s', b') \\<notin> reds P", "apply(induct vs arbitrary: es', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs es'.\n       (\\<And>es'.\n           ((map Val vs, s, b), es', s', b')\n           \\<notin> reds P) \\<Longrightarrow>\n       ((map Val (a # vs), s, b), es', s', b') \\<notin> reds P", "apply(rule notI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs es'.\n       \\<lbrakk>\\<And>es'.\n                   ((map Val vs, s, b), es', s', b') \\<notin> reds P;\n        P \\<turnstile> \\<langle>map Val (a # vs),s,\n                        b\\<rangle> [\\<rightarrow>]\n                       \\<langle>es',s',b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule reds.cases, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma vals_no_step: \"map_vals_of es = \\<lfloor>vs\\<rfloor> \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vals_of es = \\<lfloor>vs\\<rfloor> \\<Longrightarrow>\n    ((es, s, b), es', s', b') \\<notin> reds P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vals_of es = \\<lfloor>vs\\<rfloor> \\<Longrightarrow>\n    ((es, s, b), es', s', b') \\<notin> reds P", "by(drule map_vals_of_spec, simp)"], ["", "(*>*)"], ["", "lemma vals_throw_no_step [iff]: \"\\<not> P \\<turnstile> \\<langle>map Val vs @ Throw a # es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map Val vs @ Throw a # es, s, b), es', s', b') \\<notin> reds P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map Val vs @ Throw a # es, s, b), es', s', b') \\<notin> reds P", "apply(induct vs arbitrary: es', auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       P \\<turnstile> \\<langle>Throw a # es,s,b\\<rangle> [\\<rightarrow>]\n                      \\<langle>es',s',b'\\<rangle> \\<Longrightarrow>\n       False\n 2. \\<And>aa vs es'.\n       \\<lbrakk>\\<And>es'.\n                   ((map Val vs @ Throw a # es, s, b), es', s', b')\n                   \\<notin> reds P;\n        P \\<turnstile> \\<langle>Val aa # map Val vs @ Throw a # es,s,\n                        b\\<rangle> [\\<rightarrow>]\n                       \\<langle>es',s',b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule reds.cases, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa vs es'.\n       \\<lbrakk>\\<And>es'.\n                   ((map Val vs @ Throw a # es, s, b), es', s', b')\n                   \\<notin> reds P;\n        P \\<turnstile> \\<langle>Val aa # map Val vs @ Throw a # es,s,\n                        b\\<rangle> [\\<rightarrow>]\n                       \\<langle>es',s',b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule reds.cases, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma lass_val_of_red:\n \"\\<lbrakk> lass_val_of e = \\<lfloor>a\\<rfloor>; P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l', sh'),b'\\<rangle> \\<rbrakk>\n  \\<Longrightarrow> e' = unit \\<and> h' = h \\<and> l' = l(fst a\\<mapsto>snd a) \\<and> sh' = sh \\<and> b = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lass_val_of e = \\<lfloor>a\\<rfloor>;\n     P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l', sh'),b'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and>\n                      h' = h \\<and>\n                      l' = l(fst a \\<mapsto> snd a) \\<and>\n                      sh' = sh \\<and> b = b'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lass_val_of e = \\<lfloor>a\\<rfloor>;\n     P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l', sh'),b'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and>\n                      h' = h \\<and>\n                      l' = l(fst a \\<mapsto> snd a) \\<and>\n                      sh' = sh \\<and> b = b'", "by(drule lass_val_of_spec, auto)"], ["", "(*>*)"], ["", "lemma final_no_step [iff]: \"final e \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow> \\<langle>e',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow> ((e, s, b), e', s', b') \\<notin> red P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow> ((e, s, b), e', s', b') \\<notin> red P", "by(erule finalE, simp+)"], ["", "(*>*)"], ["", "lemma finals_no_step [iff]: \"finals es \\<Longrightarrow> \\<not> P \\<turnstile> \\<langle>es,s,b\\<rangle> [\\<rightarrow>] \\<langle>es',s',b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finals es \\<Longrightarrow> ((es, s, b), es', s', b') \\<notin> reds P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finals es \\<Longrightarrow> ((es, s, b), es', s', b') \\<notin> reds P", "by(erule finalsE, simp+)"], ["", "(*>*)"], ["", "lemma reds_final_same:\n\"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>* \\<langle>e',s',b'\\<rangle> \\<Longrightarrow> final e \\<Longrightarrow> e = e' \\<and> s = s' \\<and> b = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>*\n                            \\<langle>e',s',b'\\<rangle>;\n     final e\\<rbrakk>\n    \\<Longrightarrow> e = e' \\<and> s = s' \\<and> b = b'", "proof(induct rule:converse_rtrancl_induct3)"], ["proof (state)\ngoal (2 subgoals):\n 1. final e' \\<Longrightarrow> e' = e' \\<and> s' = s' \\<and> b' = b'\n 2. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        final ab \\<Longrightarrow> ab = e' \\<and> ac = s' \\<and> ba = b';\n        final a\\<rbrakk>\n       \\<Longrightarrow> a = e' \\<and> aa = s' \\<and> b = b'", "case refl"], ["proof (state)\nthis:\n  final e'\n\ngoal (2 subgoals):\n 1. final e' \\<Longrightarrow> e' = e' \\<and> s' = s' \\<and> b' = b'\n 2. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        final ab \\<Longrightarrow> ab = e' \\<and> ac = s' \\<and> ba = b';\n        final a\\<rbrakk>\n       \\<Longrightarrow> a = e' \\<and> aa = s' \\<and> b = b'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. e' = e' \\<and> s' = s' \\<and> b' = b'", "by simp"], ["proof (state)\nthis:\n  e' = e' \\<and> s' = s' \\<and> b' = b'\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        final ab \\<Longrightarrow> ab = e' \\<and> ac = s' \\<and> ba = b';\n        final a\\<rbrakk>\n       \\<Longrightarrow> a = e' \\<and> aa = s' \\<and> b = b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        final ab \\<Longrightarrow> ab = e' \\<and> ac = s' \\<and> ba = b';\n        final a\\<rbrakk>\n       \\<Longrightarrow> a = e' \\<and> aa = s' \\<and> b = b'", "case (step e0 s0 b0 e1 s1 b1)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e0,s0,b0\\<rangle> \\<rightarrow>\n                 \\<langle>e1,s1,b1\\<rangle>\n  P \\<turnstile> \\<langle>e1,s1,b1\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  final e1 \\<Longrightarrow> e1 = e' \\<and> s1 = s' \\<and> b1 = b'\n  final e0\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        final ab \\<Longrightarrow> ab = e' \\<and> ac = s' \\<and> ba = b';\n        final a\\<rbrakk>\n       \\<Longrightarrow> a = e' \\<and> aa = s' \\<and> b = b'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "proof(rule finalE[OF step.prems(1)])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       e0 = Val v \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'\n 2. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       e0 = Val v \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'\n 2. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "assume \"e0 = Val v\""], ["proof (state)\nthis:\n  e0 = Val v\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       e0 = Val v \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'\n 2. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "then"], ["proof (chain)\npicking this:\n  e0 = Val v", "show ?thesis"], ["proof (prove)\nusing this:\n  e0 = Val v\n\ngoal (1 subgoal):\n 1. e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "using step"], ["proof (prove)\nusing this:\n  e0 = Val v\n  P \\<turnstile> \\<langle>e0,s0,b0\\<rangle> \\<rightarrow>\n                 \\<langle>e1,s1,b1\\<rangle>\n  P \\<turnstile> \\<langle>e1,s1,b1\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  final e1 \\<Longrightarrow> e1 = e' \\<and> s1 = s' \\<and> b1 = b'\n  final e0\n\ngoal (1 subgoal):\n 1. e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "by simp"], ["proof (state)\nthis:\n  e0 = e' \\<and> s0 = s' \\<and> b0 = b'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "assume \"e0 = Throw a\""], ["proof (state)\nthis:\n  e0 = Throw a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       e0 = Throw a \\<Longrightarrow> e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "then"], ["proof (chain)\npicking this:\n  e0 = Throw a", "show ?thesis"], ["proof (prove)\nusing this:\n  e0 = Throw a\n\ngoal (1 subgoal):\n 1. e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "using step"], ["proof (prove)\nusing this:\n  e0 = Throw a\n  P \\<turnstile> \\<langle>e0,s0,b0\\<rangle> \\<rightarrow>\n                 \\<langle>e1,s1,b1\\<rangle>\n  P \\<turnstile> \\<langle>e1,s1,b1\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  final e1 \\<Longrightarrow> e1 = e' \\<and> s1 = s' \\<and> b1 = b'\n  final e0\n\ngoal (1 subgoal):\n 1. e0 = e' \\<and> s0 = s' \\<and> b0 = b'", "by simp"], ["proof (state)\nthis:\n  e0 = e' \\<and> s0 = s' \\<and> b0 = b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e0 = e' \\<and> s0 = s' \\<and> b0 = b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reds_throw:\n\"P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>* \\<langle>e',s',b'\\<rangle> \\<Longrightarrow> (\\<And>e\\<^sub>t. throw_of e = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow> \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,s,b\\<rangle> \\<rightarrow>*\n                   \\<langle>e',s',b'\\<rangle> \\<Longrightarrow>\n    (\\<And>e\\<^sub>t.\n        throw_of e = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n        \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>)", "proof(induct rule:converse_rtrancl_induct3)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e\\<^sub>t.\n       throw_of e' = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n       \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n 2. \\<And>a aa b ab ac ba e\\<^sub>t.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        \\<And>e\\<^sub>t.\n           throw_of ab = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n           \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>;\n        throw_of a = \\<lfloor>e\\<^sub>t\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<^sub>t'.\n                            throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "case refl"], ["proof (state)\nthis:\n  throw_of e' = \\<lfloor>e\\<^sub>t\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>e\\<^sub>t.\n       throw_of e' = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n       \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n 2. \\<And>a aa b ab ac ba e\\<^sub>t.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        \\<And>e\\<^sub>t.\n           throw_of ab = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n           \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>;\n        throw_of a = \\<lfloor>e\\<^sub>t\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<^sub>t'.\n                            throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  throw_of e' = \\<lfloor>e\\<^sub>t\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  throw_of e' = \\<lfloor>e\\<^sub>t\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba e\\<^sub>t.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        \\<And>e\\<^sub>t.\n           throw_of ab = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n           \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>;\n        throw_of a = \\<lfloor>e\\<^sub>t\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<^sub>t'.\n                            throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba e\\<^sub>t.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        \\<And>e\\<^sub>t.\n           throw_of ab = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n           \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>;\n        throw_of a = \\<lfloor>e\\<^sub>t\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<^sub>t'.\n                            throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "case (step e0 s0 b0 e1 s1 b1)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e0,s0,b0\\<rangle> \\<rightarrow>\n                 \\<langle>e1,s1,b1\\<rangle>\n  P \\<turnstile> \\<langle>e1,s1,b1\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  throw_of e1 = \\<lfloor>?e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n  \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n  throw_of e0 = \\<lfloor>e\\<^sub>t\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba e\\<^sub>t.\n       \\<lbrakk>P \\<turnstile> \\<langle>a,aa,b\\<rangle> \\<rightarrow>\n                               \\<langle>ab,ac,ba\\<rangle>;\n        P \\<turnstile> \\<langle>ab,ac,ba\\<rangle> \\<rightarrow>*\n                       \\<langle>e',s',b'\\<rangle>;\n        \\<And>e\\<^sub>t.\n           throw_of ab = \\<lfloor>e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n           \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>;\n        throw_of a = \\<lfloor>e\\<^sub>t\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<^sub>t'.\n                            throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e0,s0,b0\\<rangle> \\<rightarrow>\n                 \\<langle>e1,s1,b1\\<rangle>\n  P \\<turnstile> \\<langle>e1,s1,b1\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  throw_of e1 = \\<lfloor>?e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n  \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n  throw_of e0 = \\<lfloor>e\\<^sub>t\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e0,s0,b0\\<rangle> \\<rightarrow>\n                 \\<langle>e1,s1,b1\\<rangle>\n  P \\<turnstile> \\<langle>e1,s1,b1\\<rangle> \\<rightarrow>*\n                 \\<langle>e',s',b'\\<rangle>\n  throw_of e1 = \\<lfloor>?e\\<^sub>t\\<rfloor> \\<Longrightarrow>\n  \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n  throw_of e0 = \\<lfloor>e\\<^sub>t\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>", "by(auto elim: red.cases)"], ["proof (state)\nthis:\n  \\<exists>e\\<^sub>t'. throw_of e' = \\<lfloor>e\\<^sub>t'\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma red_hext_incr: \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l',sh'),b'\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\"\n  and reds_hext_incr: \"P \\<turnstile> \\<langle>es,(h,l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l',sh'),b'\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h') &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh),b\\<rangle> [\\<rightarrow>]\n                    \\<langle>es',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h') &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh),b\\<rangle> [\\<rightarrow>]\n                    \\<langle>es',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h')", "proof(induct rule:red_reds_inducts)"], ["proof (state)\ngoal (95 subgoals):\n 1. \\<And>h a C FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>h C l sh.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C sfs h l.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow> h \\<unlhd> h\n 4. \\<And>sh C h l.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 5. \\<And>e a aa b ba e' ab ac bb b' C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>C a aa b ba. a \\<unlhd> a\n 7. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 8. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         a \\<unlhd> ab\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ab\nA total of 95 subgoals...", "case RedNew"], ["proof (state)\nthis:\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  P \\<turnstile> C_ has_fields FDTs_\n  h'_ = h_(a_ \\<mapsto> blank P C_)\n\ngoal (95 subgoals):\n 1. \\<And>h a C FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>h C l sh.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C sfs h l.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow> h \\<unlhd> h\n 4. \\<And>sh C h l.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 5. \\<And>e a aa b ba e' ab ac bb b' C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>C a aa b ba. a \\<unlhd> a\n 7. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 8. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         a \\<unlhd> ab\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ab\nA total of 95 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  P \\<turnstile> C_ has_fields FDTs_\n  h'_ = h_(a_ \\<mapsto> blank P C_)\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h'_", "by(fastforce dest:new_Addr_SomeD simp:hext_def split:if_splits)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h'_\n\ngoal (94 subgoals):\n 1. \\<And>h C l sh.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C sfs h l.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C h l.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 4. \\<And>e a aa b ba e' ab ac bb b' C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 5. \\<And>C a aa b ba. a \\<unlhd> a\n 6. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 7. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        a \\<unlhd> a\nA total of 94 subgoals...", "next"], ["proof (state)\ngoal (94 subgoals):\n 1. \\<And>h C l sh.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C sfs h l.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C h l.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 4. \\<And>e a aa b ba e' ab ac bb b' C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 5. \\<And>C a aa b ba. a \\<unlhd> a\n 6. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 7. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        a \\<unlhd> a\nA total of 94 subgoals...", "case RedFAss"], ["proof (state)\nthis:\n  P \\<turnstile> C_ has F_,NonStatic:t_ in D_\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n\ngoal (94 subgoals):\n 1. \\<And>h C l sh.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C sfs h l.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C h l.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 4. \\<And>e a aa b ba e' ab ac bb b' C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 5. \\<And>C a aa b ba. a \\<unlhd> a\n 6. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 7. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        a \\<unlhd> a\nA total of 94 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C_ has F_,NonStatic:t_ in D_\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h_(a_ \\<mapsto> (C_, fs_((F_, D_) \\<mapsto> v_)))", "by(simp add:hext_def split:if_splits)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h_(a_ \\<mapsto> (C_, fs_((F_, D_) \\<mapsto> v_)))\n\ngoal (93 subgoals):\n 1. \\<And>h C l sh.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C sfs h l.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C h l.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 4. \\<And>e a aa b ba e' ab ac bb b' C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 5. \\<And>C a aa b ba. a \\<unlhd> a\n 6. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 7. \\<And>h a D fs C l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        a \\<unlhd> a\nA total of 93 subgoals...", "qed simp_all"], ["", "(*>*)"], ["", "lemma red_lcl_incr: \"P \\<turnstile> \\<langle>e,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0),b\\<rangle> \\<rightarrow> \\<langle>e',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1),b'\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"\nand reds_lcl_incr: \"P \\<turnstile> \\<langle>es,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1),b'\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h\\<^sub>0, l\\<^sub>0, sh\\<^sub>0),\n                     b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                     b'\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1) &&&\n    (P \\<turnstile> \\<langle>es,(h\\<^sub>0, l\\<^sub>0, sh\\<^sub>0),\n                     b\\<rangle> [\\<rightarrow>]\n                    \\<langle>es',(h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                     b'\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h\\<^sub>0, l\\<^sub>0, sh\\<^sub>0),\n                     b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                     b'\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1) &&&\n    (P \\<turnstile> \\<langle>es,(h\\<^sub>0, l\\<^sub>0, sh\\<^sub>0),\n                     b\\<rangle> [\\<rightarrow>]\n                    \\<langle>es',(h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                     b'\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1)", "by(induct rule: red_reds_inducts)(auto simp del:fun_upd_apply)"], ["", "(*>*)"], ["", "lemma red_lcl_add: \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l',sh'),b'\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l\\<^sub>0++l',sh'),b'\\<rangle>)\"\nand reds_lcl_add: \"P \\<turnstile> \\<langle>es,(h,l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l',sh'),b'\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>es,(h,l\\<^sub>0++l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l\\<^sub>0++l',sh'),b'\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     (\\<And>l\\<^sub>0.\n         P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                         b\\<rangle> \\<rightarrow>\n                        \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                         b'\\<rangle>)) &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh),b\\<rangle> [\\<rightarrow>]\n                    \\<langle>es',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     (\\<And>l\\<^sub>0.\n         P \\<turnstile> \\<langle>es,(h, l\\<^sub>0 ++ l, sh),\n                         b\\<rangle> [\\<rightarrow>]\n                        \\<langle>es',(h', l\\<^sub>0 ++ l', sh'),\n                         b'\\<rangle>))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     (\\<And>l\\<^sub>0.\n         P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                         b\\<rangle> \\<rightarrow>\n                        \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                         b'\\<rangle>)) &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh),b\\<rangle> [\\<rightarrow>]\n                    \\<langle>es',(h', l', sh'),b'\\<rangle> \\<Longrightarrow>\n     (\\<And>l\\<^sub>0.\n         P \\<turnstile> \\<langle>es,(h, l\\<^sub>0 ++ l, sh),\n                         b\\<rangle> [\\<rightarrow>]\n                        \\<langle>es',(h', l\\<^sub>0 ++ l', sh'),\n                         b'\\<rangle>))", "proof (induct rule:red_reds_inducts)"], ["proof (state)\ngoal (95 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 8. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>THROW ClassCast,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                            ba\\<rangle> \\<rightarrow>\n                           \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                            b'\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n             v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n    (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n   \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n    (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\nA total of 95 subgoals...", "case RedCast"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* C_\n\ngoal (95 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 8. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>THROW ClassCast,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                            ba\\<rangle> \\<rightarrow>\n                           \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                            b'\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n             v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n    (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n   \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n    (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\nA total of 95 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* C_\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>Cast C_ (addr a_),(h_, l\\<^sub>0 ++ l_, sh_),\n                    b_\\<rangle> \\<rightarrow>\n                   \\<langle>addr a_,(h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Cast C_ (addr a_),(h_, l\\<^sub>0 ++ l_, sh_),\n                  b_\\<rangle> \\<rightarrow>\n                 \\<langle>addr a_,(h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>\n\ngoal (94 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>THROW ClassCast,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n        v\\<^sub>2,\n                        (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\nA total of 94 subgoals...", "next"], ["proof (state)\ngoal (94 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>THROW ClassCast,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n        v\\<^sub>2,\n                        (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\nA total of 94 subgoals...", "case RedCastFail"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  (D_, C_) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (94 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>h a D fs C l sh b l\\<^sub>0.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C (addr a),\n   (h, l\\<^sub>0 ++ l, sh),b\\<rangle> \\<rightarrow>\n  \\<langle>THROW ClassCast,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 10. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n        binop (bop, v\\<^sub>1, v\\<^sub>2) =\n        \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n        v\\<^sub>2,\n                        (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\nA total of 94 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  (D_, C_) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>Cast C_ (addr a_),(h_, l\\<^sub>0 ++ l_, sh_),\n                    b_\\<rangle> \\<rightarrow>\n                   \\<langle>THROW ClassCast,(h_, l\\<^sub>0 ++ l_, sh_),\n                    b_\\<rangle>", "by(force intro:red_reds.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Cast C_ (addr a_),(h_, l\\<^sub>0 ++ l_, sh_),\n                  b_\\<rangle> \\<rightarrow>\n                 \\<langle>THROW ClassCast,(h_, l\\<^sub>0 ++ l_, sh_),\n                  b_\\<rangle>\n\ngoal (93 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 93 subgoals...", "next"], ["proof (state)\ngoal (93 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 93 subgoals...", "case RedFAcc"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  fs_ (F_, D_) = \\<lfloor>v_\\<rfloor>\n  P \\<turnstile> C_ has F_,NonStatic:t_ in D_\n\ngoal (93 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 93 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  fs_ (F_, D_) = \\<lfloor>v_\\<rfloor>\n  P \\<turnstile> C_ has F_,NonStatic:t_ in D_\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>addr a_\\<bullet>F_{D_},\n                    (h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle> \\<rightarrow>\n                   \\<langle>Val v_,(h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>addr a_\\<bullet>F_{D_},(h_, l\\<^sub>0 ++ l_, sh_),\n                  b_\\<rangle> \\<rightarrow>\n                 \\<langle>Val v_,(h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>\n\ngoal (92 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 92 subgoals...", "next"], ["proof (state)\ngoal (92 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 92 subgoals...", "case RedCall"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n\ngoal (92 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 92 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                    (h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle> \\<rightarrow>\n                   \\<langle>blocks\n                             (this # pns_, Class D_ # Ts_, Addr a_ # vs_,\n                              body_),\n                    (h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>addr a_\\<bullet>M_(map Val vs_),\n                  (h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle> \\<rightarrow>\n                 \\<langle>blocks\n                           (this # pns_, Class D_ # Ts_, Addr a_ # vs_,\n                            body_),\n                  (h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>\n\ngoal (91 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 91 subgoals...", "next"], ["proof (state)\ngoal (91 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 91 subgoals...", "case (InitBlockRed e h l V v sh b e' h' l' sh' b' v' T l\\<^sub>0)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, l(V \\<mapsto> v), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l', sh'),b'\\<rangle>\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V \\<mapsto> v), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n  l' V = \\<lfloor>v'\\<rfloor>\n\ngoal (91 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 91 subgoals...", "have IH: \"\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V \\<mapsto> v), sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>\"\n    and l'V: \"l' V = Some v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l\\<^sub>0.\n        P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V \\<mapsto> v), sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>) &&&\n    l' V = \\<lfloor>v'\\<rfloor>", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V \\<mapsto> v), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n  l' V = \\<lfloor>v'\\<rfloor>\n\ngoal (91 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 91 subgoals...", "from IH"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V \\<mapsto> v), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "have IH': \"P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V \\<mapsto> v), sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V \\<mapsto> v), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V \\<mapsto> v), sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V \\<mapsto> v), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n\ngoal (91 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 91 subgoals...", "have \"(l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)", "by(rule ext)(simp add:map_add_def)"], ["proof (state)\nthis:\n  (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\n\ngoal (91 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 91 subgoals...", "with red_reds.InitBlockRed[OF IH'] l'V"], ["proof (chain)\npicking this:\n  (l\\<^sub>0 ++ l') V = \\<lfloor>?v'\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>{V:?T; V:=Val v;; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:?T; V:=Val ?v';; e'},\n                  (h', (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V), sh'),\n                  b'\\<rangle>\n  l' V = \\<lfloor>v'\\<rfloor>\n  (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)", "show ?case"], ["proof (prove)\nusing this:\n  (l\\<^sub>0 ++ l') V = \\<lfloor>?v'\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>{V:?T; V:=Val v;; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:?T; V:=Val ?v';; e'},\n                  (h', (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V), sh'),\n                  b'\\<rangle>\n  l' V = \\<lfloor>v'\\<rfloor>\n  (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>{V:T; V:=Val v;; e},(h, l\\<^sub>0 ++ l, sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val v';; e'},\n                    (h', l\\<^sub>0 ++ l'(V := l V), sh'),b'\\<rangle>", "by(simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>{V:T; V:=Val v;; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:T; V:=Val v';; e'},\n                  (h', l\\<^sub>0 ++ l'(V := l V), sh'),b'\\<rangle>\n\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "next"], ["proof (state)\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "case (BlockRedNone e h l V sh b e' h' l' sh' b' T l\\<^sub>0)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, l(V := None), sh),b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l', sh'),b'\\<rangle>\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n  l' V = None\n  \\<not> assigned V e\n\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "have IH: \"\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V := None), sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>\"\n    and l'V: \"l' V = None\" and unass: \"\\<not> assigned V e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l\\<^sub>0.\n        P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V := None), sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>) &&&\n    l' V = None &&& \\<not> assigned V e", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n  l' V = None\n  \\<not> assigned V e\n\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "have \"l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "hence IH': \"P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0++l)(V := None), sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),b'\\<rangle>\""], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V := None), sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                    b'\\<rangle>", "using IH[of \"l\\<^sub>0(V := None)\"]"], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n  P \\<turnstile> \\<langle>e,(h, l\\<^sub>0(V := None) ++ l(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                  b'\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V := None), sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                    b'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                  b'\\<rangle>\n\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "have \"(l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n    l\\<^sub>0 ++ l'(V := l V)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (90 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 90 subgoals...", "with red_reds.BlockRedNone[OF IH' _ unass] l'V"], ["proof (chain)\npicking this:\n  (l\\<^sub>0(V := None) ++ l') V = None \\<Longrightarrow>\n  P \\<turnstile> \\<langle>{V:?T; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:?T; e'},\n                  (h', (l\\<^sub>0(V := None) ++ l')\n                   (V := (l\\<^sub>0 ++ l) V), sh'),\n                  b'\\<rangle>\n  l' V = None\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)", "show ?case"], ["proof (prove)\nusing this:\n  (l\\<^sub>0(V := None) ++ l') V = None \\<Longrightarrow>\n  P \\<turnstile> \\<langle>{V:?T; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:?T; e'},\n                  (h', (l\\<^sub>0(V := None) ++ l')\n                   (V := (l\\<^sub>0 ++ l) V), sh'),\n                  b'\\<rangle>\n  l' V = None\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>{V:T; e},(h, l\\<^sub>0 ++ l, sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; e'},(h', l\\<^sub>0 ++ l'(V := l V), sh'),\n                    b'\\<rangle>", "by(simp add: map_add_def)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>{V:T; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:T; e'},(h', l\\<^sub>0 ++ l'(V := l V), sh'),\n                  b'\\<rangle>\n\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "next"], ["proof (state)\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "case (BlockRedSome e h l V sh b e' h' l' sh' b' v T l\\<^sub>0)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, l(V := None), sh),b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l', sh'),b'\\<rangle>\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  \\<not> assigned V e\n\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "have IH: \"\\<And>l\\<^sub>0. P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V := None), sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>\"\n    and l'V: \"l' V = Some v\" and unass: \"\\<not> assigned V e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l\\<^sub>0.\n        P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V := None), sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>) &&&\n    l' V = \\<lfloor>v\\<rfloor> &&& \\<not> assigned V e", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, ?l\\<^sub>0 ++ l(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', ?l\\<^sub>0 ++ l', sh'),b'\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  \\<not> assigned V e\n\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "have \"l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "hence IH': \"P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0++l)(V := None), sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),b'\\<rangle>\""], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V := None), sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                    b'\\<rangle>", "using IH[of \"l\\<^sub>0(V := None)\"]"], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n  P \\<turnstile> \\<langle>e,(h, l\\<^sub>0(V := None) ++ l(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                  b'\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V := None), sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                    b'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V := None), sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>e',(h', l\\<^sub>0(V := None) ++ l', sh'),\n                  b'\\<rangle>\n\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "have \"(l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n    l\\<^sub>0 ++ l'(V := l V)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (89 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 89 subgoals...", "with red_reds.BlockRedSome[OF IH' _ unass] l'V"], ["proof (chain)\npicking this:\n  (l\\<^sub>0(V := None) ++ l') V = \\<lfloor>?v\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>{V:?T; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:?T; V:=Val ?v;; e'},\n                  (h', (l\\<^sub>0(V := None) ++ l')\n                   (V := (l\\<^sub>0 ++ l) V), sh'),\n                  b'\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)", "show ?case"], ["proof (prove)\nusing this:\n  (l\\<^sub>0(V := None) ++ l') V = \\<lfloor>?v\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> \\<langle>{V:?T; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:?T; V:=Val ?v;; e'},\n                  (h', (l\\<^sub>0(V := None) ++ l')\n                   (V := (l\\<^sub>0 ++ l) V), sh'),\n                  b'\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>{V:T; e},(h, l\\<^sub>0 ++ l, sh),\n                    b\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val v;; e'},\n                    (h', l\\<^sub>0 ++ l'(V := l V), sh'),b'\\<rangle>", "by(simp add:map_add_def)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>{V:T; e},(h, l\\<^sub>0 ++ l, sh),\n                  b\\<rangle> \\<rightarrow>\n                 \\<langle>{V:T; V:=Val v;; e'},\n                  (h', l\\<^sub>0 ++ l'(V := l V), sh'),b'\\<rangle>\n\ngoal (88 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 88 subgoals...", "next"], ["proof (state)\ngoal (88 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 88 subgoals...", "case RedTryCatch"], ["proof (state)\nthis:\n  hp (a___, aa___, ba___) a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* C_\n\ngoal (88 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 88 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  hp (a___, aa___, ba___) a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* C_\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>try Throw a_ catch(C_ V_) e\\<^sub>2_,\n                    (a___, l\\<^sub>0 ++ aa___, ba___),\n                    b_\\<rangle> \\<rightarrow>\n                   \\<langle>{V_:Class C_; V_:=addr a_;; e\\<^sub>2_},\n                    (a___, l\\<^sub>0 ++ aa___, ba___),b_\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>try Throw a_ catch(C_ V_) e\\<^sub>2_,\n                  (a___, l\\<^sub>0 ++ aa___, ba___),\n                  b_\\<rangle> \\<rightarrow>\n                 \\<langle>{V_:Class C_; V_:=addr a_;; e\\<^sub>2_},\n                  (a___, l\\<^sub>0 ++ aa___, ba___),b_\\<rangle>\n\ngoal (87 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 87 subgoals...", "next"], ["proof (state)\ngoal (87 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 87 subgoals...", "case RedTryFail"], ["proof (state)\nthis:\n  hp (a___, aa___, ba___) a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  (D_, C_) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (87 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 87 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  hp (a___, aa___, ba___) a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  (D_, C_) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>try Throw a_ catch(C_ V_) e\\<^sub>2_,\n                    (a___, l\\<^sub>0 ++ aa___, ba___),\n                    b_\\<rangle> \\<rightarrow>\n                   \\<langle>Throw a_,(a___, l\\<^sub>0 ++ aa___, ba___),\n                    b_\\<rangle>", "by(force intro!:red_reds.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>try Throw a_ catch(C_ V_) e\\<^sub>2_,\n                  (a___, l\\<^sub>0 ++ aa___, ba___),\n                  b_\\<rangle> \\<rightarrow>\n                 \\<langle>Throw a_,(a___, l\\<^sub>0 ++ aa___, ba___),\n                  b_\\<rangle>\n\ngoal (86 subgoals):\n 1. \\<And>h a C FDTs h' l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>addr a,(h', l\\<^sub>0 ++ l, sh),False\\<rangle>\n 2. \\<And>h C l sh l\\<^sub>0.\n       \\<lbrakk>new_Addr h = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),True\\<rangle> \\<rightarrow>\n  \\<langle>THROW OutOfMemory,(h, l\\<^sub>0 ++ l, sh),False\\<rangle>\n 3. \\<And>sh C sfs h l l\\<^sub>0.\n       sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),\n                       False\\<rangle> \\<rightarrow>\n                      \\<langle>new C,(h, l\\<^sub>0 ++ l, sh),True\\<rangle>\n 4. \\<And>sh C h l l\\<^sub>0.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>new C,\n   (h, l\\<^sub>0 ++ l, sh),False\\<rangle> \\<rightarrow>\n  \\<langle>INIT C ([C],False) \\<leftarrow> new C,(h, l\\<^sub>0 ++ l, sh),\n   False\\<rangle>\n 5. \\<And>e a aa b ba e' ab ac bb b' C l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Cast C e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Cast C e',(ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 6. \\<And>C a aa b ba l\\<^sub>0.\n       P \\<turnstile> \\<langle>Cast C null,(a, l\\<^sub>0 ++ aa, b),\n                       ba\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 7. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 8. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P \\<turnstile> \\<langle>e,(a, l\\<^sub>0 ++ aa, b),\n                           ba\\<rangle> \\<rightarrow>\n                          \\<langle>e',(ab, l\\<^sub>0 ++ ac, bb),\n                           b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>Val\n            v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n   (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n  \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n   (ab, l\\<^sub>0 ++ ac, bb),b'\\<rangle>\n 9. \\<And>bop v\\<^sub>1 v\\<^sub>2 v a aa b ba l\\<^sub>0.\n       binop (bop, v\\<^sub>1, v\\<^sub>2) =\n       \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n       P \\<turnstile> \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> Val\n       v\\<^sub>2,\n                       (a, l\\<^sub>0 ++ aa, b),ba\\<rangle> \\<rightarrow>\n                      \\<langle>Val v,(a, l\\<^sub>0 ++ aa, b),ba\\<rangle>\n 10. \\<And>l V v h sh b l\\<^sub>0.\n        l V = \\<lfloor>v\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> \\<langle>Var V,(h, l\\<^sub>0 ++ l, sh),\n                        b\\<rangle> \\<rightarrow>\n                       \\<langle>Val v,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\nA total of 86 subgoals...", "qed (simp_all add:red_reds.intros)"], ["", "(*>*)"], ["", "lemma Red_lcl_add:\nassumes \"P \\<turnstile> \\<langle>e,(h,l,sh), b\\<rangle> \\<rightarrow>* \\<langle>e',(h',l',sh'), b'\\<rangle>\" shows \"P \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l,sh),b\\<rangle> \\<rightarrow>* \\<langle>e',(h',l\\<^sub>0++l',sh'),b'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                    b\\<rangle> \\<rightarrow>*\n                   \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                    b\\<rangle> \\<rightarrow>*\n                   \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>*\n                 \\<langle>e',(h', l', sh'),b'\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                    b\\<rangle> \\<rightarrow>*\n                   \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "proof(induct rule:converse_rtrancl_induct_red)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e h l sh b.\n       P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                       b\\<rangle> \\<rightarrow>*\n                      \\<langle>e,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 2. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1\n       h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,\n                                (h\\<^sub>0, l\\<^sub>0', sh\\<^sub>0),\n                                b\\<^sub>0\\<rangle> \\<rightarrow>\n                               \\<langle>e\\<^sub>1,\n                                (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                                b\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>e\\<^sub>1,\n                        (h\\<^sub>1, l\\<^sub>0 ++ l\\<^sub>1, sh\\<^sub>1),\n                        b\\<^sub>1\\<rangle> \\<rightarrow>*\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e\\<^sub>0,\n   (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0', sh\\<^sub>0),\n   b\\<^sub>0\\<rangle> \\<rightarrow>*\n  \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>e h l sh b.\n       P \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l, sh),\n                       b\\<rangle> \\<rightarrow>*\n                      \\<langle>e,(h, l\\<^sub>0 ++ l, sh),b\\<rangle>\n 2. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1\n       h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,\n                                (h\\<^sub>0, l\\<^sub>0', sh\\<^sub>0),\n                                b\\<^sub>0\\<rangle> \\<rightarrow>\n                               \\<langle>e\\<^sub>1,\n                                (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                                b\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>e\\<^sub>1,\n                        (h\\<^sub>1, l\\<^sub>0 ++ l\\<^sub>1, sh\\<^sub>1),\n                        b\\<^sub>1\\<rangle> \\<rightarrow>*\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e\\<^sub>0,\n   (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0', sh\\<^sub>0),\n   b\\<^sub>0\\<rangle> \\<rightarrow>*\n  \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e_,(h_, l\\<^sub>0 ++ l_, sh_),\n                    b_\\<rangle> \\<rightarrow>*\n                   \\<langle>e_,(h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(h_, l\\<^sub>0 ++ l_, sh_),\n                  b_\\<rangle> \\<rightarrow>*\n                 \\<langle>e_,(h_, l\\<^sub>0 ++ l_, sh_),b_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1\n       h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,\n                                (h\\<^sub>0, l\\<^sub>0', sh\\<^sub>0),\n                                b\\<^sub>0\\<rangle> \\<rightarrow>\n                               \\<langle>e\\<^sub>1,\n                                (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                                b\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>e\\<^sub>1,\n                        (h\\<^sub>1, l\\<^sub>0 ++ l\\<^sub>1, sh\\<^sub>1),\n                        b\\<^sub>1\\<rangle> \\<rightarrow>*\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e\\<^sub>0,\n   (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0', sh\\<^sub>0),\n   b\\<^sub>0\\<rangle> \\<rightarrow>*\n  \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1\n       h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,\n                                (h\\<^sub>0, l\\<^sub>0', sh\\<^sub>0),\n                                b\\<^sub>0\\<rangle> \\<rightarrow>\n                               \\<langle>e\\<^sub>1,\n                                (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                                b\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>e\\<^sub>1,\n                        (h\\<^sub>1, l\\<^sub>0 ++ l\\<^sub>1, sh\\<^sub>1),\n                        b\\<^sub>1\\<rangle> \\<rightarrow>*\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e\\<^sub>0,\n   (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0', sh\\<^sub>0),\n   b\\<^sub>0\\<rangle> \\<rightarrow>*\n  \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "case 2"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>0_,(h\\<^sub>0_, l\\<^sub>0_, sh\\<^sub>0_),\n                  b\\<^sub>0_\\<rangle> \\<rightarrow>\n                 \\<langle>e\\<^sub>1_,(h\\<^sub>1_, l\\<^sub>1_, sh\\<^sub>1_),\n                  b\\<^sub>1_\\<rangle>\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (h\\<^sub>1_, l\\<^sub>0 ++ l\\<^sub>1_, sh\\<^sub>1_),\n                  b\\<^sub>1_\\<rangle> \\<rightarrow>*\n                 \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_, sh'_),b'_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' sh\\<^sub>0 b\\<^sub>0 e\\<^sub>1\n       h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 b\\<^sub>1 e' h' l' sh' b'.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>0,\n                                (h\\<^sub>0, l\\<^sub>0', sh\\<^sub>0),\n                                b\\<^sub>0\\<rangle> \\<rightarrow>\n                               \\<langle>e\\<^sub>1,\n                                (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1),\n                                b\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>e\\<^sub>1,\n                        (h\\<^sub>1, l\\<^sub>0 ++ l\\<^sub>1, sh\\<^sub>1),\n                        b\\<^sub>1\\<rangle> \\<rightarrow>*\n                       \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),\n                        b'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e\\<^sub>0,\n   (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0', sh\\<^sub>0),\n   b\\<^sub>0\\<rangle> \\<rightarrow>*\n  \\<langle>e',(h', l\\<^sub>0 ++ l', sh'),b'\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e\\<^sub>0_,(h\\<^sub>0_, l\\<^sub>0_, sh\\<^sub>0_),\n                  b\\<^sub>0_\\<rangle> \\<rightarrow>\n                 \\<langle>e\\<^sub>1_,(h\\<^sub>1_, l\\<^sub>1_, sh\\<^sub>1_),\n                  b\\<^sub>1_\\<rangle>\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (h\\<^sub>1_, l\\<^sub>0 ++ l\\<^sub>1_, sh\\<^sub>1_),\n                  b\\<^sub>1_\\<rangle> \\<rightarrow>*\n                 \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_, sh'_),b'_\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e\\<^sub>0_,\n                    (h\\<^sub>0_, l\\<^sub>0 ++ l\\<^sub>0_, sh\\<^sub>0_),\n                    b\\<^sub>0_\\<rangle> \\<rightarrow>*\n                   \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_, sh'_),b'_\\<rangle>", "by (blast dest: red_lcl_add intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>0_,\n                  (h\\<^sub>0_, l\\<^sub>0 ++ l\\<^sub>0_, sh\\<^sub>0_),\n                  b\\<^sub>0_\\<rangle> \\<rightarrow>*\n                 \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_, sh'_),b'_\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma assumes wf: \"wwf_J_prog P\"\nshows red_proc_pres: \"P \\<turnstile> \\<langle>e,(h,l,sh),b\\<rangle> \\<rightarrow> \\<langle>e',(h',l',sh'),b'\\<rangle>\n  \\<Longrightarrow> not_init C e \\<Longrightarrow> sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> not_init C e' \\<and> (\\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)\"\n  and reds_proc_pres: \"P \\<turnstile> \\<langle>es,(h,l,sh),b\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l',sh'),b'\\<rangle>\n  \\<Longrightarrow> not_inits C es \\<Longrightarrow> sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> not_inits C es' \\<and> (\\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                             \\<langle>e',(h', l', sh'),b'\\<rangle>;\n      not_init C e; sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> not_init C e' \\<and>\n                       (\\<exists>sfs'.\n                           sh' C =\n                           \\<lfloor>(sfs', Processing)\\<rfloor>)) &&&\n    (\\<lbrakk>P \\<turnstile> \\<langle>es,(h, l, sh),\n                              b\\<rangle> [\\<rightarrow>]\n                             \\<langle>es',(h', l', sh'),b'\\<rangle>;\n      not_inits C es; sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> not_inits C es' \\<and>\n                       (\\<exists>sfs'.\n                           sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile> \\<langle>e,(h, l, sh),b\\<rangle> \\<rightarrow>\n                             \\<langle>e',(h', l', sh'),b'\\<rangle>;\n      not_init C e; sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> not_init C e' \\<and>\n                       (\\<exists>sfs'.\n                           sh' C =\n                           \\<lfloor>(sfs', Processing)\\<rfloor>)) &&&\n    (\\<lbrakk>P \\<turnstile> \\<langle>es,(h, l, sh),\n                              b\\<rangle> [\\<rightarrow>]\n                             \\<langle>es',(h', l', sh'),b'\\<rangle>;\n      not_inits C es; sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> not_inits C es' \\<and>\n                       (\\<exists>sfs'.\n                           sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>))", "proof(induct rule:red_reds_inducts)"], ["proof (state)\ngoal (95 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 95 subgoals...", "case RedCall"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (addr a_\\<bullet>M_(map Val vs_))\n  sh_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (95 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 95 subgoals...", "then"], ["proof (chain)\npicking this:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (addr a_\\<bullet>M_(map Val vs_))\n  sh_ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (addr a_\\<bullet>M_(map Val vs_))\n  sh_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C\n     (blocks (this # pns_, Class D_ # Ts_, Addr a_ # vs_, body_)) \\<and>\n    (\\<exists>sfs'. sh_ C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "using sees_wwf_nsub_RI[OF wf RedCall.hyps(2)] sub_RI_blocks_body nsub_RI_not_init"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (addr a_\\<bullet>M_(map Val vs_))\n  sh_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body_\n  \\<lbrakk>length ?vs = length ?pns; length ?Ts = length ?pns\\<rbrakk>\n  \\<Longrightarrow> sub_RI (blocks (?pns, ?Ts, ?vs, ?body)) = sub_RI ?body\n  \\<not> sub_RI ?e \\<Longrightarrow> not_init ?C ?e\n\ngoal (1 subgoal):\n 1. not_init C\n     (blocks (this # pns_, Class D_ # Ts_, Addr a_ # vs_, body_)) \\<and>\n    (\\<exists>sfs'. sh_ C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  not_init C\n   (blocks (this # pns_, Class D_ # Ts_, Addr a_ # vs_, body_)) \\<and>\n  (\\<exists>sfs'. sh_ C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (94 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 94 subgoals...", "next"], ["proof (state)\ngoal (94 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 94 subgoals...", "case RedSCall"], ["proof (state)\nthis:\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (C_\\<bullet>\\<^sub>sM_(map Val vs_))\n  b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (94 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 94 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (C_\\<bullet>\\<^sub>sM_(map Val vs_))\n  b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (C_\\<bullet>\\<^sub>sM_(map Val vs_))\n  b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C (blocks (pns_, Ts_, vs_, body_)) \\<and>\n    (\\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "using sees_wwf_nsub_RI[OF wf RedSCall.hyps(1)] sub_RI_blocks_body nsub_RI_not_init"], ["proof (prove)\nusing this:\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  not_init C (C_\\<bullet>\\<^sub>sM_(map Val vs_))\n  b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body_\n  \\<lbrakk>length ?vs = length ?pns; length ?Ts = length ?pns\\<rbrakk>\n  \\<Longrightarrow> sub_RI (blocks (?pns, ?Ts, ?vs, ?body)) = sub_RI ?body\n  \\<not> sub_RI ?e \\<Longrightarrow> not_init ?C ?e\n\ngoal (1 subgoal):\n 1. not_init C (blocks (pns_, Ts_, vs_, body_)) \\<and>\n    (\\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  not_init C (blocks (pns_, Ts_, vs_, body_)) \\<and>\n  (\\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (93 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 93 subgoals...", "next"], ["proof (state)\ngoal (93 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 93 subgoals...", "case (RedInitDone sh C sfs C' Cs e h l b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (93 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 93 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C (INIT C' (Cs,True) \\<leftarrow> e) \\<and>\n    (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  not_init C (INIT C' (Cs,True) \\<leftarrow> e) \\<and>\n  (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (92 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 92 subgoals...", "next"], ["proof (state)\ngoal (92 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 92 subgoals...", "case (RedInitProcessing sh C sfs C' Cs e h l b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (92 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 92 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C (INIT C' (Cs,True) \\<leftarrow> e) \\<and>\n    (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  not_init C (INIT C' (Cs,True) \\<leftarrow> e) \\<and>\n  (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (91 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 91 subgoals...", "next"], ["proof (state)\ngoal (91 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 91 subgoals...", "case (RedRInit sh C sfs i sh' C' Cs v e h l b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh' = sh(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  not_init C (RI (C,Val v) ; Cs \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (91 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 91 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh' = sh(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  not_init C (RI (C,Val v) ; Cs \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh' = sh(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  not_init C (RI (C,Val v) ; Cs \\<leftarrow> e)\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C (INIT C' (Cs,True) \\<leftarrow> e) \\<and>\n    (\\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  not_init C (INIT C' (Cs,True) \\<leftarrow> e) \\<and>\n  (\\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (90 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 90 subgoals...", "next"], ["proof (state)\ngoal (90 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 90 subgoals...", "case (CallThrowParams es vs e es' v M h l sh b)"], ["proof (state)\nthis:\n  es = map Val vs @ throw e # es'\n  not_init C (Val v\\<bullet>M(es))\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (90 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 90 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = map Val vs @ throw e # es'\n  not_init C (Val v\\<bullet>M(es))\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  es = map Val vs @ throw e # es'\n  not_init C (Val v\\<bullet>M(es))\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C (throw e) \\<and>\n    (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by(auto dest: not_inits_def')"], ["proof (state)\nthis:\n  not_init C (throw e) \\<and>\n  (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (89 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 89 subgoals...", "next"], ["proof (state)\ngoal (89 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 89 subgoals...", "case (SCallThrowParams es vs e es' C M h l sh b)"], ["proof (state)\nthis:\n  es = map Val vs @ throw e # es'\n  not_init C (C\\<bullet>\\<^sub>sM(es))\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (89 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 89 subgoals...", "then"], ["proof (chain)\npicking this:\n  es = map Val vs @ throw e # es'\n  not_init C (C\\<bullet>\\<^sub>sM(es))\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  es = map Val vs @ throw e # es'\n  not_init C (C\\<bullet>\\<^sub>sM(es))\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. not_init C (throw e) \\<and>\n    (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "by(auto dest: not_inits_def')"], ["proof (state)\nthis:\n  not_init C (throw e) \\<and>\n  (\\<exists>sfs'. sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n\ngoal (88 subgoals):\n 1. \\<And>h a Ca FDTs h' l sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h' = h(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 2. \\<And>h Ca l sh.\n       \\<lbrakk>new_Addr h = None; is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW OutOfMemory) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 3. \\<And>sh Ca sfsa h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfsa, Done)\\<rfloor>; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 4. \\<And>sh Ca h l.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (INIT Ca ([Ca],False) \\<leftarrow> new Ca) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 5. \\<And>e a aa b ba e' ab ac bb b' Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (Cast Ca e);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (Cast Ca e') \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 6. \\<And>Ca a aa b ba.\n       \\<lbrakk>not_init C (Cast Ca null);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C null \\<and>\n                         (\\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 7. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca;\n        not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (addr a) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 8. \\<And>h a D fs Ca l sh b.\n       \\<lbrakk>h a = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca (addr a));\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C (THROW ClassCast) \\<and>\n                         (\\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 9. \\<And>e a aa b ba e' ab ac bb b' bop e\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                ba\\<rangle> \\<rightarrow>\n                               \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n        \\<lbrakk>not_init C e;\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C e' \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n        not_init C (e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2);\n        b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> not_init C\n                          (e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) \\<and>\n                         (\\<exists>sfs'.\n                             bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\n 10. \\<And>e a aa b ba e' ab ac bb b' v\\<^sub>1 bop.\n        \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b),\n                                 ba\\<rangle> \\<rightarrow>\n                                \\<langle>e',(ab, ac, bb),b'\\<rangle>;\n         \\<lbrakk>not_init C e;\n          b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n         \\<Longrightarrow> not_init C e' \\<and>\n                           (\\<exists>sfs'.\n                               bb C = \\<lfloor>(sfs', Processing)\\<rfloor>);\n         not_init C (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e);\n         b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> not_init C\n                           (Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e') \\<and>\n                          (\\<exists>sfs'.\n                              bb C = \\<lfloor>(sfs', Processing)\\<rfloor>)\nA total of 88 subgoals...", "qed(auto)"], ["", "end"]]}