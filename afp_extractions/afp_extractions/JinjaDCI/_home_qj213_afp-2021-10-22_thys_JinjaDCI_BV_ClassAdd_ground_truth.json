{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/BV/ClassAdd.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma err_mono: \"A \\<subseteq> B \\<Longrightarrow> err A \\<subseteq> err B\"", "lemma opt_mono: \"A \\<subseteq> B \\<Longrightarrow> opt A \\<subseteq> opt B\"", "lemma list_mono:\nassumes \"A \\<subseteq> B\" shows \"list n A \\<subseteq> list n B\"", "lemma class_add_has_fields:\nassumes fs: \"P \\<turnstile> D has_fields FDTs\" and nc: \"\\<not>is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> D has_fields FDTs\"", "lemma class_add_has_fields_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> D has_fields FDTs; \\<not>P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> D has_fields FDTs\"", "lemma class_add_has_field:\nassumes \"P \\<turnstile> C\\<^sub>0 has F,b:T in D\" and \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D\"", "lemma class_add_has_field_rev:\nassumes has: \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D\"\n and ncp: \"\\<And>D'. P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"P \\<turnstile> C\\<^sub>0 has F,b:T in D\"", "lemma class_add_sees_field:\nassumes \"P \\<turnstile> C\\<^sub>0 sees F,b:T in D\" and \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D\"", "lemma class_add_sees_field_rev:\nassumes has: \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D\"\n and ncp: \"\\<And>D'. P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"P \\<turnstile> C\\<^sub>0 sees F,b:T in D\"", "lemma class_add_field:\nassumes fd: \"P \\<turnstile> C\\<^sub>0 sees F,b:T in D\" and \"\\<not> is_class P C\"\nshows \"field P C\\<^sub>0 F = field (class_add P (C, cdec)) C\\<^sub>0 F\"", "lemma class_add_sees_methods:\nassumes ms: \"P \\<turnstile> D sees_methods Mm\" and nc: \"\\<not>is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> D sees_methods Mm\"", "lemma class_add_sees_methods_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n    \\<And>D'. P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> D sees_methods Mm\"", "lemma class_add_sees_methods_Obj:\nassumes \"P \\<turnstile> Object sees_methods Mm\" and nObj: \"C \\<noteq> Object\"\nshows \"class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\"", "lemma class_add_sees_methods_rev_Obj:\nassumes \"class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\" and nObj: \"C \\<noteq> Object\"\nshows \"P \\<turnstile> Object sees_methods Mm\"", "lemma class_add_sees_method:\nassumes \"P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\" and \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\"", "lemma class_add_method:\nassumes md: \"P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\" and \"\\<not> is_class P C\"\nshows \"method P C\\<^sub>0 M\\<^sub>0 = method (class_add P (C, cdec)) C\\<^sub>0 M\\<^sub>0\"", "lemma class_add_sees_method_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D;\n    \\<not> P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\"", "lemma class_add_sees_method_Obj:\n \"\\<lbrakk> P \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D; C \\<noteq> Object \\<rbrakk>\n  \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\"", "lemma class_add_sees_method_rev_Obj:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D; C \\<noteq> Object \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\"", "lemma class_add_is_type:\n \"is_type P T \\<Longrightarrow> is_type (class_add P (C, cdec)) T\"", "lemma class_add_types:\n \"types P \\<subseteq> types (class_add P (C, cdec))\"", "lemma class_add_states:\n \"states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl\"", "lemma class_add_check_types:\n \"check_types P mxs mxl \\<tau>s \\<Longrightarrow> check_types (class_add P (C, cdec)) mxs mxl \\<tau>s\"", "lemma class_add_subcls:\n \"\\<lbrakk> P \\<turnstile> D \\<preceq>\\<^sup>* D'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> D \\<preceq>\\<^sup>* D'\"", "lemma class_add_subcls_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> D \\<preceq>\\<^sup>* D'; \\<not>P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D'\"", "lemma class_add_subtype:\n \"\\<lbrakk> subtype P x y; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> subtype (class_add P (C, cdec)) x y\"", "lemma class_add_widens:\n \"\\<lbrakk> P \\<turnstile> Ts [\\<le>] Ts'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> (class_add P (C, cdec)) \\<turnstile> Ts [\\<le>] Ts'\"", "lemma class_add_sup_ty_opt:\n \"\\<lbrakk> P \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2\"", "lemma class_add_sup_loc:\n\"\\<lbrakk> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\"", "lemma class_add_sup_state:\n \"\\<lbrakk> P \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>'; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>'\"", "lemma class_add_sup_state_opt:\n \"\\<lbrakk> P \\<turnstile> \\<tau> \\<le>' \\<tau>'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> \\<tau> \\<le>' \\<tau>'\"", "lemma class_add_is_relevant_class:\n \"\\<lbrakk> is_relevant_class i P C\\<^sub>0; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\"", "lemma class_add_is_relevant_class_rev:\nassumes irc: \"is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\"\n  and ncp: \"\\<And>cd D'. cd \\<in> set P \\<Longrightarrow> \\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\"\n  and wfxp: \"wf_syscls P\"\nshows \"is_relevant_class i P C\\<^sub>0\"", "lemma class_add_is_relevant_entry:\n \"\\<lbrakk> is_relevant_entry P i pc e; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry (class_add P (C, cdec)) i pc e\"", "lemma class_add_is_relevant_entry_rev:\n \"\\<lbrakk> is_relevant_entry (class_add P (C, cdec)) i pc e; \n    \\<And>cd D'. cd \\<in> set P \\<Longrightarrow> \\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C;\n    wf_syscls P \\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry P i pc e\"", "lemma class_add_relevant_entries:\n \"\\<not> is_class P C\n  \\<Longrightarrow> set (relevant_entries P i pc xt) \\<subseteq> set (relevant_entries (class_add P (C, cdec)) i pc xt)\"", "lemma class_add_relevant_entries_eq:\nassumes wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"relevant_entries P i pc xt = relevant_entries (class_add P (C, cdec)) i pc xt\"", "lemma class_add_norm_eff_pc:\nassumes ne: \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i P pc \\<tau>). pc' < mpc\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i (class_add P (C, cdec)) pc \\<tau>). pc' < mpc\"", "lemma class_add_norm_eff_sup_state_opt:\nassumes ne: \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i P pc \\<tau>). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\"\n   and nclass: \"\\<not> is_class P C\" and app: \"app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i (class_add P (C, cdec)) pc \\<tau>). (class_add P (C, cdec)) \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\"", "lemma class_add_xcpt_eff_eq:\nassumes wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"xcpt_eff i P pc \\<tau> xt = xcpt_eff i (class_add P (C, cdec)) pc \\<tau> xt\"", "lemma class_add_eff_pc:\nassumes eff: \"\\<forall>(pc',\\<tau>') \\<in> set (eff i P pc xt (Some \\<tau>)). pc' < mpc\"\n  and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (eff i (class_add P (C, cdec)) pc xt (Some \\<tau>)). pc' < mpc\"", "lemma class_add_eff_sup_state_opt:\nassumes eff: \"\\<forall>(pc',\\<tau>') \\<in> set (eff i P pc xt (Some \\<tau>)). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\"\n  and wf: \"wf_prog wf_md P\"and nclass: \"\\<not> is_class P C\"\n  and app: \"app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (eff i (class_add P (C, cdec)) pc xt (Some \\<tau>)).\n         (class_add P (C, cdec)) \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\"", "lemma class_add_app\\<^sub>i:\nassumes \"app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\" and \"\\<not> is_class P C\"\nshows \"app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\"", "lemma class_add_xcpt_app:\nassumes xa: \"xcpt_app i P pc mxs xt \\<tau>\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>\"", "lemma class_add_app:\nassumes app: \"app i P mxs T pc mpc xt t\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"app i (class_add P (C, cdec)) mxs T pc mpc xt t\"", "lemma class_add_wf_mdecl:\n  \"\\<lbrakk> wf_mdecl wf_md P C\\<^sub>0 md;\n     \\<And>C\\<^sub>0 md. wf_md P C\\<^sub>0 md \\<Longrightarrow> wf_md (class_add P (C, cdec)) C\\<^sub>0 md \\<rbrakk>\n  \\<Longrightarrow> wf_mdecl wf_md (class_add P (C, cdec)) C\\<^sub>0 md\"", "lemma class_add_wf_mdecl':\nassumes wfd: \"wf_mdecl wf_md P C\\<^sub>0 md\"\n  and ms: \"(C\\<^sub>0,S,fs,ms) \\<in> set P\" and md: \"md \\<in> set ms\"\n  and wf_md': \"\\<And>C\\<^sub>0 S fs ms m.\\<lbrakk>(C\\<^sub>0,S,fs,ms) \\<in> set P; m \\<in> set ms\\<rbrakk> \\<Longrightarrow> wf_md' (class_add P (C, cdec)) C\\<^sub>0 m\"\nshows \"wf_mdecl wf_md' (class_add P (C, cdec)) C\\<^sub>0 md\"", "lemma class_add_wf_cdecl:\nassumes wfcd: \"wf_cdecl wf_md P cd\" and cdP: \"cd \\<in> set P\"\n and ncp: \"\\<not> P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\" and dist: \"distinct_fst P\"\n and wfmd: \"\\<And>C\\<^sub>0 md. wf_md P C\\<^sub>0 md \\<Longrightarrow> wf_md (class_add P (C, cdec)) C\\<^sub>0 md\"\n and nclass: \"\\<not> is_class P C\"\nshows \"wf_cdecl wf_md (class_add P (C, cdec)) cd\"", "lemma class_add_wf_cdecl':\nassumes wfcd: \"wf_cdecl wf_md P cd\" and cdP: \"cd \\<in> set P\"\n and ncp: \"\\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\" and dist: \"distinct_fst P\"\n and wfmd: \"\\<And>C\\<^sub>0 S fs ms m.\\<lbrakk>(C\\<^sub>0,S,fs,ms) \\<in> set P; m \\<in> set ms\\<rbrakk> \\<Longrightarrow> wf_md' (class_add P (C, cdec)) C\\<^sub>0 m\"\n and nclass: \"\\<not> is_class P C\"\nshows \"wf_cdecl wf_md' (class_add P (C, cdec)) cd\"", "lemma class_add_wt_start:\n \"\\<lbrakk> wt_start P C\\<^sub>0 b Ts mxl \\<tau>s; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl \\<tau>s\"", "lemma class_add_wt_instr:\nassumes wti: \"P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\"", "lemma class_add_wt_method:\nassumes wtm: \"wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)\"", "lemma class_add_wt_method':\n \"\\<lbrakk> (\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M)) P C\\<^sub>0 md;\n    wf_prog wf_md P; \\<not> is_class P C \\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n            (class_add P (C, cdec)) C\\<^sub>0 md\"", "lemma class_add_distinct_fst:\n\"\\<lbrakk> distinct_fst P; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> distinct_fst (class_add P (C, cdec))\"", "lemma class_add_conf:\n \"\\<lbrakk> P,h \\<turnstile> v :\\<le> T; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec),h \\<turnstile> v :\\<le> T\"", "lemma class_add_oconf:\nfixes obj::obj\nassumes oc: \"P,h \\<turnstile> obj \\<surd>\" and ns: \"\\<not> is_class P C\"\n  and ncp: \"\\<And>D'. P \\<turnstile> fst(obj) \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"(class_add P (C, cdec)),h \\<turnstile> obj \\<surd>\"", "lemma class_add_soconf:\nassumes soc: \"P,h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>\" and ns: \"\\<not> is_class P C\"\n  and ncp: \"\\<And>D'. P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"(class_add P (C, cdec)),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>\"", "lemma class_add_hconf:\nassumes \"P \\<turnstile> h \\<surd>\" and \"\\<not> is_class P C\"\n and \"\\<And>a obj D'. h a = Some obj \\<Longrightarrow> P \\<turnstile> fst(obj) \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"class_add P (C, cdec) \\<turnstile> h \\<surd>\"", "lemma class_add_hconf_wf:\nassumes wf: \"wf_prog wf_md P\" and \"P \\<turnstile> h \\<surd>\" and \"\\<not> is_class P C\"\n and \"\\<And>a obj. h a = Some obj \\<Longrightarrow> fst(obj) \\<noteq> C\"\nshows \"class_add P (C, cdec) \\<turnstile> h \\<surd>\"", "lemma class_add_shconf:\nassumes \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and ns: \"\\<not> is_class P C\"\n and \"\\<And>C sobj D'. sh C = Some sobj \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>\"", "lemma class_add_shconf_wf:\nassumes wf: \"wf_prog wf_md P\" and \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and \"\\<not> is_class P C\"\n and \"\\<And>C sobj. sh C = Some sobj \\<Longrightarrow> C \\<noteq> C\"\nshows \"class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>\""], "translations": [["", "lemma err_mono: \"A \\<subseteq> B \\<Longrightarrow> err A \\<subseteq> err B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> err A \\<subseteq> err B", "by(unfold err_def) auto"], ["", "lemma opt_mono: \"A \\<subseteq> B \\<Longrightarrow> opt A \\<subseteq> opt B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> opt A \\<subseteq> opt B", "by(unfold opt_def) auto"], ["", "lemma list_mono:\nassumes \"A \\<subseteq> B\" shows \"list n A \\<subseteq> list n B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list n A \\<subseteq> list n B", "proof(rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> list n A \\<Longrightarrow> x \\<in> list n B", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> list n A \\<Longrightarrow> x \\<in> list n B", "assume \"xs \\<in> list n A\""], ["proof (state)\nthis:\n  xs \\<in> list n A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> list n A \\<Longrightarrow> x \\<in> list n B", "then"], ["proof (chain)\npicking this:\n  xs \\<in> list n A", "obtain size: \"size xs = n\" and inA: \"set xs \\<subseteq> A\""], ["proof (prove)\nusing this:\n  xs \\<in> list n A\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>length xs = n; set xs \\<subseteq> A\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  length xs = n\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> list n A \\<Longrightarrow> x \\<in> list n B", "with assms"], ["proof (chain)\npicking this:\n  A \\<subseteq> B\n  length xs = n\n  set xs \\<subseteq> A", "have \"set xs \\<subseteq> B\""], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  length xs = n\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> B", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> list n A \\<Longrightarrow> x \\<in> list n B", "with size"], ["proof (chain)\npicking this:\n  length xs = n\n  set xs \\<subseteq> B", "show \"xs \\<in> list n B\""], ["proof (prove)\nusing this:\n  length xs = n\n  set xs \\<subseteq> B\n\ngoal (1 subgoal):\n 1. xs \\<in> list n B", "by(clarsimp intro!: listI)"], ["proof (state)\nthis:\n  xs \\<in> list n B\n\ngoal:\nNo subgoals!", "qed\n\n(****************************************************************)\n\n\\<comment> \\<open> adding a class in the simplest way \\<close>"], ["", "abbreviation class_add :: \"jvm_prog \\<Rightarrow> jvm_method cdecl \\<Rightarrow> jvm_prog\" where\n\"class_add P cd \\<equiv> cd#P\""], ["", "subsection \"Fields\""], ["", "lemma class_add_has_fields:\nassumes fs: \"P \\<turnstile> D has_fields FDTs\" and nc: \"\\<not>is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> D has_fields FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> D has_fields FDTs", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> D has_fields FDTs", "proof(induct rule: Fields.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Object has_fields FDTs", "case (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  \\<not> is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Object has_fields FDTs", "from has_fields_is_class_Object[OF fs] nc"], ["proof (chain)\npicking this:\n  is_class P Object\n  \\<not> is_class P C", "have \"C \\<noteq> Object\""], ["proof (prove)\nusing this:\n  is_class P Object\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. C \\<noteq> Object", "by fast"], ["proof (state)\nthis:\n  C \\<noteq> Object\n\ngoal (2 subgoals):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Object has_fields FDTs", "with has_fields_Object"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  \\<not> is_class P C\n  C \\<noteq> Object", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  \\<not> is_class P C\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object has_fields FDTs", "by(auto simp: class_def fun_upd_apply intro!: TypeRel.has_fields_Object)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'", "case rec: (has_fields_rec C1 D fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'", "with has_fields_is_class"], ["proof (chain)\npicking this:\n  ?P \\<turnstile> ?C has_fields ?FDTs \\<Longrightarrow> is_class ?P ?C\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C", "have [simp]: \"D \\<noteq> C\""], ["proof (prove)\nusing this:\n  ?P \\<turnstile> ?C has_fields ?FDTs \\<Longrightarrow> is_class ?P ?C\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. D \\<noteq> C", "by auto"], ["proof (state)\nthis:\n  D \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'", "with rec"], ["proof (chain)\npicking this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C\n  D \\<noteq> C", "have \"C1 \\<noteq> C\""], ["proof (prove)\nusing this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C\n  D \\<noteq> C\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> C", "by(clarsimp simp: is_class_def)"], ["proof (state)\nthis:\n  C1 \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca has_fields FDTs'", "with rec"], ["proof (chain)\npicking this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C\n  C1 \\<noteq> C", "show ?case"], ["proof (prove)\nusing this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D has_fields FDTs\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  \\<not> is_class P C\n  C1 \\<noteq> C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> C1 has_fields FDTs'", "by(auto simp: class_def fun_upd_apply intro: TypeRel.has_fields_rec)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> C1 has_fields FDTs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_has_fields_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> D has_fields FDTs; \\<not>P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> D has_fields FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n     (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D has_fields FDTs", "proof(induct rule: Fields.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class (class_add P (C, cdec)) Object =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        (Object, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs", "case (has_fields_Object D fs ms FDTs)"], ["proof (state)\nthis:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  (Object, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class (class_add P (C, cdec)) Object =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs;\n        (Object, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs", "then"], ["proof (chain)\npicking this:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  (Object, C) \\<notin> (subcls1 P)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  FDTs = map (\\<lambda>(F, b, T). ((F, Object), b, T)) fs\n  (Object, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object has_fields FDTs", "by(auto simp: class_def fun_upd_apply intro!: TypeRel.has_fields_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'", "case rec: (has_fields_rec C1 D fs ms FDTs FDTs')"], ["proof (state)\nthis:\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'", "then"], ["proof (chain)\npicking this:\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*", "have sub1: \"P \\<turnstile> C1 \\<prec>\\<^sup>1 D\""], ["proof (prove)\nusing this:\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "by(auto simp: class_def fun_upd_apply intro!: subcls1I split: if_split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'", "with rec.prems"], ["proof (chain)\npicking this:\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "have cls: \"\\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>*", "by (meson converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms FDTs FDTs'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D has_fields FDTs;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, b, T). ((F, Ca), b, T)) fs @ FDTs;\n        (Ca, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca has_fields FDTs'", "with cls rec"], ["proof (chain)\npicking this:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D has_fields FDTs\n  (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> D has_fields FDTs\n  FDTs' = map (\\<lambda>(F, b, T). ((F, C1), b, T)) fs @ FDTs\n  (C1, C) \\<notin> (subcls1 P)\\<^sup>*\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 has_fields FDTs'", "by(auto simp: class_def fun_upd_apply\n           intro: TypeRel.has_fields_rec split: if_split_asm)"], ["proof (state)\nthis:\n  P \\<turnstile> C1 has_fields FDTs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_has_field:\nassumes \"P \\<turnstile> C\\<^sub>0 has F,b:T in D\" and \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 has F,b:T in D\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D", "by(auto simp: has_field_def dest!: class_add_has_fields[of P C\\<^sub>0])"], ["", "lemma class_add_has_field_rev:\nassumes has: \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D\"\n and ncp: \"\\<And>D'. P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"P \\<turnstile> C\\<^sub>0 has F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C\\<^sub>0 has F,b:T in D", "using assms"], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,b:T in D\n  P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow>\n  ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C\\<^sub>0 has F,b:T in D", "by(auto simp: has_field_def dest!: class_add_has_fields_rev)"], ["", "lemma class_add_sees_field:\nassumes \"P \\<turnstile> C\\<^sub>0 sees F,b:T in D\" and \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 sees F,b:T in D\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D", "by(auto simp: sees_field_def dest!: class_add_has_fields[of P C\\<^sub>0])"], ["", "lemma class_add_sees_field_rev:\nassumes has: \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D\"\n and ncp: \"\\<And>D'. P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"P \\<turnstile> C\\<^sub>0 sees F,b:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C\\<^sub>0 sees F,b:T in D", "using assms"], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D\n  P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow>\n  ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C\\<^sub>0 sees F,b:T in D", "by(auto simp: sees_field_def dest!: class_add_has_fields_rev)"], ["", "lemma class_add_field:\nassumes fd: \"P \\<turnstile> C\\<^sub>0 sees F,b:T in D\" and \"\\<not> is_class P C\"\nshows \"field P C\\<^sub>0 F = field (class_add P (C, cdec)) C\\<^sub>0 F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field P C\\<^sub>0 F = field (class_add P (C, cdec)) C\\<^sub>0 F", "using class_add_sees_field[OF assms, of cdec] fd"], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees F,b:T in D\n  P \\<turnstile> C\\<^sub>0 sees F,b:T in D\n\ngoal (1 subgoal):\n 1. field P C\\<^sub>0 F = field (class_add P (C, cdec)) C\\<^sub>0 F", "by simp"], ["", "subsection \"Methods\""], ["", "lemma class_add_sees_methods:\nassumes ms: \"P \\<turnstile> D sees_methods Mm\" and nc: \"\\<not>is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> D sees_methods Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> D sees_methods Mm", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> D sees_methods Mm", "proof(induct rule: Methods.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Object sees_methods Mm\n 2. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "case (sees_methods_Object D fs ms Mm)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n  \\<not> is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Object sees_methods Mm\n 2. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "from sees_methods_is_class_Object[OF ms] nc"], ["proof (chain)\npicking this:\n  is_class P Object\n  \\<not> is_class P C", "have \"C \\<noteq> Object\""], ["proof (prove)\nusing this:\n  is_class P Object\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. C \\<noteq> Object", "by fast"], ["proof (state)\nthis:\n  C \\<noteq> Object\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Object sees_methods Mm\n 2. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "with sees_methods_Object"], ["proof (chain)\npicking this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n  \\<not> is_class P C\n  C \\<noteq> Object", "show ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n  \\<not> is_class P C\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "by(auto simp: class_def fun_upd_apply intro!: TypeRel.sees_methods_Object)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "case rec: (sees_methods_rec C1 D fs ms Mm Mm')"], ["proof (state)\nthis:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "with sees_methods_is_class"], ["proof (chain)\npicking this:\n  ?P \\<turnstile> ?C sees_methods ?Mm \\<Longrightarrow> is_class ?P ?C\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C", "have [simp]: \"D \\<noteq> C\""], ["proof (prove)\nusing this:\n  ?P \\<turnstile> ?C sees_methods ?Mm \\<Longrightarrow> is_class ?P ?C\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. D \\<noteq> C", "by auto"], ["proof (state)\nthis:\n  D \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "with rec"], ["proof (chain)\npicking this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C\n  D \\<noteq> C", "have \"C1 \\<noteq> C\""], ["proof (prove)\nusing this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C\n  D \\<noteq> C\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> C", "by(clarsimp simp: is_class_def)"], ["proof (state)\nthis:\n  C1 \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class P Ca = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> Ca sees_methods Mm'", "with rec"], ["proof (chain)\npicking this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C\n  C1 \\<noteq> C", "show ?case"], ["proof (prove)\nusing this:\n  class P C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  P \\<turnstile> D sees_methods Mm\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  \\<not> is_class P C\n  C1 \\<noteq> C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> C1 sees_methods Mm'", "by(auto simp: class_def fun_upd_apply intro: TypeRel.sees_methods_rec)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> C1 sees_methods Mm'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_sees_methods_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n    \\<And>D'. P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> D sees_methods Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n     \\<And>D'.\n        P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n        D' \\<noteq> C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D sees_methods Mm", "proof(induct rule: Methods.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class (class_add P (C, cdec)) Object =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        \\<And>D'.\n           P \\<turnstile> Object \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object sees_methods Mm\n 2. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "case (sees_methods_Object D fs ms Mm)"], ["proof (state)\nthis:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n  P \\<turnstile> Object \\<preceq>\\<^sup>* ?D' \\<Longrightarrow>\n  ?D' \\<noteq> C\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class (class_add P (C, cdec)) Object =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        \\<And>D'.\n           P \\<turnstile> Object \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object sees_methods Mm\n 2. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "then"], ["proof (chain)\npicking this:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n  P \\<turnstile> Object \\<preceq>\\<^sup>* ?D' \\<Longrightarrow>\n  ?D' \\<noteq> C", "show ?case"], ["proof (prove)\nusing this:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(D, fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n  P \\<turnstile> Object \\<preceq>\\<^sup>* ?D' \\<Longrightarrow>\n  ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "by(auto simp: class_def fun_upd_apply intro!: TypeRel.sees_methods_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> Object sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "case rec: (sees_methods_rec C1 D fs ms Mm Mm')"], ["proof (state)\nthis:\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      D' \\<noteq> C) \\<Longrightarrow>\n  P \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "then"], ["proof (chain)\npicking this:\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      D' \\<noteq> C) \\<Longrightarrow>\n  P \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C", "have sub1: \"P \\<turnstile> C1 \\<prec>\\<^sup>1 D\""], ["proof (prove)\nusing this:\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      D' \\<noteq> C) \\<Longrightarrow>\n  P \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "by(auto simp: class_def fun_upd_apply intro!: subcls1I)"], ["proof (state)\nthis:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "have cls: \"\\<And>D'. P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D'.\n       P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D'.\n       P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C", "fix D'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D'.\n       P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C", "assume \"P \\<turnstile> D \\<preceq>\\<^sup>* D'\""], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. \\<And>D'.\n       P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C", "with sub1"], ["proof (chain)\npicking this:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n  P \\<turnstile> D \\<preceq>\\<^sup>* D'", "have \"P \\<turnstile> C1 \\<preceq>\\<^sup>* D'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n  P \\<turnstile> D \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 \\<preceq>\\<^sup>* D'", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. \\<And>D'.\n       P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C", "with rec.prems"], ["proof (chain)\npicking this:\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* D'", "show \"D' \\<noteq> C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. D' \\<noteq> C", "by simp"], ["proof (state)\nthis:\n  D' \\<noteq> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>Ca D fs ms Mm Mm'.\n       \\<lbrakk>class (class_add P (C, cdec)) Ca =\n                \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        class_add P (C, cdec) \\<turnstile> D sees_methods Mm;\n        (\\<And>D'.\n            P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n            D' \\<noteq> C) \\<Longrightarrow>\n        P \\<turnstile> D sees_methods Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms);\n        \\<And>D'.\n           P \\<turnstile> Ca \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n           D' \\<noteq> C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ca sees_methods Mm'", "with cls rec"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      D' \\<noteq> C) \\<Longrightarrow>\n  P \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n  class (class_add P (C, cdec)) C1 = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C1 \\<noteq> Object\n  class_add P (C, cdec) \\<turnstile> D sees_methods Mm\n  (\\<And>D'.\n      P \\<turnstile> D \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      D' \\<noteq> C) \\<Longrightarrow>\n  P \\<turnstile> D sees_methods Mm\n  Mm' = Mm ++ (map_option (\\<lambda>m. (m, C1)) \\<circ> map_of ms)\n  P \\<turnstile> C1 \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n  P \\<turnstile> D \\<preceq>\\<^sup>* ?D' \\<Longrightarrow> ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 sees_methods Mm'", "by(auto simp: class_def fun_upd_apply intro: TypeRel.sees_methods_rec)"], ["proof (state)\nthis:\n  P \\<turnstile> C1 sees_methods Mm'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_sees_methods_Obj:\nassumes \"P \\<turnstile> Object sees_methods Mm\" and nObj: \"C \\<noteq> Object\"\nshows \"class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "from assms"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object", "obtain C' fs ms where cls: \"class P Object = Some(C',fs,ms)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. (\\<And>C' fs ms.\n        class P Object = \\<lfloor>(C', fs, ms)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: Methods.cases)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "with nObj"], ["proof (chain)\npicking this:\n  C \\<noteq> Object\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>", "have cls': \"class (class_add P (C, cdec)) Object = Some(C',fs,ms)\""], ["proof (prove)\nusing this:\n  C \\<noteq> Object\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>", "by(simp add: class_def fun_upd_apply)"], ["proof (state)\nthis:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "from assms cls"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>", "have \"Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms", "by(auto elim!: Methods.cases)"], ["proof (state)\nthis:\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "with assms cls'"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> Object sees_methods Mm", "by(auto simp: is_class_def fun_upd_apply intro!: sees_methods_Object)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_sees_methods_rev_Obj:\nassumes \"class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\" and nObj: \"C \\<noteq> Object\"\nshows \"P \\<turnstile> Object sees_methods Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "from assms"], ["proof (chain)\npicking this:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object", "obtain C' fs ms where cls: \"class (class_add P (C, cdec)) Object = Some(C',fs,ms)\""], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. (\\<And>C' fs ms.\n        class (class_add P (C, cdec)) Object =\n        \\<lfloor>(C', fs, ms)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!: Methods.cases)"], ["proof (state)\nthis:\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "with nObj"], ["proof (chain)\npicking this:\n  C \\<noteq> Object\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>", "have cls': \"class P Object = Some(C',fs,ms)\""], ["proof (prove)\nusing this:\n  C \\<noteq> Object\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>", "by(simp add: class_def fun_upd_apply)"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "from assms cls"], ["proof (chain)\npicking this:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>", "have \"Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\""], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class (class_add P (C, cdec)) Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms", "by(auto elim!: Methods.cases)"], ["proof (state)\nthis:\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "with assms cls'"], ["proof (chain)\npicking this:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms", "show ?thesis"], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> Object sees_methods Mm\n  C \\<noteq> Object\n  class P Object = \\<lfloor>(C', fs, ms)\\<rfloor>\n  Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm", "by(auto simp: is_class_def fun_upd_apply intro!: sees_methods_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> Object sees_methods Mm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_sees_method:\nassumes \"P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\" and \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. class_add P\n     (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D", "by(auto simp: Method_def dest!: class_add_sees_methods[of P C\\<^sub>0])"], ["", "lemma class_add_method:\nassumes md: \"P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\" and \"\\<not> is_class P C\"\nshows \"method P C\\<^sub>0 M\\<^sub>0 = method (class_add P (C, cdec)) C\\<^sub>0 M\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. method P C\\<^sub>0 M\\<^sub>0 =\n    method (class_add P (C, cdec)) C\\<^sub>0 M\\<^sub>0", "using class_add_sees_method[OF assms, of cdec] md"], ["proof (prove)\nusing this:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D\n  P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D\n\ngoal (1 subgoal):\n 1. method P C\\<^sub>0 M\\<^sub>0 =\n    method (class_add P (C, cdec)) C\\<^sub>0 M\\<^sub>0", "by simp"], ["", "lemma class_add_sees_method_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D;\n    \\<not> P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* C \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class_add P\n              (C, cdec) \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D;\n     (C\\<^sub>0, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C\\<^sub>0 sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D", "by(auto simp: Method_def dest!: class_add_sees_methods_rev)"], ["", "lemma class_add_sees_method_Obj:\n \"\\<lbrakk> P \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D; C \\<noteq> Object \\<rbrakk>\n  \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Object sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> Object sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D", "by(auto simp: Method_def dest!: class_add_sees_methods_Obj[where P=P])"], ["", "lemma class_add_sees_method_rev_Obj:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D; C \\<noteq> Object \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees M\\<^sub>0, b : Ts\\<rightarrow>T = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class_add P\n              (C, cdec) \\<turnstile> Object sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D;\n     C \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Object sees M\\<^sub>0, b :  Ts\\<rightarrow>T = m in D", "by(auto simp: Method_def dest!: class_add_sees_methods_rev_Obj[where P=P])"], ["", "subsection \"Types and states\""], ["", "lemma class_add_is_type:\n \"is_type P T \\<Longrightarrow> is_type (class_add P (C, cdec)) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P T \\<Longrightarrow> is_type (class_add P (C, cdec)) T", "by(cases cdec, simp add: is_type_def is_class_def class_def fun_upd_apply split: ty.splits)"], ["", "lemma class_add_types:\n \"types P \\<subseteq> types (class_add P (C, cdec))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. types P \\<subseteq> types (class_add P (C, cdec))", "using class_add_is_type"], ["proof (prove)\nusing this:\n  is_type ?P ?T \\<Longrightarrow> is_type (class_add ?P (?C, ?cdec)) ?T\n\ngoal (1 subgoal):\n 1. types P \\<subseteq> types (class_add P (C, cdec))", "by(cases cdec, clarsimp)"], ["", "lemma class_add_states:\n \"states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "let ?A = \"types P\" and ?B = \"types (class_add P (C, cdec))\""], ["proof (state)\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "have ab: \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. types P \\<subseteq> types (class_add P (C, cdec))", "by(rule class_add_types)"], ["proof (state)\nthis:\n  types P \\<subseteq> types (class_add P (C, cdec))\n\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "moreover"], ["proof (state)\nthis:\n  types P \\<subseteq> types (class_add P (C, cdec))\n\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "have \"\\<And>n. list n ?A \\<subseteq> list n ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       list n (types P) \\<subseteq> list n (types (class_add P (C, cdec)))", "using ab"], ["proof (prove)\nusing this:\n  types P \\<subseteq> types (class_add P (C, cdec))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       list n (types P) \\<subseteq> list n (types (class_add P (C, cdec)))", "by(rule list_mono)"], ["proof (state)\nthis:\n  list ?n (types P) \\<subseteq> list ?n (types (class_add P (C, cdec)))\n\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "moreover"], ["proof (state)\nthis:\n  list ?n (types P) \\<subseteq> list ?n (types (class_add P (C, cdec)))\n\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "have \"list mxl (err ?A) \\<subseteq> list mxl (err ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list mxl (err (types P))\n    \\<subseteq> list mxl (err (types (class_add P (C, cdec))))", "using err_mono[OF ab]"], ["proof (prove)\nusing this:\n  err (types P) \\<subseteq> err (types (class_add P (C, cdec)))\n\ngoal (1 subgoal):\n 1. list mxl (err (types P))\n    \\<subseteq> list mxl (err (types (class_add P (C, cdec))))", "by(rule list_mono)"], ["proof (state)\nthis:\n  list mxl (err (types P))\n  \\<subseteq> list mxl (err (types (class_add P (C, cdec))))\n\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "ultimately"], ["proof (chain)\npicking this:\n  types P \\<subseteq> types (class_add P (C, cdec))\n  list ?n (types P) \\<subseteq> list ?n (types (class_add P (C, cdec)))\n  list mxl (err (types P))\n  \\<subseteq> list mxl (err (types (class_add P (C, cdec))))", "show ?thesis"], ["proof (prove)\nusing this:\n  types P \\<subseteq> types (class_add P (C, cdec))\n  list ?n (types P) \\<subseteq> list ?n (types (class_add P (C, cdec)))\n  list mxl (err (types P))\n  \\<subseteq> list mxl (err (types (class_add P (C, cdec))))\n\ngoal (1 subgoal):\n 1. states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl", "by(auto simp: JVM_states_unfold intro!: err_mono opt_mono)"], ["proof (state)\nthis:\n  states P mxs mxl \\<subseteq> states (class_add P (C, cdec)) mxs mxl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_check_types:\n \"check_types P mxs mxl \\<tau>s \\<Longrightarrow> check_types (class_add P (C, cdec)) mxs mxl \\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_types P mxs mxl \\<tau>s \\<Longrightarrow>\n    check_types (class_add P (C, cdec)) mxs mxl \\<tau>s", "using class_add_states"], ["proof (prove)\nusing this:\n  states ?P ?mxs ?mxl\n  \\<subseteq> states (class_add ?P (?C, ?cdec)) ?mxs ?mxl\n\ngoal (1 subgoal):\n 1. check_types P mxs mxl \\<tau>s \\<Longrightarrow>\n    check_types (class_add P (C, cdec)) mxs mxl \\<tau>s", "by(fastforce simp: check_types_def)"], ["", "subsection \"Subclasses and subtypes\""], ["", "lemma class_add_subcls:\n \"\\<lbrakk> P \\<turnstile> D \\<preceq>\\<^sup>* D'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> D \\<preceq>\\<^sup>* D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* D';\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> D \\<preceq>\\<^sup>* D'", "proof(induct rule: rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<not> is_class P C \\<Longrightarrow>\n       class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* a\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* c", "case (rtrancl_into_rtrancl a b c)"], ["proof (state)\nthis:\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  P \\<turnstile> b \\<prec>\\<^sup>1 c\n  \\<not> is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<not> is_class P C \\<Longrightarrow>\n       class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* a\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* c", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  P \\<turnstile> b \\<prec>\\<^sup>1 c\n  \\<not> is_class P C", "have \"b \\<noteq> C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  P \\<turnstile> b \\<prec>\\<^sup>1 c\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. b \\<noteq> C", "by(clarsimp simp: is_class_def dest!: subcls1D)"], ["proof (state)\nthis:\n  b \\<noteq> C\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<not> is_class P C \\<Longrightarrow>\n       class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* a\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<not> is_class P C \\<Longrightarrow>\n        class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* c", "with rtrancl_into_rtrancl"], ["proof (chain)\npicking this:\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  P \\<turnstile> b \\<prec>\\<^sup>1 c\n  \\<not> is_class P C\n  b \\<noteq> C", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  \\<not> is_class P C \\<Longrightarrow>\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  P \\<turnstile> b \\<prec>\\<^sup>1 c\n  \\<not> is_class P C\n  b \\<noteq> C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* c", "by(fastforce dest!: subcls1D simp: class_def fun_upd_apply\n                intro!: rtrancl_trans[of a b] subcls1I)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* c\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<not> is_class P C \\<Longrightarrow>\n       class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* a", "qed(simp)"], ["", "lemma class_add_subcls_rev:\n \"\\<lbrakk> class_add P (C, cdec) \\<turnstile> D \\<preceq>\\<^sup>* D'; \\<not>P \\<turnstile> D \\<preceq>\\<^sup>* C \\<rbrakk>\n \\<Longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class_add P (C, cdec) \\<turnstile> D \\<preceq>\\<^sup>* D';\n     (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* D'", "proof(induct rule: rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n       P \\<turnstile> a \\<preceq>\\<^sup>* a\n 2. \\<And>a b c.\n       \\<lbrakk>class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b;\n        (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (a, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* c", "case (rtrancl_into_rtrancl a b c)"], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c\n  (a, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n       P \\<turnstile> a \\<preceq>\\<^sup>* a\n 2. \\<And>a b c.\n       \\<lbrakk>class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b;\n        (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (a, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* c", "then"], ["proof (chain)\npicking this:\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c\n  (a, C) \\<notin> (subcls1 P)\\<^sup>*", "have \"b \\<noteq> C\""], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c\n  (a, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. b \\<noteq> C", "by(clarsimp simp: is_class_def dest!: subcls1D)"], ["proof (state)\nthis:\n  b \\<noteq> C\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n       P \\<turnstile> a \\<preceq>\\<^sup>* a\n 2. \\<And>a b c.\n       \\<lbrakk>class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b;\n        (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n        P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (a, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* c", "with rtrancl_into_rtrancl"], ["proof (chain)\npicking this:\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c\n  (a, C) \\<notin> (subcls1 P)\\<^sup>*\n  b \\<noteq> C", "show ?case"], ["proof (prove)\nusing this:\n  class_add P (C, cdec) \\<turnstile> a \\<preceq>\\<^sup>* b\n  (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n  P \\<turnstile> a \\<preceq>\\<^sup>* b\n  class_add P (C, cdec) \\<turnstile> b \\<prec>\\<^sup>1 c\n  (a, C) \\<notin> (subcls1 P)\\<^sup>*\n  b \\<noteq> C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> a \\<preceq>\\<^sup>* c", "by(fastforce dest!: subcls1D simp: class_def fun_upd_apply\n                intro!: rtrancl_trans[of a b] subcls1I)"], ["proof (state)\nthis:\n  P \\<turnstile> a \\<preceq>\\<^sup>* c\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (a, C) \\<notin> (subcls1 P)\\<^sup>* \\<Longrightarrow>\n       P \\<turnstile> a \\<preceq>\\<^sup>* a", "qed(simp)"], ["", "lemma class_add_subtype:\n \"\\<lbrakk> subtype P x y; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> subtype (class_add P (C, cdec)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subtype P x y; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> subtype (class_add P (C, cdec)) x y", "proof(induct rule: widen.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>T.\n       \\<not> is_class P C \\<Longrightarrow>\n       subtype (class_add P (C, cdec)) T T\n 2. \\<And>Ca D.\n       \\<lbrakk>P \\<turnstile> Ca \\<preceq>\\<^sup>* D;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> subtype (class_add P (C, cdec)) (Class Ca)\n                          (Class D)\n 3. \\<And>Ca.\n       \\<not> is_class P C \\<Longrightarrow>\n       subtype (class_add P (C, cdec)) NT (Class Ca)", "case (widen_subcls C D)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  \\<not> is_class P C\n\ngoal (3 subgoals):\n 1. \\<And>T.\n       \\<not> is_class P C \\<Longrightarrow>\n       subtype (class_add P (C, cdec)) T T\n 2. \\<And>Ca D.\n       \\<lbrakk>P \\<turnstile> Ca \\<preceq>\\<^sup>* D;\n        \\<not> is_class P C\\<rbrakk>\n       \\<Longrightarrow> subtype (class_add P (C, cdec)) (Class Ca)\n                          (Class D)\n 3. \\<And>Ca.\n       \\<not> is_class P C \\<Longrightarrow>\n       subtype (class_add P (C, cdec)) NT (Class Ca)", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  \\<not> is_class P C", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. subtype (class_add P (C, cdec)) (Class C) (Class D)", "using class_add_subcls"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  \\<not> is_class P C\n  \\<lbrakk>?P \\<turnstile> ?D \\<preceq>\\<^sup>* ?D';\n   \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> class_add ?P\n                     (?C, ?cdec) \\<turnstile> ?D \\<preceq>\\<^sup>* ?D'\n\ngoal (1 subgoal):\n 1. subtype (class_add P (C, cdec)) (Class C) (Class D)", "by simp"], ["proof (state)\nthis:\n  subtype (class_add P (C, cdec)) (Class C) (Class D)\n\ngoal (2 subgoals):\n 1. \\<And>T.\n       \\<not> is_class P C \\<Longrightarrow>\n       subtype (class_add P (C, cdec)) T T\n 2. \\<And>Ca.\n       \\<not> is_class P C \\<Longrightarrow>\n       subtype (class_add P (C, cdec)) NT (Class Ca)", "qed(simp+)"], ["", "lemma class_add_widens:\n \"\\<lbrakk> P \\<turnstile> Ts [\\<le>] Ts'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> (class_add P (C, cdec)) \\<turnstile> Ts [\\<le>] Ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ts [\\<le>] Ts'; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> Ts [\\<le>] Ts'", "using class_add_subtype"], ["proof (prove)\nusing this:\n  \\<lbrakk>subtype ?P ?x ?y; \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> subtype (class_add ?P (?C, ?cdec)) ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ts [\\<le>] Ts'; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> Ts [\\<le>] Ts'", "by (metis (no_types) list_all2_mono)"], ["", "lemma class_add_sup_ty_opt:\n \"\\<lbrakk> P \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2;\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2", "using class_add_subtype"], ["proof (prove)\nusing this:\n  \\<lbrakk>subtype ?P ?x ?y; \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> subtype (class_add ?P (?C, ?cdec)) ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2;\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> l1 \\<le>\\<^sub>\\<top> l2", "by(auto simp: sup_ty_opt_def Err.le_def lesub_def split: err.splits)"], ["", "lemma class_add_sup_loc:\n\"\\<lbrakk> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "using class_add_sup_ty_opt[where P=P and C=C]"], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<turnstile> ?l1.0 \\<le>\\<^sub>\\<top> ?l2.0;\n   \\<not> is_class P C\\<rbrakk>\n  \\<Longrightarrow> class_add P\n                     (C, ?cdec) \\<turnstile> ?l1.0 \\<le>\\<^sub>\\<top> ?l2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "by (simp add: list.rel_mono_strong)"], ["", "lemma class_add_sup_state:\n \"\\<lbrakk> P \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>'; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>';\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>'", "using class_add_subtype class_add_sup_ty_opt"], ["proof (prove)\nusing this:\n  \\<lbrakk>subtype ?P ?x ?y; \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> subtype (class_add ?P (?C, ?cdec)) ?x ?y\n  \\<lbrakk>?P \\<turnstile> ?l1.0 \\<le>\\<^sub>\\<top> ?l2.0;\n   \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> class_add ?P\n                     (?C, ?cdec) \\<turnstile> ?l1.0 \\<le>\\<^sub>\\<top> ?l2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>';\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> \\<tau> \\<le>\\<^sub>i \\<tau>'", "by(auto simp: sup_state_def Listn.le_def Product.le_def lesub_def class_add_widens\n               class_add_sup_ty_opt list_all2_mono)"], ["", "lemma class_add_sup_state_opt:\n \"\\<lbrakk> P \\<turnstile> \\<tau> \\<le>' \\<tau>'; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec) \\<turnstile> \\<tau> \\<le>' \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<tau> \\<le>' \\<tau>';\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (C, cdec) \\<turnstile> \\<tau> \\<le>' \\<tau>'", "by(auto simp: sup_state_opt_def Opt.le_def lesub_def class_add_widens\n               class_add_sup_ty_opt list_all2_mono)"], ["", "subsection \"Effect\""], ["", "lemma class_add_is_relevant_class:\n \"\\<lbrakk> is_relevant_class i P C\\<^sub>0; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_relevant_class i P C\\<^sub>0; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0", "by(cases i, auto simp: class_add_subcls)"], ["", "lemma class_add_is_relevant_class_rev:\nassumes irc: \"is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\"\n  and ncp: \"\\<And>cd D'. cd \\<in> set P \\<Longrightarrow> \\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\"\n  and wfxp: \"wf_syscls P\"\nshows \"is_relevant_class i P C\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_relevant_class i P C\\<^sub>0", "using assms"], ["proof (prove)\nusing this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n\ngoal (1 subgoal):\n 1. is_relevant_class i P C\\<^sub>0", "proof(cases i)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x51 x52.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x71 x72.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<And>x101 x102.\n        \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n         \\<And>cd.\n            cd \\<in> set P \\<Longrightarrow>\n            (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n         wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 18 subgoals...", "case (Getfield F D)"], ["proof (state)\nthis:\n  i = Getfield F D\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x51 x52.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x71 x72.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<And>x101 x102.\n        \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n         \\<And>cd.\n            cd \\<in> set P \\<Longrightarrow>\n            (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n         wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 18 subgoals...", "with assms"], ["proof (chain)\npicking this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  i = Getfield F D", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  i = Getfield F D\n\ngoal (1 subgoal):\n 1. is_relevant_class i P C\\<^sub>0", "by(fastforce simp: wf_syscls_def sys_xcpts_def dest!: class_add_subcls_rev)"], ["proof (state)\nthis:\n  is_relevant_class i P C\\<^sub>0\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x71 x72.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n         \\<And>cd.\n            cd \\<in> set P \\<Longrightarrow>\n            (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n         wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x71 x72.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n         \\<And>cd.\n            cd \\<in> set P \\<Longrightarrow>\n            (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n         wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 17 subgoals...", "case (Putfield F D)"], ["proof (state)\nthis:\n  i = Putfield F D\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x71 x72.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n         \\<And>cd.\n            cd \\<in> set P \\<Longrightarrow>\n            (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n         wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 17 subgoals...", "with assms"], ["proof (chain)\npicking this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  i = Putfield F D", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  i = Putfield F D\n\ngoal (1 subgoal):\n 1. is_relevant_class i P C\\<^sub>0", "by(fastforce simp: wf_syscls_def sys_xcpts_def dest!: class_add_subcls_rev)"], ["proof (state)\nthis:\n  is_relevant_class i P C\\<^sub>0\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n      \\<And>cd.\n         cd \\<in> set P \\<Longrightarrow>\n         (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n      wf_syscls P; i = Return\\<rbrakk>\n     \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n      \\<And>cd.\n         cd \\<in> set P \\<Longrightarrow>\n         (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n      wf_syscls P; i = Return\\<rbrakk>\n     \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 16 subgoals...", "case (Checkcast D)"], ["proof (state)\nthis:\n  i = Checkcast D\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x9.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n      \\<And>cd.\n         cd \\<in> set P \\<Longrightarrow>\n         (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n      wf_syscls P; i = Return\\<rbrakk>\n     \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 16 subgoals...", "with assms"], ["proof (chain)\npicking this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  i = Checkcast D", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  i = Checkcast D\n\ngoal (1 subgoal):\n 1. is_relevant_class i P C\\<^sub>0", "by(fastforce simp: wf_syscls_def sys_xcpts_def dest!: class_add_subcls_rev)"], ["proof (state)\nthis:\n  is_relevant_class i P C\\<^sub>0\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 2. \\<And>x2.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 3. \\<And>x3.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 4. \\<And>x4.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = New x4\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 7. \\<And>x101 x102.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n        \\<And>cd.\n           cd \\<in> set P \\<Longrightarrow>\n           (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n        wf_syscls P; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 9. \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n     \\<And>cd.\n        cd \\<in> set P \\<Longrightarrow>\n        (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n     wf_syscls P; i = Return\\<rbrakk>\n    \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\n 10. \\<lbrakk>is_relevant_class i (class_add P (C, cdec)) C\\<^sub>0;\n      \\<And>cd.\n         cd \\<in> set P \\<Longrightarrow>\n         (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n      wf_syscls P; i = Pop\\<rbrakk>\n     \\<Longrightarrow> is_relevant_class i P C\\<^sub>0\nA total of 15 subgoals...", "qed(simp_all)"], ["", "lemma class_add_is_relevant_entry:\n \"\\<lbrakk> is_relevant_entry P i pc e; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry (class_add P (C, cdec)) i pc e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_relevant_entry P i pc e; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> is_relevant_entry (class_add P (C, cdec)) i pc e", "by(clarsimp simp: is_relevant_entry_def class_add_is_relevant_class)"], ["", "lemma class_add_is_relevant_entry_rev:\n \"\\<lbrakk> is_relevant_entry (class_add P (C, cdec)) i pc e; \n    \\<And>cd D'. cd \\<in> set P \\<Longrightarrow> \\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C;\n    wf_syscls P \\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry P i pc e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_relevant_entry (class_add P (C, cdec)) i pc e;\n     \\<And>cd D'.\n        cd \\<in> set P \\<Longrightarrow>\n        (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*;\n     wf_syscls P\\<rbrakk>\n    \\<Longrightarrow> is_relevant_entry P i pc e", "by(auto simp: is_relevant_entry_def dest!: class_add_is_relevant_class_rev)"], ["", "lemma class_add_relevant_entries:\n \"\\<not> is_class P C\n  \\<Longrightarrow> set (relevant_entries P i pc xt) \\<subseteq> set (relevant_entries (class_add P (C, cdec)) i pc xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_class P C \\<Longrightarrow>\n    set (relevant_entries P i pc xt)\n    \\<subseteq> set (relevant_entries (class_add P (C, cdec)) i pc xt)", "by(clarsimp simp: relevant_entries_def class_add_is_relevant_entry)"], ["", "lemma class_add_relevant_entries_eq:\nassumes wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"relevant_entries P i pc xt = relevant_entries (class_add P (C, cdec)) i pc xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "have ncp: \"\\<And>cd D'. cd \\<in> set P \\<Longrightarrow> \\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cd D'.\n       cd \\<in> set P \\<Longrightarrow>\n       (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*", "by(rule wf_subcls_nCls'[OF assms])"], ["proof (state)\nthis:\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "moreover"], ["proof (state)\nthis:\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "from wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P", "have wfsys: \"wf_syscls P\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_syscls P", "by(simp add: wf_prog_def)"], ["proof (state)\nthis:\n  wf_syscls P\n\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "moreover"], ["proof (state)\nthis:\n  wf_syscls P\n\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "note class_add_is_relevant_entry[OF _ nclass, of i pc _ cdec]\n       class_add_is_relevant_entry_rev[OF _ ncp wfsys, of cdec i pc]"], ["proof (state)\nthis:\n  is_relevant_entry P i pc ?e \\<Longrightarrow>\n  is_relevant_entry (class_add P (C, cdec)) i pc ?e\n  \\<lbrakk>is_relevant_entry (class_add P (C, cdec)) i pc ?e;\n   \\<And>cd D'. cd \\<in> set P \\<Longrightarrow> cd \\<in> set P\\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry P i pc ?e\n\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "ultimately"], ["proof (chain)\npicking this:\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  is_relevant_entry P i pc ?e \\<Longrightarrow>\n  is_relevant_entry (class_add P (C, cdec)) i pc ?e\n  \\<lbrakk>is_relevant_entry (class_add P (C, cdec)) i pc ?e;\n   \\<And>cd D'. cd \\<in> set P \\<Longrightarrow> cd \\<in> set P\\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry P i pc ?e", "show ?thesis"], ["proof (prove)\nusing this:\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  wf_syscls P\n  is_relevant_entry P i pc ?e \\<Longrightarrow>\n  is_relevant_entry (class_add P (C, cdec)) i pc ?e\n  \\<lbrakk>is_relevant_entry (class_add P (C, cdec)) i pc ?e;\n   \\<And>cd D'. cd \\<in> set P \\<Longrightarrow> cd \\<in> set P\\<rbrakk>\n  \\<Longrightarrow> is_relevant_entry P i pc ?e\n\ngoal (1 subgoal):\n 1. relevant_entries P i pc xt =\n    relevant_entries (class_add P (C, cdec)) i pc xt", "by (metis filter_cong relevant_entries_def)"], ["proof (state)\nthis:\n  relevant_entries P i pc xt =\n  relevant_entries (class_add P (C, cdec)) i pc xt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_norm_eff_pc:\nassumes ne: \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i P pc \\<tau>). pc' < mpc\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i (class_add P (C, cdec)) pc \\<tau>). pc' < mpc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n       pc' < mpc", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>). pc' < mpc\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n       pc' < mpc", "by(cases i, auto simp: norm_eff_def)"], ["", "lemma class_add_norm_eff_sup_state_opt:\nassumes ne: \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i P pc \\<tau>). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\"\n   and nclass: \"\\<not> is_class P C\" and app: \"app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (norm_eff i (class_add P (C, cdec)) pc \\<tau>). (class_add P (C, cdec)) \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "obtain ST LT where \"\\<tau> = (ST,LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<tau> = (ST, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<tau>)"], ["proof (state)\nthis:\n  \\<tau> = (ST, LT)\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  \\<not> is_class P C\n  app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\n  \\<tau> = (ST, LT)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  \\<not> is_class P C\n  app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\n  \\<tau> = (ST, LT)\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "proof(cases i)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 2. \\<And>x2.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 3. \\<And>x3.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 4. \\<And>x4.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 9. \\<And>x9.\n       \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                   P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n        \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n        \\<tau> = (ST, LT); i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                  \\<in>set\n  (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                            class_add P\n                             (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                             pc'\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n                    P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc';\n         \\<not> is_class P C; app\\<^sub>i (i, P, pc, mxs, T, \\<tau>);\n         \\<tau> = (ST, LT); i = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                                   \\<in>set\n   (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n                             class_add P\n                              (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s !\n                              pc'\nA total of 18 subgoals...", "qed(fastforce simp: norm_eff_def\n                dest!: class_add_field[where cdec=cdec] class_add_method[where cdec=cdec]\n                       class_add_sup_loc[OF _ nclass] class_add_subtype[OF _ nclass]\n                       class_add_widens[OF _ nclass] class_add_sup_state_opt[OF _ nclass])+"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (norm_eff i (class_add P (C, cdec)) pc \\<tau>).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_xcpt_eff_eq:\nassumes wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"xcpt_eff i P pc \\<tau> xt = xcpt_eff i (class_add P (C, cdec)) pc \\<tau> xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xcpt_eff i P pc \\<tau> xt =\n    xcpt_eff i (class_add P (C, cdec)) pc \\<tau> xt", "using class_add_relevant_entries_eq[OF assms, of i pc xt cdec]"], ["proof (prove)\nusing this:\n  relevant_entries P i pc xt =\n  relevant_entries (class_add P (C, cdec)) i pc xt\n\ngoal (1 subgoal):\n 1. xcpt_eff i P pc \\<tau> xt =\n    xcpt_eff i (class_add P (C, cdec)) pc \\<tau> xt", "by(cases \\<tau>, simp add: xcpt_eff_def)"], ["", "lemma class_add_eff_pc:\nassumes eff: \"\\<forall>(pc',\\<tau>') \\<in> set (eff i P pc xt (Some \\<tau>)). pc' < mpc\"\n  and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (eff i (class_add P (C, cdec)) pc xt (Some \\<tau>)). pc' < mpc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       pc' < mpc", "using eff class_add_norm_eff_pc class_add_xcpt_eff_eq[OF wf nclass]"], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n     pc' < mpc\n  \\<forall>(pc', \\<tau>')\\<in>set (norm_eff ?i ?P ?pc ?\\<tau>).\n     pc' < ?mpc \\<Longrightarrow>\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (norm_eff ?i (class_add ?P (?C, ?cdec)) ?pc ?\\<tau>).\n     pc' < ?mpc\n  xcpt_eff ?i P ?pc ?\\<tau> ?xt =\n  xcpt_eff ?i (class_add P (C, ?cdec)) ?pc ?\\<tau> ?xt\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       pc' < mpc", "by(auto simp: norm_eff_def eff_def)"], ["", "lemma class_add_eff_sup_state_opt:\nassumes eff: \"\\<forall>(pc',\\<tau>') \\<in> set (eff i P pc xt (Some \\<tau>)). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\"\n  and wf: \"wf_prog wf_md P\"and nclass: \"\\<not> is_class P C\"\n  and app: \"app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\"\nshows \"\\<forall>(pc',\\<tau>') \\<in> set (eff i (class_add P (C, cdec)) pc xt (Some \\<tau>)).\n         (class_add P (C, cdec)) \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "from eff"], ["proof (chain)\npicking this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "have ne: \"\\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n       P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "by(simp add: norm_eff_def eff_def)"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\\<in>set (norm_eff i P pc \\<tau>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "from eff"], ["proof (chain)\npicking this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "have \"\\<forall>(pc', \\<tau>')\\<in>set (xcpt_eff i P pc \\<tau> xt). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\\<in>set (xcpt_eff i P pc \\<tau> xt).\n       P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "by(simp add: xcpt_eff_def eff_def)"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\\<in>set (xcpt_eff i P pc \\<tau> xt).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "with class_add_norm_eff_sup_state_opt[OF ne nclass app]\n       class_add_xcpt_eff_eq[OF wf nclass]class_add_sup_state_opt[OF _ nclass]"], ["proof (chain)\npicking this:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (norm_eff i (class_add P (C, ?cdec)) pc \\<tau>).\n     class_add P (C, ?cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  xcpt_eff ?i P ?pc ?\\<tau> ?xt =\n  xcpt_eff ?i (class_add P (C, ?cdec)) ?pc ?\\<tau> ?xt\n  P \\<turnstile> ?\\<tau> \\<le>' ?\\<tau>' \\<Longrightarrow>\n  class_add P (C, ?cdec) \\<turnstile> ?\\<tau> \\<le>' ?\\<tau>'\n  \\<forall>(pc', \\<tau>')\\<in>set (xcpt_eff i P pc \\<tau> xt).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (norm_eff i (class_add P (C, ?cdec)) pc \\<tau>).\n     class_add P (C, ?cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  xcpt_eff ?i P ?pc ?\\<tau> ?xt =\n  xcpt_eff ?i (class_add P (C, ?cdec)) ?pc ?\\<tau> ?xt\n  P \\<turnstile> ?\\<tau> \\<le>' ?\\<tau>' \\<Longrightarrow>\n  class_add P (C, ?cdec) \\<turnstile> ?\\<tau> \\<le>' ?\\<tau>'\n  \\<forall>(pc', \\<tau>')\\<in>set (xcpt_eff i P pc \\<tau> xt).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                        \\<lfloor>\\<tau>\\<rfloor>).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "by(cases cdec, auto simp: eff_def norm_eff_def xcpt_app_def)"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                      \\<lfloor>\\<tau>\\<rfloor>).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_app\\<^sub>i:\nassumes \"app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\" and \"\\<not> is_class P C\"\nshows \"app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "proof(cases i)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x4.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = New x4\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x51 x52.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<And>x101 x102.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 18 subgoals...", "case New"], ["proof (state)\nthis:\n  i = New x4_\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x4.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = New x4\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x51 x52.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<And>x101 x102.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = New x4_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = New x4_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = New x4_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(fastforce simp: is_class_def class_def fun_upd_apply)"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x51 x52.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x51 x52.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 17 subgoals...", "case Getfield"], ["proof (state)\nthis:\n  i = Getfield x51_ x52_\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x51 x52.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Getfield x51_ x52_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Getfield x51_ x52_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Getfield x51_ x52_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(auto simp: class_add_subtype dest!: class_add_sees_field[where P=P])"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Return\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Return\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 16 subgoals...", "case Getstatic"], ["proof (state)\nthis:\n  i = Getstatic x61_ x62_ x63_\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Return\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Getstatic x61_ x62_ x63_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Getstatic x61_ x62_ x63_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Getstatic x61_ x62_ x63_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(auto dest!: class_add_sees_field[where P=P])"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Pop\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Pop\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 15 subgoals...", "case Putfield"], ["proof (state)\nthis:\n  i = Putfield x71_ x72_\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x71 x72.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Pop\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Putfield x71_ x72_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Putfield x71_ x72_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Putfield x71_ x72_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(auto dest!: class_add_subtype[where P=P] class_add_sees_field[where P=P])"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = IAdd\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = IAdd\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 14 subgoals...", "case Putstatic"], ["proof (state)\nthis:\n  i = Putstatic x81_ x82_ x83_\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = IAdd\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Putstatic x81_ x82_ x83_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Putstatic x81_ x82_ x83_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Putstatic x81_ x82_ x83_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(auto dest!: class_add_subtype[where P=P] class_add_sees_field[where P=P])"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<And>x15.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Goto x15\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<And>x15.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Goto x15\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 13 subgoals...", "case Checkcast"], ["proof (state)\nthis:\n  i = Checkcast x9_\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x9.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<And>x15.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = Goto x15\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Checkcast x9_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Checkcast x9_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Checkcast x9_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(clarsimp simp: is_class_def class_def fun_upd_apply)"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = CmpEq\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = CmpEq\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 12 subgoals...", "case Invoke"], ["proof (state)\nthis:\n  i = Invoke x101_ x102_\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x101 x102.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = CmpEq\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Invoke x101_ x102_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Invoke x101_ x102_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Invoke x101_ x102_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(fastforce dest!: class_add_widens[where P=P] class_add_sees_method[where P=P])"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<And>x17.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<And>x17.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 11 subgoals...", "case Invokestatic"], ["proof (state)\nthis:\n  i = Invokestatic x111_ x112_ x113_\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 10. \\<And>x17.\n        \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n         \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> app\\<^sub>i\n                           (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r,\n                            ST, LT)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Invokestatic x111_ x112_ x113_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Invokestatic x111_ x112_ x113_\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Invokestatic x111_ x112_ x113_\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(fastforce dest!: class_add_widens[where P=P] class_add_sees_method[where P=P])"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<And>x17.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Throw\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<And>x17.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Throw\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)", "case Return"], ["proof (state)\nthis:\n  i = Return\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Return\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 7. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 8. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 9. \\<And>x17.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 10. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n      \\<not> is_class P C; i = Throw\\<rbrakk>\n     \\<Longrightarrow> app\\<^sub>i\n                        (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                         LT)", "then"], ["proof (chain)\npicking this:\n  i = Return", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Return\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "using assms"], ["proof (prove)\nusing this:\n  i = Return\n  app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT)\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)", "by(clarsimp simp: class_add_subtype)"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST, LT)\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Load x1\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 2. \\<And>x2.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Store x2\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 3. \\<And>x3.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Push x3\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 4. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Pop\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 5. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = IAdd\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 6. \\<And>x15.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = Goto x15\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 7. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = CmpEq\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)\n 8. \\<And>x17.\n       \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n        \\<not> is_class P C; i = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> app\\<^sub>i\n                          (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                           LT)\n 9. \\<lbrakk>app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, ST, LT);\n     \\<not> is_class P C; i = Throw\\<rbrakk>\n    \\<Longrightarrow> app\\<^sub>i\n                       (i, class_add P (C, cdec), pc, mxs, T\\<^sub>r, ST,\n                        LT)", "qed(simp+)"], ["", "lemma class_add_xcpt_app:\nassumes xa: \"xcpt_app i P pc mxs xt \\<tau>\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>", "using xa class_add_relevant_entries_eq[OF wf nclass] nclass"], ["proof (prove)\nusing this:\n  xcpt_app i P pc mxs xt \\<tau>\n  relevant_entries P ?i ?pc ?xt =\n  relevant_entries (class_add P (C, ?cdec)) ?i ?pc ?xt\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>", "by(auto simp: xcpt_app_def is_class_def class_def fun_upd_apply) auto"], ["", "lemma class_add_app:\nassumes app: \"app i P mxs T pc mpc xt t\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"app i (class_add P (C, cdec)) mxs T pc mpc xt t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i (class_add P (C, cdec)) mxs T pc mpc xt t", "proof(cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "case (Some \\<tau>)"], ["proof (state)\nthis:\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "let ?P = \"class_add P (C, cdec)\""], ["proof (state)\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "from assms Some"], ["proof (chain)\npicking this:\n  app i P mxs T pc mpc xt t\n  wf_prog wf_md P\n  \\<not> is_class P C\n  t = \\<lfloor>\\<tau>\\<rfloor>", "have eff: \"\\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>). pc' < mpc\""], ["proof (prove)\nusing this:\n  app i P mxs T pc mpc xt t\n  wf_prog wf_md P\n  \\<not> is_class P C\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n       pc' < mpc", "by(simp add: app_def)"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n     pc' < mpc\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "from assms Some"], ["proof (chain)\npicking this:\n  app i P mxs T pc mpc xt t\n  wf_prog wf_md P\n  \\<not> is_class P C\n  t = \\<lfloor>\\<tau>\\<rfloor>", "have app\\<^sub>i: \"app\\<^sub>i (i,P,pc,mxs,T,\\<tau>)\""], ["proof (prove)\nusing this:\n  app i P mxs T pc mpc xt t\n  wf_prog wf_md P\n  \\<not> is_class P C\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)", "by(simp add: app_def)"], ["proof (state)\nthis:\n  app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "with class_add_app\\<^sub>i[OF _ nclass] Some"], ["proof (chain)\npicking this:\n  app\\<^sub>i (?i, P, ?pc, ?mxs, ?T\\<^sub>r, ?ST, ?LT) \\<Longrightarrow>\n  app\\<^sub>i (?i, class_add P (C, ?cdec), ?pc, ?mxs, ?T\\<^sub>r, ?ST, ?LT)\n  t = \\<lfloor>\\<tau>\\<rfloor>\n  app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)", "have \"app\\<^sub>i (i,?P,pc,mxs,T,\\<tau>)\""], ["proof (prove)\nusing this:\n  app\\<^sub>i (?i, P, ?pc, ?mxs, ?T\\<^sub>r, ?ST, ?LT) \\<Longrightarrow>\n  app\\<^sub>i (?i, class_add P (C, ?cdec), ?pc, ?mxs, ?T\\<^sub>r, ?ST, ?LT)\n  t = \\<lfloor>\\<tau>\\<rfloor>\n  app\\<^sub>i (i, P, pc, mxs, T, \\<tau>)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T, \\<tau>)", "by(cases \\<tau>,simp)"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T, \\<tau>)\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "moreover"], ["proof (state)\nthis:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T, \\<tau>)\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "from app class_add_xcpt_app[OF _ wf nclass] Some"], ["proof (chain)\npicking this:\n  app i P mxs T pc mpc xt t\n  xcpt_app ?i P ?pc ?mxs ?xt ?\\<tau> \\<Longrightarrow>\n  xcpt_app ?i (class_add P (C, ?cdec)) ?pc ?mxs ?xt ?\\<tau>\n  t = \\<lfloor>\\<tau>\\<rfloor>", "have \"xcpt_app i ?P pc mxs xt \\<tau>\""], ["proof (prove)\nusing this:\n  app i P mxs T pc mpc xt t\n  xcpt_app ?i P ?pc ?mxs ?xt ?\\<tau> \\<Longrightarrow>\n  xcpt_app ?i (class_add P (C, ?cdec)) ?pc ?mxs ?xt ?\\<tau>\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (1 subgoal):\n 1. xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>", "by(simp add: app_def del: xcpt_app_def)"], ["proof (state)\nthis:\n  xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "moreover"], ["proof (state)\nthis:\n  xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "from app class_add_eff_pc[OF eff wf nclass] Some"], ["proof (chain)\npicking this:\n  app i P mxs T pc mpc xt t\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, ?cdec)) pc xt\n                      \\<lfloor>\\<tau>\\<rfloor>).\n     pc' < mpc\n  t = \\<lfloor>\\<tau>\\<rfloor>", "have \"\\<forall>(pc',\\<tau>') \\<in> set (eff i ?P pc xt t). pc' < mpc\""], ["proof (prove)\nusing this:\n  app i P mxs T pc mpc xt t\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, ?cdec)) pc xt\n                      \\<lfloor>\\<tau>\\<rfloor>).\n     pc' < mpc\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\\<in>set (eff i (class_add P (C, cdec)) pc xt t).\n       pc' < mpc", "by auto"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i (class_add P (C, cdec)) pc xt t).\n     pc' < mpc\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "moreover"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i (class_add P (C, cdec)) pc xt t).\n     pc' < mpc\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "note app Some"], ["proof (state)\nthis:\n  app i P mxs T pc mpc xt t\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (2 subgoals):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t\n 2. \\<And>a.\n       t = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       app i (class_add P (C, cdec)) mxs T pc mpc xt t", "ultimately"], ["proof (chain)\npicking this:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T, \\<tau>)\n  xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i (class_add P (C, cdec)) pc xt t).\n     pc' < mpc\n  app i P mxs T pc mpc xt t\n  t = \\<lfloor>\\<tau>\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  app\\<^sub>i (i, class_add P (C, cdec), pc, mxs, T, \\<tau>)\n  xcpt_app i (class_add P (C, cdec)) pc mxs xt \\<tau>\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i (class_add P (C, cdec)) pc xt t).\n     pc' < mpc\n  app i P mxs T pc mpc xt t\n  t = \\<lfloor>\\<tau>\\<rfloor>\n\ngoal (1 subgoal):\n 1. app i (class_add P (C, cdec)) mxs T pc mpc xt t", "by(simp add: app_def)"], ["proof (state)\nthis:\n  app i (class_add P (C, cdec)) mxs T pc mpc xt t\n\ngoal (1 subgoal):\n 1. t = None \\<Longrightarrow>\n    app i (class_add P (C, cdec)) mxs T pc mpc xt t", "qed(simp)"], ["", "subsection \"Well-formedness and well-typedness\""], ["", "lemma class_add_wf_mdecl:\n  \"\\<lbrakk> wf_mdecl wf_md P C\\<^sub>0 md;\n     \\<And>C\\<^sub>0 md. wf_md P C\\<^sub>0 md \\<Longrightarrow> wf_md (class_add P (C, cdec)) C\\<^sub>0 md \\<rbrakk>\n  \\<Longrightarrow> wf_mdecl wf_md (class_add P (C, cdec)) C\\<^sub>0 md\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_mdecl wf_md P C\\<^sub>0 md;\n     \\<And>C\\<^sub>0 md.\n        wf_md P C\\<^sub>0 md \\<Longrightarrow>\n        wf_md (class_add P (C, cdec)) C\\<^sub>0 md\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md (class_add P (C, cdec)) C\\<^sub>0 md", "by(clarsimp simp: wf_mdecl_def class_add_is_type)"], ["", "lemma class_add_wf_mdecl':\nassumes wfd: \"wf_mdecl wf_md P C\\<^sub>0 md\"\n  and ms: \"(C\\<^sub>0,S,fs,ms) \\<in> set P\" and md: \"md \\<in> set ms\"\n  and wf_md': \"\\<And>C\\<^sub>0 S fs ms m.\\<lbrakk>(C\\<^sub>0,S,fs,ms) \\<in> set P; m \\<in> set ms\\<rbrakk> \\<Longrightarrow> wf_md' (class_add P (C, cdec)) C\\<^sub>0 m\"\nshows \"wf_mdecl wf_md' (class_add P (C, cdec)) C\\<^sub>0 md\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mdecl wf_md' (class_add P (C, cdec)) C\\<^sub>0 md", "using assms"], ["proof (prove)\nusing this:\n  wf_mdecl wf_md P C\\<^sub>0 md\n  (C\\<^sub>0, S, fs, ms) \\<in> set P\n  md \\<in> set ms\n  \\<lbrakk>(?C\\<^sub>0, ?S, ?fs, ?ms) \\<in> set P; ?m \\<in> set ?ms\\<rbrakk>\n  \\<Longrightarrow> wf_md' (class_add P (C, cdec)) ?C\\<^sub>0 ?m\n\ngoal (1 subgoal):\n 1. wf_mdecl wf_md' (class_add P (C, cdec)) C\\<^sub>0 md", "by(clarsimp simp: wf_mdecl_def class_add_is_type)"], ["", "lemma class_add_wf_cdecl:\nassumes wfcd: \"wf_cdecl wf_md P cd\" and cdP: \"cd \\<in> set P\"\n and ncp: \"\\<not> P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\" and dist: \"distinct_fst P\"\n and wfmd: \"\\<And>C\\<^sub>0 md. wf_md P C\\<^sub>0 md \\<Longrightarrow> wf_md (class_add P (C, cdec)) C\\<^sub>0 md\"\n and nclass: \"\\<not> is_class P C\"\nshows \"wf_cdecl wf_md (class_add P (C, cdec)) cd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "let ?P = \"class_add P (C, cdec)\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "obtain C1 D fs ms where [simp]: \"cd = (C1,(D,fs,ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C1 D fs ms.\n        cd = (C1, D, fs, ms) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cd)"], ["proof (state)\nthis:\n  cd = (C1, D, fs, ms)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "from wfcd"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd", "have \"\\<forall>f\\<in>set fs. wf_fdecl ?P f\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f", "by(auto simp: wf_cdecl_def wf_fdecl_def class_add_is_type)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "moreover"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "from wfcd wfmd class_add_wf_mdecl"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  wf_md P ?C\\<^sub>0 ?md \\<Longrightarrow>\n  wf_md (class_add P (C, cdec)) ?C\\<^sub>0 ?md\n  \\<lbrakk>wf_mdecl ?wf_md ?P ?C\\<^sub>0 ?md;\n   \\<And>C\\<^sub>0 md.\n      ?wf_md ?P C\\<^sub>0 md \\<Longrightarrow>\n      ?wf_md (class_add ?P (?C, ?cdec)) C\\<^sub>0 md\\<rbrakk>\n  \\<Longrightarrow> wf_mdecl ?wf_md (class_add ?P (?C, ?cdec)) ?C\\<^sub>0\n                     ?md", "have \"\\<forall>m\\<in>set ms. wf_mdecl wf_md ?P C1 m\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  wf_md P ?C\\<^sub>0 ?md \\<Longrightarrow>\n  wf_md (class_add P (C, cdec)) ?C\\<^sub>0 ?md\n  \\<lbrakk>wf_mdecl ?wf_md ?P ?C\\<^sub>0 ?md;\n   \\<And>C\\<^sub>0 md.\n      ?wf_md ?P C\\<^sub>0 md \\<Longrightarrow>\n      ?wf_md (class_add ?P (?C, ?cdec)) C\\<^sub>0 md\\<rbrakk>\n  \\<Longrightarrow> wf_mdecl ?wf_md (class_add ?P (?C, ?cdec)) ?C\\<^sub>0\n                     ?md\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set ms. wf_mdecl wf_md (class_add P (C, cdec)) C1 m", "by(auto simp: wf_cdecl_def)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md (class_add P (C, cdec)) C1 m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "moreover"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md (class_add P (C, cdec)) C1 m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "have \"C1 \\<noteq> Object \\<Longrightarrow> is_class ?P D \\<and> \\<not> ?P \\<turnstile> D \\<preceq>\\<^sup>* C1\n    \\<and> (\\<forall>(M,b,Ts,T,m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'. ?P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D' \\<longrightarrow>\n                       b = b' \\<and> ?P \\<turnstile> Ts' [\\<le>] Ts \\<and> ?P \\<turnstile> T \\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "assume nObj[simp]: \"C1 \\<noteq> Object\""], ["proof (state)\nthis:\n  C1 \\<noteq> Object\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "with cdP dist"], ["proof (chain)\npicking this:\n  cd \\<in> set P\n  distinct_fst P\n  C1 \\<noteq> Object", "have sub1: \"P \\<turnstile> C1 \\<prec>\\<^sup>1 D\""], ["proof (prove)\nusing this:\n  cd \\<in> set P\n  distinct_fst P\n  C1 \\<noteq> Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "by(auto simp: class_def intro!: subcls1I map_of_SomeI)"], ["proof (state)\nthis:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "with ncp"], ["proof (chain)\npicking this:\n  (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "have ncp': \"\\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>*", "by(auto simp: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "with wfcd"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*", "have clsD: \"is_class ?P D\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. is_class (class_add P (C, cdec)) D", "by(auto simp: wf_cdecl_def is_class_def class_def fun_upd_apply)"], ["proof (state)\nthis:\n  is_class (class_add P (C, cdec)) D\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "moreover"], ["proof (state)\nthis:\n  is_class (class_add P (C, cdec)) D\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "from wfcd sub1"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "have \"\\<not> ?P \\<turnstile> D \\<preceq>\\<^sup>* C1\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*", "by(auto simp: wf_cdecl_def dest!: class_add_subcls_rev[OF _ ncp'])"], ["proof (state)\nthis:\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "moreover"], ["proof (state)\nthis:\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "have \"\\<And>M b Ts T m D' b' Ts' T' m'. (M,b,Ts,T,m) \\<in> set ms\n            \\<Longrightarrow> ?P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D'\n            \\<Longrightarrow> b = b' \\<and> ?P \\<turnstile> Ts' [\\<le>] Ts \\<and> ?P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "fix M b Ts T m D' b' Ts' T' m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "assume ms: \"(M,b,Ts,T,m) \\<in> set ms\" and meth': \"?P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D'\""], ["proof (state)\nthis:\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "with sub1"], ["proof (chain)\npicking this:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'", "have \"P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'", "by(fastforce dest!: class_add_sees_method_rev[OF _ ncp'])"], ["proof (state)\nthis:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "with wfcd ms meth'"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'", "have \"b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'", "by(cases m', fastforce simp: wf_cdecl_def elim!: ballE[where x=\"(M,b,Ts,T,m)\"])"], ["proof (state)\nthis:\n  b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'", "show \"b = b' \\<and> ?P \\<turnstile> Ts' [\\<le>] Ts \\<and> ?P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'\n\ngoal (1 subgoal):\n 1. b = b' \\<and>\n    class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n    subtype (class_add P (C, cdec)) T T'", "by(auto dest!: class_add_subtype[OF _ nclass] class_add_widens[OF _ nclass])"], ["proof (state)\nthis:\n  b = b' \\<and>\n  class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n  subtype (class_add P (C, cdec)) T T'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?M, ?b, ?Ts, ?T, ?m) \\<in> set ms;\n   class_add P\n    (C, cdec) \\<turnstile> D sees ?M, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D'\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b' \\<and>\n                    class_add P\n                     (C, cdec) \\<turnstile> ?Ts' [\\<le>] ?Ts \\<and>\n                    subtype (class_add P (C, cdec)) ?T ?T'\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "ultimately"], ["proof (chain)\npicking this:\n  is_class (class_add P (C, cdec)) D\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n  \\<lbrakk>(?M, ?b, ?Ts, ?T, ?m) \\<in> set ms;\n   class_add P\n    (C, cdec) \\<turnstile> D sees ?M, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D'\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b' \\<and>\n                    class_add P\n                     (C, cdec) \\<turnstile> ?Ts' [\\<le>] ?Ts \\<and>\n                    subtype (class_add P (C, cdec)) ?T ?T'", "show ?thesis"], ["proof (prove)\nusing this:\n  is_class (class_add P (C, cdec)) D\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n  \\<lbrakk>(?M, ?b, ?Ts, ?T, ?m) \\<in> set ms;\n   class_add P\n    (C, cdec) \\<turnstile> D sees ?M, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D'\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b' \\<and>\n                    class_add P\n                     (C, cdec) \\<turnstile> ?Ts' [\\<le>] ?Ts \\<and>\n                    subtype (class_add P (C, cdec)) ?T ?T'\n\ngoal (1 subgoal):\n 1. is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "by clarsimp"], ["proof (state)\nthis:\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "moreover"], ["proof (state)\nthis:\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "note wfcd"], ["proof (state)\nthis:\n  wf_cdecl wf_md P cd\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md (class_add P (C, cdec)) C1 m\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n  wf_cdecl wf_md P cd", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md (class_add P (C, cdec)) C1 m\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n  wf_cdecl wf_md P cd\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md (class_add P (C, cdec)) cd", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  wf_cdecl wf_md (class_add P (C, cdec)) cd\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_wf_cdecl':\nassumes wfcd: \"wf_cdecl wf_md P cd\" and cdP: \"cd \\<in> set P\"\n and ncp: \"\\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* C\" and dist: \"distinct_fst P\"\n and wfmd: \"\\<And>C\\<^sub>0 S fs ms m.\\<lbrakk>(C\\<^sub>0,S,fs,ms) \\<in> set P; m \\<in> set ms\\<rbrakk> \\<Longrightarrow> wf_md' (class_add P (C, cdec)) C\\<^sub>0 m\"\n and nclass: \"\\<not> is_class P C\"\nshows \"wf_cdecl wf_md' (class_add P (C, cdec)) cd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "let ?P = \"class_add P (C, cdec)\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "obtain C1 D fs ms where [simp]: \"cd = (C1,(D,fs,ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C1 D fs ms.\n        cd = (C1, D, fs, ms) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cd)"], ["proof (state)\nthis:\n  cd = (C1, D, fs, ms)\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "from wfcd"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd", "have \"\\<forall>f\\<in>set fs. wf_fdecl ?P f\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f", "by(auto simp: wf_cdecl_def wf_fdecl_def class_add_is_type)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "moreover"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "from cdP wfcd wfmd"], ["proof (chain)\npicking this:\n  cd \\<in> set P\n  wf_cdecl wf_md P cd\n  \\<lbrakk>(?C\\<^sub>0, ?S, ?fs, ?ms) \\<in> set P; ?m \\<in> set ?ms\\<rbrakk>\n  \\<Longrightarrow> wf_md' (class_add P (C, cdec)) ?C\\<^sub>0 ?m", "have \"\\<forall>m\\<in>set ms. wf_mdecl wf_md' ?P C1 m\""], ["proof (prove)\nusing this:\n  cd \\<in> set P\n  wf_cdecl wf_md P cd\n  \\<lbrakk>(?C\\<^sub>0, ?S, ?fs, ?ms) \\<in> set P; ?m \\<in> set ?ms\\<rbrakk>\n  \\<Longrightarrow> wf_md' (class_add P (C, cdec)) ?C\\<^sub>0 ?m\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set ms. wf_mdecl wf_md' (class_add P (C, cdec)) C1 m", "by(auto simp: wf_cdecl_def wf_mdecl_def class_add_is_type)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md' (class_add P (C, cdec)) C1 m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "moreover"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md' (class_add P (C, cdec)) C1 m\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "have \"C1 \\<noteq> Object \\<Longrightarrow> is_class ?P D \\<and> \\<not> ?P \\<turnstile> D \\<preceq>\\<^sup>* C1\n    \\<and> (\\<forall>(M,b,Ts,T,m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'. ?P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D' \\<longrightarrow>\n                       b = b' \\<and> ?P \\<turnstile> Ts' [\\<le>] Ts \\<and> ?P \\<turnstile> T \\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "assume nObj[simp]: \"C1 \\<noteq> Object\""], ["proof (state)\nthis:\n  C1 \\<noteq> Object\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "with cdP dist"], ["proof (chain)\npicking this:\n  cd \\<in> set P\n  distinct_fst P\n  C1 \\<noteq> Object", "have sub1: \"P \\<turnstile> C1 \\<prec>\\<^sup>1 D\""], ["proof (prove)\nusing this:\n  cd \\<in> set P\n  distinct_fst P\n  C1 \\<noteq> Object\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "by(auto simp: class_def intro!: subcls1I map_of_SomeI)"], ["proof (state)\nthis:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "with ncp"], ["proof (chain)\npicking this:\n  (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "have ncp': \"\\<not> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  (fst cd, C) \\<notin> (subcls1 P)\\<^sup>*\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (D, C) \\<notin> (subcls1 P)\\<^sup>*", "by(auto simp: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "with wfcd"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*", "have clsD: \"is_class ?P D\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  (D, C) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. is_class (class_add P (C, cdec)) D", "by(auto simp: wf_cdecl_def is_class_def class_def fun_upd_apply)"], ["proof (state)\nthis:\n  is_class (class_add P (C, cdec)) D\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "moreover"], ["proof (state)\nthis:\n  is_class (class_add P (C, cdec)) D\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "from wfcd sub1"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D", "have \"\\<not> ?P \\<turnstile> D \\<preceq>\\<^sup>* C1\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*", "by(auto simp: wf_cdecl_def dest!: class_add_subcls_rev[OF _ ncp'])"], ["proof (state)\nthis:\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "moreover"], ["proof (state)\nthis:\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "have \"\\<And>M b Ts T m D' b' Ts' T' m'. (M,b,Ts,T,m) \\<in> set ms\n            \\<Longrightarrow> ?P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D'\n            \\<Longrightarrow> b = b' \\<and> ?P \\<turnstile> Ts' [\\<le>] Ts \\<and> ?P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "fix M b Ts T m D' b' Ts' T' m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "assume ms: \"(M,b,Ts,T,m) \\<in> set ms\" and meth': \"?P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D'\""], ["proof (state)\nthis:\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "with sub1"], ["proof (chain)\npicking this:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'", "have \"P \\<turnstile> D sees M,b':Ts' \\<rightarrow> T' = m' in D'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C1 \\<prec>\\<^sup>1 D\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'", "by(fastforce dest!: class_add_sees_method_rev[OF _ ncp'])"], ["proof (state)\nthis:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "with wfcd ms meth'"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P cd\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'", "have \"b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P cd\n  (M, b, Ts, T, m) \\<in> set ms\n  class_add P\n   (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n\ngoal (1 subgoal):\n 1. b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'", "by(cases m', fastforce simp: wf_cdecl_def elim!: ballE[where x=\"(M,b,Ts,T,m)\"])"], ["proof (state)\nthis:\n  b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'\n\ngoal (1 subgoal):\n 1. \\<And>M b Ts T m D' b' Ts' T' m'.\n       \\<lbrakk>(M, b, Ts, T, m) \\<in> set ms;\n        class_add P\n         (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> b = b' \\<and>\n                         class_add P\n                          (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n                         subtype (class_add P (C, cdec)) T T'", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'", "show \"b = b' \\<and> ?P \\<turnstile> Ts' [\\<le>] Ts \\<and> ?P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D'\n  b = b' \\<and> P \\<turnstile> Ts' [\\<le>] Ts \\<and> subtype P T T'\n\ngoal (1 subgoal):\n 1. b = b' \\<and>\n    class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n    subtype (class_add P (C, cdec)) T T'", "by(auto dest!: class_add_subtype[OF _ nclass] class_add_widens[OF _ nclass])"], ["proof (state)\nthis:\n  b = b' \\<and>\n  class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n  subtype (class_add P (C, cdec)) T T'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?M, ?b, ?Ts, ?T, ?m) \\<in> set ms;\n   class_add P\n    (C, cdec) \\<turnstile> D sees ?M, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D'\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b' \\<and>\n                    class_add P\n                     (C, cdec) \\<turnstile> ?Ts' [\\<le>] ?Ts \\<and>\n                    subtype (class_add P (C, cdec)) ?T ?T'\n\ngoal (1 subgoal):\n 1. C1 \\<noteq> Object \\<Longrightarrow>\n    is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "ultimately"], ["proof (chain)\npicking this:\n  is_class (class_add P (C, cdec)) D\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n  \\<lbrakk>(?M, ?b, ?Ts, ?T, ?m) \\<in> set ms;\n   class_add P\n    (C, cdec) \\<turnstile> D sees ?M, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D'\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b' \\<and>\n                    class_add P\n                     (C, cdec) \\<turnstile> ?Ts' [\\<le>] ?Ts \\<and>\n                    subtype (class_add P (C, cdec)) ?T ?T'", "show ?thesis"], ["proof (prove)\nusing this:\n  is_class (class_add P (C, cdec)) D\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>*\n  \\<lbrakk>(?M, ?b, ?Ts, ?T, ?m) \\<in> set ms;\n   class_add P\n    (C, cdec) \\<turnstile> D sees ?M, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D'\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b' \\<and>\n                    class_add P\n                     (C, cdec) \\<turnstile> ?Ts' [\\<le>] ?Ts \\<and>\n                    subtype (class_add P (C, cdec)) ?T ?T'\n\ngoal (1 subgoal):\n 1. is_class (class_add P (C, cdec)) D \\<and>\n    (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n    (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n        \\<forall>D' b' Ts' T' m'.\n           class_add P\n            (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n           b = b' \\<and>\n           class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n           subtype (class_add P (C, cdec)) T T')", "by clarsimp"], ["proof (state)\nthis:\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "moreover"], ["proof (state)\nthis:\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "note wfcd"], ["proof (state)\nthis:\n  wf_cdecl wf_md P cd\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md' (class_add P (C, cdec)) C1 m\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n  wf_cdecl wf_md P cd", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fs. wf_fdecl (class_add P (C, cdec)) f\n  \\<forall>m\\<in>set ms. wf_mdecl wf_md' (class_add P (C, cdec)) C1 m\n  C1 \\<noteq> Object \\<Longrightarrow>\n  is_class (class_add P (C, cdec)) D \\<and>\n  (D, C1) \\<notin> (subcls1 (class_add P (C, cdec)))\\<^sup>* \\<and>\n  (\\<forall>(M, b, Ts, T, m)\\<in>set ms.\n      \\<forall>D' b' Ts' T' m'.\n         class_add P\n          (C, cdec) \\<turnstile> D sees M, b' :  Ts'\\<rightarrow>T' = m' in D' \\<longrightarrow>\n         b = b' \\<and>\n         class_add P (C, cdec) \\<turnstile> Ts' [\\<le>] Ts \\<and>\n         subtype (class_add P (C, cdec)) T T')\n  wf_cdecl wf_md P cd\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md' (class_add P (C, cdec)) cd", "by(simp add: wf_cdecl_def)"], ["proof (state)\nthis:\n  wf_cdecl wf_md' (class_add P (C, cdec)) cd\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_wt_start:\n \"\\<lbrakk> wt_start P C\\<^sub>0 b Ts mxl \\<tau>s; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl \\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt_start P C\\<^sub>0 b Ts mxl \\<tau>s;\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\n                       \\<tau>s", "using class_add_sup_state_opt"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P \\<turnstile> ?\\<tau> \\<le>' ?\\<tau>';\n   \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> class_add ?P\n                     (?C, ?cdec) \\<turnstile> ?\\<tau> \\<le>' ?\\<tau>'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt_start P C\\<^sub>0 b Ts mxl \\<tau>s;\n     \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\n                       \\<tau>s", "by(clarsimp simp: wt_start_def split: staticb.splits)"], ["", "lemma class_add_wt_instr:\nassumes wti: \"P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "let ?P = \"class_add P (C, cdec)\""], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "from wti"], ["proof (chain)\npicking this:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "have eff: \"\\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt (\\<tau>s ! pc)). P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\""], ["proof (prove)\nusing this:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt (\\<tau>s ! pc)).\n       P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "by(simp add: wt_instr_def)"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt (\\<tau>s ! pc)).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "from wti"], ["proof (chain)\npicking this:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "have app\\<^sub>i: \"\\<tau>s!pc \\<noteq> None \\<Longrightarrow> app\\<^sub>i (i,P,pc,mxs,T,the (\\<tau>s!pc))\""], ["proof (prove)\nusing this:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<tau>s ! pc \\<noteq> None \\<Longrightarrow>\n    app\\<^sub>i (i, P, pc, mxs, T, the (\\<tau>s ! pc))", "by(simp add: wt_instr_def app_def)"], ["proof (state)\nthis:\n  \\<tau>s ! pc \\<noteq> None \\<Longrightarrow>\n  app\\<^sub>i (i, P, pc, mxs, T, the (\\<tau>s ! pc))\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "from wti class_add_app[OF _ wf nclass]"], ["proof (chain)\npicking this:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n  app ?i P ?mxs ?T ?pc ?mpc ?xt ?t \\<Longrightarrow>\n  app ?i (class_add P (C, ?cdec)) ?mxs ?T ?pc ?mpc ?xt ?t", "have \"app i ?P mxs T pc mpc xt (\\<tau>s!pc)\""], ["proof (prove)\nusing this:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n  app ?i P ?mxs ?T ?pc ?mpc ?xt ?t \\<Longrightarrow>\n  app ?i (class_add P (C, ?cdec)) ?mxs ?T ?pc ?mpc ?xt ?t\n\ngoal (1 subgoal):\n 1. app i (class_add P (C, cdec)) mxs T pc mpc xt (\\<tau>s ! pc)", "by(simp add: wt_instr_def)"], ["proof (state)\nthis:\n  app i (class_add P (C, cdec)) mxs T pc mpc xt (\\<tau>s ! pc)\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "moreover"], ["proof (state)\nthis:\n  app i (class_add P (C, cdec)) mxs T pc mpc xt (\\<tau>s ! pc)\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "have \"\\<forall>(pc',\\<tau>') \\<in> set (eff i ?P pc xt (\\<tau>s!pc)). ?P \\<turnstile> \\<tau>' \\<le>' \\<tau>s!pc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "proof(cases \"\\<tau>s!pc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau>s ! pc = None \\<Longrightarrow>\n    \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n 2. \\<And>a.\n       \\<tau>s ! pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<forall>(pc', \\<tau>')\n                \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                           (\\<tau>s ! pc)).\n          class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "case Some"], ["proof (state)\nthis:\n  \\<tau>s ! pc = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<tau>s ! pc = None \\<Longrightarrow>\n    \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n 2. \\<And>a.\n       \\<tau>s ! pc = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       \\<forall>(pc', \\<tau>')\n                \\<in>set (eff i (class_add P (C, cdec)) pc xt\n                           (\\<tau>s ! pc)).\n          class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "with eff class_add_eff_sup_state_opt[OF _ wf nclass app\\<^sub>i]"], ["proof (chain)\npicking this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt (\\<tau>s ! pc)).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  \\<lbrakk>\\<forall>(pc', \\<tau>')\n                    \\<in>set (eff i P pc ?xt\n                               \\<lfloor>the (\\<tau>s ! pc)\\<rfloor>).\n              P \\<turnstile> \\<tau>' \\<le>' ?\\<tau>s ! pc';\n   \\<tau>s ! pc \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                             \\<in>set (eff i (class_add P (C, ?cdec)) pc ?xt\n  \\<lfloor>the (\\<tau>s ! pc)\\<rfloor>).\n                       class_add P\n                        (C, ?cdec) \\<turnstile> \\<tau>' \\<le>' ?\\<tau>s !\n                         pc'\n  \\<tau>s ! pc = \\<lfloor>a_\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(pc', \\<tau>')\\<in>set (eff i P pc xt (\\<tau>s ! pc)).\n     P \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  \\<lbrakk>\\<forall>(pc', \\<tau>')\n                    \\<in>set (eff i P pc ?xt\n                               \\<lfloor>the (\\<tau>s ! pc)\\<rfloor>).\n              P \\<turnstile> \\<tau>' \\<le>' ?\\<tau>s ! pc';\n   \\<tau>s ! pc \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(pc', \\<tau>')\n                             \\<in>set (eff i (class_add P (C, ?cdec)) pc ?xt\n  \\<lfloor>the (\\<tau>s ! pc)\\<rfloor>).\n                       class_add P\n                        (C, ?cdec) \\<turnstile> \\<tau>' \\<le>' ?\\<tau>s !\n                         pc'\n  \\<tau>s ! pc = \\<lfloor>a_\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. \\<tau>s ! pc = None \\<Longrightarrow>\n    \\<forall>(pc', \\<tau>')\n             \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n       class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'", "qed(simp add: eff_def)"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "moreover"], ["proof (state)\nthis:\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "note wti"], ["proof (state)\nthis:\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "ultimately"], ["proof (chain)\npicking this:\n  app i (class_add P (C, cdec)) mxs T pc mpc xt (\\<tau>s ! pc)\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "show ?thesis"], ["proof (prove)\nusing this:\n  app i (class_add P (C, cdec)) mxs T pc mpc xt (\\<tau>s ! pc)\n  \\<forall>(pc', \\<tau>')\n           \\<in>set (eff i (class_add P (C, cdec)) pc xt (\\<tau>s ! pc)).\n     class_add P (C, cdec) \\<turnstile> \\<tau>' \\<le>' \\<tau>s ! pc'\n  P,T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s", "by(clarsimp simp: wt_instr_def)"], ["proof (state)\nthis:\n  class_add P (C, cdec),T,mxs,mpc,xt \\<turnstile> i,pc :: \\<tau>s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_wt_method:\nassumes wtm: \"wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)\"\n and wf: \"wf_prog wf_md P\" and nclass: \"\\<not> is_class P C\"\nshows \"wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "let ?P = \"class_add P (C, cdec)\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "let ?\\<tau>s = \"\\<Phi> C\\<^sub>0 M\\<^sub>0\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "from wtm class_add_check_types"], ["proof (chain)\npicking this:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  check_types ?P ?mxs ?mxl ?\\<tau>s \\<Longrightarrow>\n  check_types (class_add ?P (?C, ?cdec)) ?mxs ?mxl ?\\<tau>s", "have \"check_types ?P mxs ((case b of Static \\<Rightarrow> 0 | NonStatic \\<Rightarrow> 1)+size Ts+mxl\\<^sub>0) (map OK ?\\<tau>s)\""], ["proof (prove)\nusing this:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  check_types ?P ?mxs ?mxl ?\\<tau>s \\<Longrightarrow>\n  check_types (class_add ?P (?C, ?cdec)) ?mxs ?mxl ?\\<tau>s\n\ngoal (1 subgoal):\n 1. check_types (class_add P (C, cdec)) mxs\n     ((case b of Static \\<Rightarrow> 0 | NonStatic \\<Rightarrow> 1) +\n      length Ts +\n      mxl\\<^sub>0)\n     (map OK (\\<Phi> C\\<^sub>0 M\\<^sub>0))", "by(simp add: wt_method_def)"], ["proof (state)\nthis:\n  check_types (class_add P (C, cdec)) mxs\n   ((case b of Static \\<Rightarrow> 0 | NonStatic \\<Rightarrow> 1) +\n    length Ts +\n    mxl\\<^sub>0)\n   (map OK (\\<Phi> C\\<^sub>0 M\\<^sub>0))\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  check_types (class_add P (C, cdec)) mxs\n   ((case b of Static \\<Rightarrow> 0 | NonStatic \\<Rightarrow> 1) +\n    length Ts +\n    mxl\\<^sub>0)\n   (map OK (\\<Phi> C\\<^sub>0 M\\<^sub>0))\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "from wtm class_add_wt_start nclass"], ["proof (chain)\npicking this:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  \\<lbrakk>wt_start ?P ?C\\<^sub>0 ?b ?Ts ?mxl ?\\<tau>s;\n   \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> wt_start (class_add ?P (?C, ?cdec)) ?C\\<^sub>0 ?b ?Ts\n                     ?mxl ?\\<tau>s\n  \\<not> is_class P C", "have \"wt_start ?P C\\<^sub>0 b Ts mxl\\<^sub>0 ?\\<tau>s\""], ["proof (prove)\nusing this:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  \\<lbrakk>wt_start ?P ?C\\<^sub>0 ?b ?Ts ?mxl ?\\<tau>s;\n   \\<not> is_class ?P ?C\\<rbrakk>\n  \\<Longrightarrow> wt_start (class_add ?P (?C, ?cdec)) ?C\\<^sub>0 ?b ?Ts\n                     ?mxl ?\\<tau>s\n  \\<not> is_class P C\n\ngoal (1 subgoal):\n 1. wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\\<^sub>0\n     (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "by(simp add: wt_method_def)"], ["proof (state)\nthis:\n  wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\\<^sub>0\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\\<^sub>0\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "from wtm class_add_wt_instr[OF _ wf nclass]"], ["proof (chain)\npicking this:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  P,?T,?mxs,?mpc,?xt \\<turnstile> ?i,?pc :: ?\\<tau>s \\<Longrightarrow>\n  class_add P (C, ?cdec),?T,?mxs,?mpc,?xt \\<turnstile> ?i,?pc :: ?\\<tau>s", "have \"\\<forall>pc < size is. ?P,T\\<^sub>r,mxs,size is,xt \\<turnstile> is!pc,pc :: ?\\<tau>s\""], ["proof (prove)\nusing this:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  P,?T,?mxs,?mpc,?xt \\<turnstile> ?i,?pc :: ?\\<tau>s \\<Longrightarrow>\n  class_add P (C, ?cdec),?T,?mxs,?mpc,?xt \\<turnstile> ?i,?pc :: ?\\<tau>s\n\ngoal (1 subgoal):\n 1. \\<forall>pc<length is.\n       class_add P\n        (C, cdec),T\\<^sub>r,mxs,length\n                                 is,xt \\<turnstile> is !\n              pc,pc :: \\<Phi> C\\<^sub>0 M\\<^sub>0", "by(clarsimp simp: wt_method_def)"], ["proof (state)\nthis:\n  \\<forall>pc<length is.\n     class_add P\n      (C, cdec),T\\<^sub>r,mxs,length\n                               is,xt \\<turnstile> is !\n            pc,pc :: \\<Phi> C\\<^sub>0 M\\<^sub>0\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>pc<length is.\n     class_add P\n      (C, cdec),T\\<^sub>r,mxs,length\n                               is,xt \\<turnstile> is !\n            pc,pc :: \\<Phi> C\\<^sub>0 M\\<^sub>0\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "note wtm"], ["proof (state)\nthis:\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "ultimately"], ["proof (chain)\npicking this:\n  check_types (class_add P (C, cdec)) mxs\n   ((case b of Static \\<Rightarrow> 0 | NonStatic \\<Rightarrow> 1) +\n    length Ts +\n    mxl\\<^sub>0)\n   (map OK (\\<Phi> C\\<^sub>0 M\\<^sub>0))\n  wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\\<^sub>0\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  \\<forall>pc<length is.\n     class_add P\n      (C, cdec),T\\<^sub>r,mxs,length\n                               is,xt \\<turnstile> is !\n            pc,pc :: \\<Phi> C\\<^sub>0 M\\<^sub>0\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "show ?thesis"], ["proof (prove)\nusing this:\n  check_types (class_add P (C, cdec)) mxs\n   ((case b of Static \\<Rightarrow> 0 | NonStatic \\<Rightarrow> 1) +\n    length Ts +\n    mxl\\<^sub>0)\n   (map OK (\\<Phi> C\\<^sub>0 M\\<^sub>0))\n  wt_start (class_add P (C, cdec)) C\\<^sub>0 b Ts mxl\\<^sub>0\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n  \\<forall>pc<length is.\n     class_add P\n      (C, cdec),T\\<^sub>r,mxs,length\n                               is,xt \\<turnstile> is !\n            pc,pc :: \\<Phi> C\\<^sub>0 M\\<^sub>0\n  wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n   (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)", "by(clarsimp simp: wt_method_def)"], ["proof (state)\nthis:\n  wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0\n   is xt (\\<Phi> C\\<^sub>0 M\\<^sub>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_wt_method':\n \"\\<lbrakk> (\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M)) P C\\<^sub>0 md;\n    wf_prog wf_md P; \\<not> is_class P C \\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n            (class_add P (C, cdec)) C\\<^sub>0 md\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case md of\n             (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n               wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                (\\<Phi> C\\<^sub>0 M);\n     wf_prog wf_md P; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> case md of\n                      (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                       xt) \\<Rightarrow>\n                        wt_method (class_add P (C, cdec)) C\\<^sub>0 b Ts\n                         T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                         (\\<Phi> C\\<^sub>0 M)", "by(clarsimp simp: class_add_wt_method)"], ["", "subsection \\<open> @{text \"distinct_fst\"} \\<close>"], ["", "lemma class_add_distinct_fst:\n\"\\<lbrakk> distinct_fst P; \\<not> is_class P C \\<rbrakk>\n  \\<Longrightarrow> distinct_fst (class_add P (C, cdec))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct_fst P; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> distinct_fst (class_add P (C, cdec))", "by(clarsimp simp: distinct_fst_def is_class_def class_def)"], ["", "subsection \"Conformance\""], ["", "lemma class_add_conf:\n \"\\<lbrakk> P,h \\<turnstile> v :\\<le> T; \\<not> is_class P C \\<rbrakk>\n \\<Longrightarrow> class_add P (C, cdec),h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> v :\\<le> T; \\<not> is_class P C\\<rbrakk>\n    \\<Longrightarrow> class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "by(clarsimp simp: conf_def class_add_subtype)"], ["", "lemma class_add_oconf:\nfixes obj::obj\nassumes oc: \"P,h \\<turnstile> obj \\<surd>\" and ns: \"\\<not> is_class P C\"\n  and ncp: \"\\<And>D'. P \\<turnstile> fst(obj) \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"(class_add P (C, cdec)),h \\<turnstile> obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile> obj \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile> obj \\<surd>", "obtain C\\<^sub>0 fs where [simp]: \"obj=(C\\<^sub>0,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C\\<^sub>0 fs.\n        obj = (C\\<^sub>0, fs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases obj)"], ["proof (state)\nthis:\n  obj = (C\\<^sub>0, fs)\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile> obj \\<surd>", "from oc"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> obj \\<surd>", "have\n    oc': \"\\<And>F D T. P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow> (\\<exists>v. fs (F, D) = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> T)\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> obj \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>F D T.\n       P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow>\n       \\<exists>v.\n          fs (F, D) = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> T", "by(simp add: oconf_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C\\<^sub>0 has ?F,NonStatic:?T in ?D \\<Longrightarrow>\n  \\<exists>v.\n     fs (?F, ?D) = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile> obj \\<surd>", "have \"\\<And>F D T. class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\n                       \\<Longrightarrow> \\<exists>v. fs(F,D) = Some v \\<and> class_add P (C, cdec),h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F D T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow>\n       \\<exists>v.\n          fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F D T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow>\n       \\<exists>v.\n          fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "fix F D T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F D T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow>\n       \\<exists>v.\n          fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "assume \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\""], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\n\ngoal (1 subgoal):\n 1. \\<And>F D T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow>\n       \\<exists>v.\n          fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "with class_add_has_field_rev[OF _ ncp]"], ["proof (chain)\npicking this:\n  \\<lbrakk>class_add ?P\n            (C, ?cdec) \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D;\n   \\<And>D'.\n      ?P \\<turnstile> ?C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      P \\<turnstile> fst obj \\<preceq>\\<^sup>* D'\\<rbrakk>\n  \\<Longrightarrow> ?P \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D", "have meth: \"P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\""], ["proof (prove)\nusing this:\n  \\<lbrakk>class_add ?P\n            (C, ?cdec) \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D;\n   \\<And>D'.\n      ?P \\<turnstile> ?C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      P \\<turnstile> fst obj \\<preceq>\\<^sup>* D'\\<rbrakk>\n  \\<Longrightarrow> ?P \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\n\ngoal (1 subgoal):\n 1. \\<And>F D T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D \\<Longrightarrow>\n       \\<exists>v.\n          fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D", "show \"\\<exists>v. fs(F,D) = Some v \\<and> class_add P (C, cdec),h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n       class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "using oc'[OF meth] class_add_conf[OF _ ns]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 has F,NonStatic:T in D\n  \\<exists>v.\n     fs (F, D) = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> T\n  P,?h \\<turnstile> ?v :\\<le> ?T \\<Longrightarrow>\n  class_add P (C, ?cdec),?h \\<turnstile> ?v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n       class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "by(fastforce simp: oconf_def)"], ["proof (state)\nthis:\n  \\<exists>v.\n     fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 has ?F,NonStatic:?T in ?D \\<Longrightarrow>\n  \\<exists>v.\n     fs (?F, ?D) = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile> obj \\<surd>", "then"], ["proof (chain)\npicking this:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 has ?F,NonStatic:?T in ?D \\<Longrightarrow>\n  \\<exists>v.\n     fs (?F, ?D) = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> ?T", "show ?thesis"], ["proof (prove)\nusing this:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 has ?F,NonStatic:?T in ?D \\<Longrightarrow>\n  \\<exists>v.\n     fs (?F, ?D) = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile> obj \\<surd>", "by(simp add: oconf_def)"], ["proof (state)\nthis:\n  class_add P (C, cdec),h \\<turnstile> obj \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_soconf:\nassumes soc: \"P,h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>\" and ns: \"\\<not> is_class P C\"\n  and ncp: \"\\<And>D'. P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"(class_add P (C, cdec)),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>", "from soc"], ["proof (chain)\npicking this:\n  P,h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>", "have\n    oc': \"\\<And>F T. P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow> (\\<exists>v. sfs F = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> T)\""], ["proof (prove)\nusing this:\n  P,h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>F T.\n       P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow>\n       \\<exists>v.\n          sfs F = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> T", "by(simp add: soconf_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C\\<^sub>0 has ?F,Static:?T in C\\<^sub>0 \\<Longrightarrow>\n  \\<exists>v.\n     sfs ?F = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>", "have \"\\<And>F T. class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\n                       \\<Longrightarrow> \\<exists>v. sfs F = Some v \\<and> class_add P (C, cdec),h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow>\n       \\<exists>v.\n          sfs F = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow>\n       \\<exists>v.\n          sfs F = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "fix F T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow>\n       \\<exists>v.\n          sfs F = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "assume \"class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\""], ["proof (state)\nthis:\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>F T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow>\n       \\<exists>v.\n          sfs F = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "with class_add_has_field_rev[OF _ ncp]"], ["proof (chain)\npicking this:\n  \\<lbrakk>class_add ?P\n            (C, ?cdec) \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D;\n   \\<And>D'.\n      ?P \\<turnstile> ?C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D'\\<rbrakk>\n  \\<Longrightarrow> ?P \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0", "have meth: \"P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>class_add ?P\n            (C, ?cdec) \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D;\n   \\<And>D'.\n      ?P \\<turnstile> ?C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<Longrightarrow>\n      P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D'\\<rbrakk>\n  \\<Longrightarrow> ?P \\<turnstile> ?C\\<^sub>0 has ?F,?b:?T in ?D\n  class_add P (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>F T.\n       class_add P\n        (C, cdec) \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0 \\<Longrightarrow>\n       \\<exists>v.\n          sfs F = \\<lfloor>v\\<rfloor> \\<and>\n          class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0", "show \"\\<exists>v. sfs F = Some v \\<and> class_add P (C, cdec),h \\<turnstile> v :\\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       sfs F = \\<lfloor>v\\<rfloor> \\<and>\n       class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "using oc'[OF meth] class_add_conf[OF _ ns]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C\\<^sub>0 has F,Static:T in C\\<^sub>0\n  \\<exists>v. sfs F = \\<lfloor>v\\<rfloor> \\<and> P,h \\<turnstile> v :\\<le> T\n  P,?h \\<turnstile> ?v :\\<le> ?T \\<Longrightarrow>\n  class_add P (C, ?cdec),?h \\<turnstile> ?v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       sfs F = \\<lfloor>v\\<rfloor> \\<and>\n       class_add P (C, cdec),h \\<turnstile> v :\\<le> T", "by(fastforce simp: soconf_def)"], ["proof (state)\nthis:\n  \\<exists>v.\n     sfs F = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 has ?F,Static:?T in C\\<^sub>0 \\<Longrightarrow>\n  \\<exists>v.\n     sfs ?F = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>", "then"], ["proof (chain)\npicking this:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 has ?F,Static:?T in C\\<^sub>0 \\<Longrightarrow>\n  \\<exists>v.\n     sfs ?F = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> ?T", "show ?thesis"], ["proof (prove)\nusing this:\n  class_add P\n   (C, cdec) \\<turnstile> C\\<^sub>0 has ?F,Static:?T in C\\<^sub>0 \\<Longrightarrow>\n  \\<exists>v.\n     sfs ?F = \\<lfloor>v\\<rfloor> \\<and>\n     class_add P (C, cdec),h \\<turnstile> v :\\<le> ?T\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>", "by(simp add: soconf_def)"], ["proof (state)\nthis:\n  class_add P (C, cdec),h,C\\<^sub>0 \\<turnstile>\\<^sub>s sfs \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_add_hconf:\nassumes \"P \\<turnstile> h \\<surd>\" and \"\\<not> is_class P C\"\n and \"\\<And>a obj D'. h a = Some obj \\<Longrightarrow> P \\<turnstile> fst(obj) \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"class_add P (C, cdec) \\<turnstile> h \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> h \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  \\<not> is_class P C\n  \\<lbrakk>h ?a = \\<lfloor>?obj\\<rfloor>;\n   P \\<turnstile> fst ?obj \\<preceq>\\<^sup>* ?D'\\<rbrakk>\n  \\<Longrightarrow> ?D' \\<noteq> C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> h \\<surd>", "by(auto simp: hconf_def intro!: class_add_oconf)"], ["", "lemma class_add_hconf_wf:\nassumes wf: \"wf_prog wf_md P\" and \"P \\<turnstile> h \\<surd>\" and \"\\<not> is_class P C\"\n and \"\\<And>a obj. h a = Some obj \\<Longrightarrow> fst(obj) \\<noteq> C\"\nshows \"class_add P (C, cdec) \\<turnstile> h \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> h \\<surd>", "using wf_subcls_nCls[OF wf] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_class P ?C; P \\<turnstile> ?D \\<preceq>\\<^sup>* ?D';\n   ?D \\<noteq> ?C\\<rbrakk>\n  \\<Longrightarrow> ?D' \\<noteq> ?C\n  wf_prog wf_md P\n  P \\<turnstile> h \\<surd>\n  \\<not> is_class P C\n  h ?a = \\<lfloor>?obj\\<rfloor> \\<Longrightarrow> fst ?obj \\<noteq> C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec) \\<turnstile> h \\<surd>", "by(fastforce simp: hconf_def intro!: class_add_oconf)"], ["", "lemma class_add_shconf:\nassumes \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and ns: \"\\<not> is_class P C\"\n and \"\\<And>C sobj D'. sh C = Some sobj \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<Longrightarrow> D' \\<noteq> C\"\nshows \"class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<not> is_class P C\n  \\<lbrakk>sh ?C = \\<lfloor>?sobj\\<rfloor>;\n   P \\<turnstile> ?C \\<preceq>\\<^sup>* ?D'\\<rbrakk>\n  \\<Longrightarrow> ?D' \\<noteq> ?C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>", "by(fastforce simp: shconf_def)"], ["", "lemma class_add_shconf_wf:\nassumes wf: \"wf_prog wf_md P\" and \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and \"\\<not> is_class P C\"\n and \"\\<And>C sobj. sh C = Some sobj \\<Longrightarrow> C \\<noteq> C\"\nshows \"class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>", "using wf_subcls_nCls[OF wf] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_class P ?C; P \\<turnstile> ?D \\<preceq>\\<^sup>* ?D';\n   ?D \\<noteq> ?C\\<rbrakk>\n  \\<Longrightarrow> ?D' \\<noteq> ?C\n  wf_prog wf_md P\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<not> is_class P C\n  sh ?C = \\<lfloor>?sobj\\<rfloor> \\<Longrightarrow> ?C \\<noteq> ?C\n\ngoal (1 subgoal):\n 1. class_add P (C, cdec),h \\<turnstile>\\<^sub>s sh \\<surd>", "by(fastforce simp: shconf_def)"], ["", "end"]]}