{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/Compiler/Compiler2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma bop_expr_length_aux [simp]:\n \"length (case bop of Eq \\<Rightarrow> [CmpEq] | Add \\<Rightarrow> [IAdd]) = Suc 0\"", "lemma max_stack1': \"\\<not>sub_RI e \\<Longrightarrow> 1 \\<le> max_stack e\"", "lemma compE\\<^sub>2_not_Nil': \"\\<not>sub_RI e \\<Longrightarrow> compE\\<^sub>2 e \\<noteq> []\"", "lemma compE\\<^sub>2_nRet: \"\\<And>i. i \\<in> set (compE\\<^sub>2 e\\<^sub>1) \\<Longrightarrow> i \\<noteq> Return\"\n and \"\\<And>i. i \\<in> set (compEs\\<^sub>2 es\\<^sub>1) \\<Longrightarrow> i \\<noteq> Return\"", "lemma compMb\\<^sub>2 [simp]:\n  \"compMb\\<^sub>2 b e = (max_stack e, max_vars e,\n                   compE\\<^sub>2 e @ [Return], compxE\\<^sub>2 e 0 0)\""], "translations": [["", "lemma bop_expr_length_aux [simp]:\n \"length (case bop of Eq \\<Rightarrow> [CmpEq] | Add \\<Rightarrow> [IAdd]) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (case bop of Eq \\<Rightarrow> [CmpEq] | Add \\<Rightarrow> [IAdd]) =\n    Suc 0", "by(cases bop, simp+)"], ["", "primrec compE\\<^sub>2 :: \"expr\\<^sub>1 \\<Rightarrow> instr list\"\n  and compEs\\<^sub>2 :: \"expr\\<^sub>1 list \\<Rightarrow> instr list\" where\n  \"compE\\<^sub>2 (new C) = [New C]\"\n| \"compE\\<^sub>2 (Cast C e) = compE\\<^sub>2 e @ [Checkcast C]\"\n| \"compE\\<^sub>2 (Val v) = [Push v]\"\n| \"compE\\<^sub>2 (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) = compE\\<^sub>2 e\\<^sub>1 @ compE\\<^sub>2 e\\<^sub>2 @ \n  (case bop of Eq \\<Rightarrow> [CmpEq]\n            | Add \\<Rightarrow> [IAdd])\"\n| \"compE\\<^sub>2 (Var i) = [Load i]\"\n| \"compE\\<^sub>2 (i:=e) = compE\\<^sub>2 e @ [Store i, Push Unit]\"\n| \"compE\\<^sub>2 (e\\<bullet>F{D}) = compE\\<^sub>2 e @ [Getfield F D]\"\n| \"compE\\<^sub>2 (C\\<bullet>\\<^sub>sF{D}) = [Getstatic C F D]\"\n| \"compE\\<^sub>2 (e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2) =\n       compE\\<^sub>2 e\\<^sub>1 @ compE\\<^sub>2 e\\<^sub>2 @ [Putfield F D, Push Unit]\"\n| \"compE\\<^sub>2 (C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2) =\n       compE\\<^sub>2 e\\<^sub>2 @ [Putstatic C F D, Push Unit]\"\n| \"compE\\<^sub>2 (e\\<bullet>M(es)) = compE\\<^sub>2 e @ compEs\\<^sub>2 es @ [Invoke M (size es)]\"\n| \"compE\\<^sub>2 (C\\<bullet>\\<^sub>sM(es)) = compEs\\<^sub>2 es @ [Invokestatic C M (size es)]\"\n| \"compE\\<^sub>2 ({i:T; e}) = compE\\<^sub>2 e\"\n| \"compE\\<^sub>2 (e\\<^sub>1;;e\\<^sub>2) = compE\\<^sub>2 e\\<^sub>1 @ [Pop] @ compE\\<^sub>2 e\\<^sub>2\"\n| \"compE\\<^sub>2 (if (e) e\\<^sub>1 else e\\<^sub>2) =\n        (let cnd   = compE\\<^sub>2 e;\n             thn   = compE\\<^sub>2 e\\<^sub>1;\n             els   = compE\\<^sub>2 e\\<^sub>2;\n             test  = IfFalse (int(size thn + 2)); \n             thnex = Goto (int(size els + 1))\n         in cnd @ [test] @ thn @ [thnex] @ els)\"\n| \"compE\\<^sub>2 (while (e) c) =\n        (let cnd   = compE\\<^sub>2 e;\n             bdy   = compE\\<^sub>2 c;\n             test  = IfFalse (int(size bdy + 3)); \n             loop  = Goto (-int(size bdy + size cnd + 2))\n         in cnd @ [test] @ bdy @ [Pop] @ [loop] @ [Push Unit])\"\n| \"compE\\<^sub>2 (throw e) = compE\\<^sub>2 e @ [instr.Throw]\"\n| \"compE\\<^sub>2 (try e\\<^sub>1 catch(C i) e\\<^sub>2) =\n   (let catch = compE\\<^sub>2 e\\<^sub>2\n    in compE\\<^sub>2 e\\<^sub>1 @ [Goto (int(size catch)+2), Store i] @ catch)\"\n| \"compE\\<^sub>2 (INIT C (Cs,b) \\<leftarrow> e) = []\"\n| \"compE\\<^sub>2 (RI(C,e);Cs \\<leftarrow> e') = []\"\n\n| \"compEs\\<^sub>2 []     = []\"\n| \"compEs\\<^sub>2 (e#es) = compE\\<^sub>2 e @ compEs\\<^sub>2 es\""], ["", "text\\<open> Compilation of exception table. Is given start address of code\nto compute absolute addresses necessary in exception table. \\<close>"], ["", "primrec compxE\\<^sub>2  :: \"expr\\<^sub>1      \\<Rightarrow> pc \\<Rightarrow> nat \\<Rightarrow> ex_table\"\n  and compxEs\\<^sub>2 :: \"expr\\<^sub>1 list \\<Rightarrow> pc \\<Rightarrow> nat \\<Rightarrow> ex_table\" where\n  \"compxE\\<^sub>2 (new C) pc d = []\"\n| \"compxE\\<^sub>2 (Cast C e) pc d = compxE\\<^sub>2 e pc d\"\n| \"compxE\\<^sub>2 (Val v) pc d = []\"\n| \"compxE\\<^sub>2 (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) pc d =\n   compxE\\<^sub>2 e\\<^sub>1 pc d @ compxE\\<^sub>2 e\\<^sub>2 (pc + size(compE\\<^sub>2 e\\<^sub>1)) (d+1)\"\n| \"compxE\\<^sub>2 (Var i) pc d = []\"\n| \"compxE\\<^sub>2 (i:=e) pc d = compxE\\<^sub>2 e pc d\"\n| \"compxE\\<^sub>2 (e\\<bullet>F{D}) pc d = compxE\\<^sub>2 e pc d\"\n| \"compxE\\<^sub>2 (C\\<bullet>\\<^sub>sF{D}) pc d = []\"\n| \"compxE\\<^sub>2 (e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2) pc d =\n   compxE\\<^sub>2 e\\<^sub>1 pc d @ compxE\\<^sub>2 e\\<^sub>2 (pc + size(compE\\<^sub>2 e\\<^sub>1)) (d+1)\"\n| \"compxE\\<^sub>2 (C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2) pc d = compxE\\<^sub>2 e\\<^sub>2 pc d\"\n| \"compxE\\<^sub>2 (e\\<bullet>M(es)) pc d =\n   compxE\\<^sub>2 e pc d @ compxEs\\<^sub>2 es (pc + size(compE\\<^sub>2 e)) (d+1)\"\n| \"compxE\\<^sub>2 (C\\<bullet>\\<^sub>sM(es)) pc d = compxEs\\<^sub>2 es pc d\"\n| \"compxE\\<^sub>2 ({i:T; e}) pc d = compxE\\<^sub>2 e pc d\"\n| \"compxE\\<^sub>2 (e\\<^sub>1;;e\\<^sub>2) pc d =\n   compxE\\<^sub>2 e\\<^sub>1 pc d @ compxE\\<^sub>2 e\\<^sub>2 (pc+size(compE\\<^sub>2 e\\<^sub>1)+1) d\"\n| \"compxE\\<^sub>2 (if (e) e\\<^sub>1 else e\\<^sub>2) pc d =\n        (let pc\\<^sub>1   = pc + size(compE\\<^sub>2 e) + 1;\n             pc\\<^sub>2   = pc\\<^sub>1 + size(compE\\<^sub>2 e\\<^sub>1) + 1\n         in compxE\\<^sub>2 e pc d @ compxE\\<^sub>2 e\\<^sub>1 pc\\<^sub>1 d @ compxE\\<^sub>2 e\\<^sub>2 pc\\<^sub>2 d)\"\n| \"compxE\\<^sub>2 (while (b) e) pc d =\n   compxE\\<^sub>2 b pc d @ compxE\\<^sub>2 e (pc+size(compE\\<^sub>2 b)+1) d\"\n| \"compxE\\<^sub>2 (throw e) pc d = compxE\\<^sub>2 e pc d\"\n| \"compxE\\<^sub>2 (try e\\<^sub>1 catch(C i) e\\<^sub>2) pc d =\n   (let pc\\<^sub>1 = pc + size(compE\\<^sub>2 e\\<^sub>1)\n    in compxE\\<^sub>2 e\\<^sub>1 pc d @ compxE\\<^sub>2 e\\<^sub>2 (pc\\<^sub>1+2) d @ [(pc,pc\\<^sub>1,C,pc\\<^sub>1+1,d)])\"\n| \"compxE\\<^sub>2 (INIT C (Cs, b) \\<leftarrow> e) pc d = []\"\n| \"compxE\\<^sub>2 (RI(C, e);Cs \\<leftarrow> e') pc d = []\"\n\n| \"compxEs\\<^sub>2 [] pc d    = []\"\n| \"compxEs\\<^sub>2 (e#es) pc d = compxE\\<^sub>2 e pc d @ compxEs\\<^sub>2 es (pc+size(compE\\<^sub>2 e)) (d+1)\""], ["", "primrec max_stack :: \"expr\\<^sub>1 \\<Rightarrow> nat\"\n  and max_stacks :: \"expr\\<^sub>1 list \\<Rightarrow> nat\" where\n  \"max_stack (new C) = 1\"\n| \"max_stack (Cast C e) = max_stack e\"\n| \"max_stack (Val v) = 1\"\n| \"max_stack (e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2) = max (max_stack e\\<^sub>1) (max_stack e\\<^sub>2) + 1\"\n| \"max_stack (Var i) = 1\"\n| \"max_stack (i:=e) = max_stack e\"\n| \"max_stack (e\\<bullet>F{D}) = max_stack e\"\n| \"max_stack (C\\<bullet>\\<^sub>sF{D}) = 1\"\n| \"max_stack (e\\<^sub>1\\<bullet>F{D} := e\\<^sub>2) = max (max_stack e\\<^sub>1) (max_stack e\\<^sub>2) + 1\"\n| \"max_stack (C\\<bullet>\\<^sub>sF{D} := e\\<^sub>2) = max_stack e\\<^sub>2\"\n| \"max_stack (e\\<bullet>M(es)) = max (max_stack e) (max_stacks es) + 1\"\n| \"max_stack (C\\<bullet>\\<^sub>sM(es)) = max_stacks es + 1\"\n| \"max_stack ({i:T; e}) = max_stack e\"\n| \"max_stack (e\\<^sub>1;;e\\<^sub>2) = max (max_stack e\\<^sub>1) (max_stack e\\<^sub>2)\"\n| \"max_stack (if (e) e\\<^sub>1 else e\\<^sub>2) =\n  max (max_stack e) (max (max_stack e\\<^sub>1) (max_stack e\\<^sub>2))\"\n| \"max_stack (while (e) c) = max (max_stack e) (max_stack c)\"\n| \"max_stack (throw e) = max_stack e\"\n| \"max_stack (try e\\<^sub>1 catch(C i) e\\<^sub>2) = max (max_stack e\\<^sub>1) (max_stack e\\<^sub>2)\"\n \n| \"max_stacks [] = 0\"\n| \"max_stacks (e#es) = max (max_stack e) (1 + max_stacks es)\""], ["", "lemma max_stack1': \"\\<not>sub_RI e \\<Longrightarrow> 1 \\<le> max_stack e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sub_RI e \\<Longrightarrow> 1 \\<le> max_stack e", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sub_RI e \\<Longrightarrow> 1 \\<le> max_stack e", "by(induct e) (simp_all add:max_def)"], ["", "(*>*)"], ["", "lemma compE\\<^sub>2_not_Nil': \"\\<not>sub_RI e \\<Longrightarrow> compE\\<^sub>2 e \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sub_RI e \\<Longrightarrow> compE\\<^sub>2 e \\<noteq> []", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sub_RI e \\<Longrightarrow> compE\\<^sub>2 e \\<noteq> []", "by(induct e) auto"], ["", "(*>*)"], ["", "lemma compE\\<^sub>2_nRet: \"\\<And>i. i \\<in> set (compE\\<^sub>2 e\\<^sub>1) \\<Longrightarrow> i \\<noteq> Return\"\n and \"\\<And>i. i \\<in> set (compEs\\<^sub>2 es\\<^sub>1) \\<Longrightarrow> i \\<noteq> Return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> set (compE\\<^sub>2 e\\<^sub>1) \\<Longrightarrow>\n        i \\<noteq> Return) &&&\n    (\\<And>i.\n        i \\<in> set (compEs\\<^sub>2 es\\<^sub>1) \\<Longrightarrow>\n        i \\<noteq> Return)", "by(induct rule: compE\\<^sub>2.induct compEs\\<^sub>2.induct, auto simp: nth_append split: bop.splits)"], ["", "definition compMb\\<^sub>2 :: \"staticb \\<Rightarrow> expr\\<^sub>1 \\<Rightarrow> jvm_method\"\nwhere\n  \"compMb\\<^sub>2  \\<equiv>  \\<lambda>b body.\n  let ins = compE\\<^sub>2 body @ [Return];\n      xt = compxE\\<^sub>2 body 0 0\n  in (max_stack body, max_vars body, ins, xt)\""], ["", "definition compP\\<^sub>2 :: \"J\\<^sub>1_prog \\<Rightarrow> jvm_prog\"\nwhere\n  \"compP\\<^sub>2  \\<equiv>  compP compMb\\<^sub>2\""], ["", "(*<*)"], ["", "declare compP\\<^sub>2_def [simp]"], ["", "(*>*)"], ["", "lemma compMb\\<^sub>2 [simp]:\n  \"compMb\\<^sub>2 b e = (max_stack e, max_vars e,\n                   compE\\<^sub>2 e @ [Return], compxE\\<^sub>2 e 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compMb\\<^sub>2 b e =\n    (max_stack e, max_vars e, compE\\<^sub>2 e @ [Return],\n     compxE\\<^sub>2 e 0 0)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compMb\\<^sub>2 b e =\n    (max_stack e, max_vars e, compE\\<^sub>2 e @ [Return],\n     compxE\\<^sub>2 e 0 0)", "by (simp add: compMb\\<^sub>2_def)"], ["", "(*>*)"], ["", "end"]]}