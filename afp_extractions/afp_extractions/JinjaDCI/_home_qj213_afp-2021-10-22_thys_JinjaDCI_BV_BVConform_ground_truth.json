{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/BV/BVConform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma Called_context_Called_set:\n \"Called_context P D i \\<Longrightarrow> i \\<in> Called_set\"", "lemma conf_f_def2:\n  \"conf_f P h sh (ST,LT) is (stk,loc,C,M,pc,ics) \\<equiv>\n  P,h \\<turnstile> stk [:\\<le>] ST \\<and> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < size is \\<and> P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\"", "lemma confT_Err [iff]: \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> Err\"", "lemma confT_OK [iff]:  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> OK T = (P,h \\<turnstile> x :\\<le> T)\"", "lemma confT_cases:\n  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> X = (X = Err \\<or> (\\<exists>T. X = OK T \\<and> P,h \\<turnstile> x :\\<le> T))\"", "lemma confT_hext [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> x :\\<le>\\<^sub>\\<top> T\"", "lemma confT_widen [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; P \\<turnstile> T \\<le>\\<^sub>\\<top> T' \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T'\"", "lemmas confTs_Cons1 [iff] = list_all2_Cons1 [of \"confT P h\"] for P h", "lemma confTs_confT_sup:\n  \"\\<lbrakk> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < size LT; LT!n = OK T; P \\<turnstile> T \\<le> T' \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> (loc!n) :\\<le> T'\"", "lemma confTs_hext [intro?]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\"", "lemma confTs_widen [intro?, trans]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<Longrightarrow> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\"", "lemma confTs_map [iff]:\n  \"\\<And>vs. (P,h \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] map OK Ts) = (P,h \\<turnstile> vs [:\\<le>] Ts)\"", "lemma reg_widen_Err [iff]:\n  \"\\<And>LT. (P \\<turnstile> replicate n Err [\\<le>\\<^sub>\\<top>] LT) = (LT = replicate n Err)\"", "lemma confTs_Err [iff]:\n  \"P,h \\<turnstile> replicate n v [:\\<le>\\<^sub>\\<top>] replicate n Err\"", "lemma valid_ics_shupd:\nassumes \"P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\" and \"distinct (C'#ics_classes ics)\"\nshows \"P,h,sh(C' \\<mapsto> (sfs, i')) \\<turnstile>\\<^sub>i (C, M, pc, ics)\"", "lemma conf_f_Throwing:\nassumes \"conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Called Cs)\"\n  and \"is_class P C'\" and \"h xcp = Some obj\" and \"sh C' = Some(sfs,Processing)\"\nshows \"conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Throwing (C' # Cs) xcp)\"", "lemma conf_f_shupd:\nassumes \"conf_f P h sh (ST,LT) ins f\"\n and \"i = Processing\n       \\<or> (distinct (C#ics_classes (ics_of f)) \\<and> (curr_method f = clinit \\<longrightarrow> C \\<noteq> curr_class f))\"\nshows \"conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST,LT) ins f\"", "lemma conf_f_shupd':\nassumes \"conf_f P h sh (ST,LT) ins f\"\n and \"sh C = Some(sfs,i)\"\nshows \"conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST,LT) ins f\"", "lemmas [simp del] = fun_upd_apply", "lemma conf_fs_hext:\n  \"\\<And>C M n T\\<^sub>r. \n  \\<lbrakk> conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r frs\"", "lemma conf_fs_shupd:\nassumes \"conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\"\n and dist: \"distinct (C#clinit_classes frs)\"\nshows \"conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C\\<^sub>0 M n T frs\"", "lemma conf_fs_shupd':\nassumes \"conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\"\n and shC: \"sh C = Some(sfs,i)\"\nshows \"conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C\\<^sub>0 M n T frs\"", "lemma conf_clinit_Cons:\nassumes \"conf_clinit P sh (f#frs)\"\nshows \"conf_clinit P sh frs\"", "lemma conf_clinit_Cons_Cons:\n \"conf_clinit P sh (f'#f#frs) \\<Longrightarrow> conf_clinit P sh (f'#frs)\"", "lemma conf_clinit_diff:\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\"\nshows \"conf_clinit P sh ((stk',loc',C,M,pc',ics)#frs)\"", "lemma conf_clinit_diff':\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\"\nshows \"conf_clinit P sh ((stk',loc',C,M,pc',No_ics)#frs)\"", "lemma conf_clinit_Called_Throwing:\n \"conf_clinit P sh ((stk', loc', C', clinit, pc', ics') # (stk, loc, C, M, pc, Called Cs) # fs)\n  \\<Longrightarrow> conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C' # Cs) xcp) # fs)\"", "lemma conf_clinit_Throwing:\n \"conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C'#Cs) xcp) # fs)\n  \\<Longrightarrow> conf_clinit P sh ((stk, loc, C, M, pc, Throwing Cs xcp) # fs)\"", "lemma conf_clinit_Called:\n \"\\<lbrakk> conf_clinit P sh ((stk, loc, C, M, pc, Called (C'#Cs)) # frs);\n    P \\<turnstile> C' sees clinit,Static: [] \\<rightarrow> Void=(mxs',mxl',ins',xt') in C' \\<rbrakk>\n  \\<Longrightarrow> conf_clinit P sh (create_init_frame P C' # (stk, loc, C, M, pc, Called Cs) # frs)\"", "lemma conf_clinit_Cons_nclinit:\nassumes \"conf_clinit P sh frs\" and nclinit: \"M \\<noteq> clinit\"\nshows \"conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\"", "lemma conf_clinit_Invoke:\nassumes \"conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\" and \"M' \\<noteq> clinit\"\nshows \"conf_clinit P sh ((stk', loc', C', M', pc', No_ics) # (stk, loc, C, M, pc, No_ics) # frs)\"", "lemma conf_clinit_nProc_dist:\nassumes \"conf_clinit P sh frs\"\n  and \"\\<forall>sfs. sh C \\<noteq> Some(sfs,Processing)\"\nshows \"distinct (C # clinit_classes frs)\"", "lemma conf_clinit_shupd:\nassumes \"conf_clinit P sh frs\"\n and dist: \"distinct (C#clinit_classes frs)\"\nshows \"conf_clinit P (sh(C \\<mapsto> (sfs, i))) frs\"", "lemma conf_clinit_shupd':\nassumes \"conf_clinit P sh frs\"\n and \"sh C = Some(sfs,i)\"\nshows \"conf_clinit P (sh(C \\<mapsto> (sfs', i))) frs\"", "lemma conf_clinit_shupd_Called:\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,Calling C' Cs)#frs)\"\n and dist: \"distinct (C'#clinit_classes ((stk,loc,C,M,pc,Calling C' Cs)#frs))\"\n and cls: \"is_class P C'\"\nshows \"conf_clinit P (sh(C' \\<mapsto> (sfs, Processing))) ((stk,loc,C,M,pc,Called (C'#Cs))#frs)\"", "lemma conf_clinit_shupd_Calling:\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,Calling C' Cs)#frs)\"\n and dist: \"distinct (C'#clinit_classes ((stk,loc,C,M,pc,Calling C' Cs)#frs))\"\n and cls: \"is_class P C'\"\nshows \"conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n         ((stk,loc,C,M,pc,Calling (fst(the(class P C'))) (C'#Cs))#frs)\"", "lemma correct_state_Cons:\nassumes cr: \"P,\\<Phi> |- (xp,h,f#frs,sh) [ok]\"\nshows \"P,\\<Phi> |- (xp,h,frs,sh) [ok]\"", "lemma correct_state_shupd:\nassumes cs: \"P,\\<Phi> |- (xp,h,frs,sh) [ok]\" and shC: \"sh C = Some(sfs,i)\"\n and dist: \"distinct (C#clinit_classes frs)\"\nshows \"P,\\<Phi> |- (xp,h,frs,sh(C \\<mapsto> (sfs, i'))) [ok]\"", "lemma correct_state_Throwing_ex:\nassumes correct: \"P,\\<Phi> \\<turnstile> (xp,h,(stk,loc,C,M,pc,ics)#frs,sh)\\<surd>\"\nshows \"\\<And>Cs a. ics = Throwing Cs a \\<Longrightarrow> \\<exists>obj. h a = Some obj\""], "translations": [["", "lemma Called_context_Called_set:\n \"Called_context P D i \\<Longrightarrow> i \\<in> Called_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Called_context P D i \\<Longrightarrow> i \\<in> Called_set", "by(cases i, auto)"], ["", "fun valid_ics :: \"jvm_prog \\<Rightarrow> heap \\<Rightarrow> sheap \\<Rightarrow> cname \\<times> mname \\<times> pc \\<times> init_call_status \\<Rightarrow> bool\"\n  (\"_,_,_ \\<turnstile>\\<^sub>i _\" [51,51,51,51] 50) where\n\"valid_ics P h sh (C,M,pc,Calling C' Cs)\n = (let ins = instrs_of P C M in Called_context P (last (C'#Cs)) (ins!pc)\n    \\<and> is_class P C')\" |\n\"valid_ics P h sh (C,M,pc,Throwing Cs a)\n =(let ins = instrs_of P C M in \\<exists>C1. Called_context P C1 (ins!pc)\n    \\<and> (\\<exists>obj. h a = Some obj))\" |\n\"valid_ics P h sh (C,M,pc,Called Cs)\n = (let ins = instrs_of P C M\n    in \\<exists>C1 sobj. Called_context P C1 (ins!pc) \\<and> sh C1 = Some sobj)\" |\n\"valid_ics P _ _ _ = True\""], ["", "definition conf_f  :: \"jvm_prog \\<Rightarrow> heap \\<Rightarrow> sheap \\<Rightarrow> ty\\<^sub>i \\<Rightarrow> bytecode \\<Rightarrow> frame \\<Rightarrow> bool\"\nwhere\n  \"conf_f P h sh \\<equiv> \\<lambda>(ST,LT) is (stk,loc,C,M,pc,ics).\n  P,h \\<turnstile> stk [:\\<le>] ST \\<and> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < size is \\<and> P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["", "lemma conf_f_def2:\n  \"conf_f P h sh (ST,LT) is (stk,loc,C,M,pc,ics) \\<equiv>\n  P,h \\<turnstile> stk [:\\<le>] ST \\<and> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and> pc < size is \\<and> P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, ics) \\<equiv>\n    P,h \\<turnstile> stk [:\\<le>] ST \\<and>\n    P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\n    pc < length is \\<and> P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "by (simp add: conf_f_def)"], ["", "primrec conf_fs :: \"[jvm_prog,heap,sheap,ty\\<^sub>P,cname,mname,nat,ty,frame list] \\<Rightarrow> bool\"\nwhere\n  \"conf_fs P h sh \\<Phi> C\\<^sub>0 M\\<^sub>0 n\\<^sub>0 T\\<^sub>0 [] = True\"\n| \"conf_fs P h sh \\<Phi> C\\<^sub>0 M\\<^sub>0 n\\<^sub>0 T\\<^sub>0 (f#frs) =\n  (let (stk,loc,C,M,pc,ics) = f in\n  (\\<exists>ST LT b Ts T mxs mxl\\<^sub>0 is xt.\n    \\<Phi> C M ! pc = Some (ST,LT) \\<and> \n    (P \\<turnstile> C sees M,b:Ts \\<rightarrow> T = (mxs,mxl\\<^sub>0,is,xt) in C) \\<and>\n    ((\\<exists>D Ts' T' m D'. M\\<^sub>0 \\<noteq> clinit \\<and> ics = No_ics \\<and>\n       is!pc = Invoke M\\<^sub>0 n\\<^sub>0 \\<and> ST!n\\<^sub>0 = Class D \\<and>\n       P \\<turnstile> D sees M\\<^sub>0,NonStatic:Ts' \\<rightarrow> T' = m in D' \\<and> P \\<turnstile> C\\<^sub>0 \\<preceq>\\<^sup>* D' \\<and> P \\<turnstile> T\\<^sub>0 \\<le> T') \\<or>\n     (\\<exists>D Ts' T' m. M\\<^sub>0 \\<noteq> clinit \\<and> ics = No_ics \\<and>\n       is!pc = Invokestatic D M\\<^sub>0 n\\<^sub>0 \\<and>\n       P \\<turnstile> D sees M\\<^sub>0,Static:Ts' \\<rightarrow> T' = m in C\\<^sub>0 \\<and> P \\<turnstile> T\\<^sub>0 \\<le> T') \\<or>\n     (M\\<^sub>0 = clinit \\<and> (\\<exists>Cs. ics = Called Cs))) \\<and>\n    conf_f P h sh (ST, LT) is f \\<and> conf_fs P h sh \\<Phi> C M (size Ts) T frs))\""], ["", "fun ics_classes :: \"init_call_status \\<Rightarrow> cname list\" where\n\"ics_classes (Calling C Cs) = Cs\" |\n\"ics_classes (Throwing Cs a) = Cs\" |\n\"ics_classes (Called Cs) = Cs\" |\n\"ics_classes _ = []\""], ["", "fun frame_clinit_classes :: \"frame \\<Rightarrow> cname list\" where\n\"frame_clinit_classes (stk,loc,C,M,pc,ics) = (if M=clinit then [C] else []) @ ics_classes ics\""], ["", "abbreviation clinit_classes :: \"frame list \\<Rightarrow> cname list\" where\n\"clinit_classes frs \\<equiv> concat (map frame_clinit_classes frs)\""], ["", "definition distinct_clinit :: \"frame list \\<Rightarrow> bool\" where\n\"distinct_clinit frs \\<equiv> distinct (clinit_classes frs)\""], ["", "definition conf_clinit :: \"jvm_prog \\<Rightarrow> sheap \\<Rightarrow> frame list \\<Rightarrow> bool\" where\n\"conf_clinit P sh frs\n   \\<equiv> distinct_clinit frs \\<and>\n      (\\<forall>C \\<in> set(clinit_classes frs). is_class P C \\<and> (\\<exists>sfs. sh C = Some(sfs, Processing)))\""], ["", "(*************************)"], ["", "definition correct_state :: \"[jvm_prog,ty\\<^sub>P,jvm_state] \\<Rightarrow> bool\"  (\"_,_ \\<turnstile> _ \\<surd>\"  [61,0,0] 61)\nwhere\n  \"correct_state P \\<Phi> \\<equiv> \\<lambda>(xp,h,frs,sh).\n  case xp of\n     None \\<Rightarrow> (case frs of\n             [] \\<Rightarrow> True\n             | (f#fs) \\<Rightarrow> P\\<turnstile> h\\<surd> \\<and> P,h\\<turnstile>\\<^sub>s sh\\<surd> \\<and> conf_clinit P sh frs \\<and>\n             (let (stk,loc,C,M,pc,ics) = f\n              in \\<exists>b Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                    (P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = (mxs,mxl\\<^sub>0,is,xt) in C) \\<and>\n                    \\<Phi> C M ! pc = Some \\<tau> \\<and>\n                    conf_f P h sh \\<tau> is f \\<and> conf_fs P h sh \\<Phi> C M (size Ts) T fs))\n  | Some x \\<Rightarrow> frs = []\""], ["", "notation\n  correct_state  (\"_,_ |- _ [ok]\"  [61,0,0] 61)"], ["", "subsection \\<open> Values and @{text \"\\<top>\"} \\<close>"], ["", "lemma confT_Err [iff]: \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> Err", "by (simp add: confT_def)"], ["", "lemma confT_OK [iff]:  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> OK T = (P,h \\<turnstile> x :\\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> OK T) =\n    (P,h \\<turnstile> x :\\<le> T)", "by (simp add: confT_def)"], ["", "lemma confT_cases:\n  \"P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> X = (X = Err \\<or> (\\<exists>T. X = OK T \\<and> P,h \\<turnstile> x :\\<le> T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> X) =\n    (X = Err \\<or>\n     (\\<exists>T. X = OK T \\<and> P,h \\<turnstile> x :\\<le> T))", "by (cases X) auto"], ["", "lemma confT_hext [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> x :\\<le>\\<^sub>\\<top> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T;\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> x :\\<le>\\<^sub>\\<top> T", "by (cases T) (blast intro: conf_hext)+"], ["", "lemma confT_widen [intro?, trans]:\n  \"\\<lbrakk> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T; P \\<turnstile> T \\<le>\\<^sub>\\<top> T' \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T;\n     P \\<turnstile> T \\<le>\\<^sub>\\<top> T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> x :\\<le>\\<^sub>\\<top> T'", "by (cases T', auto intro: conf_widen)"], ["", "subsection \\<open> Stack and Registers \\<close>"], ["", "lemmas confTs_Cons1 [iff] = list_all2_Cons1 [of \"confT P h\"] for P h"], ["", "lemma confTs_confT_sup:\n  \"\\<lbrakk> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < size LT; LT!n = OK T; P \\<turnstile> T \\<le> T' \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> (loc!n) :\\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < length LT;\n     LT ! n = OK T; subtype P T T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < length LT;\n     LT ! n = OK T; subtype P T T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply (frule list_all2_lengthD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; n < length LT;\n     LT ! n = OK T; subtype P T T'; length loc = length LT\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply (drule list_all2_nthD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length LT; LT ! n = OK T; subtype P T T';\n     length loc = length LT;\n     P,h \\<turnstile> loc ! n :\\<le>\\<^sub>\\<top> LT ! n\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length LT; LT ! n = OK T; subtype P T T';\n     length loc = length LT; P,h \\<turnstile> loc ! n :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc ! n :\\<le> T'", "apply (erule conf_widen, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma confTs_hext [intro?]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT", "by (fast elim: list_all2_mono confT_hext)"], ["", "lemma confTs_widen [intro?, trans]:\n  \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<Longrightarrow> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<Longrightarrow> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n     P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by (rule list_all2_trans, rule confT_widen)"], ["", "lemma confTs_map [iff]:\n  \"\\<And>vs. (P,h \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] map OK Ts) = (P,h \\<turnstile> vs [:\\<le>] Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs.\n       (P,h \\<turnstile> vs [:\\<le>\\<^sub>\\<top>] map OK Ts) =\n       (P,h \\<turnstile> vs [:\\<le>] Ts)", "by (induct Ts) (auto simp: list_all2_Cons2)"], ["", "lemma reg_widen_Err [iff]:\n  \"\\<And>LT. (P \\<turnstile> replicate n Err [\\<le>\\<^sub>\\<top>] LT) = (LT = replicate n Err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>LT.\n       P \\<turnstile> replicate n Err [\\<le>\\<^sub>\\<top>] LT =\n       (LT = replicate n Err)", "by (induct n) (auto simp: list_all2_Cons1)"], ["", "lemma confTs_Err [iff]:\n  \"P,h \\<turnstile> replicate n v [:\\<le>\\<^sub>\\<top>] replicate n Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate n v [:\\<le>\\<^sub>\\<top>] replicate n Err", "by (induct n) auto"], ["", "subsection \\<open> valid @{text \"init_call_status\"} \\<close>"], ["", "lemma valid_ics_shupd:\nassumes \"P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\" and \"distinct (C'#ics_classes ics)\"\nshows \"P,h,sh(C' \\<mapsto> (sfs, i')) \\<turnstile>\\<^sub>i (C, M, pc, ics)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h,sh(C' \\<mapsto> (sfs, i')) \\<turnstile>\\<^sub>i (C, M, pc, ics)", "using assms"], ["proof (prove)\nusing this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  distinct (C' # ics_classes ics)\n\ngoal (1 subgoal):\n 1. P,h,sh(C' \\<mapsto> (sfs, i')) \\<turnstile>\\<^sub>i (C, M, pc, ics)", "by(cases ics; clarsimp simp: fun_upd_apply) fastforce"], ["", "subsection \\<open> correct-frame \\<close>"], ["", "lemma conf_f_Throwing:\nassumes \"conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Called Cs)\"\n  and \"is_class P C'\" and \"h xcp = Some obj\" and \"sh C' = Some(sfs,Processing)\"\nshows \"conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Throwing (C' # Cs) xcp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Throwing (C' # Cs) xcp)", "using assms"], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Called Cs)\n  is_class P C'\n  h xcp = \\<lfloor>obj\\<rfloor>\n  sh C' = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST, LT) is (stk, loc, C, M, pc, Throwing (C' # Cs) xcp)", "by(auto simp: conf_f_def2)"], ["", "lemma conf_f_shupd:\nassumes \"conf_f P h sh (ST,LT) ins f\"\n and \"i = Processing\n       \\<or> (distinct (C#ics_classes (ics_of f)) \\<and> (curr_method f = clinit \\<longrightarrow> C \\<noteq> curr_class f))\"\nshows \"conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST,LT) ins f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f", "using assms"], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins f\n  i = Processing \\<or>\n  distinct (C # ics_classes (ics_of f)) \\<and>\n  (curr_method f = clinit \\<longrightarrow> C \\<noteq> curr_class f)\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f", "by(cases f, cases \"ics_of f\"; clarsimp simp: conf_f_def2 fun_upd_apply) fastforce+"], ["", "lemma conf_f_shupd':\nassumes \"conf_f P h sh (ST,LT) ins f\"\n and \"sh C = Some(sfs,i)\"\nshows \"conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST,LT) ins f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f", "using assms"], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins f\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f", "by(cases f, cases \"ics_of f\"; clarsimp simp: conf_f_def2 fun_upd_apply) fastforce+"], ["", "subsection \\<open> correct-frames \\<close>"], ["", "lemmas [simp del] = fun_upd_apply"], ["", "lemma conf_fs_hext:\n  \"\\<And>C M n T\\<^sub>r. \n  \\<lbrakk> conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C M n T\\<^sub>r.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r frs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C M n T\\<^sub>r.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r frs", "apply (induct frs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C M n T\\<^sub>r.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r [];\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r []\n 2. \\<And>a frs C M n T\\<^sub>r.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        conf_fs P h sh \\<Phi> C M n T\\<^sub>r (a # frs);\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r (a # frs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a frs C M n T\\<^sub>r.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        conf_fs P h sh \\<Phi> C M n T\\<^sub>r (a # frs);\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r (a # frs)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b frs C M n T\\<^sub>r.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        conf_fs P h sh \\<Phi> C M n T\\<^sub>r\n         ((a, aa, ab, ac, ad, b) # frs);\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\n                          ((a, aa, ab, ac, ad, b) # frs)", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b frs C M n T\\<^sub>r.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        \\<exists>ST LT.\n           \\<Phi> ab ac ! ad = \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n           (\\<exists>ba Ts T mxs mxl\\<^sub>0 is.\n               (\\<exists>xt.\n                   P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n                                  mxl\\<^sub>0, is, xt) in ab) \\<and>\n               (M \\<noteq> clinit \\<and>\n                b = No_ics \\<and>\n                is ! ad = Invoke M n \\<and>\n                (\\<exists>D.\n                    ST ! n = Class D \\<and>\n                    (\\<exists>Ts' T' a aa ab b D'.\n                        P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a,\n        aa, ab, b) in D' \\<and>\n                        P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n                        subtype P T\\<^sub>r T')) \\<or>\n                M \\<noteq> clinit \\<and>\n                b = No_ics \\<and>\n                (\\<exists>D.\n                    is ! ad = Invokestatic D M n \\<and>\n                    (\\<exists>Ts' T'.\n                        (\\<exists>a aa ab b.\n                            P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a,\n         aa, ab, b) in C) \\<and>\n                        subtype P T\\<^sub>r T')) \\<or>\n                M = clinit \\<and> (\\<exists>Cs. b = Called Cs)) \\<and>\n               conf_f P h sh (ST, LT) is (a, aa, ab, ac, ad, b) \\<and>\n               conf_fs P h sh \\<Phi> ab ac (length Ts) T frs);\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! ad =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>ba Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n             mxl\\<^sub>0, is, xt) in ab) \\<and>\n                                (M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 is ! ad = Invoke M n \\<and>\n                                 (\\<exists>D.\n                                     ST ! n = Class D \\<and>\n                                     (\\<exists>Ts' T' a aa ab b D'.\n   P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                         b) in D' \\<and>\n   P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 (\\<exists>D.\n                                     is ! ad = Invokestatic D M n \\<and>\n                                     (\\<exists>Ts' T'.\n   (\\<exists>a aa ab b.\n       P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                          b) in C) \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M = clinit \\<and>\n                                 (\\<exists>Cs. b = Called Cs)) \\<and>\n                                conf_f P h' sh (ST, LT) is\n                                 (a, aa, ab, ac, ad, b) \\<and>\n                                conf_fs P h' sh \\<Phi> ab ac (length Ts) T\n                                 frs)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b frs C M n T\\<^sub>r ST LT ba Ts T mxs mxl\\<^sub>0\n       is xt.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! ad = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n                       mxl\\<^sub>0, is, xt) in ab;\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        is ! ad = Invoke M n \\<and>\n        (\\<exists>D.\n            ST ! n = Class D \\<and>\n            (\\<exists>Ts' T' a aa ab b D'.\n                P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a,\naa, ab, b) in D' \\<and>\n                P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        (\\<exists>D.\n            is ! ad = Invokestatic D M n \\<and>\n            (\\<exists>Ts' T'.\n                (\\<exists>a aa ab b.\n                    P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a,\n aa, ab, b) in C) \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M = clinit \\<and> (\\<exists>Cs. b = Called Cs);\n        conf_f P h sh (ST, LT) is (a, aa, ab, ac, ad, b);\n        conf_fs P h sh \\<Phi> ab ac (length Ts) T frs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! ad =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>ba Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n             mxl\\<^sub>0, is, xt) in ab) \\<and>\n                                (M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 is ! ad = Invoke M n \\<and>\n                                 (\\<exists>D.\n                                     ST ! n = Class D \\<and>\n                                     (\\<exists>Ts' T' a aa ab b D'.\n   P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                         b) in D' \\<and>\n   P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 (\\<exists>D.\n                                     is ! ad = Invokestatic D M n \\<and>\n                                     (\\<exists>Ts' T'.\n   (\\<exists>a aa ab b.\n       P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                          b) in C) \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M = clinit \\<and>\n                                 (\\<exists>Cs. b = Called Cs)) \\<and>\n                                conf_f P h' sh (ST, LT) is\n                                 (a, aa, ab, ac, ad, b) \\<and>\n                                conf_fs P h' sh \\<Phi> ab ac (length Ts) T\n                                 frs)", "apply (unfold conf_f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b frs C M n T\\<^sub>r ST LT ba Ts T mxs mxl\\<^sub>0\n       is xt.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! ad = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n                       mxl\\<^sub>0, is, xt) in ab;\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        is ! ad = Invoke M n \\<and>\n        (\\<exists>D.\n            ST ! n = Class D \\<and>\n            (\\<exists>Ts' T' a aa aaa b D'.\n                P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a,\naa, aaa, b) in D' \\<and>\n                P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        (\\<exists>D.\n            is ! ad = Invokestatic D M n \\<and>\n            (\\<exists>Ts' T'.\n                (\\<exists>a aa aaa b.\n                    P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a,\n aa, aaa, b) in C) \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M = clinit \\<and> (\\<exists>Cs. b = Called Cs);\n        (case (ST, LT) of\n         (ST, LT) \\<Rightarrow>\n           \\<lambda>is (stk, loc, C, M, pc, ics).\n              P,h \\<turnstile> stk [:\\<le>] ST \\<and>\n              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\n              pc < length is \\<and>\n              P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics))\n         is (a, aa, ab, ac, ad, b);\n        conf_fs P h sh \\<Phi> ab ac (length Ts) T frs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! ad =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>ba Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n             mxl\\<^sub>0, is, xt) in ab) \\<and>\n                                (M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 is ! ad = Invoke M n \\<and>\n                                 (\\<exists>D.\n                                     ST ! n = Class D \\<and>\n                                     (\\<exists>Ts' T' a aa aaa b D'.\n   P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a, aa, aaa,\n                         b) in D' \\<and>\n   P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 (\\<exists>D.\n                                     is ! ad = Invokestatic D M n \\<and>\n                                     (\\<exists>Ts' T'.\n   (\\<exists>a aa aaa b.\n       P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a, aa, aaa,\n                          b) in C) \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M = clinit \\<and>\n                                 (\\<exists>Cs. b = Called Cs)) \\<and>\n                                (case (ST, LT) of\n                                 (ST, LT) \\<Rightarrow>\n                                   \\<lambda>is (stk, loc, C, M, pc, ics).\nP,h' \\<turnstile> stk [:\\<le>] ST \\<and>\nP,h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\npc < length is \\<and> P,h',sh \\<turnstile>\\<^sub>i (C, M, pc, ics))\n                                 is (a, aa, ab, ac, ad, b) \\<and>\n                                conf_fs P h' sh \\<Phi> ab ac (length Ts) T\n                                 frs)", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b frs C M n T\\<^sub>r ST LT ba Ts T mxs mxl\\<^sub>0\n       is xt.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! ad = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n                       mxl\\<^sub>0, is, xt) in ab;\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        is ! ad = Invoke M n \\<and>\n        (\\<exists>D.\n            ST ! n = Class D \\<and>\n            (\\<exists>Ts' T' a aa ab b D'.\n                P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a,\naa, ab, b) in D' \\<and>\n                P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        (\\<exists>D.\n            is ! ad = Invokestatic D M n \\<and>\n            (\\<exists>Ts' T'.\n                (\\<exists>a aa ab b.\n                    P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a,\n aa, ab, b) in C) \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M = clinit \\<and> (\\<exists>Cs. b = Called Cs);\n        P,h \\<turnstile> a [:\\<le>] ST \\<and>\n        P,h \\<turnstile> aa [:\\<le>\\<^sub>\\<top>] LT \\<and>\n        ad < length is \\<and> P,h,sh \\<turnstile>\\<^sub>i (ab, ac, ad, b);\n        conf_fs P h sh \\<Phi> ab ac (length Ts) T frs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! ad =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>ba Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n             mxl\\<^sub>0, is, xt) in ab) \\<and>\n                                (M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 is ! ad = Invoke M n \\<and>\n                                 (\\<exists>D.\n                                     ST ! n = Class D \\<and>\n                                     (\\<exists>Ts' T' a aa ab b D'.\n   P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                         b) in D' \\<and>\n   P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 (\\<exists>D.\n                                     is ! ad = Invokestatic D M n \\<and>\n                                     (\\<exists>Ts' T'.\n   (\\<exists>a aa ab b.\n       P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                          b) in C) \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M = clinit \\<and>\n                                 (\\<exists>Cs. b = Called Cs)) \\<and>\n                                P,h' \\<turnstile> a [:\\<le>] ST \\<and>\n                                P,h' \\<turnstile> aa [:\\<le>\\<^sub>\\<top>] LT \\<and>\n                                ad < length is \\<and>\n                                P,h',sh \\<turnstile>\\<^sub>i (ab, ac, ad,\n                        b) \\<and>\n                                conf_fs P h' sh \\<Phi> ab ac (length Ts) T\n                                 frs)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b frs C M n T\\<^sub>r ST LT ba Ts T mxs mxl\\<^sub>0\n       is xt.\n       \\<lbrakk>\\<And>C M n T\\<^sub>r.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C M n T\\<^sub>r frs;\n                    h \\<unlhd> h'\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h' sh \\<Phi> C M n T\\<^sub>r\nfrs;\n        h \\<unlhd> h'; \\<Phi> ab ac ! ad = \\<lfloor>(ST, LT)\\<rfloor>;\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n                       mxl\\<^sub>0, is, xt) in ab;\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        is ! ad = Invoke M n \\<and>\n        (\\<exists>D.\n            ST ! n = Class D \\<and>\n            (\\<exists>Ts' T' a aa ab b D'.\n                P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a,\naa, ab, b) in D' \\<and>\n                P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M \\<noteq> clinit \\<and>\n        b = No_ics \\<and>\n        (\\<exists>D.\n            is ! ad = Invokestatic D M n \\<and>\n            (\\<exists>Ts' T'.\n                (\\<exists>a aa ab b.\n                    P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a,\n aa, ab, b) in C) \\<and>\n                subtype P T\\<^sub>r T')) \\<or>\n        M = clinit \\<and> (\\<exists>Cs. b = Called Cs);\n        conf_fs P h sh \\<Phi> ab ac (length Ts) T frs;\n        P,h \\<turnstile> a [:\\<le>] ST;\n        P,h \\<turnstile> aa [:\\<le>\\<^sub>\\<top>] LT; ad < length is;\n        P,h,sh \\<turnstile>\\<^sub>i (ab, ac, ad, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ST LT.\n                            \\<Phi> ab ac ! ad =\n                            \\<lfloor>(ST, LT)\\<rfloor> \\<and>\n                            (\\<exists>ba Ts T mxs mxl\\<^sub>0 is.\n                                (\\<exists>xt.\n                                    P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (mxs,\n             mxl\\<^sub>0, is, xt) in ab) \\<and>\n                                (M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 is ! ad = Invoke M n \\<and>\n                                 (\\<exists>D.\n                                     ST ! n = Class D \\<and>\n                                     (\\<exists>Ts' T' a aa ab b D'.\n   P \\<turnstile> D sees M, NonStatic :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                         b) in D' \\<and>\n   P \\<turnstile> C \\<preceq>\\<^sup>* D' \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M \\<noteq> clinit \\<and>\n                                 b = No_ics \\<and>\n                                 (\\<exists>D.\n                                     is ! ad = Invokestatic D M n \\<and>\n                                     (\\<exists>Ts' T'.\n   (\\<exists>a aa ab b.\n       P \\<turnstile> D sees M, Static :  Ts'\\<rightarrow>T' = (a, aa, ab,\n                          b) in C) \\<and>\n   subtype P T\\<^sub>r T')) \\<or>\n                                 M = clinit \\<and>\n                                 (\\<exists>Cs. b = Called Cs)) \\<and>\n                                P,h' \\<turnstile> a [:\\<le>] ST \\<and>\n                                P,h' \\<turnstile> aa [:\\<le>\\<^sub>\\<top>] LT \\<and>\n                                ad < length is \\<and>\n                                P,h',sh \\<turnstile>\\<^sub>i (ab, ac, ad,\n                        b) \\<and>\n                                conf_fs P h' sh \\<Phi> ab ac (length Ts) T\n                                 frs)", "apply (fastforce elim!: confs_hext confTs_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma conf_fs_shupd:\nassumes \"conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\"\n and dist: \"distinct (C#clinit_classes frs)\"\nshows \"conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C\\<^sub>0 M n T frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C\\<^sub>0 M n T frs", "using assms"], ["proof (prove)\nusing this:\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\n  distinct (C # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C\\<^sub>0 M n T frs", "proof(induct frs arbitrary: C\\<^sub>0 C M n T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "case (Cons f' frs')"], ["proof (state)\nthis:\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   distinct (?C # clinit_classes frs')\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (sfs, i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   distinct (?C # clinit_classes frs')\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (sfs, i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))", "obtain stk' loc' C' M' pc' ics' where f': \"f' = (stk',loc',C',M',pc',ics')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   distinct (?C # clinit_classes frs')\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (sfs, i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))\n\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc' ics'.\n        f' = (stk', loc', C', M', pc', ics') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases f')"], ["proof (state)\nthis:\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "with assms Cons"], ["proof (chain)\npicking this:\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\n  distinct (C # clinit_classes frs)\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   distinct (?C # clinit_classes frs')\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (sfs, i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))\n  f' = (stk', loc', C', M', pc', ics')", "obtain ST LT b Ts T1 mxs mxl\\<^sub>0 ins xt where\n    ty: \"\\<Phi> C' M' ! pc' = Some (ST,LT)\" and\n    meth: \"P \\<turnstile> C' sees M',b:Ts \\<rightarrow> T1 = (mxs,mxl\\<^sub>0,ins,xt) in C'\" and\n    conf: \"conf_f P h sh (ST, LT) ins f'\" and\n    confs: \"conf_fs P h sh \\<Phi> C' M' (size Ts) T1 frs'\""], ["proof (prove)\nusing this:\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\n  distinct (C # clinit_classes frs)\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   distinct (?C # clinit_classes frs')\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (sfs, i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT b Ts T1 mxs mxl\\<^sub>0 ins xt.\n        \\<lbrakk>\\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n         P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs,\n                        mxl\\<^sub>0, ins, xt) in C';\n         conf_f P h sh (ST, LT) ins f';\n         conf_fs P h sh \\<Phi> C' M' (length Ts) T1 frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C'\n  conf_f P h sh (ST, LT) ins f'\n  conf_fs P h sh \\<Phi> C' M' (length Ts) T1 frs'\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "from f' Cons.prems(2)"], ["proof (chain)\npicking this:\n  f' = (stk', loc', C', M', pc', ics')\n  distinct (C # clinit_classes (f' # frs'))", "have\n   \"distinct (C#ics_classes (ics_of f')) \\<and> (curr_method f' = clinit \\<longrightarrow> C \\<noteq> curr_class f')\""], ["proof (prove)\nusing this:\n  f' = (stk', loc', C', M', pc', ics')\n  distinct (C # clinit_classes (f' # frs'))\n\ngoal (1 subgoal):\n 1. distinct (C # ics_classes (ics_of f')) \\<and>\n    (curr_method f' = clinit \\<longrightarrow> C \\<noteq> curr_class f')", "by fastforce"], ["proof (state)\nthis:\n  distinct (C # ics_classes (ics_of f')) \\<and>\n  (curr_method f' = clinit \\<longrightarrow> C \\<noteq> curr_class f')\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "with conf_f_shupd[where C=C, OF conf]"], ["proof (chain)\npicking this:\n  ?i = Processing \\<or>\n  distinct (C # ics_classes (ics_of f')) \\<and>\n  (curr_method f' = clinit \\<longrightarrow>\n   C \\<noteq> curr_class f') \\<Longrightarrow>\n  conf_f P h (sh(C \\<mapsto> (?sfs, ?i))) (ST, LT) ins f'\n  distinct (C # ics_classes (ics_of f')) \\<and>\n  (curr_method f' = clinit \\<longrightarrow> C \\<noteq> curr_class f')", "have\n    conf': \"conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f'\""], ["proof (prove)\nusing this:\n  ?i = Processing \\<or>\n  distinct (C # ics_classes (ics_of f')) \\<and>\n  (curr_method f' = clinit \\<longrightarrow>\n   C \\<noteq> curr_class f') \\<Longrightarrow>\n  conf_f P h (sh(C \\<mapsto> (?sfs, ?i))) (ST, LT) ins f'\n  distinct (C # ics_classes (ics_of f')) \\<and>\n  (curr_method f' = clinit \\<longrightarrow> C \\<noteq> curr_class f')\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f'", "by simp"], ["proof (state)\nthis:\n  conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f'\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  distinct (C # clinit_classes (f' # frs'))", "have dist': \"distinct (C # clinit_classes frs')\""], ["proof (prove)\nusing this:\n  distinct (C # clinit_classes (f' # frs'))\n\ngoal (1 subgoal):\n 1. distinct (C # clinit_classes frs')", "by(auto simp: distinct_length_2_or_more)"], ["proof (state)\nthis:\n  distinct (C # clinit_classes frs')\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "from Cons.hyps[OF confs dist']"], ["proof (chain)\npicking this:\n  conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'", "have\n    confs': \"conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'\""], ["proof (prove)\nusing this:\n  conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'\n\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'", "by simp"], ["proof (state)\nthis:\n  conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    distinct (C # clinit_classes frs)\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        distinct (C # clinit_classes (a # frs))\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "from conf' confs' ty meth f' Cons.prems"], ["proof (chain)\npicking this:\n  conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f'\n  conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C'\n  f' = (stk', loc', C', M', pc', ics')\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))", "show ?case"], ["proof (prove)\nusing this:\n  conf_f P h (sh(C \\<mapsto> (sfs, i))) (ST, LT) ins f'\n  conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C' M' (length Ts) T1 frs'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C'\n  f' = (stk', loc', C', M', pc', ics')\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  distinct (C # clinit_classes (f' # frs'))\n\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C\\<^sub>0 M n T\n     (f' # frs')", "by(fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi> C\\<^sub>0 M n T (f' # frs')\n\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 C M n T.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        distinct (C # clinit_classes [])\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs, i))) \\<Phi>\n                          C\\<^sub>0 M n T []", "qed(simp)"], ["", "lemma conf_fs_shupd':\nassumes \"conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\"\n and shC: \"sh C = Some(sfs,i)\"\nshows \"conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C\\<^sub>0 M n T frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C\\<^sub>0 M n T frs", "using assms"], ["proof (prove)\nusing this:\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C\\<^sub>0 M n T frs", "proof(induct frs arbitrary: C\\<^sub>0 C M n T sfs i sfs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T sfs i sfs'.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "case (Cons f' frs')"], ["proof (state)\nthis:\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   sh ?C = \\<lfloor>(?sfs, ?i)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (?sfs', ?i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T sfs i sfs'.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   sh ?C = \\<lfloor>(?sfs, ?i)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (?sfs', ?i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>", "obtain stk' loc' C' M' pc' ics' where f': \"f' = (stk',loc',C',M',pc',ics')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   sh ?C = \\<lfloor>(?sfs, ?i)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (?sfs', ?i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc' ics'.\n        f' = (stk', loc', C', M', pc', ics') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases f')"], ["proof (state)\nthis:\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T sfs i sfs'.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "with assms Cons"], ["proof (chain)\npicking this:\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   sh ?C = \\<lfloor>(?sfs, ?i)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (?sfs', ?i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  f' = (stk', loc', C', M', pc', ics')", "obtain ST LT b Ts T1 mxs mxl\\<^sub>0 ins xt where\n    ty: \"\\<Phi> C' M' ! pc' = Some (ST,LT)\" and\n    meth: \"P \\<turnstile> C' sees M',b:Ts \\<rightarrow> T1 = (mxs,mxl\\<^sub>0,ins,xt) in C'\" and\n    conf: \"conf_f P h sh (ST, LT) ins f'\" and\n    confs: \"conf_fs P h sh \\<Phi> C' M' (size Ts) T1 frs'\" and\n    shC': \"sh C = Some(sfs,i)\""], ["proof (prove)\nusing this:\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  \\<lbrakk>conf_fs P h sh \\<Phi> ?C\\<^sub>0 ?M ?n ?T frs';\n   sh ?C = \\<lfloor>(?sfs, ?i)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> conf_fs P h (sh(?C \\<mapsto> (?sfs', ?i))) \\<Phi>\n                     ?C\\<^sub>0 ?M ?n ?T frs'\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT b Ts T1 mxs mxl\\<^sub>0 ins xt.\n        \\<lbrakk>\\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n         P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs,\n                        mxl\\<^sub>0, ins, xt) in C';\n         conf_f P h sh (ST, LT) ins f';\n         conf_fs P h sh \\<Phi> C' M' (length Ts) T1 frs';\n         sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C'\n  conf_f P h sh (ST, LT) ins f'\n  conf_fs P h sh \\<Phi> C' M' (length Ts) T1 frs'\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T sfs i sfs'.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "have conf': \"conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f'", "by(rule conf_f_shupd'[OF conf shC'])"], ["proof (state)\nthis:\n  conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f'\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T sfs i sfs'.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "from Cons.hyps[OF confs shC']"], ["proof (chain)\npicking this:\n  conf_fs P h (sh(C \\<mapsto> (?sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'", "have\n    confs': \"conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'\""], ["proof (prove)\nusing this:\n  conf_fs P h (sh(C \\<mapsto> (?sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'\n\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'", "by simp"], ["proof (state)\nthis:\n  conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'\n\ngoal (2 subgoals):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []\n 2. \\<And>a frs C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>\\<And>C\\<^sub>0 C M n T sfs i sfs'.\n                   \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T frs;\n                    sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n                   \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i)))\n\\<Phi> C\\<^sub>0 M n T frs;\n        conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (a # frs);\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T (a # frs)", "from conf' confs' ty meth f' Cons.prems"], ["proof (chain)\npicking this:\n  conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f'\n  conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C'\n  f' = (stk', loc', C', M', pc', ics')\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  conf_f P h (sh(C \\<mapsto> (sfs', i))) (ST, LT) ins f'\n  conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C' M' (length Ts) T1 frs'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T1 = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C'\n  f' = (stk', loc', C', M', pc', ics')\n  conf_fs P h sh \\<Phi> C\\<^sub>0 M n T (f' # frs')\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C\\<^sub>0 M n T\n     (f' # frs')", "by(fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi> C\\<^sub>0 M n T (f' # frs')\n\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 C M n T sfs i sfs'.\n       \\<lbrakk>conf_fs P h sh \\<Phi> C\\<^sub>0 M n T [];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> conf_fs P h (sh(C \\<mapsto> (sfs', i))) \\<Phi>\n                          C\\<^sub>0 M n T []", "qed(simp)"], ["", "subsection \\<open> correctness wrt @{term clinit} use \\<close>"], ["", "lemma conf_clinit_Cons:\nassumes \"conf_clinit P sh (f#frs)\"\nshows \"conf_clinit P sh frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh frs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_clinit P sh frs", "from assms"], ["proof (chain)\npicking this:\n  conf_clinit P sh (f # frs)", "have dist: \"distinct_clinit (f#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh (f # frs)\n\ngoal (1 subgoal):\n 1. distinct_clinit (f # frs)", "by(cases \"curr_method f = clinit\", auto simp: conf_clinit_def)"], ["proof (state)\nthis:\n  distinct_clinit (f # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh frs", "then"], ["proof (chain)\npicking this:\n  distinct_clinit (f # frs)", "have dist': \"distinct_clinit frs\""], ["proof (prove)\nusing this:\n  distinct_clinit (f # frs)\n\ngoal (1 subgoal):\n 1. distinct_clinit frs", "by(simp add: distinct_clinit_def)"], ["proof (state)\nthis:\n  distinct_clinit frs\n\ngoal (1 subgoal):\n 1. conf_clinit P sh frs", "with assms"], ["proof (chain)\npicking this:\n  conf_clinit P sh (f # frs)\n  distinct_clinit frs", "show ?thesis"], ["proof (prove)\nusing this:\n  conf_clinit P sh (f # frs)\n  distinct_clinit frs\n\ngoal (1 subgoal):\n 1. conf_clinit P sh frs", "by(cases frs; fastforce simp: conf_clinit_def)"], ["proof (state)\nthis:\n  conf_clinit P sh frs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conf_clinit_Cons_Cons:\n \"conf_clinit P sh (f'#f#frs) \\<Longrightarrow> conf_clinit P sh (f'#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh (f' # f # frs) \\<Longrightarrow>\n    conf_clinit P sh (f' # frs)", "by(auto simp: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_diff:\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\"\nshows \"conf_clinit P sh ((stk',loc',C,M,pc',ics)#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk', loc', C, M, pc', ics) # frs)", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk', loc', C, M, pc', ics) # frs)", "by(cases \"M = clinit\", simp_all add: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_diff':\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\"\nshows \"conf_clinit P sh ((stk',loc',C,M,pc',No_ics)#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk', loc', C, M, pc', No_ics) # frs)", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk', loc', C, M, pc', No_ics) # frs)", "by(cases \"M = clinit\", simp_all add: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_Called_Throwing:\n \"conf_clinit P sh ((stk', loc', C', clinit, pc', ics') # (stk, loc, C, M, pc, Called Cs) # fs)\n  \\<Longrightarrow> conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C' # Cs) xcp) # fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((stk', loc', C', clinit, pc', ics') #\n      (stk, loc, C, M, pc, Called Cs) # fs) \\<Longrightarrow>\n    conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C' # Cs) xcp) # fs)", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_Throwing:\n \"conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C'#Cs) xcp) # fs)\n  \\<Longrightarrow> conf_clinit P sh ((stk, loc, C, M, pc, Throwing Cs xcp) # fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((stk, loc, C, M, pc, Throwing (C' # Cs) xcp) # fs) \\<Longrightarrow>\n    conf_clinit P sh ((stk, loc, C, M, pc, Throwing Cs xcp) # fs)", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_Called:\n \"\\<lbrakk> conf_clinit P sh ((stk, loc, C, M, pc, Called (C'#Cs)) # frs);\n    P \\<turnstile> C' sees clinit,Static: [] \\<rightarrow> Void=(mxs',mxl',ins',xt') in C' \\<rbrakk>\n  \\<Longrightarrow> conf_clinit P sh (create_init_frame P C' # (stk, loc, C, M, pc, Called Cs) # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conf_clinit P sh\n              ((stk, loc, C, M, pc, Called (C' # Cs)) # frs);\n     P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                               mxl', ins', xt') in C'\\<rbrakk>\n    \\<Longrightarrow> conf_clinit P sh\n                       (create_init_frame P C' #\n                        (stk, loc, C, M, pc, Called Cs) # frs)", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_Cons_nclinit:\nassumes \"conf_clinit P sh frs\" and nclinit: \"M \\<noteq> clinit\"\nshows \"conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "from nclinit"], ["proof (chain)\npicking this:\n  M \\<noteq> clinit", "have \"clinit_classes ((stk, loc, C, M, pc, No_ics) # frs) = clinit_classes frs\""], ["proof (prove)\nusing this:\n  M \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. clinit_classes ((stk, loc, C, M, pc, No_ics) # frs) = clinit_classes frs", "by simp"], ["proof (state)\nthis:\n  clinit_classes ((stk, loc, C, M, pc, No_ics) # frs) = clinit_classes frs\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "with assms"], ["proof (chain)\npicking this:\n  conf_clinit P sh frs\n  M \\<noteq> clinit\n  clinit_classes ((stk, loc, C, M, pc, No_ics) # frs) = clinit_classes frs", "show ?thesis"], ["proof (prove)\nusing this:\n  conf_clinit P sh frs\n  M \\<noteq> clinit\n  clinit_classes ((stk, loc, C, M, pc, No_ics) # frs) = clinit_classes frs\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conf_clinit_Invoke:\nassumes \"conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\" and \"M' \\<noteq> clinit\"\nshows \"conf_clinit P sh ((stk', loc', C', M', pc', No_ics) # (stk, loc, C, M, pc, No_ics) # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((stk', loc', C', M', pc', No_ics) #\n      (stk, loc, C, M, pc, No_ics) # frs)", "using assms conf_clinit_Cons_nclinit conf_clinit_diff'"], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  M' \\<noteq> clinit\n  \\<lbrakk>conf_clinit ?P ?sh ?frs; ?M \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> conf_clinit ?P ?sh\n                     ((?stk, ?loc, ?C, ?M, ?pc, No_ics) # ?frs)\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, ?ics) # ?frs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk', ?loc', ?C, ?M, ?pc', No_ics) # ?frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((stk', loc', C', M', pc', No_ics) #\n      (stk, loc, C, M, pc, No_ics) # frs)", "by auto"], ["", "lemma conf_clinit_nProc_dist:\nassumes \"conf_clinit P sh frs\"\n  and \"\\<forall>sfs. sh C \\<noteq> Some(sfs,Processing)\"\nshows \"distinct (C # clinit_classes frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (C # clinit_classes frs)", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh frs\n  \\<forall>sfs. sh C \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. distinct (C # clinit_classes frs)", "by(auto simp: conf_clinit_def distinct_clinit_def)"], ["", "lemma conf_clinit_shupd:\nassumes \"conf_clinit P sh frs\"\n and dist: \"distinct (C#clinit_classes frs)\"\nshows \"conf_clinit P (sh(C \\<mapsto> (sfs, i))) frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C \\<mapsto> (sfs, i))) frs", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh frs\n  distinct (C # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C \\<mapsto> (sfs, i))) frs", "by(simp add: conf_clinit_def fun_upd_apply)"], ["", "lemma conf_clinit_shupd':\nassumes \"conf_clinit P sh frs\"\n and \"sh C = Some(sfs,i)\"\nshows \"conf_clinit P (sh(C \\<mapsto> (sfs', i))) frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C \\<mapsto> (sfs', i))) frs", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh frs\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C \\<mapsto> (sfs', i))) frs", "by(fastforce simp: conf_clinit_def fun_upd_apply)"], ["", "lemma conf_clinit_shupd_Called:\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,Calling C' Cs)#frs)\"\n and dist: \"distinct (C'#clinit_classes ((stk,loc,C,M,pc,Calling C' Cs)#frs))\"\n and cls: \"is_class P C'\"\nshows \"conf_clinit P (sh(C' \\<mapsto> (sfs, Processing))) ((stk,loc,C,M,pc,Called (C'#Cs))#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n     ((stk, loc, C, M, pc, Called (C' # Cs)) # frs)", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling C' Cs) # frs)\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\n  is_class P C'\n\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n     ((stk, loc, C, M, pc, Called (C' # Cs)) # frs)", "by(clarsimp simp: conf_clinit_def fun_upd_apply distinct_clinit_def)"], ["", "lemma conf_clinit_shupd_Calling:\nassumes \"conf_clinit P sh ((stk,loc,C,M,pc,Calling C' Cs)#frs)\"\n and dist: \"distinct (C'#clinit_classes ((stk,loc,C,M,pc,Calling C' Cs)#frs))\"\n and cls: \"is_class P C'\"\nshows \"conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n         ((stk,loc,C,M,pc,Calling (fst(the(class P C'))) (C'#Cs))#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n     ((stk, loc, C, M, pc, Calling (fst (the (class P C'))) (C' # Cs)) #\n      frs)", "using assms"], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling C' Cs) # frs)\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\n  is_class P C'\n\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n     ((stk, loc, C, M, pc, Calling (fst (the (class P C'))) (C' # Cs)) #\n      frs)", "by(clarsimp simp: conf_clinit_def fun_upd_apply distinct_clinit_def)"], ["", "subsection \\<open> correct state \\<close>"], ["", "lemma correct_state_Cons:\nassumes cr: \"P,\\<Phi> |- (xp,h,f#frs,sh) [ok]\"\nshows \"P,\\<Phi> |- (xp,h,frs,sh) [ok]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh) [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh) [ok]", "from cr"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (xp, h, f # frs, sh) [ok]", "have dist: \"conf_clinit P sh (f#frs)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (xp, h, f # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. conf_clinit P sh (f # frs)", "by(simp add: correct_state_def)"], ["proof (state)\nthis:\n  conf_clinit P sh (f # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh) [ok]", "then"], ["proof (chain)\npicking this:\n  conf_clinit P sh (f # frs)", "have \"conf_clinit P sh frs\""], ["proof (prove)\nusing this:\n  conf_clinit P sh (f # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh frs", "by(rule conf_clinit_Cons)"], ["proof (state)\nthis:\n  conf_clinit P sh frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh) [ok]", "with cr"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (xp, h, f # frs, sh) [ok]\n  conf_clinit P sh frs", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (xp, h, f # frs, sh) [ok]\n  conf_clinit P sh frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh) [ok]", "by(cases frs; fastforce simp: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- (xp, h, frs, sh) [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma correct_state_shupd:\nassumes cs: \"P,\\<Phi> |- (xp,h,frs,sh) [ok]\" and shC: \"sh C = Some(sfs,i)\"\n and dist: \"distinct (C#clinit_classes frs)\"\nshows \"P,\\<Phi> |- (xp,h,frs,sh(C \\<mapsto> (sfs, i'))) [ok]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto> (sfs, i'))) [ok]", "using assms"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (xp, h, frs, sh) [ok]\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  distinct (C # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto> (sfs, i'))) [ok]", "proof(cases xp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "case None"], ["proof (state)\nthis:\n  xp = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "with assms"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (xp, h, frs, sh) [ok]\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  distinct (C # clinit_classes frs)\n  xp = None", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (xp, h, frs, sh) [ok]\n  sh C = \\<lfloor>(sfs, i)\\<rfloor>\n  distinct (C # clinit_classes frs)\n  xp = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto> (sfs, i'))) [ok]", "proof(cases frs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "case (Cons f' frs')"], ["proof (state)\nthis:\n  frs = f' # frs'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "let ?sh = \"sh(C \\<mapsto> (sfs, i'))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "obtain stk' loc' C' M' pc' ics' where f': \"f' = (stk',loc',C',M',pc',ics')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc' ics'.\n        f' = (stk', loc', C', M', pc', ics') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases f')"], ["proof (state)\nthis:\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "with cs Cons None"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (xp, h, frs, sh) [ok]\n  frs = f' # frs'\n  xp = None\n  f' = (stk', loc', C', M', pc', ics')", "obtain b Ts T mxs mxl\\<^sub>0 ins xt ST LT where\n         meth: \"P \\<turnstile> C' sees M',b:Ts\\<rightarrow>T = (mxs,mxl\\<^sub>0,ins,xt) in C'\"\n     and ty: \"\\<Phi> C' M' ! pc' = Some (ST,LT)\" and conf: \"conf_f P h sh (ST,LT) ins f'\"\n     and confs: \"conf_fs P h sh \\<Phi> C' M' (size Ts) T frs'\"\n     and confc: \"conf_clinit P sh frs\"\n     and h_ok: \"P\\<turnstile> h\\<surd>\" and sh_ok: \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (xp, h, frs, sh) [ok]\n  frs = f' # frs'\n  xp = None\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. (\\<And>b Ts T mxs mxl\\<^sub>0 ins xt ST LT.\n        \\<lbrakk>P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs,\n                               mxl\\<^sub>0, ins, xt) in C';\n         \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins f';\n         conf_fs P h sh \\<Phi> C' M' (length Ts) T frs';\n         conf_clinit P sh frs; P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: correct_state_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins f'\n  conf_fs P h sh \\<Phi> C' M' (length Ts) T frs'\n  conf_clinit P sh frs\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "from Cons dist"], ["proof (chain)\npicking this:\n  frs = f' # frs'\n  distinct (C # clinit_classes frs)", "have dist': \"distinct (C#clinit_classes frs')\""], ["proof (prove)\nusing this:\n  frs = f' # frs'\n  distinct (C # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. distinct (C # clinit_classes frs')", "by(auto simp: distinct_length_2_or_more)"], ["proof (state)\nthis:\n  distinct (C # clinit_classes frs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "from shconf_upd_obj[OF sh_ok shconfD[OF sh_ok shC]]"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (sfs, ?i')) \\<surd>", "have sh_ok': \"P,h \\<turnstile>\\<^sub>s ?sh \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (sfs, ?i')) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (sfs, i')) \\<surd>", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (sfs, i')) \\<surd>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "from conf f' valid_ics_shupd Cons dist"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins f'\n  f' = (stk', loc', C', M', pc', ics')\n  \\<lbrakk>?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics);\n   distinct (?C' # ics_classes ?ics)\\<rbrakk>\n  \\<Longrightarrow> ?P,?h,?sh(?C' \\<mapsto>\n                    (?sfs, ?i')) \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  frs = f' # frs'\n  distinct (C # clinit_classes frs)", "have conf': \"conf_f P h ?sh (ST,LT) ins f'\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins f'\n  f' = (stk', loc', C', M', pc', ics')\n  \\<lbrakk>?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics);\n   distinct (?C' # ics_classes ?ics)\\<rbrakk>\n  \\<Longrightarrow> ?P,?h,?sh(?C' \\<mapsto>\n                    (?sfs, ?i')) \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  frs = f' # frs'\n  distinct (C # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (sfs, i'))) (ST, LT) ins f'", "by(auto simp: conf_f_def2 fun_upd_apply)"], ["proof (state)\nthis:\n  conf_f P h (sh(C \\<mapsto> (sfs, i'))) (ST, LT) ins f'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "have confs': \"conf_fs P h ?sh \\<Phi> C' M' (size Ts) T frs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (sfs, i'))) \\<Phi> C' M' (length Ts) T frs'", "by(rule conf_fs_shupd[OF confs dist'])"], ["proof (state)\nthis:\n  conf_fs P h (sh(C \\<mapsto> (sfs, i'))) \\<Phi> C' M' (length Ts) T frs'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "have confc': \"conf_clinit P ?sh frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C \\<mapsto> (sfs, i'))) frs", "by(rule conf_clinit_shupd[OF confc dist])"], ["proof (state)\nthis:\n  conf_clinit P (sh(C \\<mapsto> (sfs, i'))) frs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]\n 2. \\<And>a list.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "with h_ok sh_ok' meth ty conf' confs' f' Cons None"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (sfs, i')) \\<surd>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (sh(C \\<mapsto> (sfs, i'))) (ST, LT) ins f'\n  conf_fs P h (sh(C \\<mapsto> (sfs, i'))) \\<Phi> C' M' (length Ts) T frs'\n  f' = (stk', loc', C', M', pc', ics')\n  frs = f' # frs'\n  xp = None\n  conf_clinit P (sh(C \\<mapsto> (sfs, i'))) frs", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (sfs, i')) \\<surd>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (sh(C \\<mapsto> (sfs, i'))) (ST, LT) ins f'\n  conf_fs P h (sh(C \\<mapsto> (sfs, i'))) \\<Phi> C' M' (length Ts) T frs'\n  f' = (stk', loc', C', M', pc', ics')\n  frs = f' # frs'\n  xp = None\n  conf_clinit P (sh(C \\<mapsto> (sfs, i'))) frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto> (sfs, i'))) [ok]", "by(fastforce simp: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto> (sfs, i'))) [ok]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>; distinct (C # clinit_classes frs);\n     xp = None; frs = []\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n                                   (sfs, i'))) [ok]", "qed(simp add: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto> (sfs, i'))) [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>P,\\<Phi> |- (xp, h, frs, sh) [ok];\n        sh C = \\<lfloor>(sfs, i)\\<rfloor>;\n        distinct (C # clinit_classes frs); xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (xp, h, frs, sh(C \\<mapsto>\n(sfs, i'))) [ok]", "qed(simp add: correct_state_def)"], ["", "lemma correct_state_Throwing_ex:\nassumes correct: \"P,\\<Phi> \\<turnstile> (xp,h,(stk,loc,C,M,pc,ics)#frs,sh)\\<surd>\"\nshows \"\\<And>Cs a. ics = Throwing Cs a \\<Longrightarrow> \\<exists>obj. h a = Some obj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cs a.\n       ics = Throwing Cs a \\<Longrightarrow>\n       \\<exists>obj. h a = \\<lfloor>obj\\<rfloor>", "using correct"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (xp, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. \\<And>Cs a.\n       ics = Throwing Cs a \\<Longrightarrow>\n       \\<exists>obj. h a = \\<lfloor>obj\\<rfloor>", "by(clarsimp simp: correct_state_def conf_f_def)"], ["", "end"]]}