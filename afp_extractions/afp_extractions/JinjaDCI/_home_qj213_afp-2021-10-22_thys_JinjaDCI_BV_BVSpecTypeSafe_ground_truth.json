{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/BV/BVSpecTypeSafe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemmas defs1 = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def", "lemmas widen_rules [intro] = conf_widen confT_widen confs_widens confTs_widen", "lemma Invoke_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invoke n M) pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\"", "lemma Invokestatic_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invokestatic C\\<^sub>0 n M) pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\"", "lemma Called_set_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> i \\<in> Called_set \\<Longrightarrow>\n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P i pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\"", "lemma uncaught_xcpt_correct:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes h:  \"h xcp = Some obj\"\n  shows \"\\<And>f. P,\\<Phi> \\<turnstile> (None, h, f#frs, sh)\\<surd>\n     \\<Longrightarrow> curr_method f \\<noteq> clinit \\<Longrightarrow> P,\\<Phi> \\<turnstile> find_handler P xcp h frs sh \\<surd>\" \n  (is \"\\<And>f. ?correct (None, h, f#frs, sh) \\<Longrightarrow> ?prem f \\<Longrightarrow> ?correct (?find frs)\")", "lemma exec_instr_xcpt_h:\n  \"\\<lbrakk>  fst (exec_instr (ins!pc) P h stk vars C M pc ics frs sh) = Some xcp;\n       P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n       P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>obj. h xcp = Some obj\" \n  (is \"\\<lbrakk> ?xcpt; ?wt; ?correct \\<rbrakk> \\<Longrightarrow> ?thesis\")", "lemma exec_step_xcpt_h:\nassumes xcpt: \"fst (exec_step P h stk vars C M pc ics frs sh) = Some xcp\"\n and ins: \"instrs_of P C M = ins\"\n and wti: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n and correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\nshows \"\\<exists>obj. h xcp = Some obj\"", "lemma conf_sys_xcpt:\n  \"\\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> Addr (addr_of_sys_xcpt C) :\\<le> Class C\"", "lemma match_ex_table_SomeD:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set xt. matches_ex_entry P C pc (f,t,D,h,d) \\<and> h = pc' \\<and> d=d'\"", "lemma xcpt_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtp:  \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes xp:   \"fst (exec_step P h stk loc C M pc ics frs sh) = Some xcp\"\n  assumes s':   \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Calling_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes ics: \"ics = Calling C' Cs\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Throwing_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes ics: \"ics = Throwing (C'#Cs) a\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Called_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes ics[simp]: \"ics = Called (C'#Cs)\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Invoke_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invoke M' n\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes no_xcp: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Invokestatic_nInit_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invokestatic D M' n\" and nclinit: \"M' \\<noteq> clinit\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes no_xcp: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh (fst(method P D M')) = Some(sfs, Done)))\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Invokestatic_Init_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invokestatic D M' n\" and nclinit: \"M' \\<noteq> clinit\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes no_xcp: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh (fst(method P D M')) \\<noteq> Some(sfs, Done)\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Return_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wt_prog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins: \"ins ! pc = Return\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Load_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Load idx; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh); \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Store_correct:\n\"\\<lbrakk> wf_prog wt P;\n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C;\n  ins!pc = Store idx;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh);\n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Push_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Push v;\n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh);\n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Cast_conf2:\n  \"\\<lbrakk> wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T; cast_ok P C h v; \n     P \\<turnstile> Class C \\<le> T'; is_class P C\\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\"", "lemma Checkcast_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Checkcast D; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>;\n    fst (exec_step P h stk loc C M pc ics frs sh) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P", "lemma Getfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Getstatic_nInit_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh (fst(field P D F)) = Some(sfs, Done)))\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Getstatic_Init_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh (fst(field P D F)) \\<noteq> Some(sfs, Done)\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Putfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Putstatic_nInit_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh (fst(field P D F)) = Some(sfs, Done)))\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Putstatic_Init_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh (fst(field P D F)) \\<noteq> Some(sfs, Done)\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma oconf_blank2 [intro, simp]:\n    \"\\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>\"", "lemma obj_ty_blank [iff]: \"obj_ty (blank P C) = Class C\"", "lemma New_nInit_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes no_x: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh X = Some(sfs, Done)))\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma New_Init_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes no_x: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh X \\<noteq> Some(sfs, Done)\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Goto_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Goto branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma IfFalse_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IfFalse branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma CmpEq_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = CmpEq;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Pop_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Pop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma IAdd_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IAdd; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Throw_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Throw; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>;\n  fst (exec_step P h stk loc C M pc ics frs sh) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma step_correct:\nfixes \\<sigma>' :: jvm_state\nassumes wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n and meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n and exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n and conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\nshows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma correct_state_impl_Some_method:\n  \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \n  \\<Longrightarrow> \\<exists>b m Ts T. P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in C\"", "lemma BV_correct_1 [rule_format]:\n\"\\<And>\\<sigma>. \\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> \\<sigma>\\<surd>\\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "theorem progress:\n  \"\\<lbrakk> xp=None; frs\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs,sh) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\"", "lemma progress_conform:\n  \"\\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> (xp,h,frs,sh)\\<surd>; xp=None; frs\\<noteq>[]\\<rbrakk> \n  \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs,sh) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<and> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "theorem BV_correct [rule_format]:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>\\<surd> \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma hconf_start:   \n  assumes wf: \"wf_prog wf_mb P\"\n  shows \"P \\<turnstile> (start_heap P) \\<surd>\"", "lemma shconf_start:   \n  \"\\<not> is_class P Start \\<Longrightarrow> P,start_heap P \\<turnstile>\\<^sub>s start_sheap \\<surd>\"", "lemma BV_correct_initial: \n  shows \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not>is_class P Start;\n     P \\<turnstile> C sees M,Static:[]\\<rightarrow>Void = m in C; M \\<noteq> clinit;\n     \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m \\<rbrakk>\n  \\<Longrightarrow> start_prog P C M,\\<Phi>' \\<turnstile> start_state P \\<surd>\"", "theorem typesafe:\n  assumes welltyped:   \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes nstart:      \"\\<not> is_class P Start\"\n  assumes main_method: \"P \\<turnstile> C sees M,Static:[]\\<rightarrow>Void = m in C\"\n  assumes nclinit:     \"M \\<noteq> clinit\"\n  assumes \\<Phi>:           \"\\<And>C. C \\<noteq> Start \\<Longrightarrow> \\<Phi>' C = \\<Phi> C\"\n  assumes \\<Phi>':          \"\\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\" \"\\<Phi>' Start clinit = start_\\<phi>\\<^sub>m\"\n  assumes Obj_start_m:\n    \"(\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void)\"\n  shows \"start_prog P C M \\<turnstile> start_state P -jvm\\<rightarrow> \\<sigma>  \\<Longrightarrow>  start_prog P C M,\\<Phi>' \\<turnstile> \\<sigma> \\<surd>\""], "translations": [["", "lemmas defs1 = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def"], ["", "lemmas widen_rules [intro] = conf_widen confT_widen confs_widens confTs_widen"], ["", "subsection \\<open> Exception Handling \\<close>"], ["", "text \\<open>\n  For the @{text Invoke} instruction the BV has checked all handlers\n  that guard the current @{text pc}.\n\\<close>"], ["", "lemma Invoke_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invoke n M) pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n    \\<exists>(f, t, D, h, d)\n             \\<in>set (relevant_entries P (Invoke n M) pc xt).\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n       pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "by (induct xt) (auto simp: relevant_entries_def matches_ex_entry_def \n                                 is_relevant_entry_def split: if_split_asm)"], ["", "text \\<open>\n  For the @{text Invokestatic} instruction the BV has checked all handlers\n  that guard the current @{text pc}.\n\\<close>"], ["", "lemma Invokestatic_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invokestatic C\\<^sub>0 n M) pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n    \\<exists>(f, t, D, h, d)\n             \\<in>set (relevant_entries P (Invokestatic C\\<^sub>0 n M) pc\n                        xt).\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n       pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "by (induct xt) (auto simp: relevant_entries_def matches_ex_entry_def \n                                 is_relevant_entry_def split: if_split_asm)"], ["", "text \\<open>\n  For the instrs in @{text Called_set} the BV has checked all handlers\n  that guard the current @{text pc}.\n\\<close>"], ["", "lemma Called_set_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> i \\<in> Called_set \\<Longrightarrow>\n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P i pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor>;\n     i \\<in> Called_set\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(f, t, D, h, d)\n                               \\<in>set (relevant_entries P i pc xt).\n                         P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n                         pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "by (induct xt) (auto simp: relevant_entries_def matches_ex_entry_def \n                                 is_relevant_entry_def split: if_split_asm)"], ["", "text \\<open>\n  We can prove separately that the recursive search for exception\n  handlers (@{text find_handler}) in the frame stack results in \n  a conforming state (if there was no matching exception handler \n  in the current frame). We require that the exception is a valid\n  heap address, and that the state before the exception occurred\n  conforms. \n\\<close>"], ["", "lemma uncaught_xcpt_correct:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes h:  \"h xcp = Some obj\"\n  shows \"\\<And>f. P,\\<Phi> \\<turnstile> (None, h, f#frs, sh)\\<surd>\n     \\<Longrightarrow> curr_method f \\<noteq> clinit \\<Longrightarrow> P,\\<Phi> \\<turnstile> find_handler P xcp h frs sh \\<surd>\" \n  (is \"\\<And>f. ?correct (None, h, f#frs, sh) \\<Longrightarrow> ?prem f \\<Longrightarrow> ?correct (?find frs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "proof (induct frs) \n  \\<comment> \\<open>the base\n case is trivial as it should be\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>P,\\<Phi> |- (None, h, [f], sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h [] sh [ok]\n 2. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "show \"?correct (?find [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h [] sh [ok]", "by (simp add: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h [] sh [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "next\n  \\<comment> \\<open>we will need both forms @{text wf_jvm_prog} and @{text wf_prog} later\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "from wt"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain mb where wf: \"wf_prog mb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>mb. wf_prog mb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)\n\n  \\<comment> \\<open>the assumptions for the cons case:\\<close>"], ["proof (state)\nthis:\n  wf_prog mb P\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "fix f f' frs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "assume cr: \"?correct (None, h, f#f'#frs', sh)\""], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h, f # f' # frs', sh) [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "assume pr: \"?prem f\"\n\n  \\<comment> \\<open>the induction hypothesis:\\<close>"], ["proof (state)\nthis:\n  curr_method f \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "assume IH: \"\\<And>f. ?correct (None, h, f#frs', sh) \\<Longrightarrow> ?prem f \\<Longrightarrow> ?correct (?find frs')\""], ["proof (state)\nthis:\n  \\<lbrakk>P,\\<Phi> |- (None, h, ?f # frs', sh) [ok];\n   curr_method ?f \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "from cr pr conf_clinit_Cons[where frs=\"f'#frs'\" and f=f]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f # f' # frs', sh) [ok]\n  curr_method f \\<noteq> clinit\n  conf_clinit ?P ?sh (f # f' # frs') \\<Longrightarrow>\n  conf_clinit ?P ?sh (f' # frs')", "obtain\n        confc: \"conf_clinit P sh (f'#frs')\"\n    and cr': \"?correct (None, h, f'#frs', sh)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f # f' # frs', sh) [ok]\n  curr_method f \\<noteq> clinit\n  conf_clinit ?P ?sh (f # f' # frs') \\<Longrightarrow>\n  conf_clinit ?P ?sh (f' # frs')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>conf_clinit P sh (f' # frs');\n      P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp: correct_state_def)"], ["proof (state)\nthis:\n  conf_clinit P sh (f' # frs')\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "obtain stk loc C M pc ics where [simp]: \"f' = (stk,loc,C,M,pc,ics)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc C M pc ics.\n        f' = (stk, loc, C, M, pc, ics) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases f')"], ["proof (state)\nthis:\n  f' = (stk, loc, C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "from cr'"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]", "obtain b Ts T mxs mxl\\<^sub>0 ins xt where\n    meth: \"P \\<turnstile> C sees M,b:Ts \\<rightarrow> T = (mxs,mxl\\<^sub>0,ins,xt) in C\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>b Ts T mxs mxl\\<^sub>0 ins xt.\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: correct_state_def, blast)"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "hence xt[simp]: \"ex_table_of P C M = xt\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. ex_table_of P C M = xt", "by simp"], ["proof (state)\nthis:\n  ex_table_of P C M = xt\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "have cls: \"is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P C", "by(rule sees_method_is_class'[OF meth])"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "from cr'"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]", "obtain sfs where\n    sfs: \"M = clinit \\<Longrightarrow> sh C = Some(sfs,Processing)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>sfs.\n        (M = clinit \\<Longrightarrow>\n         sh C = \\<lfloor>(sfs, Processing)\\<rfloor>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp: defs1 conf_clinit_def)"], ["proof (state)\nthis:\n  M = clinit \\<Longrightarrow> sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>P,\\<Phi> |- (None, h, f # frs, sh) [ok];\n                    curr_method f \\<noteq> clinit\\<rbrakk>\n                   \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs\n            sh [ok];\n        P,\\<Phi> |- (None, h, f # a # frs, sh) [ok];\n        curr_method f \\<noteq> clinit\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) sh [ok]", "show \"?correct (?find (f'#frs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "proof (cases \"match_ex_table P (cname_of h xcp) pc xt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n 2. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "case None"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (2 subgoals):\n 1. match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n 2. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "with cr' IH[of f']"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n   curr_method f' \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok]\n  match_ex_table P (cname_of h xcp) pc xt = None", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n   curr_method f' \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok]\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "proof(cases \"M=clinit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n     \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n      curr_method f' \\<noteq> clinit\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok];\n     match_ex_table P (cname_of h xcp) pc xt = None; M = clinit\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n 2. \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n     \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n      curr_method f' \\<noteq> clinit\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok];\n     match_ex_table P (cname_of h xcp) pc xt = None;\n     M \\<noteq> clinit\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "case True"], ["proof (state)\nthis:\n  M = clinit\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n     \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n      curr_method f' \\<noteq> clinit\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok];\n     match_ex_table P (cname_of h xcp) pc xt = None; M = clinit\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n 2. \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n     \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n      curr_method f' \\<noteq> clinit\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok];\n     match_ex_table P (cname_of h xcp) pc xt = None;\n     M \\<noteq> clinit\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "then"], ["proof (chain)\npicking this:\n  M = clinit", "show ?thesis"], ["proof (prove)\nusing this:\n  M = clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "using xt cr' IH[of f'] None h conf_clinit_Called_Throwing\n        conf_f_Throwing[where h=h and sh=sh, OF _ cls h sfs]"], ["proof (prove)\nusing this:\n  M = clinit\n  ex_table_of P C M = xt\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n   curr_method f' \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok]\n  match_ex_table P (cname_of h xcp) pc xt = None\n  h xcp = \\<lfloor>obj\\<rfloor>\n  conf_clinit ?P ?sh\n   ((?stk', ?loc', ?C', clinit, ?pc', ?ics') #\n    (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) # ?fs) \\<Longrightarrow>\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, Throwing (?C' # ?Cs) ?xcp) # ?fs)\n  \\<lbrakk>conf_f P h sh (?ST, ?LT) ?is\n            (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs);\n   M = clinit\\<rbrakk>\n  \\<Longrightarrow> conf_f P h sh (?ST, ?LT) ?is\n                     (?stk, ?loc, ?C, ?M, ?pc, Throwing (C # ?Cs) xcp)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "by(cases frs', auto simp: correct_state_def image_iff) fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n     \\<lbrakk>P,\\<Phi> |- (None, h, f' # frs', sh) [ok];\n      curr_method f' \\<noteq> clinit\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h frs' sh [ok];\n     match_ex_table P (cname_of h xcp) pc xt = None;\n     M \\<noteq> clinit\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "qed(auto)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "fix pc_d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "assume \"match_ex_table P (cname_of h xcp) pc xt = Some pc_d\""], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "then"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>", "obtain pc' d' where \n      match: \"match_ex_table P (cname_of h xcp) pc xt = Some (pc',d')\"\n      (is \"?match (cname_of h xcp) = _\")"], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>pc' d'.\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases pc_d) auto"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "from wt meth cr' [simplified]"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs', sh) [ok]", "have wti: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs', sh) [ok]\n\ngoal (1 subgoal):\n 1. P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "by (fastforce simp: correct_state_def conf_f_def\n                   dest: sees_method_fun\n                   elim!: wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "from cr'"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]", "obtain ST LT where \\<Phi>: \"\\<Phi> C M ! pc = Some (ST, LT)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: sees_method_fun simp: correct_state_def)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "from cr' \\<Phi> meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "have conf': \"conf_f P h sh (ST, LT) ins f'\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST, LT) ins f'", "by (unfold correct_state_def) (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  conf_f P h sh (ST, LT) ins f'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "hence loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and \n          stk: \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins f'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT &&&\n    P,h \\<turnstile> stk [:\\<le>] ST", "by (unfold conf_f_def) auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "hence [simp]: \"size stk = size ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. length stk = length ST", "by (simp add: list_all2_lengthD)"], ["proof (state)\nthis:\n  length stk = length ST\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "from cr meth pr"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f # f' # frs', sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  curr_method f \\<noteq> clinit", "obtain D n M' where\n      ins: \"ins!pc = Invoke n M' \\<or> ins!pc = Invokestatic D n M'\" (is \"_ = ?i \\<or> _ = ?i'\")"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f # f' # frs', sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  curr_method f \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. (\\<And>n M' D.\n        ins ! pc = Invoke n M' \\<or>\n        ins ! pc = Invokestatic D n M' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: sees_method_fun simp: correct_state_def)"], ["proof (state)\nthis:\n  ins ! pc = Invoke n M' \\<or> ins ! pc = Invokestatic D n M'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "with match"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  ins ! pc = Invoke n M' \\<or> ins ! pc = Invokestatic D n M'", "obtain f1 t D where\n      rel: \"(f1,t,D,pc',d') \\<in> set (relevant_entries P (ins!pc) pc xt)\" and\n      D: \"P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  ins ! pc = Invoke n M' \\<or> ins ! pc = Invokestatic D n M'\n\ngoal (1 subgoal):\n 1. (\\<And>f1 t D.\n        \\<lbrakk>(f1, t, D, pc', d')\n                 \\<in> set (relevant_entries P (ins ! pc) pc xt);\n         P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: Invoke_handlers Invokestatic_handlers)"], ["proof (state)\nthis:\n  (f1, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "from rel"], ["proof (chain)\npicking this:\n  (f1, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)", "have \n      \"(pc', Some (Class D # drop (size ST - d') ST, LT)) \\<in> set (xcpt_eff (ins!pc) P pc (ST,LT) xt)\"\n      (is \"(_, Some (?ST',_)) \\<in> _\")"], ["proof (prove)\nusing this:\n  (f1, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n\ngoal (1 subgoal):\n 1. (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n    \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)", "by (force simp: xcpt_eff_def image_def)"], ["proof (state)\nthis:\n  (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n  \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "with wti \\<Phi>"], ["proof (chain)\npicking this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n  \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)", "obtain \n      pc: \"pc' < size ins\" and\n      \"P \\<turnstile> Some (?ST', LT) \\<le>' \\<Phi> C M ! pc'\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n  \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>pc' < length ins;\n      P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                               LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: defs1) blast"], ["proof (state)\nthis:\n  pc' < length ins\n  P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                           LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "then"], ["proof (chain)\npicking this:\n  pc' < length ins\n  P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                           LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'", "obtain ST' LT' where\n      \\<Phi>': \"\\<Phi> C M ! pc' = Some (ST',LT')\" and\n      less: \"P \\<turnstile> (?ST', LT) \\<le>\\<^sub>i (ST',LT')\""], ["proof (prove)\nusing this:\n  pc' < length ins\n  P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                           LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Class D # drop (length ST - d') ST,\n                         LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "let ?f = \"(Addr xcp # drop (length stk - d') stk, loc, C, M, pc',No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "have \"conf_f P h sh (ST',LT') ins ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "from wf less loc"], ["proof (chain)\npicking this:\n  wf_prog mb P\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  wf_prog mb P\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by simp blast"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "from D h"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  h xcp = \\<lfloor>obj\\<rfloor>", "have \"P,h \\<turnstile> Addr xcp :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr xcp :\\<le> Class D", "by (simp add: conf_def obj_ty_def case_prod_unfold)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "with less stk"], ["proof (chain)\npicking this:\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> Addr xcp :\\<le> Class D", "have \"P,h \\<turnstile> Addr xcp # drop (length stk - d') stk  [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'", "by (auto intro!: list_all2_dropI)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "using pc conf'"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'\n  pc' < length ins\n  conf_f P h sh (ST, LT) ins f'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "by(auto simp: conf_f_def)"], ["proof (state)\nthis:\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "with cr' match \\<Phi>' meth pc"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  pc' < length ins\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs', sh) [ok]\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  pc' < length ins\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]", "by (unfold correct_state_def)\n                    (cases \"M=clinit\"; fastforce dest: sees_method_fun simp: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') sh [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text \\<open>\n  The requirement of lemma @{text uncaught_xcpt_correct} (that\n  the exception is a valid reference on the heap) is always met\n  for welltyped instructions and conformant states:\n\\<close>"], ["", "lemma exec_instr_xcpt_h:\n  \"\\<lbrakk>  fst (exec_instr (ins!pc) P h stk vars C M pc ics frs sh) = Some xcp;\n       P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n       P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>obj. h xcp = Some obj\" \n  (is \"\\<lbrakk> ?xcpt; ?wt; ?correct \\<rbrakk> \\<Longrightarrow> ?thesis\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "note [simp] = split_beta"], ["proof (state)\nthis:\n  (case ?prod of (x, xa) \\<Rightarrow> ?f x xa) = ?f (fst ?prod) (snd ?prod)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "note [split] = if_split_asm option.split_asm"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  (\\<not> (?Q \\<and> \\<not> ?P ?x \\<or> \\<not> ?Q \\<and> \\<not> ?P ?y))\n  ?P (case ?option of None \\<Rightarrow> ?f1.0\n      | \\<lfloor>x\\<rfloor> \\<Rightarrow> ?f2.0 x) =\n  (\\<not> (?option = None \\<and> \\<not> ?P ?f1.0 \\<or>\n           (\\<exists>x2.\n               ?option = \\<lfloor>x2\\<rfloor> \\<and> \\<not> ?P (?f2.0 x2))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume wt: ?wt ?correct"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "hence pre: \"preallocated h\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. preallocated h", "by (simp add: correct_state_def hconf_def)"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume xcpt: ?xcpt"], ["proof (state)\nthis:\n  fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n  \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with exec_instr_xcpts"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<sigma>' =\n           exec_instr ?i ?P ?h ?stk ?loc ?C ?M ?pc ?ics' ?frs ?sh;\n   fst ?\\<sigma>' = \\<lfloor>?a\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ?i = Throw \\<or>\n                    ?a \\<in> {a. \\<exists>x\\<in>sys_xcpts.\n                                    a = addr_of_sys_xcpt x}\n  fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n  \\<lfloor>xcp\\<rfloor>", "have\n   opt: \"ins!pc = Throw \\<or> xcp \\<in> {a. \\<exists>x \\<in> sys_xcpts. a = addr_of_sys_xcpt x}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<sigma>' =\n           exec_instr ?i ?P ?h ?stk ?loc ?C ?M ?pc ?ics' ?frs ?sh;\n   fst ?\\<sigma>' = \\<lfloor>?a\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> ?i = Throw \\<or>\n                    ?a \\<in> {a. \\<exists>x\\<in>sys_xcpts.\n                                    a = addr_of_sys_xcpt x}\n  fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n  \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. ins ! pc = Throw \\<or>\n    xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x}", "by simp"], ["proof (state)\nthis:\n  ins ! pc = Throw \\<or>\n  xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with pre"], ["proof (chain)\npicking this:\n  preallocated h\n  ins ! pc = Throw \\<or>\n  xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x}", "show ?thesis"], ["proof (prove)\nusing this:\n  preallocated h\n  ins ! pc = Throw \\<or>\n  xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x}\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "proof (cases \"ins!pc\")"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 5. \\<And>x51 x52.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 7. \\<And>x71 x72.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 9. \\<And>x9.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 10. \\<And>x101 x102.\n        \\<lbrakk>preallocated h;\n         ins ! pc = Throw \\<or>\n         xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\nA total of 18 subgoals...", "case Throw"], ["proof (state)\nthis:\n  ins ! pc = Throw\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 5. \\<And>x51 x52.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 7. \\<And>x71 x72.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 9. \\<And>x9.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 10. \\<And>x101 x102.\n        \\<lbrakk>preallocated h;\n         ins ! pc = Throw \\<or>\n         xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\nA total of 18 subgoals...", "with xcpt wt pre"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n  \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  preallocated h\n  ins ! pc = Throw", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk vars C M pc ics frs sh) =\n  \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  preallocated h\n  ins ! pc = Throw\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "by (clarsimp iff: list_all2_Cons2 simp: defs1) \n         (auto dest: non_npD simp: is_refT_def elim: preallocatedE)"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 5. \\<And>x51 x52.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 7. \\<And>x71 x72.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 9. \\<And>x9.\n       \\<lbrakk>preallocated h;\n        ins ! pc = Throw \\<or>\n        xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n        ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 10. \\<And>x101 x102.\n        \\<lbrakk>preallocated h;\n         ins ! pc = Throw \\<or>\n         xcp \\<in> {a. \\<exists>x\\<in>sys_xcpts. a = addr_of_sys_xcpt x};\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\nA total of 17 subgoals...", "qed (auto elim: preallocatedE)"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma exec_step_xcpt_h:\nassumes xcpt: \"fst (exec_step P h stk vars C M pc ics frs sh) = Some xcp\"\n and ins: \"instrs_of P C M = ins\"\n and wti: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n and correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\nshows \"\\<exists>obj. h xcp = Some obj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "from correct"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "have pre: \"preallocated h\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. preallocated h", "by(simp add: defs1 hconf_def)"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "{"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "fix C' Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume ics[simp]: \"ics = Calling C' Cs\""], ["proof (state)\nthis:\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with xcpt"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk vars C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Calling C' Cs", "have \"xcp = addr_of_sys_xcpt NoClassDefFoundError\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk vars C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt NoClassDefFoundError", "by(cases ics, auto simp: split_beta split: init_state.splits if_split_asm)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt NoClassDefFoundError\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with pre"], ["proof (chain)\npicking this:\n  preallocated h\n  xcp = addr_of_sys_xcpt NoClassDefFoundError", "have ?thesis"], ["proof (prove)\nusing this:\n  preallocated h\n  xcp = addr_of_sys_xcpt NoClassDefFoundError\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "using preallocated_def"], ["proof (prove)\nusing this:\n  preallocated h\n  xcp = addr_of_sys_xcpt NoClassDefFoundError\n  preallocated ?h \\<equiv>\n  \\<forall>C\\<in>sys_xcpts.\n     \\<exists>fs. ?h (addr_of_sys_xcpt C) = \\<lfloor>(C, fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "by force"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "}"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "{"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "fix Cs a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume [simp]: \"ics = Throwing Cs a\""], ["proof (state)\nthis:\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with xcpt"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk vars C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing Cs a", "have eq: \"a = xcp\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk vars C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. a = xcp", "by(cases Cs; simp)"], ["proof (state)\nthis:\n  a = xcp\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "from correct"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "have \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "by(auto simp: defs1)"], ["proof (state)\nthis:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with eq"], ["proof (chain)\npicking this:\n  a = xcp\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "have ?thesis"], ["proof (prove)\nusing this:\n  a = xcp\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "}"], ["proof (state)\nthis:\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "{"], ["proof (state)\nthis:\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "fix Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume ics: \"ics = No_ics \\<or> ics = Called Cs\""], ["proof (state)\nthis:\n  ics = No_ics \\<or> ics = Called Cs\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with exec_instr_xcpt_h[OF _ wti correct] xcpt ins"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk ?vars C M pc ics frs sh) =\n  \\<lfloor>?xcp\\<rfloor> \\<Longrightarrow>\n  \\<exists>obj. h ?xcp = \\<lfloor>obj\\<rfloor>\n  fst (exec_step P h stk vars C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  instrs_of P C M = ins\n  ics = No_ics \\<or> ics = Called Cs", "have ?thesis"], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk ?vars C M pc ics frs sh) =\n  \\<lfloor>?xcp\\<rfloor> \\<Longrightarrow>\n  \\<exists>obj. h ?xcp = \\<lfloor>obj\\<rfloor>\n  fst (exec_step P h stk vars C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  instrs_of P C M = ins\n  ics = No_ics \\<or> ics = Called Cs\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "}"], ["proof (state)\nthis:\n  ics = No_ics \\<or> ics = Called ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n  ics = No_ics \\<or> ics = Called ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n  ics = No_ics \\<or> ics = Called ?Cs2 \\<Longrightarrow>\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "by(cases ics, auto)"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conf_sys_xcpt:\n  \"\\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> Addr (addr_of_sys_xcpt C) :\\<le> Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> Addr\n  (addr_of_sys_xcpt C) :\\<le> Class C", "by (auto elim: preallocatedE)"], ["", "lemma match_ex_table_SomeD:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set xt. matches_ex_entry P C pc (f,t,D,h,d) \\<and> h = pc' \\<and> d=d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n    \\<exists>(f, t, D, h, d)\\<in>set xt.\n       matches_ex_entry P C pc (f, t, D, h, d) \\<and> h = pc' \\<and> d = d'", "by (induct xt) (auto split: if_split_asm)"], ["", "text \\<open>\n  Finally we can state that, whenever an exception occurs, the\n  next state always conforms:\n\\<close>"], ["", "lemma xcpt_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtp:  \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes xp:   \"fst (exec_step P h stk loc C M pc ics frs sh) = Some xcp\"\n  assumes s':   \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtp"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "have ins[simp]: \"instrs_of P C M = ins\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. instrs_of P C M = ins", "by simp"], ["proof (state)\nthis:\n  instrs_of P C M = ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have cls: \"is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P C", "by(rule sees_method_is_class[OF meth])"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain sfs where\n    sfs: \"M = clinit \\<Longrightarrow> sh C = Some(sfs,Processing)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>sfs.\n        (M = clinit \\<Longrightarrow>\n         sh C = \\<lfloor>(sfs, Processing)\\<rfloor>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: correct_state_def conf_clinit_def conf_f_def2)"], ["proof (state)\nthis:\n  M = clinit \\<Longrightarrow> sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note conf_sys_xcpt [elim!]"], ["proof (state)\nthis:\n  \\<lbrakk>preallocated ?h; ?C \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> ?P,?h \\<turnstile> Addr\n  (addr_of_sys_xcpt ?C) :\\<le> Class ?C\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note xp' = meth s' xp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain ST LT where\n    h_ok:  \"P \\<turnstile> h \\<surd>\" and\n    sh_ok:  \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>_pc: \"\\<Phi> C M ! pc = Some (ST, LT)\" and\n    frame:  \"conf_f P h sh (ST,LT) ins (stk,loc,C,M,pc,ics)\" and\n    frames: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\" and\n    vics: \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs);\n         P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: defs1 dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)", "obtain \n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and\n    loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc:  \"pc < size ins\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n      pc < length ins\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold conf_f_def) auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h_ok"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>", "have preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n\ngoal (1 subgoal):\n 1. preallocated h", "by (simp add: hconf_def)"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note wtp"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from exec_step_xcpt_h[OF xp ins wt correct]"], ["proof (chain)\npicking this:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "obtain obj where h: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by clarify"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note correct"], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  h xcp = \\<lfloor>obj\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "have fh: \"curr_method (stk,loc,C,M,pc,ics) \\<noteq> clinit\n    \\<Longrightarrow> P,\\<Phi> \\<turnstile> find_handler P xcp h frs sh \\<surd>\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  h xcp = \\<lfloor>obj\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. curr_method (stk, loc, C, M, pc, ics) \\<noteq> clinit \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "by (rule uncaught_xcpt_correct)"], ["proof (state)\nthis:\n  curr_method (stk, loc, C, M, pc, ics) \\<noteq> clinit \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with xp'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  curr_method (stk, loc, C, M, pc, ics) \\<noteq> clinit \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "have \"M \\<noteq> clinit \\<Longrightarrow> \\<forall>Cs a. ics \\<noteq> Throwing Cs a\n   \\<Longrightarrow> match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow> ?thesis\" \n    (is \"?nc \\<Longrightarrow> ?t \\<Longrightarrow> ?m (cname_of h xcp) = _ \\<Longrightarrow> _\" is \"?nc \\<Longrightarrow> ?t \\<Longrightarrow> ?match = _ \\<Longrightarrow> _\")"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  curr_method (stk, loc, C, M, pc, ics) \\<noteq> clinit \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<noteq> clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n     match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "by(cases ics; simp add: split_beta)"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<noteq> clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<noteq> clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct xp' conf_clinit_Called_Throwing conf_f_Throwing[where h=h and sh=sh, OF _ cls h sfs]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  conf_clinit ?P ?sh\n   ((?stk', ?loc', ?C', clinit, ?pc', ?ics') #\n    (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) # ?fs) \\<Longrightarrow>\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, Throwing (?C' # ?Cs) ?xcp) # ?fs)\n  \\<lbrakk>conf_f P h sh (?ST, ?LT) ?is\n            (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs);\n   M = clinit\\<rbrakk>\n  \\<Longrightarrow> conf_f P h sh (?ST, ?LT) ?is\n                     (?stk, ?loc, ?C, ?M, ?pc, Throwing (C # ?Cs) xcp)", "have \"M = clinit \\<Longrightarrow> \\<forall>Cs a. ics \\<noteq> Throwing Cs a\n   \\<Longrightarrow> match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  conf_clinit ?P ?sh\n   ((?stk', ?loc', ?C', clinit, ?pc', ?ics') #\n    (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) # ?fs) \\<Longrightarrow>\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, Throwing (?C' # ?Cs) ?xcp) # ?fs)\n  \\<lbrakk>conf_f P h sh (?ST, ?LT) ?is\n            (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs);\n   M = clinit\\<rbrakk>\n  \\<Longrightarrow> conf_f P h sh (?ST, ?LT) ?is\n                     (?stk, ?loc, ?C, ?M, ?pc, Throwing (C # ?Cs) xcp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>M = clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n     match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "by(cases frs, auto simp: correct_state_def image_iff split_beta) fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>M = clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>M = clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  \\<lbrakk>M = clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix pc_d"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"?match = Some pc_d\""], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>", "obtain pc' d' where some_handler: \"?match = Some (pc',d')\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>pc' d'.\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases pc_d) auto"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have [simp]: \"size stk = size ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. length stk = length ST", ".."], ["proof (state)\nthis:\n  length stk = length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have\n      eff: \"\\<forall>(pc', s')\\<in>set (xcpt_eff (ins!pc) P pc (ST,LT) xt).\n             pc' < size ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M!pc'\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n       pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'", "by (auto simp: defs1)"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from some_handler"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>", "obtain f t D where\n      xt: \"(f,t,D,pc',d') \\<in> set xt\" and\n      \"matches_ex_entry P (cname_of h xcp) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>f t D.\n        \\<lbrakk>(f, t, D, pc', d') \\<in> set xt;\n         matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc', d')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: match_ex_table_SomeD)"], ["proof (state)\nthis:\n  (f, t, D, pc', d') \\<in> set xt\n  matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence match: \"P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\"  \"pc \\<in> {f..<t}\""], ["proof (prove)\nusing this:\n  (f, t, D, pc', d') \\<in> set xt\n  matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D &&& pc \\<in> {f..<t}", "by (auto simp: matches_ex_entry_def)"], ["proof (state)\nthis:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix C' Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume ics: \"ics = Calling C' Cs \\<or> ics = Called (C'#Cs)\""], ["proof (state)\nthis:\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?stk' = \"Addr xcp # drop (length stk - d') stk\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f = \"(?stk', loc, C, M, pc', No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from some_handler xp' ics"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)", "have \\<sigma>': \"\\<sigma>' = (None, h, ?f#frs, sh)\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n     sh)", "by (cases ics; simp add: split_beta)"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from xp ics"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)", "have \"xcp = addr_of_sys_xcpt NoClassDefFoundError\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt NoClassDefFoundError", "by(cases ics, auto simp: split_beta split: init_state.splits if_split_asm)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt NoClassDefFoundError\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with match preh"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NoClassDefFoundError", "have conf: \"P,h \\<turnstile> Addr xcp :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NoClassDefFoundError\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr xcp :\\<le> Class D", "by fastforce"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct ics"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)", "obtain C1 where \"Called_context P C1 (ins!pc)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n\ngoal (1 subgoal):\n 1. (\\<And>C1.\n        Called_context P C1 (ins ! pc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp: correct_state_def conf_f_def2)"], ["proof (state)\nthis:\n  Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  Called_context P C1 (ins ! pc)", "have \"ins!pc \\<in> Called_set\""], ["proof (prove)\nusing this:\n  Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. ins ! pc \\<in> Called_set", "by(rule Called_context_Called_set)"], ["proof (state)\nthis:\n  ins ! pc \\<in> Called_set\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with xt match"], ["proof (chain)\npicking this:\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc \\<in> Called_set", "have \"(f,t,D,pc',d') \\<in> set (relevant_entries P (ins!pc) pc xt)\""], ["proof (prove)\nusing this:\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc \\<in> Called_set\n\ngoal (1 subgoal):\n 1. (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)", "by(auto simp: relevant_entries_def is_relevant_entry_def)"], ["proof (state)\nthis:\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with eff"], ["proof (chain)\npicking this:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)", "obtain ST' LT' where\n        \\<Phi>_pc': \"\\<Phi> C M ! pc' = Some (ST', LT')\" and\n        pc':   \"pc' < size ins\" and\n        less:  \"P \\<turnstile> (Class D # drop (size ST - d') ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         pc' < length ins;\n         P \\<turnstile> (Class D # drop (length ST - d') ST,\n                         LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: xcpt_eff_def sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with conf loc stk conf_f_def2 frame ics"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  conf_f ?P ?h ?sh (?ST, ?LT) ?is (?stk, ?loc, ?C, ?M, ?pc, ?ics) \\<equiv>\n  ?P,?h \\<turnstile> ?stk [:\\<le>] ?ST \\<and>\n  ?P,?h \\<turnstile> ?loc [:\\<le>\\<^sub>\\<top>] ?LT \\<and>\n  ?pc < length ?is \\<and> ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')", "have \"conf_f P h sh (ST',LT') ins ?f\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  conf_f ?P ?h ?sh (?ST, ?LT) ?is (?stk, ?loc, ?C, ?M, ?pc, ?ics) \\<equiv>\n  ?P,?h \\<turnstile> ?stk [:\\<le>] ?ST \\<and>\n  ?P,?h \\<turnstile> ?loc [:\\<le>\\<^sub>\\<top>] ?LT \\<and>\n  ?pc < length ?is \\<and> ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "by (auto simp: defs1 intro: list_all2_dropI)"], ["proof (state)\nthis:\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with meth h_ok frames \\<Phi>_pc' \\<sigma>' sh_ok confc ics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<sigma>' =\n  (None, h,\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n   sh)\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<sigma>' =\n  (None, h,\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n   sh)\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs \\<or> ics = Called (C' # Cs)\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (unfold correct_state_def)\n           (auto dest: sees_method_fun conf_clinit_diff' sees_method_is_class; fastforce)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<or> ics = Called (?C'2 # ?Cs2) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<or> ics = Called (?C'2 # ?Cs2) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<or> ics = Called (?C'2 # ?Cs2) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume ics: \"ics = No_ics \\<or> ics = Called []\""], ["proof (state)\nthis:\n  ics = No_ics \\<or> ics = Called []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?stk' = \"Addr xcp # drop (length stk - d') stk\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f = \"(?stk', loc, C, M, pc', No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from some_handler xp' ics"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []", "have \\<sigma>': \"\\<sigma>' = (None, h, ?f#frs, sh)\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n     sh)", "by (cases ics; simp add: split_beta)"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from xp ics"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []", "obtain\n        \"(f,t,D,pc',d') \\<in> set (relevant_entries P (ins!pc) pc xt)\" and\n        conf: \"P,h \\<turnstile> Addr xcp :\\<le> Class D\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(f, t, D, pc', d')\n              \\<in> set (relevant_entries P (ins ! pc) pc xt);\n      P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"ins!pc\")"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 18 subgoals...", "case Return"], ["proof (state)\nthis:\n  ins ! pc = Return\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 18 subgoals...", "with xp ics"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Return", "have False"], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Return\n\ngoal (1 subgoal):\n 1. False", "by(cases ics; cases frs, auto simp: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 17 subgoals...", "case New"], ["proof (state)\nthis:\n  ins ! pc = New x4_\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 17 subgoals...", "with xp match"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = New x4_", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = New x4_\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 17 subgoals...", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 17 subgoals...", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_step_xcpt_h[OF _ ins])"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x101 x102.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 17 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 16 subgoals...", "case Getfield"], ["proof (state)\nthis:\n  ins ! pc = Getfield x51_ x52_\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 16 subgoals...", "with xp ics"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Getfield x51_ x52_", "have xcp: \"xcp = addr_of_sys_xcpt NullPointer \\<or> xcp = addr_of_sys_xcpt NoSuchFieldError\n          \\<or> xcp = addr_of_sys_xcpt IncompatibleClassChangeError\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Getfield x51_ x52_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt NullPointer \\<or>\n    xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n    xcp = addr_of_sys_xcpt IncompatibleClassChangeError", "by (cases ics; simp add: split_beta split: if_split_asm staticb.splits)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 16 subgoals...", "with Getfield match preh"], ["proof (chain)\npicking this:\n  ins ! pc = Getfield x51_ x52_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = Getfield x51_ x52_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (fastforce simp: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called [];\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 16 subgoals...", "with match preh xt xcp"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by(fastforce simp: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "case Getstatic"], ["proof (state)\nthis:\n  ins ! pc = Getstatic x61_ x62_ x63_\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "with xp match"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Getstatic x61_ x62_ x63_", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Getstatic x61_ x62_ x63_\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_step_xcpt_h[OF _ ins])"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62 x63.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "case Putfield"], ["proof (state)\nthis:\n  ins ! pc = Putfield x71_ x72_\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "with xp ics"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Putfield x71_ x72_", "have xcp: \"xcp = addr_of_sys_xcpt NullPointer \\<or> xcp = addr_of_sys_xcpt NoSuchFieldError\n          \\<or> xcp = addr_of_sys_xcpt IncompatibleClassChangeError\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Putfield x71_ x72_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt NullPointer \\<or>\n    xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n    xcp = addr_of_sys_xcpt IncompatibleClassChangeError", "by (cases ics; simp add: split_beta split: if_split_asm staticb.splits)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "with Putfield match preh"], ["proof (chain)\npicking this:\n  ins ! pc = Putfield x71_ x72_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = Putfield x71_ x72_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (fastforce simp: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x71 x72.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "with match preh xt xcp"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  xcp = addr_of_sys_xcpt NullPointer \\<or>\n  xcp = addr_of_sys_xcpt NoSuchFieldError \\<or>\n  xcp = addr_of_sys_xcpt IncompatibleClassChangeError\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x15.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x15.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "case Putstatic"], ["proof (state)\nthis:\n  ins ! pc = Putstatic x81_ x82_ x83_\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x15.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "with xp match"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Putstatic x81_ x82_ x83_", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Putstatic x81_ x82_ x83_\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x15.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x15.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_step_xcpt_h[OF _ ins])"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82 x83.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x15.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "case Checkcast"], ["proof (state)\nthis:\n  ins ! pc = Checkcast x9_\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "with xp ics"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Checkcast x9_", "have [simp]: \"xcp = addr_of_sys_xcpt ClassCast\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = No_ics \\<or> ics = Called []\n  ins ! pc = Checkcast x9_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt ClassCast", "by (cases ics; simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt ClassCast\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "with Checkcast match preh"], ["proof (chain)\npicking this:\n  ins ! pc = Checkcast x9_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt ClassCast", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = Checkcast x9_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt ClassCast\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x9.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "with match preh xt"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x17.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x17.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "case Invoke"], ["proof (state)\nthis:\n  ins ! pc = Invoke x101_ x102_\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x17.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "with xp match"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Invoke x101_ x102_", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Invoke x101_ x102_\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x17.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x17.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_step_xcpt_h[OF _ ins])"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x101 x102.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x17.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_step P h stk loc C M pc ics frs sh) =\n         \\<lfloor>xcp\\<rfloor>;\n         ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "case Invokestatic"], ["proof (state)\nthis:\n  ins ! pc = Invokestatic x111_ x112_ x113_\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "with xp match"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Invokestatic x111_ x112_ x113_", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Invokestatic x111_ x112_ x113_\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_step_xcpt_h[OF _ ins])"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x111 x112 x113.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called [];\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n      ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Throw"], ["proof (state)\nthis:\n  ins ! pc = Throw\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "with xp match preh"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  ins ! pc = Throw", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  ins ! pc = Throw\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_step_xcpt_h[OF _ ins])"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (8 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x15.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = Goto x15\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>;\n     ics = No_ics \\<or> ics = Called []; ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x17.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_step P h stk loc C M pc ics frs sh) =\n        \\<lfloor>xcp\\<rfloor>;\n        ics = No_ics \\<or> ics = Called []; ins ! pc = IfFalse x17\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed(cases ics, (auto)[5])+"], ["proof (state)\nthis:\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with eff"], ["proof (chain)\npicking this:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D", "obtain ST' LT' where\n        \\<Phi>_pc': \"\\<Phi> C M ! pc' = Some (ST', LT')\" and\n        pc':   \"pc' < size ins\" and\n        less:  \"P \\<turnstile> (Class D # drop (size ST - d') ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         pc' < length ins;\n         P \\<turnstile> (Class D # drop (length ST - d') ST,\n                         LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: xcpt_eff_def sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with conf loc stk conf_f_def2 frame ics"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  conf_f ?P ?h ?sh (?ST, ?LT) ?is (?stk, ?loc, ?C, ?M, ?pc, ?ics) \\<equiv>\n  ?P,?h \\<turnstile> ?stk [:\\<le>] ?ST \\<and>\n  ?P,?h \\<turnstile> ?loc [:\\<le>\\<^sub>\\<top>] ?LT \\<and>\n  ?pc < length ?is \\<and> ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = No_ics \\<or> ics = Called []\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')", "have \"conf_f P h sh (ST',LT') ins ?f\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  conf_f ?P ?h ?sh (?ST, ?LT) ?is (?stk, ?loc, ?C, ?M, ?pc, ?ics) \\<equiv>\n  ?P,?h \\<turnstile> ?stk [:\\<le>] ?ST \\<and>\n  ?P,?h \\<turnstile> ?loc [:\\<le>\\<^sub>\\<top>] ?LT \\<and>\n  ?pc < length ?is \\<and> ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = No_ics \\<or> ics = Called []\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "by (auto simp: defs1 intro: list_all2_dropI)"], ["proof (state)\nthis:\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with meth h_ok frames \\<Phi>_pc' \\<sigma>' sh_ok confc ics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<sigma>' =\n  (None, h,\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n   sh)\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = No_ics \\<or> ics = Called []\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<sigma>' =\n  (None, h,\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics) # frs,\n   sh)\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = No_ics \\<or> ics = Called []\n  conf_f P h sh (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc', No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (unfold correct_state_def) (auto dest: sees_method_fun conf_clinit_diff'; fastforce)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = No_ics \\<or> ics = Called [] \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ics = Calling ?C'2 ?Cs2 \\<or> ics = Called (?C'2 # ?Cs2) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ics = No_ics \\<or> ics = Called [] \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]", "have \"\\<forall>Cs a. ics \\<noteq> Throwing Cs a \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  ics = Calling ?C'2 ?Cs2 \\<or> ics = Called (?C'2 # ?Cs2) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ics = No_ics \\<or> ics = Called [] \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<forall>Cs a. ics \\<noteq> Throwing Cs a \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "by(cases ics; metis list.exhaust)"], ["proof (state)\nthis:\n  \\<forall>Cs a. ics \\<noteq> Throwing Cs a \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>match_ex_table P (cname_of h xcp) pc xt =\n           \\<lfloor>?pc_d2\\<rfloor>;\n   \\<forall>Cs a. ics \\<noteq> Throwing Cs a\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>match_ex_table P (cname_of h xcp) pc xt =\n           \\<lfloor>?pc_d2\\<rfloor>;\n   \\<forall>Cs a. ics \\<noteq> Throwing Cs a\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  \\<lbrakk>match_ex_table P (cname_of h xcp) pc xt =\n           \\<lfloor>?pc_d2\\<rfloor>;\n   \\<forall>Cs a. ics \\<noteq> Throwing Cs a\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix Cs a"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"ics = Throwing Cs a\""], ["proof (state)\nthis:\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with xp'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing Cs a", "have ics: \"ics = Throwing [] xcp\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. ics = Throwing [] xcp", "by(cases Cs; clarsimp)"], ["proof (state)\nthis:\n  ics = Throwing [] xcp\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?frs = \"(stk,loc,C,M,pc,No_ics)#frs\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have eT: \"exec_step P h stk loc C M pc (Throwing [] xcp) frs sh = (Some xcp, h, ?frs, sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc (Throwing [] xcp) frs sh =\n    (\\<lfloor>xcp\\<rfloor>, h, (stk, loc, C, M, pc, No_ics) # frs, sh)", "by auto"], ["proof (state)\nthis:\n  exec_step P h stk loc C M pc (Throwing [] xcp) frs sh =\n  (\\<lfloor>xcp\\<rfloor>, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with xp' ics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing [] xcp\n  exec_step P h stk loc C M pc (Throwing [] xcp) frs sh =\n  (\\<lfloor>xcp\\<rfloor>, h, (stk, loc, C, M, pc, No_ics) # frs, sh)", "have \\<sigma>'_fh: \"\\<sigma>' = find_handler P xcp h ?frs sh\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing [] xcp\n  exec_step P h stk loc C M pc (Throwing [] xcp) frs sh =\n  (\\<lfloor>xcp\\<rfloor>, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. \\<sigma>' = find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs) sh", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' = find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs) sh\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "have [simp]: \"xt = ex_table_of P C M\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. xt = ex_table_of P C M", "by simp"], ["proof (state)\nthis:\n  xt = ex_table_of P C M\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?match = \"match_ex_table P (cname_of h xcp) pc xt\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume clinit: \"M = clinit\" and None: \"?match = None\""], ["proof (state)\nthis:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note asms = clinit None"], ["proof (state)\nthis:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"P,\\<Phi> |- find_handler P xcp h ?frs sh [ok]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]", "proof(cases frs)"], ["proof (state)\ngoal (2 subgoals):\n 1. frs = [] \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]\n 2. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "case Nil"], ["proof (state)\nthis:\n  frs = []\n\ngoal (2 subgoals):\n 1. frs = [] \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]\n 2. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "with h_ok sh_ok asms"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  frs = []", "show \"P,\\<Phi> |- find_handler P xcp h ?frs sh [ok]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  frs = []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]", "by(simp add: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "case [simp]: (Cons f' frs')"], ["proof (state)\nthis:\n  frs = f' # frs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "obtain stk' loc' C' M' pc' ics' where\n          [simp]: \"f' = (stk',loc',C',M',pc',ics')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc' ics'.\n        f' = (stk', loc', C', M', pc', ics') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases f')"], ["proof (state)\nthis:\n  f' = (stk', loc', C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "have cls: \"is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P C", "by(rule sees_method_is_class[OF meth])"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "have shC: \"sh C = Some(sfs,Processing)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "by(rule sfs[OF clinit])"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "from correct"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain b Ts T mxs' mxl\\<^sub>0' ins' xt' ST' LT' where\n          meth': \"P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs', mxl\\<^sub>0', ins', xt') in C'\" and\n          \\<Phi>_pc': \"\\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\" and\n          frame': \"conf_f P h sh (ST',LT') ins' (stk', loc', C', M', pc', ics')\" and\n          frames': \"conf_fs P h sh \\<Phi> C' M' (length Ts) T frs'\" and\n          confc': \"conf_clinit P sh ((stk',loc',C',M',pc',ics')#frs')\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>b Ts T mxs' mxl\\<^sub>0' ins' xt' ST' LT'.\n        \\<lbrakk>P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs',\n                               mxl\\<^sub>0', ins', xt') in C';\n         \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         conf_f P h sh (ST', LT') ins' (stk', loc', C', M', pc', ics');\n         conf_fs P h sh \\<Phi> C' M' (length Ts) T frs';\n         conf_clinit P sh ((stk', loc', C', M', pc', ics') # frs')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: conf_clinit_Cons simp: correct_state_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs', mxl\\<^sub>0',\n                ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h sh (ST', LT') ins' (stk', loc', C', M', pc', ics')\n  conf_fs P h sh \\<Phi> C' M' (length Ts) T frs'\n  conf_clinit P sh ((stk', loc', C', M', pc', ics') # frs')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "from meth'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs', mxl\\<^sub>0',\n                ins', xt') in C'", "have\n          ins'[simp]: \"instrs_of P C' M' = ins'\"\n          and [simp]: \"xt' = ex_table_of P C' M'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs', mxl\\<^sub>0',\n                ins', xt') in C'\n\ngoal (1 subgoal):\n 1. instrs_of P C' M' = ins' &&& xt' = ex_table_of P C' M'", "by simp+"], ["proof (state)\nthis:\n  instrs_of P C' M' = ins'\n  xt' = ex_table_of P C' M'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "let ?f' = \"case ics' of Called Cs' \\<Rightarrow> (stk',loc',C',M',pc',Throwing (C#Cs') xcp)\n                              | _ \\<Rightarrow> (stk',loc',C',M',pc',ics')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "from asms confc"], ["proof (chain)\npicking this:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)", "have confc_T: \"conf_clinit P sh (?f'#frs')\""], ["proof (prove)\nusing this:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((case ics' of\n       Called Cs' \\<Rightarrow>\n         (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n       | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n      frs')", "by(cases ics', auto simp: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  conf_clinit P sh\n   ((case ics' of\n     Called Cs' \\<Rightarrow>\n       (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n     | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n    frs')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "from asms conf_f_Throwing[where h=h and sh=sh, OF _ cls h shC] frame'"], ["proof (chain)\npicking this:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  conf_f P h sh (?ST, ?LT) ?is\n   (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) \\<Longrightarrow>\n  conf_f P h sh (?ST, ?LT) ?is\n   (?stk, ?loc, ?C, ?M, ?pc, Throwing (C # ?Cs) xcp)\n  conf_f P h sh (ST', LT') ins' (stk', loc', C', M', pc', ics')", "have\n         frame_T: \"conf_f P h sh (ST', LT') ins' ?f'\""], ["proof (prove)\nusing this:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  conf_f P h sh (?ST, ?LT) ?is\n   (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) \\<Longrightarrow>\n  conf_f P h sh (?ST, ?LT) ?is\n   (?stk, ?loc, ?C, ?M, ?pc, Throwing (C # ?Cs) xcp)\n  conf_f P h sh (ST', LT') ins' (stk', loc', C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST', LT') ins'\n     (case ics' of\n      Called Cs' \\<Rightarrow>\n        (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n      | _ \\<Rightarrow> (stk', loc', C', M', pc', ics'))", "by(cases ics'; simp)"], ["proof (state)\nthis:\n  conf_f P h sh (ST', LT') ins'\n   (case ics' of\n    Called Cs' \\<Rightarrow>\n      (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n    | _ \\<Rightarrow> (stk', loc', C', M', pc', ics'))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "with h_ok sh_ok meth' \\<Phi>_pc' confc_T frames'"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs', mxl\\<^sub>0',\n                ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_clinit P sh\n   ((case ics' of\n     Called Cs' \\<Rightarrow>\n       (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n     | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n    frs')\n  conf_fs P h sh \\<Phi> C' M' (length Ts) T frs'\n  conf_f P h sh (ST', LT') ins'\n   (case ics' of\n    Called Cs' \\<Rightarrow>\n      (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n    | _ \\<Rightarrow> (stk', loc', C', M', pc', ics'))", "have \"P,\\<Phi> |- (None, h, ?f'#frs', sh) [ok]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C' sees M', b :  Ts\\<rightarrow>T = (mxs', mxl\\<^sub>0',\n                ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_clinit P sh\n   ((case ics' of\n     Called Cs' \\<Rightarrow>\n       (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n     | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n    frs')\n  conf_fs P h sh \\<Phi> C' M' (length Ts) T frs'\n  conf_f P h sh (ST', LT') ins'\n   (case ics' of\n    Called Cs' \\<Rightarrow>\n      (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n    | _ \\<Rightarrow> (stk', loc', C', M', pc', ics'))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (None, h,\n                 (case ics' of\n                  Called Cs' \\<Rightarrow>\n                    (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n                  | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n                 frs',\n                 sh) [ok]", "by(cases ics') (fastforce simp: correct_state_def)+"], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h,\n               (case ics' of\n                Called Cs' \\<Rightarrow>\n                  (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n                | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n               frs',\n               sh) [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       frs = a # list \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                    sh [ok]", "with asms"], ["proof (chain)\npicking this:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  P,\\<Phi> |- (None, h,\n               (case ics' of\n                Called Cs' \\<Rightarrow>\n                  (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n                | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n               frs',\n               sh) [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  M = clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  P,\\<Phi> |- (None, h,\n               (case ics' of\n                Called Cs' \\<Rightarrow>\n                  (stk', loc', C', M', pc', Throwing (C # Cs') xcp)\n                | _ \\<Rightarrow> (stk', loc', C', M', pc', ics')) #\n               frs',\n               sh) [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]", "by(cases ics'; simp)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>M = clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>M = clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  \\<lbrakk>M = clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume asms: \"M \\<noteq> clinit\" \"?match = None\""], ["proof (state)\nthis:\n  M \\<noteq> clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from asms uncaught_xcpt_correct[OF wtp h correct]"], ["proof (chain)\npicking this:\n  M \\<noteq> clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  curr_method (stk, loc, C, M, pc, ics) \\<noteq> clinit \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "have \"P,\\<Phi> |- find_handler P xcp h frs sh [ok]\""], ["proof (prove)\nusing this:\n  M \\<noteq> clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  curr_method (stk, loc, C, M, pc, ics) \\<noteq> clinit \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with asms"], ["proof (chain)\npicking this:\n  M \\<noteq> clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]", "have \"P,\\<Phi> |- find_handler P xcp h ?frs sh [ok]\""], ["proof (prove)\nusing this:\n  M \\<noteq> clinit\n  match_ex_table P (cname_of h xcp) pc xt = None\n  P,\\<Phi> |- find_handler P xcp h frs sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]", "by auto"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<noteq> clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<noteq> clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<noteq> clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix pc_d"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume some_handler: \"?match = \\<lfloor>pc_d\\<rfloor>\"\n        (is \"?match = \\<lfloor>pc_d\\<rfloor>\")"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>", "obtain pc1 d1 where sh': \"?match = Some(pc1,d1)\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>pc1 d1.\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc1, d1)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases pc_d, simp)"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc1, d1)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?stk' = \"Addr xcp # drop (length stk - d1) stk\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f = \"(?stk', loc, C, M, pc1, No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have [simp]: \"size stk = size ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. length stk = length ST", ".."], ["proof (state)\nthis:\n  length stk = length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have\n        eff: \"\\<forall>(pc1, s')\\<in>set (xcpt_eff (ins!pc) P pc (ST,LT) xt).\n               pc1 < size ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M!pc1\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc1, s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n       pc1 < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc1", "by (auto simp: defs1)"], ["proof (state)\nthis:\n  \\<forall>(pc1, s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc1 < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc1\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from match_ex_table_SomeD[OF sh']"], ["proof (chain)\npicking this:\n  \\<exists>(f, t, D, ha, d)\\<in>set xt.\n     matches_ex_entry P (cname_of h xcp) pc (f, t, D, ha, d) \\<and>\n     ha = pc1 \\<and> d = d1", "obtain f t D where\n        xt: \"(f,t,D,pc1,d1) \\<in> set xt\" and\n        \"matches_ex_entry P (cname_of h xcp) pc (f,t,D,pc1,d1)\""], ["proof (prove)\nusing this:\n  \\<exists>(f, t, D, ha, d)\\<in>set xt.\n     matches_ex_entry P (cname_of h xcp) pc (f, t, D, ha, d) \\<and>\n     ha = pc1 \\<and> d = d1\n\ngoal (1 subgoal):\n 1. (\\<And>f t D.\n        \\<lbrakk>(f, t, D, pc1, d1) \\<in> set xt;\n         matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc1, d1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f, t, D, pc1, d1) \\<in> set xt\n  matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc1, d1)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence match: \"P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\"  \"pc \\<in> {f..<t}\""], ["proof (prove)\nusing this:\n  (f, t, D, pc1, d1) \\<in> set xt\n  matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc1, d1)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D &&& pc \\<in> {f..<t}", "by (auto simp: matches_ex_entry_def)"], ["proof (state)\nthis:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ics vics"], ["proof (chain)\npicking this:\n  ics = Throwing [] xcp\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "obtain C1 where \"Called_context P C1 (ins ! pc)\""], ["proof (prove)\nusing this:\n  ics = Throwing [] xcp\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. (\\<And>C1.\n        Called_context P C1 (ins ! pc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  Called_context P C1 (ins ! pc)", "have \"ins!pc \\<in> Called_set\""], ["proof (prove)\nusing this:\n  Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. ins ! pc \\<in> Called_set", "by(rule Called_context_Called_set)"], ["proof (state)\nthis:\n  ins ! pc \\<in> Called_set\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with match xt xp ics"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  (f, t, D, pc1, d1) \\<in> set xt\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing [] xcp\n  ins ! pc \\<in> Called_set", "obtain\n        res: \"(f,t,D,pc1,d1) \\<in> set (relevant_entries P (ins!pc) pc xt)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  (f, t, D, pc1, d1) \\<in> set xt\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing [] xcp\n  ins ! pc \\<in> Called_set\n\ngoal (1 subgoal):\n 1. ((f, t, D, pc1, d1)\n     \\<in> set (relevant_entries P (ins ! pc) pc xt) \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: relevant_entries_def is_relevant_entry_def)"], ["proof (state)\nthis:\n  (f, t, D, pc1, d1) \\<in> set (relevant_entries P (ins ! pc) pc xt)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with h match xt xp ics"], ["proof (chain)\npicking this:\n  h xcp = \\<lfloor>obj\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  (f, t, D, pc1, d1) \\<in> set xt\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing [] xcp\n  (f, t, D, pc1, d1) \\<in> set (relevant_entries P (ins ! pc) pc xt)", "have conf: \"P,h \\<turnstile> Addr xcp :\\<le> Class D\""], ["proof (prove)\nusing this:\n  h xcp = \\<lfloor>obj\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  (f, t, D, pc1, d1) \\<in> set xt\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>xcp\\<rfloor>\n  ics = Throwing [] xcp\n  (f, t, D, pc1, d1) \\<in> set (relevant_entries P (ins ! pc) pc xt)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr xcp :\\<le> Class D", "by (auto simp: relevant_entries_def conf_def case_prod_unfold)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with eff res"], ["proof (chain)\npicking this:\n  \\<forall>(pc1, s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc1 < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc1\n  (f, t, D, pc1, d1) \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D", "obtain ST1 LT1 where\n        \\<Phi>_pc1: \"\\<Phi> C M ! pc1 = Some (ST1, LT1)\" and\n        pc1:   \"pc1 < size ins\" and\n        less1:  \"P \\<turnstile> (Class D # drop (size ST - d1) ST, LT) \\<le>\\<^sub>i (ST1, LT1)\""], ["proof (prove)\nusing this:\n  \\<forall>(pc1, s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc1 < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc1\n  (f, t, D, pc1, d1) \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>ST1 LT1.\n        \\<lbrakk>\\<Phi> C M ! pc1 = \\<lfloor>(ST1, LT1)\\<rfloor>;\n         pc1 < length ins;\n         P \\<turnstile> (Class D # drop (length ST - d1) ST,\n                         LT) \\<le>\\<^sub>i (ST1, LT1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: xcpt_eff_def sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc1 = \\<lfloor>(ST1, LT1)\\<rfloor>\n  pc1 < length ins\n  P \\<turnstile> (Class D # drop (length ST - d1) ST,\n                  LT) \\<le>\\<^sub>i (ST1, LT1)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with conf loc stk conf_f_def2 frame ics"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  conf_f ?P ?h ?sh (?ST, ?LT) ?is (?stk, ?loc, ?C, ?M, ?pc, ?ics) \\<equiv>\n  ?P,?h \\<turnstile> ?stk [:\\<le>] ?ST \\<and>\n  ?P,?h \\<turnstile> ?loc [:\\<le>\\<^sub>\\<top>] ?LT \\<and>\n  ?pc < length ?is \\<and> ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Throwing [] xcp\n  \\<Phi> C M ! pc1 = \\<lfloor>(ST1, LT1)\\<rfloor>\n  pc1 < length ins\n  P \\<turnstile> (Class D # drop (length ST - d1) ST,\n                  LT) \\<le>\\<^sub>i (ST1, LT1)", "have frame1: \"conf_f P h sh (ST1,LT1) ins ?f\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  conf_f ?P ?h ?sh (?ST, ?LT) ?is (?stk, ?loc, ?C, ?M, ?pc, ?ics) \\<equiv>\n  ?P,?h \\<turnstile> ?stk [:\\<le>] ?ST \\<and>\n  ?P,?h \\<turnstile> ?loc [:\\<le>\\<^sub>\\<top>] ?LT \\<and>\n  ?pc < length ?is \\<and> ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ?ics)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Throwing [] xcp\n  \\<Phi> C M ! pc1 = \\<lfloor>(ST1, LT1)\\<rfloor>\n  pc1 < length ins\n  P \\<turnstile> (Class D # drop (length ST - d1) ST,\n                  LT) \\<le>\\<^sub>i (ST1, LT1)\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST1, LT1) ins\n     (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1, No_ics)", "by (auto simp: defs1 intro: list_all2_dropI)"], ["proof (state)\nthis:\n  conf_f P h sh (ST1, LT1) ins\n   (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<Phi>_pc1 h_ok sh_ok meth frame1 frames conf_clinit_diff'[OF confc]"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc1 = \\<lfloor>(ST1, LT1)\\<rfloor>\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_f P h sh (ST1, LT1) ins\n   (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1, No_ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((?stk', ?loc', C, M, ?pc', No_ics) # frs)", "have\n        \"P,\\<Phi> |- (None, h, ?f # frs, sh) [ok]\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc1 = \\<lfloor>(ST1, LT1)\\<rfloor>\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_f P h sh (ST1, LT1) ins\n   (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1, No_ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((?stk', ?loc', C, M, ?pc', No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (None, h,\n                 (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1,\n                  No_ics) #\n                 frs,\n                 sh) [ok]", "by(fastforce simp: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h,\n               (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1,\n                No_ics) #\n               frs,\n               sh) [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with sh'"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc1, d1)\\<rfloor>\n  P,\\<Phi> |- (None, h,\n               (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1,\n                No_ics) #\n               frs,\n               sh) [ok]", "have \"P,\\<Phi> |- find_handler P xcp h ?frs sh [ok]\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc1, d1)\\<rfloor>\n  P,\\<Phi> |- (None, h,\n               (Addr xcp # drop (length stk - d1) stk, loc, C, M, pc1,\n                No_ics) #\n               frs,\n               sh) [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]", "by auto"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt =\n  \\<lfloor>?pc_d2\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>M = clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n  \\<lbrakk>M \\<noteq> clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n  match_ex_table P (cname_of h xcp) pc xt =\n  \\<lfloor>?pc_d2\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]", "have cr': \"P,\\<Phi> |- find_handler P xcp h ?frs sh [ok]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>M = clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n  \\<lbrakk>M \\<noteq> clinit;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h\n                                 ((stk, loc, C, M, pc, No_ics) # frs)\n                                 sh [ok]\n  match_ex_table P (cname_of h xcp) pc xt =\n  \\<lfloor>?pc_d2\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n                 sh [ok]", "by(cases \"?match\") blast+"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \\<sigma>'_fh"], ["proof (chain)\npicking this:\n  \\<sigma>' = find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs) sh\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' = find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs) sh\n  P,\\<Phi> |- find_handler P xcp h ((stk, loc, C, M, pc, No_ics) # frs)\n               sh [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>M \\<noteq> clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>M = clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>match_ex_table P (cname_of h xcp) pc xt =\n           \\<lfloor>?pc_d2\\<rfloor>;\n   \\<forall>Cs a. ics \\<noteq> Throwing Cs a\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<noteq> clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>M = clinit; \\<forall>Cs a. ics \\<noteq> Throwing Cs a;\n   match_ex_table P (cname_of h xcp) pc xt = None\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>match_ex_table P (cname_of h xcp) pc xt =\n           \\<lfloor>?pc_d2\\<rfloor>;\n   \\<forall>Cs a. ics \\<noteq> Throwing Cs a\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (cases \"?match\") blast+"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n\n(**********Non-exception Single-step correctness*************************)"], ["", "declare defs1 [simp]"], ["", "subsection \\<open> Initialization procedure steps \\<close>"], ["", "text \\<open>\n  In this section we prove that, for states that result in a step of the\n  initialization procedure rather than an instruction execution, the state\n  after execution of the step still conforms.\n\\<close>"], ["", "lemma Calling_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes ics: \"ics = Calling C' Cs\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where\n    h_ok: \"P \\<turnstile> h \\<surd>\" and\n    sh_ok: \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:  \"conf_f P h sh (ST, LT) ins (stk,loc,C,M,pc,ics)\" and\n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\" and\n    vics: \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs);\n         P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ics"], ["proof (chain)\npicking this:\n  ics = Calling C' Cs\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "have confc\\<^sub>0: \"conf_clinit P sh ((stk,loc,C,M,pc,Calling C' Cs)#frs)\""], ["proof (prove)\nusing this:\n  ics = Calling C' Cs\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Calling C' Cs) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling C' Cs) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from vics ics"], ["proof (chain)\npicking this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs", "have cls': \"is_class P C'\""], ["proof (prove)\nusing this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. is_class P C'", "by auto"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume None: \"sh C' = None\""], ["proof (state)\nthis:\n  sh C' = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?sh = \"sh(C' \\<mapsto> (sblank P C', Prepared))\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "obtain FDTs where\n     flds: \"P \\<turnstile> C' has_fields FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        P \\<turnstile> C' has_fields FDTs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using wf_Fields_Ex[OF wf cls']"], ["proof (prove)\nusing this:\n  \\<exists>FDTs. P \\<turnstile> C' has_fields FDTs\n\ngoal (1 subgoal):\n 1. (\\<And>FDTs.\n        P \\<turnstile> C' has_fields FDTs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> C' has_fields FDTs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from shconf_upd_obj[where C=C', OF sh_ok soconf_sblank[OF flds]]"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sblank P C', ?i')) \\<surd>", "have sh_ok': \"P,h \\<turnstile>\\<^sub>s ?sh \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sblank P C', ?i')) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto>\n    (sblank P C', Prepared)) \\<surd>", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sblank P C', Prepared)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from None"], ["proof (chain)\npicking this:\n  sh C' = None", "have \"\\<forall>sfs. sh C' \\<noteq> Some(sfs,Processing)\""], ["proof (prove)\nusing this:\n  sh C' = None\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with conf_clinit_nProc_dist[OF confc]"], ["proof (chain)\npicking this:\n  \\<forall>sfs.\n     sh ?C \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n  distinct (?C # clinit_classes ((stk, loc, C, M, pc, ics) # frs))\n  \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>", "have\n     dist': \"distinct (C' # clinit_classes ((stk, loc, C, M, pc, ics) # frs))\""], ["proof (prove)\nusing this:\n  \\<forall>sfs.\n     sh ?C \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n  distinct (?C # clinit_classes ((stk, loc, C, M, pc, ics) # frs))\n  \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. distinct (C' # clinit_classes ((stk, loc, C, M, pc, ics) # frs))", "by simp"], ["proof (state)\nthis:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, ics) # frs))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, ics) # frs))", "have dist'': \"distinct (C' # clinit_classes frs)\""], ["proof (prove)\nusing this:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, ics) # frs))\n\ngoal (1 subgoal):\n 1. distinct (C' # clinit_classes frs)", "by simp"], ["proof (state)\nthis:\n  distinct (C' # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have confc': \"conf_clinit P ?sh ((stk, loc, C, M, pc, ics) # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (sblank P C', Prepared)))\n     ((stk, loc, C, M, pc, ics) # frs)", "by(rule conf_clinit_shupd[OF confc dist'])"], ["proof (state)\nthis:\n  conf_clinit P (sh(C' \\<mapsto> (sblank P C', Prepared)))\n   ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have fs': \"conf_fs P h ?sh \\<Phi> C M (size Ts) T frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C' \\<mapsto> (sblank P C', Prepared))) \\<Phi> C M\n     (length Ts) T frs", "by(rule conf_fs_shupd[OF fs dist''])"], ["proof (state)\nthis:\n  conf_fs P h (sh(C' \\<mapsto> (sblank P C', Prepared))) \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from vics ics"], ["proof (chain)\npicking this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs", "have vics': \"P,h,?sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\""], ["proof (prove)\nusing this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. P,h,sh(C' \\<mapsto>\n    (sblank P C', Prepared)) \\<turnstile>\\<^sub>i (C, M, pc, ics)", "by auto"], ["proof (state)\nthis:\n  P,h,sh(C' \\<mapsto>\n  (sblank P C', Prepared)) \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from s' ics None"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs\n  sh C' = None", "have \"\\<sigma>' = (None, h, (stk, loc, C, M, pc, ics)#frs, ?sh)\""], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs\n  sh C' = None\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h, (stk, loc, C, M, pc, ics) # frs, sh(C' \\<mapsto>\n     (sblank P C', Prepared)))", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, ics) # frs, sh(C' \\<mapsto>\n   (sblank P C', Prepared)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with mC h_ok sh_ok' \\<Phi> stk loc pc fs' confc vics' confc' frame None"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sblank P C', Prepared)) \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h (sh(C' \\<mapsto> (sblank P C', Prepared))) \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh(C' \\<mapsto>\n  (sblank P C', Prepared)) \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  conf_clinit P (sh(C' \\<mapsto> (sblank P C', Prepared)))\n   ((stk, loc, C, M, pc, ics) # frs)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  sh C' = None\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, ics) # frs, sh(C' \\<mapsto>\n   (sblank P C', Prepared)))", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sblank P C', Prepared)) \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h (sh(C' \\<mapsto> (sblank P C', Prepared))) \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh(C' \\<mapsto>\n  (sblank P C', Prepared)) \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  conf_clinit P (sh(C' \\<mapsto> (sblank P C', Prepared)))\n   ((stk, loc, C, M, pc, ics) # frs)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  sh C' = None\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, ics) # frs, sh(C' \\<mapsto>\n   (sblank P C', Prepared)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  sh C' = None \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  sh C' = None \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  sh C' = None \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"sh C' = Some a\""], ["proof (state)\nthis:\n  sh C' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  sh C' = \\<lfloor>a\\<rfloor>", "obtain sfs i where shC'[simp]: \"sh C' = Some(sfs,i)\""], ["proof (prove)\nusing this:\n  sh C' = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i.\n        sh C' = \\<lfloor>(sfs, i)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases a, simp)"], ["proof (state)\nthis:\n  sh C' = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc ics"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs", "have last: \"\\<exists>sobj. sh (last(C'#Cs)) = Some sobj\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. \\<exists>sobj. sh (last (C' # Cs)) = \\<lfloor>sobj\\<rfloor>", "by(fastforce simp: conf_clinit_def)"], ["proof (state)\nthis:\n  \\<exists>sobj. sh (last (C' # Cs)) = \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let \"?f\" = \"\\<lambda>ics'. (stk, loc, C, M, pc, ics'::init_call_status)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume i: \"i = Done \\<or> i = Processing\""], ["proof (state)\nthis:\n  i = Done \\<or> i = Processing\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?ics = \"Called Cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from last vics ics"], ["proof (chain)\npicking this:\n  \\<exists>sobj. sh (last (C' # Cs)) = \\<lfloor>sobj\\<rfloor>\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs", "have vics': \"P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ?ics)\""], ["proof (prove)\nusing this:\n  \\<exists>sobj. sh (last (C' # Cs)) = \\<lfloor>sobj\\<rfloor>\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, Called Cs)", "by auto"], ["proof (state)\nthis:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, Called Cs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc ics"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs", "have confc': \"conf_clinit P sh (?f ?ics#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Called Cs) # frs)", "by(cases \"M=clinit\"; clarsimp simp: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Called Cs) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i s' ics"], ["proof (chain)\npicking this:\n  i = Done \\<or> i = Processing\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs", "have \"\\<sigma>' = (None, h, ?f ?ics#frs, sh)\""], ["proof (prove)\nusing this:\n  i = Done \\<or> i = Processing\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (stk, loc, C, M, pc, Called Cs) # frs, sh)", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Called Cs) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with mC h_ok sh_ok \\<Phi> stk loc pc fs confc' vics' frame ics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Called Cs) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, Called Cs)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Calling C' Cs\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Called Cs) # frs, sh)", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Called Cs) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, Called Cs)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Calling C' Cs\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Called Cs) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  i = Done \\<or> i = Processing \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  i = Done \\<or> i = Processing \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  i = Done \\<or> i = Processing \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume i[simp]: \"i = Error\""], ["proof (state)\nthis:\n  i = Error\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?a = \"addr_of_sys_xcpt NoClassDefFoundError\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?ics = \"Throwing Cs ?a\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h_ok"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>", "have preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n\ngoal (1 subgoal):\n 1. preallocated h", "by (simp add: hconf_def)"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  preallocated h", "obtain obj where ha: \"h ?a = Some obj\""], ["proof (prove)\nusing this:\n  preallocated h\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h (addr_of_sys_xcpt NoClassDefFoundError) =\n        \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: preallocated_def sys_xcpts_def)"], ["proof (state)\nthis:\n  h (addr_of_sys_xcpt NoClassDefFoundError) = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with vics ics"], ["proof (chain)\npicking this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n  h (addr_of_sys_xcpt NoClassDefFoundError) = \\<lfloor>obj\\<rfloor>", "have vics': \"P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ?ics)\""], ["proof (prove)\nusing this:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n  h (addr_of_sys_xcpt NoClassDefFoundError) = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h,sh \\<turnstile>\\<^sub>i (C, M, pc,\n                                 Throwing Cs\n                                  (addr_of_sys_xcpt NoClassDefFoundError))", "by auto"], ["proof (state)\nthis:\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc,\n                               Throwing Cs\n                                (addr_of_sys_xcpt NoClassDefFoundError))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc ics"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs", "have confc'': \"conf_clinit P sh (?f ?ics#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((stk, loc, C, M, pc,\n       Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n      frs)", "by(cases \"M=clinit\"; clarsimp simp: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  conf_clinit P sh\n   ((stk, loc, C, M, pc,\n     Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n    frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from s' ics"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs", "have \\<sigma>': \"\\<sigma>' = (None, h, ?f ?ics#frs, sh)\""], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (stk, loc, C, M, pc,\n      Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n     frs,\n     sh)", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (stk, loc, C, M, pc,\n    Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n   frs,\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC h_ok sh_ok \\<Phi> stk loc pc fs confc'' vics \\<sigma>' ics ha"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh\n   ((stk, loc, C, M, pc,\n     Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n    frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  \\<sigma>' =\n  (None, h,\n   (stk, loc, C, M, pc,\n    Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n   frs,\n   sh)\n  ics = Calling C' Cs\n  h (addr_of_sys_xcpt NoClassDefFoundError) = \\<lfloor>obj\\<rfloor>", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh\n   ((stk, loc, C, M, pc,\n     Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n    frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  \\<sigma>' =\n  (None, h,\n   (stk, loc, C, M, pc,\n    Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n   frs,\n   sh)\n  ics = Calling C' Cs\n  h (addr_of_sys_xcpt NoClassDefFoundError) = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  i = Error \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  i = Error \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  i = Error \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume i[simp]: \"i = Prepared\""], ["proof (state)\nthis:\n  i = Prepared\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?sh = \"sh(C' \\<mapsto> (sfs,Processing))\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?D = \"fst(the(class P C'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?ics = \"if C' = Object then Called (C'#Cs) else Calling ?D (C'#Cs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from shconf_upd_obj[where C=C', OF sh_ok shconfD[OF sh_ok shC']]"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, ?i')) \\<surd>", "have sh_ok': \"P,h \\<turnstile>\\<^sub>s ?sh \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, ?i')) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, Processing)) \\<surd>", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, Processing)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from cls'"], ["proof (chain)\npicking this:\n  is_class P C'", "have \"C' \\<noteq> Object \\<Longrightarrow> P \\<turnstile> C' \\<preceq>\\<^sup>* ?D\""], ["proof (prove)\nusing this:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. C' \\<noteq> Object \\<Longrightarrow>\n    P \\<turnstile> C' \\<preceq>\\<^sup>* fst (the (class P C'))", "by(auto simp: is_class_def intro!: subcls1I)"], ["proof (state)\nthis:\n  C' \\<noteq> Object \\<Longrightarrow>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* fst (the (class P C'))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with is_class_supclass[OF wf _ cls']"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* ?D \\<Longrightarrow> is_class P ?D\n  C' \\<noteq> Object \\<Longrightarrow>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* fst (the (class P C'))", "have D: \"C' \\<noteq>  Object \\<Longrightarrow> is_class P ?D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* ?D \\<Longrightarrow> is_class P ?D\n  C' \\<noteq> Object \\<Longrightarrow>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* fst (the (class P C'))\n\ngoal (1 subgoal):\n 1. C' \\<noteq> Object \\<Longrightarrow> is_class P (fst (the (class P C')))", "by simp"], ["proof (state)\nthis:\n  C' \\<noteq> Object \\<Longrightarrow> is_class P (fst (the (class P C')))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i"], ["proof (chain)\npicking this:\n  i = Prepared", "have \"\\<forall>sfs. sh C' \\<noteq> Some(sfs,Processing)\""], ["proof (prove)\nusing this:\n  i = Prepared\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with conf_clinit_nProc_dist[OF confc\\<^sub>0]"], ["proof (chain)\npicking this:\n  \\<forall>sfs.\n     sh ?C \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n  distinct (?C # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\n  \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>", "have\n       dist': \"distinct (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\""], ["proof (prove)\nusing this:\n  \\<forall>sfs.\n     sh ?C \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n  distinct (?C # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\n  \\<forall>sfs. sh C' \\<noteq> \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. distinct\n     (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))", "by fast"], ["proof (state)\nthis:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))", "have dist'': \"distinct (C' # clinit_classes frs)\""], ["proof (prove)\nusing this:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Calling C' Cs) # frs))\n\ngoal (1 subgoal):\n 1. distinct (C' # clinit_classes frs)", "by simp"], ["proof (state)\nthis:\n  distinct (C' # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from conf_clinit_shupd_Calling[OF confc\\<^sub>0 dist' cls']\n           conf_clinit_shupd_Called[OF confc\\<^sub>0 dist' cls']"], ["proof (chain)\npicking this:\n  conf_clinit P (sh(C' \\<mapsto> (?sfs, Processing)))\n   ((stk, loc, C, M, pc, Calling (fst (the (class P C'))) (C' # Cs)) # frs)\n  conf_clinit P (sh(C' \\<mapsto> (?sfs, Processing)))\n   ((stk, loc, C, M, pc, Called (C' # Cs)) # frs)", "have confc': \"conf_clinit P ?sh (?f ?ics#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P (sh(C' \\<mapsto> (?sfs, Processing)))\n   ((stk, loc, C, M, pc, Calling (fst (the (class P C'))) (C' # Cs)) # frs)\n  conf_clinit P (sh(C' \\<mapsto> (?sfs, Processing)))\n   ((stk, loc, C, M, pc, Called (C' # Cs)) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n     ((stk, loc, C, M, pc,\n       if C' = Object then Called (C' # Cs)\n       else Calling (fst (the (class P C'))) (C' # Cs)) #\n      frs)", "by clarsimp"], ["proof (state)\nthis:\n  conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n   ((stk, loc, C, M, pc,\n     if C' = Object then Called (C' # Cs)\n     else Calling (fst (the (class P C'))) (C' # Cs)) #\n    frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with last ics"], ["proof (chain)\npicking this:\n  \\<exists>sobj. sh (last (C' # Cs)) = \\<lfloor>sobj\\<rfloor>\n  ics = Calling C' Cs\n  conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n   ((stk, loc, C, M, pc,\n     if C' = Object then Called (C' # Cs)\n     else Calling (fst (the (class P C'))) (C' # Cs)) #\n    frs)", "have \"\\<exists>sobj. ?sh (last(C'#Cs)) = Some sobj\""], ["proof (prove)\nusing this:\n  \\<exists>sobj. sh (last (C' # Cs)) = \\<lfloor>sobj\\<rfloor>\n  ics = Calling C' Cs\n  conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n   ((stk, loc, C, M, pc,\n     if C' = Object then Called (C' # Cs)\n     else Calling (fst (the (class P C'))) (C' # Cs)) #\n    frs)\n\ngoal (1 subgoal):\n 1. \\<exists>sobj.\n       (sh(C' \\<mapsto> (sfs, Processing))) (last (C' # Cs)) =\n       \\<lfloor>sobj\\<rfloor>", "by(auto simp: conf_clinit_def fun_upd_apply)"], ["proof (state)\nthis:\n  \\<exists>sobj.\n     (sh(C' \\<mapsto> (sfs, Processing))) (last (C' # Cs)) =\n     \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with D vics ics"], ["proof (chain)\npicking this:\n  C' \\<noteq> Object \\<Longrightarrow> is_class P (fst (the (class P C')))\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n  \\<exists>sobj.\n     (sh(C' \\<mapsto> (sfs, Processing))) (last (C' # Cs)) =\n     \\<lfloor>sobj\\<rfloor>", "have vics': \"P,h,?sh \\<turnstile>\\<^sub>i (C, M, pc, ?ics)\""], ["proof (prove)\nusing this:\n  C' \\<noteq> Object \\<Longrightarrow> is_class P (fst (the (class P C')))\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  ics = Calling C' Cs\n  \\<exists>sobj.\n     (sh(C' \\<mapsto> (sfs, Processing))) (last (C' # Cs)) =\n     \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h,sh(C' \\<mapsto>\n    (sfs,\n     Processing)) \\<turnstile>\\<^sub>i (C, M, pc,\n  if C' = Object then Called (C' # Cs)\n  else Calling (fst (the (class P C'))) (C' # Cs))", "by auto"], ["proof (state)\nthis:\n  P,h,sh(C' \\<mapsto>\n  (sfs,\n   Processing)) \\<turnstile>\\<^sub>i (C, M, pc,\nif C' = Object then Called (C' # Cs)\nelse Calling (fst (the (class P C'))) (C' # Cs))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have fs': \"conf_fs P h ?sh \\<Phi> C M (size Ts) T frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C' \\<mapsto> (sfs, Processing))) \\<Phi> C M (length Ts)\n     T frs", "by(rule conf_fs_shupd[OF fs dist''])"], ["proof (state)\nthis:\n  conf_fs P h (sh(C' \\<mapsto> (sfs, Processing))) \\<Phi> C M (length Ts) T\n   frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame vics'"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  P,h,sh(C' \\<mapsto>\n  (sfs,\n   Processing)) \\<turnstile>\\<^sub>i (C, M, pc,\nif C' = Object then Called (C' # Cs)\nelse Calling (fst (the (class P C'))) (C' # Cs))", "have frame': \"conf_f P h ?sh (ST, LT) ins (?f ?ics)\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  P,h,sh(C' \\<mapsto>\n  (sfs,\n   Processing)) \\<turnstile>\\<^sub>i (C, M, pc,\nif C' = Object then Called (C' # Cs)\nelse Calling (fst (the (class P C'))) (C' # Cs))\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C' \\<mapsto> (sfs, Processing))) (ST, LT) ins\n     (stk, loc, C, M, pc,\n      if C' = Object then Called (C' # Cs)\n      else Calling (fst (the (class P C'))) (C' # Cs))", "by simp"], ["proof (state)\nthis:\n  conf_f P h (sh(C' \\<mapsto> (sfs, Processing))) (ST, LT) ins\n   (stk, loc, C, M, pc,\n    if C' = Object then Called (C' # Cs)\n    else Calling (fst (the (class P C'))) (C' # Cs))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i s' ics"], ["proof (chain)\npicking this:\n  i = Prepared\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs", "have \"\\<sigma>' = (None, h, ?f ?ics#frs, ?sh)\""], ["proof (prove)\nusing this:\n  i = Prepared\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (stk, loc, C, M, pc,\n      if C' = Object then Called (C' # Cs)\n      else Calling (fst (the (class P C'))) (C' # Cs)) #\n     frs,\n     sh(C' \\<mapsto> (sfs, Processing)))", "by(auto simp: if_split_asm)"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (stk, loc, C, M, pc,\n    if C' = Object then Called (C' # Cs)\n    else Calling (fst (the (class P C'))) (C' # Cs)) #\n   frs,\n   sh(C' \\<mapsto> (sfs, Processing)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with mC h_ok sh_ok' \\<Phi> stk loc pc fs' confc' frame' ics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, Processing)) \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h (sh(C' \\<mapsto> (sfs, Processing))) \\<Phi> C M (length Ts) T\n   frs\n  conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n   ((stk, loc, C, M, pc,\n     if C' = Object then Called (C' # Cs)\n     else Calling (fst (the (class P C'))) (C' # Cs)) #\n    frs)\n  conf_f P h (sh(C' \\<mapsto> (sfs, Processing))) (ST, LT) ins\n   (stk, loc, C, M, pc,\n    if C' = Object then Called (C' # Cs)\n    else Calling (fst (the (class P C'))) (C' # Cs))\n  ics = Calling C' Cs\n  \\<sigma>' =\n  (None, h,\n   (stk, loc, C, M, pc,\n    if C' = Object then Called (C' # Cs)\n    else Calling (fst (the (class P C'))) (C' # Cs)) #\n   frs,\n   sh(C' \\<mapsto> (sfs, Processing)))", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, Processing)) \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h (sh(C' \\<mapsto> (sfs, Processing))) \\<Phi> C M (length Ts) T\n   frs\n  conf_clinit P (sh(C' \\<mapsto> (sfs, Processing)))\n   ((stk, loc, C, M, pc,\n     if C' = Object then Called (C' # Cs)\n     else Calling (fst (the (class P C'))) (C' # Cs)) #\n    frs)\n  conf_f P h (sh(C' \\<mapsto> (sfs, Processing))) (ST, LT) ins\n   (stk, loc, C, M, pc,\n    if C' = Object then Called (C' # Cs)\n    else Calling (fst (the (class P C'))) (C' # Cs))\n  ics = Calling C' Cs\n  \\<sigma>' =\n  (None, h,\n   (stk, loc, C, M, pc,\n    if C' = Object then Called (C' # Cs)\n    else Calling (fst (the (class P C'))) (C' # Cs)) #\n   frs,\n   sh(C' \\<mapsto> (sfs, Processing)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  i = Prepared \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  i = Done \\<or> i = Processing \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  i = Error \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  i = Prepared \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "have ?thesis"], ["proof (prove)\nusing this:\n  i = Done \\<or> i = Processing \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  i = Error \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  i = Prepared \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(cases i, auto)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  sh C' = \\<lfloor>?a2\\<rfloor> \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  sh C' = None \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  sh C' = \\<lfloor>?a2\\<rfloor> \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  sh C' = None \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  sh C' = \\<lfloor>?a2\\<rfloor> \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(cases \"sh C'\", auto)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Throwing_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes ics: \"ics = Throwing (C'#Cs) a\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where\n    h_ok: \"P \\<turnstile> h \\<surd>\" and\n    sh_ok: \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:  \"conf_f P h sh (ST, LT) ins (stk,loc,C,M,pc,ics)\" and\n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\" and\n    vics: \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs);\n         P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ics"], ["proof (chain)\npicking this:\n  ics = Throwing (C' # Cs) a\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "have confc\\<^sub>0: \"conf_clinit P sh ((stk,loc,C,M,pc,Throwing (C'#Cs) a)#frs)\""], ["proof (prove)\nusing this:\n  ics = Throwing (C' # Cs) a\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C' # Cs) a) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Throwing (C' # Cs) a) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame ics mC"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Throwing (C' # Cs) a\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "have\n   cc: \"\\<exists>C1. Called_context P C1 (ins ! pc)\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Throwing (C' # Cs) a\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. \\<exists>C1. Called_context P C1 (ins ! pc)", "by(clarsimp simp: conf_f_def2)"], ["proof (state)\nthis:\n  \\<exists>C1. Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame ics"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Throwing (C' # Cs) a", "obtain obj where ha: \"h a = Some obj\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ics = Throwing (C' # Cs) a\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h a = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: conf_f_def2)"], ["proof (state)\nthis:\n  h a = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc ics"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Throwing (C' # Cs) a", "obtain sfs i where shC': \"sh C' = Some(sfs,i)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Throwing (C' # Cs) a\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i.\n        sh C' = \\<lfloor>(sfs, i)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: conf_clinit_def)"], ["proof (state)\nthis:\n  sh C' = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  sh C' = \\<lfloor>(sfs, i)\\<rfloor>", "have sfs: \"P,h,C' \\<turnstile>\\<^sub>s sfs \\<surd>\""], ["proof (prove)\nusing this:\n  sh C' = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h,C' \\<turnstile>\\<^sub>s sfs \\<surd>", "by(rule shconfD[OF sh_ok])"], ["proof (state)\nthis:\n  P,h,C' \\<turnstile>\\<^sub>s sfs \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from s' ics"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Throwing (C' # Cs) a", "have \\<sigma>': \"\\<sigma>' = (None, h, (stk,loc,C,M,pc,Throwing Cs a)#frs, sh(C' \\<mapsto> (fst(the(sh C')), Error)))\"\n    (is \"\\<sigma>' = (None, h, ?f'#frs, ?sh')\")"], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ics = Throwing (C' # Cs) a\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h, (stk, loc, C, M, pc, Throwing Cs a) # frs, sh(C' \\<mapsto>\n     (fst (the (sh C')), Error)))", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, Throwing Cs a) # frs, sh(C' \\<mapsto>\n   (fst (the (sh C')), Error)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc ics"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Throwing (C' # Cs) a", "have dist: \"distinct (C' # clinit_classes (?f' # frs))\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Throwing (C' # Cs) a\n\ngoal (1 subgoal):\n 1. distinct\n     (C' # clinit_classes ((stk, loc, C, M, pc, Throwing Cs a) # frs))", "by (simp add: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Throwing Cs a) # frs))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Throwing Cs a) # frs))", "have dist': \"distinct (C' # clinit_classes frs)\""], ["proof (prove)\nusing this:\n  distinct (C' # clinit_classes ((stk, loc, C, M, pc, Throwing Cs a) # frs))\n\ngoal (1 subgoal):\n 1. distinct (C' # clinit_classes frs)", "by simp"], ["proof (state)\nthis:\n  distinct (C' # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from conf_clinit_Throwing confc ics"], ["proof (chain)\npicking this:\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, Throwing (?C' # ?Cs) ?xcp) #\n    ?fs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk, ?loc, ?C, ?M, ?pc, Throwing ?Cs ?xcp) # ?fs)\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Throwing (C' # Cs) a", "have confc': \"conf_clinit P sh (?f' # frs)\""], ["proof (prove)\nusing this:\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, Throwing (?C' # ?Cs) ?xcp) #\n    ?fs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk, ?loc, ?C, ?M, ?pc, Throwing ?Cs ?xcp) # ?fs)\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  ics = Throwing (C' # Cs) a\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Throwing Cs a) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Throwing Cs a) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from shconf_upd_obj[OF sh_ok sfs] shC'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, ?i')) \\<surd>\n  sh C' = \\<lfloor>(sfs, i)\\<rfloor>", "have \"P,h \\<turnstile>\\<^sub>s ?sh' \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto> (sfs, ?i')) \\<surd>\n  sh C' = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto>\n    (fst (the (sh C')), Error)) \\<surd>", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto>\n  (fst (the (sh C')), Error)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto>\n  (fst (the (sh C')), Error)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_fs P h ?sh' \\<Phi> C M (length Ts) T frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C' \\<mapsto> (fst (the (sh C')), Error))) \\<Phi> C M\n     (length Ts) T frs", "by(rule conf_fs_shupd[OF fs dist'])"], ["proof (state)\nthis:\n  conf_fs P h (sh(C' \\<mapsto> (fst (the (sh C')), Error))) \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_fs P h (sh(C' \\<mapsto> (fst (the (sh C')), Error))) \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P ?sh' (?f' # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C' \\<mapsto> (fst (the (sh C')), Error)))\n     ((stk, loc, C, M, pc, Throwing Cs a) # frs)", "by(rule conf_clinit_shupd[OF confc' dist])"], ["proof (state)\nthis:\n  conf_clinit P (sh(C' \\<mapsto> (fst (the (sh C')), Error)))\n   ((stk, loc, C, M, pc, Throwing Cs a) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P (sh(C' \\<mapsto> (fst (the (sh C')), Error)))\n   ((stk, loc, C, M, pc, Throwing Cs a) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note \\<sigma>' h_ok mC \\<Phi> pc stk loc ha cc"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, Throwing Cs a) # frs, sh(C' \\<mapsto>\n   (fst (the (sh C')), Error)))\n  P \\<turnstile> h \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  h a = \\<lfloor>obj\\<rfloor>\n  \\<exists>C1. Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto>\n  (fst (the (sh C')), Error)) \\<surd>\n  conf_fs P h (sh(C' \\<mapsto> (fst (the (sh C')), Error))) \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P (sh(C' \\<mapsto> (fst (the (sh C')), Error)))\n   ((stk, loc, C, M, pc, Throwing Cs a) # frs)\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, Throwing Cs a) # frs, sh(C' \\<mapsto>\n   (fst (the (sh C')), Error)))\n  P \\<turnstile> h \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  h a = \\<lfloor>obj\\<rfloor>\n  \\<exists>C1. Called_context P C1 (ins ! pc)", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh(C' \\<mapsto>\n  (fst (the (sh C')), Error)) \\<surd>\n  conf_fs P h (sh(C' \\<mapsto> (fst (the (sh C')), Error))) \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P (sh(C' \\<mapsto> (fst (the (sh C')), Error)))\n   ((stk, loc, C, M, pc, Throwing Cs a) # frs)\n  \\<sigma>' =\n  (None, h, (stk, loc, C, M, pc, Throwing Cs a) # frs, sh(C' \\<mapsto>\n   (fst (the (sh C')), Error)))\n  P \\<turnstile> h \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  h a = \\<lfloor>obj\\<rfloor>\n  \\<exists>C1. Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Called_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes ics[simp]: \"ics = Called (C'#Cs)\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where\n    h_ok: \"P \\<turnstile> h \\<surd>\" and\n    sh_ok: \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    frame:  \"conf_f P h sh (ST, LT) ins (stk,loc,C,M,pc,ics)\" and\n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\" and\n    vics: \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs);\n         P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)", "have confc\\<^sub>0: \"conf_clinit P sh ((stk,loc,C,M,pc,Called (C'#Cs))#frs)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Called (C' # Cs)) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Called (C' # Cs)) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame mC"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain C1 sobj where\n    ss: \"Called_context P C1 (ins ! pc)\" and\n    shC1: \"sh C1 = Some sobj\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>C1 sobj.\n        \\<lbrakk>Called_context P C1 (ins ! pc);\n         sh C1 = \\<lfloor>sobj\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: conf_f_def2)"], ["proof (state)\nthis:\n  Called_context P C1 (ins ! pc)\n  sh C1 = \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc wf_sees_clinit[OF wf]"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  class P ?C = \\<lfloor>?a\\<rfloor> \\<Longrightarrow>\n  \\<exists>m.\n     P \\<turnstile> ?C sees clinit, Static :  []\\<rightarrow>Void = m in ?C", "obtain mxs' mxl' ins' xt' where\n   clinit: \"P \\<turnstile> C' sees clinit,Static: [] \\<rightarrow> Void=(mxs',mxl',ins',xt') in C'\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  class P ?C = \\<lfloor>?a\\<rfloor> \\<Longrightarrow>\n  \\<exists>m.\n     P \\<turnstile> ?C sees clinit, Static :  []\\<rightarrow>Void = m in ?C\n\ngoal (1 subgoal):\n 1. (\\<And>mxs' mxl' ins' xt'.\n        P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                                  mxl', ins', xt') in C' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp: conf_clinit_def is_class_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?loc' = \"replicate mxl' undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from s' clinit"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'", "have \\<sigma>': \"\\<sigma>' = (None, h, ([],?loc',C',clinit,0,No_ics)#(stk,loc,C,M,pc,Called Cs)#frs, sh)\"\n    (is \"\\<sigma>' = (None, h, ?if#?f'#frs, sh)\")"], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n     (stk, loc, C, M, pc, Called Cs) # frs,\n     sh)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n   (stk, loc, C, M, pc, Called Cs) # frs,\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wtprog clinit"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n  \\<sigma>' =\n  (None, h,\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n   (stk, loc, C, M, pc, Called Cs) # frs,\n   sh)", "obtain start: \"wt_start P C' Static [] mxl' (\\<Phi> C' clinit)\" and ins': \"ins' \\<noteq> []\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n  \\<sigma>' =\n  (None, h,\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n   (stk, loc, C, M, pc, Called Cs) # frs,\n   sh)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wt_start P C' Static [] mxl' (\\<Phi> C' clinit);\n      ins' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: wt_jvm_prog_impl_wt_start)"], ["proof (state)\nthis:\n  wt_start P C' Static [] mxl' (\\<Phi> C' clinit)\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  wt_start P C' Static [] mxl' (\\<Phi> C' clinit)\n  ins' \\<noteq> []", "obtain LT\\<^sub>0 where LT\\<^sub>0: \"\\<Phi> C' clinit ! 0 = Some ([], LT\\<^sub>0)\""], ["proof (prove)\nusing this:\n  wt_start P C' Static [] mxl' (\\<Phi> C' clinit)\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>LT\\<^sub>0.\n        \\<Phi> C' clinit ! 0 =\n        \\<lfloor>([], LT\\<^sub>0)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: wt_start_def defs1 sup_state_opt_any_Some split: staticb.splits)"], ["proof (state)\nthis:\n  \\<Phi> C' clinit ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<Phi> C' clinit ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_f P h sh ([], LT\\<^sub>0) ins' ?if\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "let ?LT = \"replicate mxl' Err\""], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] ?LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "from start LT\\<^sub>0"], ["proof (chain)\npicking this:\n  wt_start P C' Static [] mxl' (\\<Phi> C' clinit)\n  \\<Phi> C' clinit ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>", "have \"P \\<turnstile> \\<dots> [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  wt_start P C' Static [] mxl' (\\<Phi> C' clinit)\n  \\<Phi> C' clinit ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> replicate mxl' Err [\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "by (simp add: wt_start_def)"], ["proof (state)\nthis:\n  P \\<turnstile> replicate mxl' Err [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "."], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "using ins'"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], replicate mxl' undefined, C', clinit, 0, No_ics)", "by simp"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from conf_clinit_Called confc clinit"], ["proof (chain)\npicking this:\n  \\<lbrakk>conf_clinit ?P ?sh\n            ((?stk, ?loc, ?C, ?M, ?pc, Called (?C' # ?Cs)) # ?frs);\n   ?P \\<turnstile> ?C' sees clinit, Static :  []\\<rightarrow>Void = (?mxs',\n                               ?mxl', ?ins', ?xt') in ?C'\\<rbrakk>\n  \\<Longrightarrow> conf_clinit ?P ?sh\n                     (create_init_frame ?P ?C' #\n                      (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) # ?frs)\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'", "have \"conf_clinit P sh (?if # ?f' # frs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>conf_clinit ?P ?sh\n            ((?stk, ?loc, ?C, ?M, ?pc, Called (?C' # ?Cs)) # ?frs);\n   ?P \\<turnstile> ?C' sees clinit, Static :  []\\<rightarrow>Void = (?mxs',\n                               ?mxl', ?ins', ?xt') in ?C'\\<rbrakk>\n  \\<Longrightarrow> conf_clinit ?P ?sh\n                     (create_init_frame ?P ?C' #\n                      (?stk, ?loc, ?C, ?M, ?pc, Called ?Cs) # ?frs)\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     (([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n      (stk, loc, C, M, pc, Called Cs) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh\n   (([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n    (stk, loc, C, M, pc, Called Cs) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P sh\n   (([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n    (stk, loc, C, M, pc, Called Cs) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note \\<sigma>' h_ok sh_ok mC \\<Phi> pc stk loc clinit ss shC1 fs"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n   (stk, loc, C, M, pc, Called Cs) # frs,\n   sh)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n  Called_context P C1 (ins ! pc)\n  sh C1 = \\<lfloor>sobj\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi> C' clinit ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics)\n  conf_clinit P sh\n   (([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n    (stk, loc, C, M, pc, Called Cs) # frs)\n  \\<sigma>' =\n  (None, h,\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n   (stk, loc, C, M, pc, Called Cs) # frs,\n   sh)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n  Called_context P C1 (ins ! pc)\n  sh C1 = \\<lfloor>sobj\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<Phi> C' clinit ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics)\n  conf_clinit P sh\n   (([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n    (stk, loc, C, M, pc, Called Cs) # frs)\n  \\<sigma>' =\n  (None, h,\n   ([], replicate mxl' undefined, C', clinit, 0, No_ics) #\n   (stk, loc, C, M, pc, Called Cs) # frs,\n   sh)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> C' sees clinit, Static :  []\\<rightarrow>Void = (mxs',\n                            mxl', ins', xt') in C'\n  Called_context P C1 (ins ! pc)\n  sh C1 = \\<lfloor>sobj\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Single Instructions \\<close>"], ["", "text \\<open>\n  In this section we prove for each single (welltyped) instruction\n  that the state after execution of the instruction still conforms.\n  Since we have already handled exceptions above, we can now assume that\n  no exception occurs in this step. For instructions that may call\n  the initialization procedure, we cover the calling and non-calling\n  cases separately.\n\\<close>"], ["", "lemma Invoke_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invoke M' n\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes no_xcp: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth_C approx ins"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Invoke M' n", "have [simp]: \"ics = No_ics\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Invoke M' n\n\ngoal (1 subgoal):\n 1. ics = No_ics", "by(cases ics, auto)"], ["proof (state)\nthis:\n  ics = No_ics\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note split_paired_Ex [simp del]"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wfprog: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins meth_C approx"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h sh (ST,LT) ins (stk,loc,C,M,pc,ics)\" and\n    frames:  \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc:   \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have n: \"n < size ST\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. n < length ST", "by simp"], ["proof (state)\nthis:\n  n < length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  n < length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"stk!n = Null\""], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins no_xcp meth_C"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  stk ! n = Null", "have False"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. False", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", ".."], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"ST!n = NT\""], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with n"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> stk!n :\\<le> ST!n\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by (simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n", "have \"stk!n = Null\""], ["proof (prove)\nusing this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n = Null", "by simp"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins no_xcp meth_C"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  stk ! n = Null", "have False"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. False", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", ".."], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume NT: \"ST!n \\<noteq> NT\" and Null: \"stk!n \\<noteq> Null\""], ["proof (state)\nthis:\n  ST ! n \\<noteq> NT\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from NT ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "obtain D D' b Ts T m ST' LT' where\n      D:   \"ST!n = Class D\" and\n      pc': \"pc+1 < size ins\" and\n      m_D: \"P \\<turnstile> D sees M',b: Ts\\<rightarrow>T = m in D'\" and\n      Ts:  \"P \\<turnstile> rev (take n ST) [\\<le>] Ts\" and\n      \\<Phi>':  \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n      LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      ST': \"P \\<turnstile> (T # drop (n+1) ST) [\\<le>] ST'\" and\n      b[simp]: \"b = NonStatic\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D b Ts T m D' ST' LT'.\n        \\<lbrakk>ST ! n = Class D; pc + 1 < length ins;\n         P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = m in D';\n         P \\<turnstile> rev (take n ST) [\\<le>] Ts;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         P \\<turnstile> (T # drop (n + 1) ST) [\\<le>] ST';\n         b = NonStatic\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  ST ! n = Class D\n  pc + 1 < length ins\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = m in D'\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T # drop (n + 1) ST) [\\<le>] ST'\n  b = NonStatic\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)", "obtain \n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and\n    loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from n stk D"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST ! n = Class D", "have \"P,h \\<turnstile> stk!n :\\<le> Class D\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST ! n = Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> Class D", "by (auto simp: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with Null"], ["proof (chain)\npicking this:\n  stk ! n \\<noteq> Null\n  P,h \\<turnstile> stk ! n :\\<le> Class D", "obtain a C' fs where\n      Addr:   \"stk!n = Addr a\" and\n      obj:    \"h a = Some (C',fs)\" and\n      C'subD: \"P \\<turnstile> C' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  stk ! n \\<noteq> Null\n  P,h \\<turnstile> stk ! n :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a C' fs.\n        \\<lbrakk>stk ! n = Addr a; h a = \\<lfloor>(C', fs)\\<rfloor>;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest!: conf_ClassD)"], ["proof (state)\nthis:\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wfprog m_D no_xcp"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = m in D'\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D", "obtain Ts' T' D'' mxs' mxl' ins' xt' where\n      m_C': \"P \\<turnstile> C' sees M',NonStatic: Ts'\\<rightarrow>T' = (mxs',mxl',ins',xt') in D''\" and\n      T':   \"P \\<turnstile> T' \\<le> T\" and\n      Ts':  \"P \\<turnstile> Ts [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = m in D'\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. (\\<And>Ts' T' mxs' mxl' ins' xt' D''.\n        \\<lbrakk>P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs',\n   mxl', ins', xt') in D'';\n         subtype P T' T; P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_mono)"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  subtype P T' T\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wf_NonStatic_nclinit wtprog"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_prog ?wf_md ?P;\n   ?P \\<turnstile> ?C sees ?M, NonStatic :  ?Ts\\<rightarrow>?T = (?mxs,\n                            ?mxl, ?ins, ?xt) in ?D\\<rbrakk>\n  \\<Longrightarrow> ?M \\<noteq> clinit\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  subtype P T' T\n  P \\<turnstile> Ts [\\<le>] Ts'", "have nclinit: \"M' \\<noteq> clinit\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_prog ?wf_md ?P;\n   ?P \\<turnstile> ?C sees ?M, NonStatic :  ?Ts\\<rightarrow>?T = (?mxs,\n                            ?mxl, ?ins, ?xt) in ?D\\<rbrakk>\n  \\<Longrightarrow> ?M \\<noteq> clinit\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  subtype P T' T\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. M' \\<noteq> clinit", "by(simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  M' \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have D''subD': \"P \\<turnstile> D'' \\<preceq>\\<^sup>* D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D'' \\<preceq>\\<^sup>* D'", "by(rule sees_method_decl_mono[OF C'subD m_D m_C'])"], ["proof (state)\nthis:\n  P \\<turnstile> D'' \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?loc' = \"Addr a # rev (take n stk) @ replicate mxl' undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f' = \"([], ?loc', D'', M', 0, No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f  = \"(stk, loc, C, M, pc, ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from Addr obj m_C' ins \\<sigma>' meth_C no_xcp"], ["proof (chain)\npicking this:\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  ins ! pc = Invoke M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  fst (exec_step P h stk loc C M pc ics frs sh) = None", "have s': \"\\<sigma>' = (None, h, ?f' # ?f # frs, sh)\""], ["proof (prove)\nusing this:\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  ins ! pc = Invoke M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics) #\n     (stk, loc, C, M, pc, ics) # frs,\n     sh)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics) #\n   (stk, loc, C, M, pc, ics) # frs,\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from Ts n"], ["proof (chain)\npicking this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  n < length ST", "have [simp]: \"size Ts = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  n < length ST\n\ngoal (1 subgoal):\n 1. length Ts = n", "by (auto dest: list_all2_lengthD simp: min_def)"], ["proof (state)\nthis:\n  length Ts = n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with Ts'"], ["proof (chain)\npicking this:\n  P \\<turnstile> Ts [\\<le>] Ts'\n  length Ts = n", "have [simp]: \"size Ts' = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Ts [\\<le>] Ts'\n  length Ts = n\n\ngoal (1 subgoal):\n 1. length Ts' = n", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length Ts' = n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from m_C' wfprog"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  wf_prog wfmb P", "obtain mD'': \"P \\<turnstile> D'' sees M',NonStatic:Ts'\\<rightarrow>T'=(mxs',mxl',ins',xt') in D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. (P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs',\n                              mxl', ins', xt') in D'' \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: sees_method_idemp)"], ["proof (state)\nthis:\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''", "obtain start: \"wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M')\" and ins': \"ins' \\<noteq> []\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M');\n      ins' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: wt_jvm_prog_impl_wt_start)"], ["proof (state)\nthis:\n  wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []", "obtain LT\\<^sub>0 where LT\\<^sub>0: \"\\<Phi> D'' M' ! 0 = Some ([], LT\\<^sub>0)\""], ["proof (prove)\nusing this:\n  wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>LT\\<^sub>0.\n        \\<Phi> D'' M' ! 0 =\n        \\<lfloor>([], LT\\<^sub>0)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: wt_start_def defs1 sup_state_opt_any_Some split: staticb.splits)"], ["proof (state)\nthis:\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_f P h sh ([], LT\\<^sub>0) ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "let ?LT = \"OK (Class D'') # (map OK Ts') @ (replicate mxl' Err)\""], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "hence \"P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "note Ts"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "also"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "note Ts'"], ["proof (state)\nthis:\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts'", "have \"P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "have \"P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "from m_C'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''", "have \"P \\<turnstile> C' \\<preceq>\\<^sup>* D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                          ins', xt') in D''\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' \\<preceq>\\<^sup>* D''", "by (rule sees_method_decl_above)"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "with obj"], ["proof (chain)\npicking this:\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''", "have \"P,h \\<turnstile> Addr a :\\<le> Class D''\""], ["proof (prove)\nusing this:\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a :\\<le> Class D''", "by (simp add: conf_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a :\\<le> Class D''\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts' @\n              replicate mxl' Err\n  P,h \\<turnstile> Addr a :\\<le> Class D''", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] ?LT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts' @\n              replicate mxl' Err\n  P,h \\<turnstile> Addr a :\\<le> Class D''\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a #\n                     rev (take n stk) @\n                     replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n                map OK Ts' @ replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n              map OK Ts' @ replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n              map OK Ts' @ replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "from start LT\\<^sub>0"], ["proof (chain)\npicking this:\n  wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M')\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>", "have \"P \\<turnstile> \\<dots> [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  wt_start P D'' NonStatic Ts' mxl' (\\<Phi> D'' M')\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (OK (Class D'') #\n                    map OK Ts' @\n                    replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "by (simp add: wt_start_def)"], ["proof (state)\nthis:\n  P \\<turnstile> (OK (Class D'') #\n                  map OK Ts' @\n                  replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a #\n                     rev (take n stk) @\n                     replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "."], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "using ins' nclinit"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n  ins' \\<noteq> []\n  M' \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n      No_ics)", "by simp"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P sh (?f'#?f#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     (([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n       No_ics) #\n      (stk, loc, C, M, pc, ics) # frs)", "using conf_clinit_Invoke[OF confc nclinit]"], ["proof (prove)\nusing this:\n  conf_clinit P sh\n   ((?stk', ?loc', ?C', M', ?pc', No_ics) #\n    (stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     (([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n       No_ics) #\n      (stk, loc, C, M, pc, ics) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh\n   (([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n     No_ics) #\n    (stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics)\n  conf_clinit P sh\n   (([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n     No_ics) #\n    (stk, loc, C, M, pc, ics) # frs)", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics)\n  conf_clinit P sh\n   (([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n     No_ics) #\n    (stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "using s' \\<Phi>_pc approx meth_C m_D T' ins D nclinit D''subD'"], ["proof (prove)\nusing this:\n  P \\<turnstile> D'' sees M', NonStatic :  Ts'\\<rightarrow>T' = (mxs', mxl',\n                           ins', xt') in D''\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics)\n  conf_clinit P sh\n   (([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n     No_ics) #\n    (stk, loc, C, M, pc, ics) # frs)\n  \\<sigma>' =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0,\n    No_ics) #\n   (stk, loc, C, M, pc, ics) # frs,\n   sh)\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = m in D'\n  subtype P T' T\n  ins ! pc = Invoke M' n\n  ST ! n = Class D\n  M' \\<noteq> clinit\n  P \\<turnstile> D'' \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(fastforce dest: sees_method_fun [of _ C])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ST ! n \\<noteq> NT; stk ! n \\<noteq> Null\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>ST ! n \\<noteq> NT; stk ! n \\<noteq> Null\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>ST ! n \\<noteq> NT; stk ! n \\<noteq> Null\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by blast"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Invokestatic_nInit_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invokestatic D M' n\" and nclinit: \"M' \\<noteq> clinit\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes no_xcp: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh (fst(method P D M')) = Some(sfs, Done)))\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note split_paired_Ex [simp del]"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wfprog: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins meth_C approx"], ["proof (chain)\npicking this:\n  ins ! pc = Invokestatic D M' n\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h sh (ST,LT) ins (stk,loc,C,M,pc,ics)\" and\n    frames:  \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc:   \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\""], ["proof (prove)\nusing this:\n  ins ! pc = Invokestatic D M' n\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = Invokestatic D M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have n: \"n \\<le> size ST\""], ["proof (prove)\nusing this:\n  ins ! pc = Invokestatic D M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<le> length ST", "by simp"], ["proof (state)\nthis:\n  n \\<le> length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = Invokestatic D M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "obtain D' b Ts T mxs' mxl' ins' xt' ST' LT' where\n    pc': \"pc+1 < size ins\" and\n    m_D: \"P \\<turnstile> D sees M',b: Ts\\<rightarrow>T = (mxs',mxl',ins',xt') in D'\" and\n    Ts:  \"P \\<turnstile> rev (take n ST) [\\<le>] Ts\" and\n    \\<Phi>':  \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n    LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n    ST': \"P \\<turnstile> (T # drop n ST) [\\<le>] ST'\" and\n    b[simp]: \"b = Static\""], ["proof (prove)\nusing this:\n  ins ! pc = Invokestatic D M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>b Ts T mxs' mxl' ins' xt' D' ST' LT'.\n        \\<lbrakk>pc + 1 < length ins;\n         P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl',\n                      ins', xt') in D';\n         P \\<turnstile> rev (take n ST) [\\<le>] Ts;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         P \\<turnstile> (T # drop n ST) [\\<le>] ST'; b = Static\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  pc + 1 < length ins\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T # drop n ST) [\\<le>] ST'\n  b = Static\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)", "obtain \n  stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and\n  loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\nusing this:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?loc' = \"rev (take n stk) @ replicate mxl' undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f' = \"([], ?loc', D', M', 0, No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f  = \"(stk, loc, C, M, pc, No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from m_D ins \\<sigma>' meth_C no_xcp cs"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (method P D M')) = \\<lfloor>(sfs, Done)\\<rfloor>)", "have s': \"\\<sigma>' = (None, h, ?f' # ?f # frs, sh)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (method P D M')) = \\<lfloor>(sfs, Done)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n     (stk, loc, C, M, pc, No_ics) # frs,\n     sh)", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n   (stk, loc, C, M, pc, No_ics) # frs,\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from Ts n"], ["proof (chain)\npicking this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  n \\<le> length ST", "have [simp]: \"size Ts = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  n \\<le> length ST\n\ngoal (1 subgoal):\n 1. length Ts = n", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length Ts = n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from m_D wfprog b"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  wf_prog wfmb P\n  b = Static", "obtain mD': \"P \\<turnstile> D' sees M',Static:Ts\\<rightarrow>T=(mxs',mxl',ins',xt') in D'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  wf_prog wfmb P\n  b = Static\n\ngoal (1 subgoal):\n 1. (P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl',\n                        ins', xt') in D' \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: sees_method_idemp)"], ["proof (state)\nthis:\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'", "obtain start: \"wt_start P D' Static Ts mxl' (\\<Phi> D' M')\" and ins': \"ins' \\<noteq> []\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wt_start P D' Static Ts mxl' (\\<Phi> D' M');\n      ins' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: wt_jvm_prog_impl_wt_start)"], ["proof (state)\nthis:\n  wt_start P D' Static Ts mxl' (\\<Phi> D' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  wt_start P D' Static Ts mxl' (\\<Phi> D' M')\n  ins' \\<noteq> []", "obtain LT\\<^sub>0 where LT\\<^sub>0: \"\\<Phi> D' M' ! 0 = Some ([], LT\\<^sub>0)\""], ["proof (prove)\nusing this:\n  wt_start P D' Static Ts mxl' (\\<Phi> D' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>LT\\<^sub>0.\n        \\<Phi> D' M' ! 0 =\n        \\<lfloor>([], LT\\<^sub>0)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: wt_start_def defs1 sup_state_opt_any_Some split: staticb.splits)"], ["proof (state)\nthis:\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_f P h sh ([], LT\\<^sub>0) ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "let ?LT = \"(map OK Ts) @ (replicate mxl' Err)\""], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "hence \"P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "note Ts"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts", "have \"P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "have \"P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "from m_D"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'", "have \"P \\<turnstile> D \\<preceq>\\<^sup>* D'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D \\<preceq>\\<^sup>* D'", "by (rule sees_method_decl_above)"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts @\n              replicate mxl' Err\n  P \\<turnstile> D \\<preceq>\\<^sup>* D'", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] ?LT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts @\n              replicate mxl' Err\n  P \\<turnstile> D \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) @\n                     replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] map OK Ts @\n                replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts @\n              replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts @\n              replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "from start LT\\<^sub>0"], ["proof (chain)\npicking this:\n  wt_start P D' Static Ts mxl' (\\<Phi> D' M')\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>", "have \"P \\<turnstile> \\<dots> [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  wt_start P D' Static Ts mxl' (\\<Phi> D' M')\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (map OK Ts @\n                    replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "by (simp add: wt_start_def)"], ["proof (state)\nthis:\n  P \\<turnstile> (map OK Ts @\n                  replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) @\n                     replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "."], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "using ins'"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. conf_f P h sh ([], LT\\<^sub>0) ins'\n     ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)", "by simp"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P sh (?f'#?f#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     (([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n      (stk, loc, C, M, pc, No_ics) # frs)", "by(rule conf_clinit_Invoke[OF confc nclinit])"], ["proof (state)\nthis:\n  conf_clinit P sh\n   (([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n    (stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)\n  conf_clinit P sh\n   (([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n    (stk, loc, C, M, pc, No_ics) # frs)", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)\n  conf_clinit P sh\n   (([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n    (stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "using s' \\<Phi>_pc approx meth_C m_D ins nclinit"], ["proof (prove)\nusing this:\n  P \\<turnstile> D' sees M', Static :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n                     xt') in D'\n  \\<Phi> D' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h sh ([], LT\\<^sub>0) ins'\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics)\n  conf_clinit P sh\n   (([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n    (stk, loc, C, M, pc, No_ics) # frs)\n  \\<sigma>' =\n  (None, h,\n   ([], rev (take n stk) @ replicate mxl' undefined, D', M', 0, No_ics) #\n   (stk, loc, C, M, pc, No_ics) # frs,\n   sh)\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  M' \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (fastforce dest: sees_method_fun [of _ C])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Invokestatic_Init_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invokestatic D M' n\" and nclinit: \"M' \\<noteq> clinit\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes no_xcp: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh (fst(method P D M')) \\<noteq> Some(sfs, Done)\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note split_paired_Ex [simp del]"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wfprog: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins meth_C approx"], ["proof (chain)\npicking this:\n  ins ! pc = Invokestatic D M' n\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and\n    frames:  \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc:   \"conf_clinit P sh ((stk,loc,C,M,pc,No_ics)#frs)\" and\n    pc:      \"pc < size ins\""], ["proof (prove)\nusing this:\n  ins ! pc = Invokestatic D M' n\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n         pc < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n  pc < length ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = Invokestatic D M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "obtain D' b Ts T mxs' mxl' ins' xt' where\n    m_D: \"P \\<turnstile> D sees M',b: Ts\\<rightarrow>T = (mxs',mxl',ins',xt') in D'\" and\n    b[simp]: \"b = Static\""], ["proof (prove)\nusing this:\n  ins ! pc = Invokestatic D M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>b Ts T mxs' mxl' ins' xt' D'.\n        \\<lbrakk>P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs',\n                              mxl', ins', xt') in D';\n         b = Static\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  b = Static\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f  = \"(stk, loc, C, M, pc, Calling D' [])\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from m_D ins \\<sigma>' meth_C no_xcp nDone"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n  \\<forall>sfs.\n     sh (fst (method P D M')) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "have s': \"\\<sigma>' = (None, h, ?f # frs, sh)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n  \\<forall>sfs.\n     sh (fst (method P D M')) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D' []) # frs, sh)", "by(auto split: init_state.splits)"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D' []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have cls: \"is_class P D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class P D'", "by(rule sees_method_is_class'[OF m_D])"], ["proof (state)\nthis:\n  is_class P D'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "have confc': \"conf_clinit P sh (?f#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Calling D' []) # frs)", "by(auto simp: conf_clinit_def distinct_clinit_def split: if_split_asm)"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D' []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with s' \\<Phi>_pc approx meth_C m_D ins nclinit stk loc pc cls frames"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D' []) # frs, sh)\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  M' \\<noteq> clinit\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  is_class P D'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D' []) # frs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D' []) # frs, sh)\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> D sees M', b :  Ts\\<rightarrow>T = (mxs', mxl', ins',\n               xt') in D'\n  ins ! pc = Invokestatic D M' n\n  M' \\<noteq> clinit\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  is_class P D'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D' []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(fastforce dest: sees_method_fun [of _ C])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "declare list_all2_Cons2 [iff]"], ["", "lemma Return_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wt_prog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins: \"ins ! pc = Return\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth correct ins"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Return", "have [simp]: \"ics = No_ics\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Return\n\ngoal (1 subgoal):\n 1. ics = No_ics", "by(cases ics, auto)"], ["proof (state)\nthis:\n  ics = No_ics\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt_prog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth ins s'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)", "have \"frs = [] \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "by (simp add: correct_state_def)"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix f frs'"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume frs': \"frs = f#frs'\""], ["proof (state)\nthis:\n  frs = f # frs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  frs = f # frs'", "obtain stk' loc' C' M' pc' ics' where \n      f: \"f = (stk',loc',C',M',pc',ics')\""], ["proof (prove)\nusing this:\n  frs = f # frs'\n\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc' ics'.\n        f = (stk', loc', C', M', pc', ics') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases f)"], ["proof (state)\nthis:\n  f = (stk', loc', C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain ST LT where\n      h_ok:   \"P \\<turnstile> h \\<surd>\" and\n      sh_ok:   \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n      \\<Phi>_pc: \"\\<Phi> C M ! pc = Some (ST, LT)\" and\n      frame:  \"conf_f P h sh (ST, LT) ins (stk,loc,C,M,pc,ics)\" and\n      frames: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n      confc: \"conf_clinit P sh frs\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun conf_clinit_Cons simp: correct_state_def)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = Return\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain U ST\\<^sub>0 where \"ST = U # ST\\<^sub>0\" \"P \\<turnstile> U \\<le> T\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = Return\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>U ST\\<^sub>0.\n        \\<lbrakk>ST = U # ST\\<^sub>0; subtype P U T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wt_instr_def app_def) blast"], ["proof (state)\nthis:\n  ST = U # ST\\<^sub>0\n  subtype P U T\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wf frame"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ST = U # ST\\<^sub>0\n  subtype P U T", "have hd_stk: \"P,h \\<turnstile> hd stk :\\<le> T\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  ST = U # ST\\<^sub>0\n  subtype P U T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T", "by (auto simp: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' frames meth"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain ST' LT' b' Ts'' T'' mxs' mxl\\<^sub>0' ins' xt' where\n      \\<Phi>': \"\\<Phi> C' M' ! pc' = Some (ST', LT')\" and\n      meth_C':  \"P \\<turnstile> C' sees M',b':Ts''\\<rightarrow>T''=(mxs',mxl\\<^sub>0',ins',xt') in C'\" and\n      frame':   \"conf_f P h sh (ST',LT') ins' f\" and\n      conf_fs:  \"conf_fs P h sh \\<Phi> C' M' (size Ts'') T'' frs'\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT' b' Ts'' T'' mxs' mxl\\<^sub>0' ins' xt'.\n        \\<lbrakk>\\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                            mxl\\<^sub>0', ins', xt') in C';\n         conf_f P h sh (ST', LT') ins' f;\n         conf_fs P h sh \\<Phi> C' M' (length Ts'') T'' frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  conf_f P h sh (ST', LT') ins' f\n  conf_fs P h sh \\<Phi> C' M' (length Ts'') T'' frs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frame'"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  conf_f P h sh (ST', LT') ins' f", "obtain\n      stk': \"P,h \\<turnstile> stk' [:\\<le>] ST'\" and\n      loc': \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\" and\n      pc':  \"pc' < size ins'\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  conf_f P h sh (ST', LT') ins' f\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk' [:\\<le>] ST';\n      P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT';\n      pc' < length ins'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume b[simp]: \"b = NonStatic\""], ["proof (state)\nthis:\n  b = NonStatic\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wf_NonStatic_nclinit[OF wf] meth"], ["proof (chain)\npicking this:\n  P \\<turnstile> ?C sees ?M, NonStatic :  ?Ts\\<rightarrow>?T = (?mxs, ?mxl,\n                          ?ins, ?xt) in ?D \\<Longrightarrow>\n  ?M \\<noteq> clinit\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "have nclinit[simp]: \"M \\<noteq> clinit\""], ["proof (prove)\nusing this:\n  P \\<turnstile> ?C sees ?M, NonStatic :  ?Ts\\<rightarrow>?T = (?mxs, ?mxl,\n                          ?ins, ?xt) in ?D \\<Longrightarrow>\n  ?M \\<noteq> clinit\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. M \\<noteq> clinit", "by simp"], ["proof (state)\nthis:\n  M \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' meth ins s'"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)", "have \\<sigma>':\n        \"\\<sigma>' = (None,h,(hd stk#(drop (1+size Ts) stk'),loc',C',M',pc'+1,ics')#frs',sh)\"\n        (is \"\\<sigma>' = (None,h,?f'#frs',sh)\")"], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n     frs',\n     sh)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') # frs',\n   sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' confc conf_clinit_diff"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_clinit P sh frs\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, ?ics) # ?frs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk', ?loc', ?C, ?M, ?pc', ?ics) # ?frs)", "have confc'': \"conf_clinit P sh (?f'#frs')\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_clinit P sh frs\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, ?ics) # ?frs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk', ?loc', ?C, ?M, ?pc', ?ics) # ?frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n      frs')", "by blast"], ["proof (state)\nthis:\n  conf_clinit P sh\n   ((hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n    frs')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \\<Phi>' meth_C' f frs' frames meth"], ["proof (chain)\npicking this:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_clinit P sh\n   ((hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n    frs')", "obtain D Ts' T' m D' where\n        ins': \"ins' ! pc' = Invoke M (size Ts)\" and\n        D: \"ST' ! (size Ts) = Class D\" and\n        meth_D: \"P \\<turnstile> D sees M,b: Ts'\\<rightarrow>T' = m in D'\" and\n        T': \"P \\<turnstile> T \\<le> T'\" and\n        CsubD': \"P \\<turnstile> C \\<preceq>\\<^sup>* D'\""], ["proof (prove)\nusing this:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_clinit P sh\n   ((hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n    frs')\n\ngoal (1 subgoal):\n 1. (\\<And>D Ts' T' m D'.\n        \\<lbrakk>ins' ! pc' = Invoke M (length Ts);\n         ST' ! length Ts = Class D;\n         P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in D';\n         subtype P T T'; P \\<turnstile> C \\<preceq>\\<^sup>* D'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: sees_method_fun sees_method_fun[OF sees_method_idemp])"], ["proof (state)\nthis:\n  ins' ! pc' = Invoke M (length Ts)\n  ST' ! length Ts = Class D\n  P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in D'\n  subtype P T T'\n  P \\<turnstile> C \\<preceq>\\<^sup>* D'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt_prog meth_C' pc'"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  pc' < length ins'", "have \"P,T'',mxs',size ins',xt' \\<turnstile> ins'!pc',pc' :: \\<Phi> C' M'\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "by (rule wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins' \\<Phi>' D meth_D"], ["proof (chain)\npicking this:\n  ins' ! pc' = Invoke M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  ST' ! length Ts = Class D\n  P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in D'\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "obtain ST'' LT'' where\n        \\<Phi>_suc:   \"\\<Phi> C' M' ! Suc pc' = Some (ST'', LT'')\" and\n        less:    \"P \\<turnstile> (T' # drop (size Ts+1) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\" and\n        suc_pc': \"Suc pc' < size ins'\""], ["proof (prove)\nusing this:\n  ins' ! pc' = Invoke M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  ST' ! length Ts = Class D\n  P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in D'\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. (\\<And>ST'' LT''.\n        \\<lbrakk>\\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>;\n         P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                         LT') \\<le>\\<^sub>i (ST'', LT'');\n         Suc pc' < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from hd_stk T'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  subtype P T T'", "have hd_stk': \"P,h \\<turnstile> hd stk :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  subtype P T T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have frame'':\n        \"conf_f P h sh (ST'',LT'') ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "from stk'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "have \"P,h \\<turnstile> drop (1+size Ts) stk' [:\\<le>] drop (1+size Ts) ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> drop (1 + length Ts)\n                      stk' [:\\<le>] drop (1 + length Ts) ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "with hd_stk' less"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'", "have \"P,h \\<turnstile> hd stk # drop (1+size Ts) stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "from wf loc' less"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')", "have \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "note suc_pc'"], ["proof (state)\nthis:\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "from f frs' frames"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "(* ics' = No_ics *)"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "have \"P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')", "by auto"], ["proof (state)\nthis:\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \\<sigma>' frs' f meth h_ok sh_ok hd_stk \\<Phi>_suc frames confc'' meth_C' \\<Phi>'"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') # frs',\n   sh)\n  frs = f # frs'\n  f = (stk', loc', C', M', pc', ics')\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh\n   ((hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n    frs')\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') # frs',\n   sh)\n  frs = f # frs'\n  f = (stk', loc', C', M', pc', ics')\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh\n   ((hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics') #\n    frs')\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1, ics')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(fastforce dest: sees_method_fun [of _ C'])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  b = NonStatic \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  b = NonStatic \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  b = NonStatic \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume b[simp]: \"b = Static\" and nclinit[simp]: \"M \\<noteq> clinit\""], ["proof (state)\nthis:\n  b = Static\n  M \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' meth ins s'"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)", "have \\<sigma>':\n        \"\\<sigma>' = (None,h,(hd stk#(drop (size Ts) stk'),loc',C',M',pc'+1,ics')#frs',sh)\"\n        (is \"\\<sigma>' = (None,h,?f'#frs',sh)\")"], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs',\n     sh)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs', sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' confc conf_clinit_diff"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_clinit P sh frs\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, ?ics) # ?frs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk', ?loc', ?C, ?M, ?pc', ?ics) # ?frs)", "have confc'': \"conf_clinit P sh (?f'#frs')\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_clinit P sh frs\n  conf_clinit ?P ?sh\n   ((?stk, ?loc, ?C, ?M, ?pc, ?ics) # ?frs) \\<Longrightarrow>\n  conf_clinit ?P ?sh ((?stk', ?loc', ?C, ?M, ?pc', ?ics) # ?frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs')", "by blast"], ["proof (state)\nthis:\n  conf_clinit P sh\n   ((hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \\<Phi>' meth_C' f frs' frames meth"], ["proof (chain)\npicking this:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_clinit P sh\n   ((hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs')", "obtain D Ts' T' m where\n        ins': \"ins' ! pc' = Invokestatic D M (size Ts)\" and\n        meth_D: \"P \\<turnstile> D sees M,b: Ts'\\<rightarrow>T' = m in C\" and\n        T': \"P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_clinit P sh\n   ((hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs')\n\ngoal (1 subgoal):\n 1. (\\<And>D Ts' T' m.\n        \\<lbrakk>ins' ! pc' = Invokestatic D M (length Ts);\n         P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in C;\n         subtype P T T'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: sees_method_fun sees_method_mono2[OF _ wf sees_method_idemp])"], ["proof (state)\nthis:\n  ins' ! pc' = Invokestatic D M (length Ts)\n  P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in C\n  subtype P T T'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt_prog meth_C' pc'"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  pc' < length ins'", "have \"P,T'',mxs',size ins',xt' \\<turnstile> ins'!pc',pc' :: \\<Phi> C' M'\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "by (rule wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins' \\<Phi>' meth_D"], ["proof (chain)\npicking this:\n  ins' ! pc' = Invokestatic D M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in C\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "obtain ST'' LT'' where\n        \\<Phi>_suc:   \"\\<Phi> C' M' ! Suc pc' = Some (ST'', LT'')\" and\n        less:    \"P \\<turnstile> (T' # drop (size Ts) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\" and\n        suc_pc': \"Suc pc' < size ins'\""], ["proof (prove)\nusing this:\n  ins' ! pc' = Invokestatic D M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> D sees M, b :  Ts'\\<rightarrow>T' = m in C\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. (\\<And>ST'' LT''.\n        \\<lbrakk>\\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>;\n         P \\<turnstile> (T' # drop (length Ts) ST',\n                         LT') \\<le>\\<^sub>i (ST'', LT'');\n         Suc pc' < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  P \\<turnstile> (T' # drop (length Ts) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from hd_stk T'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  subtype P T T'", "have hd_stk': \"P,h \\<turnstile> hd stk :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  subtype P T T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have frame'':\n        \"conf_f P h sh (ST'',LT'') ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "from stk'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "have \"P,h \\<turnstile> drop (size Ts) stk' [:\\<le>] drop (size Ts) ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "with hd_stk' less"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'", "have \"P,h \\<turnstile> hd stk # drop (size Ts) stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk # drop (length Ts) stk' [:\\<le>] ST''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "from wf loc' less"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts) ST', LT') \\<le>\\<^sub>i (ST'', LT'')", "have \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "note suc_pc'"], ["proof (state)\nthis:\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "moreover"], ["proof (state)\nthis:\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "from f frs' frames"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "(* ics' = No_ics *)"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "have \"P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')", "by auto"], ["proof (state)\nthis:\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> drop (length Ts) stk' [:\\<le>] drop (length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', Suc pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST'', LT'') ins'\n     (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \\<sigma>' frs' f meth h_ok sh_ok hd_stk \\<Phi>_suc frames confc'' meth_C' \\<Phi>'"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs', sh)\n  frs = f # frs'\n  f = (stk', loc', C', M', pc', ics')\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh\n   ((hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs')\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs', sh)\n  frs = f # frs'\n  f = (stk', loc', C', M', pc', ics')\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh\n   ((hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics') # frs')\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h sh (ST'', LT'') ins'\n   (hd stk # drop (length Ts) stk', loc', C', M', pc' + 1, ics')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(fastforce dest: sees_method_fun [of _ C'])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>b = Static; M \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>b = Static; M \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  \\<lbrakk>b = Static; M \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume b[simp]: \"b = Static\" and clinit[simp]: \"M = clinit\""], ["proof (state)\nthis:\n  b = Static\n  M = clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frs' meth ins s'"], ["proof (chain)\npicking this:\n  frs = f # frs'\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)", "have \\<sigma>':\n        \"\\<sigma>' = (None,h,frs,sh(C\\<mapsto>(fst(the(sh C)), Done)))\" (is \"\\<sigma>' = (None,h,frs,?sh)\")"], ["proof (prove)\nusing this:\n  frs = f # frs'\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, frs, sh(C \\<mapsto> (fst (the (sh C)), Done)))", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, frs, sh(C \\<mapsto> (fst (the (sh C)), Done)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "have dist': \"distinct (C # clinit_classes frs)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. distinct (C # clinit_classes frs)", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  distinct (C # clinit_classes frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' correct"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "have confc1:\n       \"conf_clinit P sh ((stk, loc, C, clinit, pc, No_ics) # (stk',loc',C',M',pc',ics') # frs')\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. conf_clinit P sh\n     ((stk, loc, C, clinit, pc, No_ics) #\n      (stk', loc', C', M', pc', ics') # frs')", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh\n   ((stk, loc, C, clinit, pc, No_ics) #\n    (stk', loc', C', M', pc', ics') # frs')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  conf_clinit P sh\n   ((stk, loc, C, clinit, pc, No_ics) #\n    (stk', loc', C', M', pc', ics') # frs')", "have ics_dist: \"distinct (C # ics_classes ics')\""], ["proof (prove)\nusing this:\n  conf_clinit P sh\n   ((stk, loc, C, clinit, pc, No_ics) #\n    (stk', loc', C', M', pc', ics') # frs')\n\ngoal (1 subgoal):\n 1. distinct (C # ics_classes ics')", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  distinct (C # ics_classes ics')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from conf_clinit_Cons_Cons[OF confc1]"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, clinit, pc, No_ics) # frs')", "have dist'': \"distinct (C # clinit_classes frs')\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, clinit, pc, No_ics) # frs')\n\ngoal (1 subgoal):\n 1. distinct (C # clinit_classes frs')", "by(simp add: conf_clinit_def distinct_clinit_def)"], ["proof (state)\nthis:\n  distinct (C # clinit_classes frs')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct shconf_upd_obj[OF sh_ok _ [OF shconfD[OF sh_ok]]]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  sh ?C = \\<lfloor>(?sfs', ?i2)\\<rfloor> \\<Longrightarrow>\n  P,h \\<turnstile>\\<^sub>s sh(?C \\<mapsto> (?sfs', ?i')) \\<surd>", "have sh'_ok: \"P,h \\<turnstile>\\<^sub>s ?sh \\<surd>\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  sh ?C = \\<lfloor>(?sfs', ?i2)\\<rfloor> \\<Longrightarrow>\n  P,h \\<turnstile>\\<^sub>s sh(?C \\<mapsto> (?sfs', ?i')) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto>\n    (fst (the (sh C)), Done)) \\<surd>", "by(clarsimp simp: conf_clinit_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (fst (the (sh C)), Done)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have frame'':\n        \"conf_f P h ?sh (ST',LT') ins' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f", "note stk' loc' pc' f valid_ics_shupd[OF _ ics_dist]"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n  f = (stk', loc', C', M', pc', ics')\n  ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics') \\<Longrightarrow>\n  ?P,?h,?sh(C \\<mapsto>\n  (?sfs, ?i')) \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics')\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n  f = (stk', loc', C', M', pc', ics')\n  ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics') \\<Longrightarrow>\n  ?P,?h,?sh(C \\<mapsto>\n  (?sfs, ?i')) \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics')\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f", "from f frs' frames"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "have \"P,h,sh \\<turnstile>\\<^sub>i (C', M', pc', ics')\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,h,sh \\<turnstile>\\<^sub>i (C', M', pc', ics')", "by auto"], ["proof (state)\nthis:\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n  f = (stk', loc', C', M', pc', ics')\n  ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics') \\<Longrightarrow>\n  ?P,?h,?sh(C \\<mapsto>\n  (?sfs, ?i')) \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics')\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', pc', ics')", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n  f = (stk', loc', C', M', pc', ics')\n  ?P,?h,?sh \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics') \\<Longrightarrow>\n  ?P,?h,?sh(C \\<mapsto>\n  (?sfs, ?i')) \\<turnstile>\\<^sub>i (?C, ?M, ?pc, ics')\n  P,h,sh \\<turnstile>\\<^sub>i (C', M', pc', ics')\n\ngoal (1 subgoal):\n 1. conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f", "by (simp add: conf_f_def2)"], ["proof (state)\nthis:\n  conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have conf_fs': \"conf_fs P h ?sh \\<Phi> C' M' (length Ts'') T'' frs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) \\<Phi> C' M'\n     (length Ts'') T'' frs'", "by(rule conf_fs_shupd[OF conf_fs dist''])"], ["proof (state)\nthis:\n  conf_fs P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) \\<Phi> C' M'\n   (length Ts'') T'' frs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have confc'': \"conf_clinit P ?sh frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(C \\<mapsto> (fst (the (sh C)), Done))) frs", "by(rule conf_clinit_shupd[OF confc dist'])"], ["proof (state)\nthis:\n  conf_clinit P (sh(C \\<mapsto> (fst (the (sh C)), Done))) frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<sigma>' f frs' h_ok sh'_ok conf_fs' frame'' \\<Phi>' stk' loc' pc' meth_C' confc''"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, frs, sh(C \\<mapsto> (fst (the (sh C)), Done)))\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (fst (the (sh C)), Done)) \\<surd>\n  conf_fs P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) \\<Phi> C' M'\n   (length Ts'') T'' frs'\n  conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  conf_clinit P (sh(C \\<mapsto> (fst (the (sh C)), Done))) frs", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, frs, sh(C \\<mapsto> (fst (the (sh C)), Done)))\n  f = (stk', loc', C', M', pc', ics')\n  frs = f # frs'\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(C \\<mapsto> (fst (the (sh C)), Done)) \\<surd>\n  conf_fs P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) \\<Phi> C' M'\n   (length Ts'') T'' frs'\n  conf_f P h (sh(C \\<mapsto> (fst (the (sh C)), Done))) (ST', LT') ins' f\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n  P \\<turnstile> C' sees M', b' :  Ts''\\<rightarrow>T'' = (mxs',\n                     mxl\\<^sub>0', ins', xt') in C'\n  conf_clinit P (sh(C \\<mapsto> (fst (the (sh C)), Done))) frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>b = Static; M = clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  b = NonStatic \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>b = Static; M \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>b = Static; M = clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "have ?thesis"], ["proof (prove)\nusing this:\n  b = NonStatic \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>b = Static; M \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>b = Static; M = clinit\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (cases b) blast+"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  frs = ?f2 # ?frs'2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  frs = ?f2 # ?frs'2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  frs = ?f2 # ?frs'2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (cases frs) blast+"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "declare sup_state_opt_any_Some [iff]"], ["", "declare not_Err_eq [iff]"], ["", "lemma Load_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Load idx; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh); \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT ab.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (loc ! idx # stk, loc, C, M, Suc pc, No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = Load idx; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Load idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; idx < length LT;\n        \\<forall>x\\<in>set (xcpt_eff (Load idx) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(ab # ST, LT)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    subtype P ab z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Load idx) P pc (ST, LT)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        length ST < mxs; LT ! idx = OK ab\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((loc ! idx # stk, loc, C, M, Suc pc, No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             (\\<exists>a b.\n                                 \\<Phi> C M ! Suc pc =\n                                 \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                 P,h \\<turnstile> loc ! idx #\n            stk [:\\<le>] a \\<and>\n                                 P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                 Suc pc < length is \\<and>\n                                 conf_fs P h sh \\<Phi> C M (length Ts) T\n                                  frs))", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT ab.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (loc ! idx # stk, loc, C, M, Suc pc, No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = Load idx;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Load idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; idx < length LT;\n        \\<forall>x\\<in>set (xcpt_eff (Load idx) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>a b.\n           (a = Suc pc \\<and>\n            b = \\<lfloor>(ab # ST, LT)\\<rfloor> \\<longrightarrow>\n            (\\<exists>a b.\n                \\<Phi> C M ! Suc pc = \\<lfloor>(a, b)\\<rfloor> \\<and>\n                (\\<exists>z zs.\n                    a = z # zs \\<and>\n                    subtype P ab z \\<and>\n                    P \\<turnstile> ST [\\<le>] zs) \\<and>\n                P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] b)) \\<and>\n           ((a, b)\n            \\<in> set (xcpt_eff (Load idx) P pc (ST, LT)\n                        xt) \\<longrightarrow>\n            P \\<turnstile> b \\<le>' \\<Phi> C M ! a);\n        length ST < mxs; LT ! idx = OK ab;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((loc ! idx # stk, loc, C, M, Suc pc, No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             (\\<exists>a b.\n                                 \\<Phi> C M ! Suc pc =\n                                 \\<lfloor>(a, b)\\<rfloor> \\<and>\n                                 P,h \\<turnstile> loc ! idx #\n            stk [:\\<le>] a \\<and>\n                                 P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b \\<and>\n                                 Suc pc < length is \\<and>\n                                 conf_fs P h sh \\<Phi> C M (length Ts) T\n                                  frs))", "apply(fastforce elim!: confTs_confT_sup conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "declare [[simproc del: list_to_set_comprehension]]"], ["", "lemma Store_correct:\n\"\\<lbrakk> wf_prog wt P;\n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C;\n  ins!pc = Store idx;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh);\n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc[idx := z], C, M, Suc pc, No_ics) # frs,\n                 sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = Store idx; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((zs, loc[idx := z], C, M, Suc pc, No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                             P,h \\<turnstile> loc\n                             [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc[idx := z], C, M, Suc pc, No_ics) # frs,\n                 sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = Store idx;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((zs, loc[idx := z], C, M, Suc pc, No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                             P,h \\<turnstile> loc\n                             [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (blast intro!: list_all2_update_cong conf_clinit_diff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Push_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Push v;\n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh);\n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT y bb z zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (v # stk, loc, C, M, Suc pc, No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = Push v; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; subtype P y z;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((v # stk, loc, C, M, Suc pc, No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> v :\\<le> z \\<and>\n                             P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT y bb z zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (v # stk, loc, C, M, Suc pc, No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = Push v;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; subtype P y z;\n        P \\<turnstile> ST [\\<le>] zs;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((v # stk, loc, C, M, Suc pc, No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> v :\\<le> z \\<and>\n                             P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (blast dest: typeof_lit_conf conf_clinit_diff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Cast_conf2:\n  \"\\<lbrakk> wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T; cast_ok P C h v; \n     P \\<turnstile> Class C \\<le> T'; is_class P C\\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T;\n     cast_ok P C h v; subtype P (Class C) T'; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T;\n     cast_ok P C h v; subtype P (Class C) T'; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (unfold cast_ok_def is_refT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n     T = NT \\<or> (\\<exists>C. T = Class C);\n     v = Null \\<or>\n     P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n     subtype P (Class C) T'; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (frule Class_widen)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n     T = NT \\<or> (\\<exists>C. T = Class C);\n     v = Null \\<or>\n     P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n     subtype P (Class C) T'; is_class P C; \\<exists>D. T' = Class D\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (elim exE disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = NT;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 2. \\<And>D.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = NT;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 3. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 4. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = NT;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 2. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 3. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 2. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (clarsimp simp: conf_def obj_ty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D Ca T'a.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca)\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)", "apply (cases v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>D Ca T'a.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Unit\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 2. \\<And>D Ca T'a.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Null\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 3. \\<And>D Ca T'a x3.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 4. \\<And>D Ca T'a x4.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 5. \\<And>D Ca T'a x5.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Addr x5\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)", "apply (auto intro: rtrancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Checkcast_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Checkcast D; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>;\n    fst (exec_step P h stk loc C M pc ics frs sh) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (clarsimp simp: wf_jvm_prog_phi_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta baa Taa ST bb z zs za zsa.\n       \\<lbrakk>ics = No_ics;\n        wf_prog\n         (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n              (\\<Phi> C M))\n         P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = Checkcast D; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, baa)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] baa; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs; cast_ok P D h z;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, baa) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, baa) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        is_class P D; is_refT Taa;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(za # zsa, bb)\\<rfloor>;\n        \\<sigma>' =\n        (None, h, (z # zs, loc, C, M, Suc pc, No_ics) # frs, sh);\n        P \\<turnstile> baa [\\<le>\\<^sub>\\<top>] bb; stk = z # zs;\n        P,h \\<turnstile> z :\\<le> Taa; P,h \\<turnstile> zs [:\\<le>] ST;\n        subtype P (Class D) za; P \\<turnstile> ST [\\<le>] zsa\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((z # zs, loc, C, M, Suc pc, No_ics) # frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> z :\\<le> za \\<and>\n                             P,h \\<turnstile> zs [:\\<le>] zsa \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta baa Taa ST bb z zs za zsa.\n       \\<lbrakk>ics = No_ics;\n        wf_prog\n         (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n              (\\<Phi> C M))\n         P;\n        ins ! pc = Checkcast D; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, baa)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] baa; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs; cast_ok P D h z;\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, baa) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, baa) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        is_class P D; is_refT Taa;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(za # zsa, bb)\\<rfloor>;\n        \\<sigma>' =\n        (None, h, (z # zs, loc, C, M, Suc pc, No_ics) # frs, sh);\n        P \\<turnstile> baa [\\<le>\\<^sub>\\<top>] bb; stk = z # zs;\n        P,h \\<turnstile> z :\\<le> Taa; P,h \\<turnstile> zs [:\\<le>] ST;\n        subtype P (Class D) za; P \\<turnstile> ST [\\<le>] zsa;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((z # zs, loc, C, M, Suc pc, No_ics) # frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> z :\\<le> za \\<and>\n                             P,h \\<turnstile> zs [:\\<le>] zsa \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (blast intro: Cast_conf2 dest: sees_method_fun conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "declare split_paired_All [simp del]"], ["", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P"], ["", "lemma Getfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf i"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Getfield F D", "have [simp]: \"ics = No_ics\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Getfield F D\n\ngoal (1 subgoal):\n 1. ics = No_ics", "by(cases ics, auto)"], ["proof (state)\nthis:\n  ics = No_ics\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and\n    \"sh\\<surd>\": \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = Getfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain oT ST'' vT ST' LT' vT' where \n    oT: \"P \\<turnstile> oT \\<le> Class D\" and\n    ST: \"ST = oT # ST''\" and\n    F:  \"P \\<turnstile> D sees F,NonStatic:vT in D\" and\n    pc': \"pc+1 < size ins\"  and\n    \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (vT'#ST', LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and  \n    vT': \"P \\<turnstile> vT \\<le> vT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Getfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>oT ST'' vT vT' ST' LT'.\n        \\<lbrakk>subtype P oT (Class D); ST = oT # ST'';\n         P \\<turnstile> D sees F,NonStatic:vT in D; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         subtype P vT vT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  subtype P oT (Class D)\n  ST = oT # ST''\n  P \\<turnstile> D sees F,NonStatic:vT in D\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = oT # ST''", "obtain ref stk' where \n    stk': \"stk = ref#stk'\" and\n    ref:  \"P,h \\<turnstile> ref :\\<le> oT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = oT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk'; P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk' i mC s' xc"], ["proof (chain)\npicking this:\n  stk = ref # stk'\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = None", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  stk = ref # stk'\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by (simp add: split_beta split:if_split_asm)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a D' fs where \n    a: \"ref = Addr a\" and h: \"h a = Some (D', fs)\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a D' fs.\n        \\<lbrakk>ref = Addr a; h a = \\<lfloor>(D', fs)\\<rfloor>;\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD)"], ["proof (state)\nthis:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from D' F"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F,NonStatic:vT in D", "have has_field: \"P \\<turnstile> D' has F,NonStatic:vT in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F,NonStatic:vT in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F,NonStatic:vT in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F,NonStatic:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F,NonStatic:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \"h\\<surd>\" h"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>", "have \"P,h \\<turnstile> (D', fs) \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> (D', fs) \\<surd>", "by (rule hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' has F,NonStatic:vT in D\n  P,h \\<turnstile> (D', fs) \\<surd>", "obtain v where v: \"fs (F, D) = Some v\" \"P,h \\<turnstile> v :\\<le> vT\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' has F,NonStatic:vT in D\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fs (F, D) = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile> v :\\<le> vT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: oconf_def has_field_def) \n       (blast dest: has_fields_fun)"], ["proof (state)\nthis:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from conf_clinit_diff[OF confc]"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((?stk', ?loc', C, M, ?pc', ics) # frs)", "have confc': \"conf_clinit P sh ((v#stk',loc,C,M,pc+1,ics)#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((?stk', ?loc', C, M, ?pc', ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((v # stk', loc, C, M, pc + 1, ics) # frs)", "by simp"], ["proof (state)\nthis:\n  conf_clinit P sh ((v # stk', loc, C, M, pc + 1, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from a h i mC s' stk' v xc has_field"], ["proof (chain)\npicking this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  stk = ref # stk'\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> D' has F,NonStatic:vT in D", "have \"\\<sigma>' = (None, h, (v#stk',loc,C,M,pc+1,ics)#frs, sh)\""], ["proof (prove)\nusing this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  stk = ref # stk'\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> D' has F,NonStatic:vT in D\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1, ics) # frs, sh)", "by(simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from v vT'"], ["proof (chain)\npicking this:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'", "have \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", "by blast"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note \"h\\<surd>\" \"sh\\<surd>\" mC \\<Phi>' pc' v fs confc'"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((v # stk', loc, C, M, pc + 1, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1, ics) # frs, sh)\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((v # stk', loc, C, M, pc + 1, ics) # frs)", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1, ics) # frs, sh)\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((v # stk', loc, C, M, pc + 1, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Getstatic_nInit_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh (fst(field P D F)) = Some(sfs, Done)))\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and\n    \"sh\\<surd>\": \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\" and\n    vics: \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs);\n         P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt cs"], ["proof (chain)\npicking this:\n  ins ! pc = Getstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)", "obtain vT ST' LT' vT' where \n    F:  \"P \\<turnstile> C' sees F,Static:vT in D\" and\n    pc': \"pc+1 < size ins\"  and\n    \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (vT'#ST', LT')\" and\n    ST': \"P \\<turnstile> ST [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and  \n    vT': \"P \\<turnstile> vT \\<le> vT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Getstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>vT vT' ST' LT'.\n        \\<lbrakk>P \\<turnstile> C' sees F,Static:vT in D;\n         pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         subtype P vT vT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees F,Static:vT in D\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with mC i vics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Getstatic C' F D\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  P \\<turnstile> C' sees F,Static:vT in D\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  subtype P vT vT'", "obtain sobj where\n    cc': \"ics = Called [] \\<Longrightarrow> Called_context P D (ins!pc) \\<and> sh D = Some sobj\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Getstatic C' F D\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  P \\<turnstile> C' sees F,Static:vT in D\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. (\\<And>sobj.\n        (ics = Called [] \\<Longrightarrow>\n         Called_context P D (ins ! pc) \\<and>\n         sh D = \\<lfloor>sobj\\<rfloor>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: has_visible_field)"], ["proof (state)\nthis:\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from field_def2[OF sees_field_idemp[OF F]]"], ["proof (chain)\npicking this:\n  field P D F = (D, Static, vT)", "have D[simp]: \"fst(field P D F) = D\""], ["proof (prove)\nusing this:\n  field P D F = (D, Static, vT)\n\ngoal (1 subgoal):\n 1. fst (field P D F) = D", "by simp"], ["proof (state)\nthis:\n  fst (field P D F) = D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from cs cc'"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>", "obtain sfs i where shD: \"sh D = Some(sfs,i)\""], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i.\n        sh D = \\<lfloor>(sfs, i)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases sobj, auto)"], ["proof (state)\nthis:\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note has_field_idemp[OF has_visible_field[OF F]]"], ["proof (state)\nthis:\n  P \\<turnstile> D has F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D has F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \"sh\\<surd>\" shD"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>", "have \"P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>", "by (rule shconfD)"], ["proof (state)\nthis:\n  P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has F,Static:vT in D\n  P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>", "obtain v where v: \"sfs F = Some v\" \"P,h \\<turnstile> v :\\<le> vT\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F,Static:vT in D\n  P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>sfs F = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile> v :\\<le> vT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: soconf_def has_field_def) blast"], ["proof (state)\nthis:\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i mC s' v xc F cs cc' shD"], ["proof (chain)\npicking this:\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT in D\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>", "have \"\\<sigma>' = (None, h, (v#stk,loc,C,M,pc+1,No_ics)#frs, sh)\""], ["proof (prove)\nusing this:\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT in D\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (v # stk, loc, C, M, pc + 1, No_ics) # frs, sh)", "by(fastforce simp: split_beta split: if_split_asm init_call_status.splits)"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (v # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (v # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> ST [\\<le>] ST'", "have \"P,h \\<turnstile> stk [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> ST [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from v vT'"], ["proof (chain)\npicking this:\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'", "have \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", "by blast"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P sh ((v#stk,loc,C,M,pc+1,No_ics)#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((v # stk, loc, C, M, pc + 1, No_ics) # frs)", "by(rule conf_clinit_diff'[OF confc])"], ["proof (state)\nthis:\n  conf_clinit P sh ((v # stk, loc, C, M, pc + 1, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P sh ((v # stk, loc, C, M, pc + 1, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note \"h\\<surd>\" \"sh\\<surd>\" mC \\<Phi>' pc' v fs"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (v # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n  P,h \\<turnstile> stk [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_clinit P sh ((v # stk, loc, C, M, pc + 1, No_ics) # frs)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (v # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n  P,h \\<turnstile> stk [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_clinit P sh ((v # stk, loc, C, M, pc + 1, No_ics) # frs)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  sfs F = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Getstatic_Init_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh (fst(field P D F)) \\<noteq> Some(sfs, Done)\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and\n    \"sh\\<surd>\": \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,No_ics)#frs)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt nDone"], ["proof (chain)\npicking this:\n  ins ! pc = Getstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "obtain vT where \n    F:  \"P \\<turnstile> C' sees F,Static:vT in D\""], ["proof (prove)\nusing this:\n  ins ! pc = Getstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>vT.\n        P \\<turnstile> C' sees F,Static:vT in D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees F,Static:vT in D", "have has_field: \"P \\<turnstile> C' has F,Static:vT in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,Static:vT in D", "by(rule has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> C' has F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from field_def2[OF sees_field_idemp[OF F]] has_field_is_class'[OF has_field]"], ["proof (chain)\npicking this:\n  field P D F = (D, Static, vT)\n  is_class P D", "obtain\n    D[simp]: \"fst(field P D F) = D\" and\n    cls: \"is_class P D\""], ["proof (prove)\nusing this:\n  field P D F = (D, Static, vT)\n  is_class P D\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>fst (field P D F) = D; is_class P D\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  fst (field P D F) = D\n  is_class P D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i mC s' xc F nDone"], ["proof (chain)\npicking this:\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT in D\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "have \"\\<sigma>' = (None, h, (stk,loc,C,M,pc,Calling D [])#frs, sh)\""], ["proof (prove)\nusing this:\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT in D\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)", "by(auto simp: split_beta split: if_split_asm init_state.splits)"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "have \"conf_clinit P sh ((stk,loc,C,M,pc,Calling D [])#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)", "by(auto simp: conf_clinit_def distinct_clinit_def split: if_split_asm)"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note loc stk \"h\\<surd>\" \"sh\\<surd>\" mC \\<Phi> pc fs i has_field cls"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C' has F,Static:vT in D\n  is_class P D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C' has F,Static:vT in D\n  is_class P D", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  ins ! pc = Getstatic C' F D\n  P \\<turnstile> C' has F,Static:vT in D\n  is_class P D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Putfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf i"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Putfield F D", "have [simp]: \"ics = No_ics\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  ins ! pc = Putfield F D\n\ngoal (1 subgoal):\n 1. ics = No_ics", "by(cases ics, auto)"], ["proof (state)\nthis:\n  ics = No_ics\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and      \n    \"sh\\<surd>\": \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and    \n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics) # frs)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = Putfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain vT vT' oT ST'' ST' LT' where \n    ST: \"ST = vT # oT # ST''\" and\n    field: \"P \\<turnstile> D sees F,NonStatic:vT' in D\" and\n    oT: \"P \\<turnstile> oT \\<le> Class D\" and vT: \"P \\<turnstile> vT \\<le> vT'\" and\n    pc': \"pc+1 < size ins\" and \n    \\<Phi>': \"\\<Phi> C M!(pc+1) = Some (ST',LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Putfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>vT oT ST'' vT' ST' LT'.\n        \\<lbrakk>ST = vT # oT # ST'';\n         P \\<turnstile> D sees F,NonStatic:vT' in D; subtype P oT (Class D);\n         subtype P vT vT'; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  ST = vT # oT # ST''\n  P \\<turnstile> D sees F,NonStatic:vT' in D\n  subtype P oT (Class D)\n  subtype P vT vT'\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''", "obtain v ref stk' where \n    stk': \"stk = v#ref#stk'\" and\n    v:    \"P,h \\<turnstile> v :\\<le> vT\" and \n    ref:  \"P,h \\<turnstile> ref :\\<le> oT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>v ref stk'.\n        \\<lbrakk>stk = v # ref # stk'; P,h \\<turnstile> v :\\<le> vT;\n         P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v # ref # stk'\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk' i mC s' xc"], ["proof (chain)\npicking this:\n  stk = v # ref # stk'\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = None", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  stk = v # ref # stk'\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a D' fs where \n    a: \"ref = Addr a\" and h: \"h a = Some (D', fs)\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a D' fs.\n        \\<lbrakk>ref = Addr a; h a = \\<lfloor>(D', fs)\\<rfloor>;\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD)"], ["proof (state)\nthis:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from v vT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'", "have vT': \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from field D'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees F,NonStatic:vT' in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have has_field: \"P \\<turnstile> D' has F,NonStatic:vT' in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees F,NonStatic:vT' in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F,NonStatic:vT' in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F,NonStatic:vT' in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?h' = \"h(a\\<mapsto>(D', fs((F, D)\\<mapsto>v)))\" and ?f' = \"(stk',loc,C,M,pc+1,ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h"], ["proof (chain)\npicking this:\n  h a = \\<lfloor>(D', fs)\\<rfloor>", "have hext: \"h \\<unlhd> ?h'\""], ["proof (prove)\nusing this:\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "by (rule hext_upd_obj)"], ["proof (state)\nthis:\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"sh\\<surd>'\": \"P,?h' \\<turnstile>\\<^sub>s sh \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto>\n    (D', fs((F, D) \\<mapsto> v))) \\<turnstile>\\<^sub>s sh \\<surd>", "by(rule shconf_hupd_obj[OF \"sh\\<surd>\" h])"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile>\\<^sub>s sh \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from a h i mC s' stk' has_field field"], ["proof (chain)\npicking this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  stk = v # ref # stk'\n  P \\<turnstile> D' has F,NonStatic:vT' in D\n  P \\<turnstile> D sees F,NonStatic:vT' in D", "have \"\\<sigma>' = (None, ?h', ?f'#frs, sh)\""], ["proof (prove)\nusing this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  stk = v # ref # stk'\n  P \\<turnstile> D' has F,NonStatic:vT' in D\n  P \\<turnstile> D sees F,NonStatic:vT' in D\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n     (stk', loc, C, M, pc + 1, ics) # frs, sh)", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1, ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \"h\\<surd>\" h"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>", "have \"P,h \\<turnstile> (D',fs)\\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> (D', fs) \\<surd>", "by (rule hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with has_field vT'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' has F,NonStatic:vT' in D\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> (D', fs) \\<surd>", "have \"P,h \\<turnstile> (D',fs((F, D)\\<mapsto>v))\\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' has F,NonStatic:vT' in D\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \"h\\<surd>\" h"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>", "have \"P \\<turnstile> ?h'\\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>", "by (rule hconf_upd_obj)"], ["proof (state)\nthis:\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from this hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "have \"P,?h' \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto>\n    (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'", "by (rule confs_hext)"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from this hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "have \"P,?h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto>\n    (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by (rule confTs_hext)"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from fs hext"], ["proof (chain)\npicking this:\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "have \"conf_fs P ?h' sh \\<Phi> C M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) sh \\<Phi> C M\n     (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) sh \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) sh \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P sh (?f' # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk', loc, C, M, pc + 1, ics) # frs)", "by(rule conf_clinit_diff[OF confc])"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk', loc, C, M, pc + 1, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk', loc, C, M, pc + 1, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note mC \\<Phi>' pc' \"sh\\<surd>'\""], ["proof (state)\nthis:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile>\\<^sub>s sh \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1, ics) # frs, sh)\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) sh \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P sh ((stk', loc, C, M, pc + 1, ics) # frs)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile>\\<^sub>s sh \\<surd>", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1, ics) # frs, sh)\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) sh \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P sh ((stk', loc, C, M, pc + 1, ics) # frs)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile>\\<^sub>s sh \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Putstatic_nInit_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh (fst(field P D F)) = Some(sfs, Done)))\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and\n    \"sh\\<surd>\": \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,ics)#frs)\" and\n    vics: \"P,h,sh \\<turnstile>\\<^sub>i (C,M,pc,ics)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs);\n         P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt cs"], ["proof (chain)\npicking this:\n  ins ! pc = Putstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)", "obtain vT vT' ST'' ST' LT' where \n    ST: \"ST = vT # ST''\" and\n    F:  \"P \\<turnstile> C' sees F,Static:vT' in D\" and\n    vT: \"P \\<turnstile> vT \\<le> vT'\" and\n    pc': \"pc+1 < size ins\"  and\n    \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Putstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>vT ST'' vT' ST' LT'.\n        \\<lbrakk>ST = vT # ST''; P \\<turnstile> C' sees F,Static:vT' in D;\n         subtype P vT vT'; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ST = vT # ST''\n  P \\<turnstile> C' sees F,Static:vT' in D\n  subtype P vT vT'\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # ST''", "obtain v stk' where \n    stk': \"stk = v#stk'\" and\n    v:    \"P,h \\<turnstile> v :\\<le> vT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>v stk'.\n        \\<lbrakk>stk = v # stk'; P,h \\<turnstile> v :\\<le> vT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v # stk'\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from v vT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'", "have vT': \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with mC i vics"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Putstatic C' F D\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  P,h \\<turnstile> v :\\<le> vT'", "obtain sobj where\n    cc': \"ics = Called [] \\<Longrightarrow> Called_context P D (ins!pc) \\<and> sh D = Some sobj\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  ins ! pc = Putstatic C' F D\n  P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics)\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. (\\<And>sobj.\n        (ics = Called [] \\<Longrightarrow>\n         Called_context P D (ins ! pc) \\<and>\n         sh D = \\<lfloor>sobj\\<rfloor>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest: has_visible_field)"], ["proof (state)\nthis:\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from field_def2[OF sees_field_idemp[OF F]]"], ["proof (chain)\npicking this:\n  field P D F = (D, Static, vT')", "have D[simp]: \"fst(field P D F) = D\""], ["proof (prove)\nusing this:\n  field P D F = (D, Static, vT')\n\ngoal (1 subgoal):\n 1. fst (field P D F) = D", "by simp"], ["proof (state)\nthis:\n  fst (field P D F) = D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from cs cc'"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>", "obtain sfs i where shD: \"sh D = Some(sfs,i)\""], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i.\n        sh D = \\<lfloor>(sfs, i)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases sobj, auto)"], ["proof (state)\nthis:\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?sh' = \"sh(D\\<mapsto>(sfs(F\\<mapsto>v),i))\" and ?f' = \"(stk',loc,C,M,pc+1,No_ics)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have m_D: \"P \\<turnstile> D has F,Static:vT' in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has F,Static:vT' in D", "by (rule has_field_idemp[OF has_visible_field[OF F]])"], ["proof (state)\nthis:\n  P \\<turnstile> D has F,Static:vT' in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \"sh\\<surd>\" shD"], ["proof (chain)\npicking this:\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>", "have sfs: \"P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>", "by (rule shconfD)"], ["proof (state)\nthis:\n  P,h,D \\<turnstile>\\<^sub>s sfs \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"sh'\\<surd>\": \"P,h \\<turnstile>\\<^sub>s ?sh' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile>\\<^sub>s sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)) \\<surd>", "by (rule shconf_upd_obj[OF \"sh\\<surd>\" soconf_fupd[OF m_D vT' sfs]])"], ["proof (state)\nthis:\n  P,h \\<turnstile>\\<^sub>s sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i mC s' v xc F cs cc' shD stk'"], ["proof (chain)\npicking this:\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P,h \\<turnstile> v :\\<le> vT\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT' in D\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n  stk = v # stk'", "have \"\\<sigma>' = (None, h, (stk',loc,C,M,pc+1,No_ics)#frs, ?sh')\""], ["proof (prove)\nusing this:\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P,h \\<turnstile> v :\\<le> vT\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT' in D\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>)\n  ics = Called [] \\<Longrightarrow>\n  Called_context P D (ins ! pc) \\<and> sh D = \\<lfloor>sobj\\<rfloor>\n  sh D = \\<lfloor>(sfs, i)\\<rfloor>\n  stk = v # stk'\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h, (stk', loc, C, M, pc + 1, No_ics) # frs, sh(D \\<mapsto>\n     (sfs(F \\<mapsto> v), i)))", "by(fastforce simp: split_beta split: if_split_asm init_call_status.splits)"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h, (stk', loc, C, M, pc + 1, No_ics) # frs, sh(D \\<mapsto>\n   (sfs(F \\<mapsto> v), i)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h, (stk', loc, C, M, pc + 1, No_ics) # frs, sh(D \\<mapsto>\n   (sfs(F \\<mapsto> v), i)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_fs P h ?sh' \\<Phi> C M (size Ts) T frs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_fs P h (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i))) \\<Phi> C M\n     (length Ts) T frs", "by (rule conf_fs_shupd'[OF fs shD])"], ["proof (state)\nthis:\n  conf_fs P h (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i))) \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_fs P h (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i))) \\<Phi> C M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P ?sh' ((stk',loc,C,M,pc+1,No_ics)#frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)))\n     ((stk', loc, C, M, pc + 1, No_ics) # frs)", "by(rule conf_clinit_diff'[OF conf_clinit_shupd'[OF confc shD]])"], ["proof (state)\nthis:\n  conf_clinit P (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)))\n   ((stk', loc, C, M, pc + 1, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)))\n   ((stk', loc, C, M, pc + 1, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note \"h\\<surd>\" \"sh'\\<surd>\" mC \\<Phi>' pc' v vT'"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)) \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h, (stk', loc, C, M, pc + 1, No_ics) # frs, sh(D \\<mapsto>\n   (sfs(F \\<mapsto> v), i)))\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i))) \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)))\n   ((stk', loc, C, M, pc + 1, No_ics) # frs)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)) \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> v :\\<le> vT'", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h, (stk', loc, C, M, pc + 1, No_ics) # frs, sh(D \\<mapsto>\n   (sfs(F \\<mapsto> v), i)))\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P h (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i))) \\<Phi> C M\n   (length Ts) T frs\n  conf_clinit P (sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)))\n   ((stk', loc, C, M, pc + 1, No_ics) # frs)\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh(D \\<mapsto> (sfs(F \\<mapsto> v), i)) \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Putstatic_Init_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putstatic C' F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes xc: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh (fst(field P D F)) \\<noteq> Some(sfs, Done)\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and\n    \"sh\\<surd>\": \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc: \"conf_clinit P sh ((stk,loc,C,M,pc,No_ics)#frs)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt nDone"], ["proof (chain)\npicking this:\n  ins ! pc = Putstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "obtain vT where \n    F:  \"P \\<turnstile> C' sees F,Static:vT in D\""], ["proof (prove)\nusing this:\n  ins ! pc = Putstatic C' F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>vT.\n        P \\<turnstile> C' sees F,Static:vT in D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees F,Static:vT in D", "have has_field: \"P \\<turnstile> C' has F,Static:vT in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has F,Static:vT in D", "by(rule has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> C' has F,Static:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from field_def2[OF sees_field_idemp[OF F]] has_field_is_class'[OF has_field]"], ["proof (chain)\npicking this:\n  field P D F = (D, Static, vT)\n  is_class P D", "obtain\n    D[simp]: \"fst(field P D F) = D\" and\n    cls: \"is_class P D\""], ["proof (prove)\nusing this:\n  field P D F = (D, Static, vT)\n  is_class P D\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>fst (field P D F) = D; is_class P D\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  fst (field P D F) = D\n  is_class P D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i mC s' xc F nDone"], ["proof (chain)\npicking this:\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT in D\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "have \"\\<sigma>' = (None, h, (stk,loc,C,M,pc,Calling D [])#frs, sh)\""], ["proof (prove)\nusing this:\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n  P \\<turnstile> C' sees F,Static:vT in D\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)", "by(auto simp: split_beta split: if_split_asm init_state.splits)"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "have \"conf_clinit P sh ((stk,loc,C,M,pc,Calling D [])#frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)", "by(auto simp: conf_clinit_def distinct_clinit_def split: if_split_asm)"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note loc stk \"h\\<surd>\" \"sh\\<surd>\" mC \\<Phi> pc fs i has_field cls"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C' has F,Static:vT in D\n  is_class P D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C' has F,Static:vT in D\n  is_class P D", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling D []) # frs, sh)\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling D []) # frs)\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  pc < length ins\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  ins ! pc = Putstatic C' F D\n  P \\<turnstile> C' has F,Static:vT in D\n  is_class P D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n  \n(* FIXME: move *)"], ["", "lemma oconf_blank2 [intro, simp]:\n    \"\\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>", "by (fastforce simp: oconf_blank dest: wf_Fields_Ex)"], ["", "(*>*)"], ["", "lemma obj_ty_blank [iff]: \"obj_ty (blank P C) = Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (blank P C) = Class C", "by (simp add: blank_def)"], ["", "lemma New_nInit_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n  assumes conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\n  assumes no_x: \"fst (exec_step P h stk loc C M pc ics frs sh) = None\"\n  assumes cs: \"ics = Called [] \\<or> (ics = No_ics \\<and> (\\<exists>sfs. sh X = Some(sfs, Done)))\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    sheap_ok: \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h sh (ST,LT) ins (stk,loc,C,M,pc,ics)\" and\n    frames:  \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc:   \"conf_clinit P sh ((stk,loc,C,M,pc,ics) # frs)\""], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain ST' LT' where\n    is_class_X: \"is_class P X\" and\n    mxs:       \"size ST < mxs\" and\n    suc_pc:     \"pc+1 < size ins\" and\n    \\<Phi>_suc:      \"\\<Phi> C M!(pc+1) = Some (ST', LT')\" and\n    less:       \"P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>is_class P X; length ST < mxs; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_class P X\n  length ST < mxs\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins no_x cs meth"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  ics = Called [] \\<or>\n  ics = No_ics \\<and> (\\<exists>sfs. sh X = \\<lfloor>(sfs, Done)\\<rfloor>)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain oref where new_Addr: \"new_Addr h = Some oref\""], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  ics = Called [] \\<or>\n  ics = No_ics \\<and> (\\<exists>sfs. sh X = \\<lfloor>(sfs, Done)\\<rfloor>)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>oref.\n        new_Addr h = \\<lfloor>oref\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence h: \"h oref = None\""], ["proof (prove)\nusing this:\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n\ngoal (1 subgoal):\n 1. h oref = None", "by (rule new_Addr_SomeD)"], ["proof (state)\nthis:\n  h oref = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with exec ins meth new_Addr cs"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ins ! pc = New X\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n  ics = Called [] \\<or>\n  ics = No_ics \\<and> (\\<exists>sfs. sh X = \\<lfloor>(sfs, Done)\\<rfloor>)\n  h oref = None", "have \\<sigma>':\n    \"\\<sigma>' = (None, h(oref \\<mapsto> blank P X), (Addr oref#stk,loc,C,M,pc+1,No_ics)#frs, sh)\"\n    (is \"\\<sigma>' = (None, ?h', ?f # frs, sh)\")"], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  ins ! pc = New X\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n  ics = Called [] \\<or>\n  ics = No_ics \\<and> (\\<exists>sfs. sh X = \\<lfloor>(sfs, Done)\\<rfloor>)\n  h oref = None\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h(oref \\<mapsto> blank P X),\n     (Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs, sh)", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wf h heap_ok is_class_X"], ["proof (chain)\npicking this:\n  wf_prog wt P\n  h oref = None\n  P \\<turnstile> h \\<surd>\n  is_class P X", "have h': \"P \\<turnstile> ?h' \\<surd>\""], ["proof (prove)\nusing this:\n  wf_prog wt P\n  h oref = None\n  P \\<turnstile> h \\<surd>\n  is_class P X\n\ngoal (1 subgoal):\n 1. P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>", "by (auto intro: hconf_new)"], ["proof (state)\nthis:\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h frame less suc_pc wf"], ["proof (chain)\npicking this:\n  h oref = None\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n  pc + 1 < length ins\n  wf_prog wt P", "have \"conf_f P ?h' sh (ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  h oref = None\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, ics)\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n  pc + 1 < length ins\n  wf_prog wt P\n\ngoal (1 subgoal):\n 1. conf_f P (h(oref \\<mapsto> blank P X)) sh (ST', LT') ins\n     (Addr oref # stk, loc, C, M, pc + 1, No_ics)", "apply (clarsimp simp: fun_upd_apply conf_def blank_def split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z zs.\n       \\<lbrakk>h oref = None; Suc pc < length ins; wf_prog wt P;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        P,h,sh \\<turnstile>\\<^sub>i (C, M, pc, ics); ST' = z # zs;\n        subtype P (Class X) z; P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> P,h(oref \\<mapsto>\n                         (X, init_fields\n                              (ifields P\n                                X))) \\<turnstile> stk [:\\<le>] zs \\<and>\n                         P,h(oref \\<mapsto>\n                         (X, init_fields\n                              (ifields P\n                                X))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "apply (auto intro: confs_hext confTs_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  conf_f P (h(oref \\<mapsto> blank P X)) sh (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_f P (h(oref \\<mapsto> blank P X)) sh (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h"], ["proof (chain)\npicking this:\n  h oref = None", "have \"h \\<unlhd> ?h'\""], ["proof (prove)\nusing this:\n  h oref = None\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h(oref \\<mapsto> blank P X)", "by simp"], ["proof (state)\nthis:\n  h \\<unlhd> h(oref \\<mapsto> blank P X)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with frames"], ["proof (chain)\npicking this:\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  h \\<unlhd> h(oref \\<mapsto> blank P X)", "have \"conf_fs P ?h' sh \\<Phi> C M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  h \\<unlhd> h(oref \\<mapsto> blank P X)\n\ngoal (1 subgoal):\n 1. conf_fs P (h(oref \\<mapsto> blank P X)) sh \\<Phi> C M (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P (h(oref \\<mapsto> blank P X)) sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_fs P (h(oref \\<mapsto> blank P X)) sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"P,?h' \\<turnstile>\\<^sub>s sh \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h(oref \\<mapsto> blank P X) \\<turnstile>\\<^sub>s sh \\<surd>", "by(rule shconf_hnew[OF sheap_ok h])"], ["proof (state)\nthis:\n  P,h(oref \\<mapsto> blank P X) \\<turnstile>\\<^sub>s sh \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h(oref \\<mapsto> blank P X) \\<turnstile>\\<^sub>s sh \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_clinit P sh (?f # frs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_clinit P sh ((Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs)", "by(rule conf_clinit_diff'[OF confc])"], ["proof (state)\nthis:\n  conf_clinit P sh ((Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n  conf_f P (h(oref \\<mapsto> blank P X)) sh (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics)\n  conf_fs P (h(oref \\<mapsto> blank P X)) sh \\<Phi> C M (length Ts) T frs\n  P,h(oref \\<mapsto> blank P X) \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n  conf_f P (h(oref \\<mapsto> blank P X)) sh (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics)\n  conf_fs P (h(oref \\<mapsto> blank P X)) sh \\<Phi> C M (length Ts) T frs\n  P,h(oref \\<mapsto> blank P X) \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "using meth \\<Phi>_suc"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs, sh)\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n  conf_f P (h(oref \\<mapsto> blank P X)) sh (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1, No_ics)\n  conf_fs P (h(oref \\<mapsto> blank P X)) sh \\<Phi> C M (length Ts) T frs\n  P,h(oref \\<mapsto> blank P X) \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_clinit P sh ((Addr oref # stk, loc, C, M, pc + 1, No_ics) # frs)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma New_Init_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n  assumes conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n  assumes no_x: \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\"\n  assumes nDone: \"\\<forall>sfs. sh X \\<noteq> Some(sfs, Done)\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    sheap_ok: \"P,h \\<turnstile>\\<^sub>s sh \\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h sh (ST,LT) ins (stk,loc,C,M,pc,No_ics)\" and\n    frames:  \"conf_fs P h sh \\<Phi> C M (size Ts) T frs\" and\n    confc:   \"conf_clinit P sh ((stk,loc,C,M,pc,No_ics) # frs)\""], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, No_ics);\n         conf_fs P h sh \\<Phi> C M (length Ts) T frs;\n         conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, No_ics)\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain ST' LT' where\n    is_class_X: \"is_class P X\" and\n    mxs:       \"size ST < mxs\" and\n    suc_pc:     \"pc+1 < size ins\" and\n    \\<Phi>_suc:      \"\\<Phi> C M!(pc+1) = Some (ST', LT')\" and\n    less:       \"P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>is_class P X; length ST < mxs; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_class P X\n  length ST < mxs\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with exec ins meth nDone"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  ins ! pc = New X\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<forall>sfs. sh X \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  is_class P X\n  length ST < mxs\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')", "have \\<sigma>':\n    \"\\<sigma>' = (None, h, (stk,loc,C,M,pc,Calling X [])#frs, sh)\"\n    (is \"\\<sigma>' = (None, h, ?f # frs, sh)\")"], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  ins ! pc = New X\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<forall>sfs. sh X \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  is_class P X\n  length ST < mxs\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling X []) # frs, sh)", "by(auto split: init_state.splits)"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling X []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling X []) # frs, sh)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth frame is_class_X ins"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, No_ics)\n  is_class P X\n  ins ! pc = New X", "have \"conf_f P h sh (ST, LT) ins ?f\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, No_ics)\n  is_class P X\n  ins ! pc = New X\n\ngoal (1 subgoal):\n 1. conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, Calling X [])", "by auto"], ["proof (state)\nthis:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, Calling X [])\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, Calling X [])\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note heap_ok sheap_ok frames"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from confc"], ["proof (chain)\npicking this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)", "have \"conf_clinit P sh (?f # frs)\""], ["proof (prove)\nusing this:\n  conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs)\n\ngoal (1 subgoal):\n 1. conf_clinit P sh ((stk, loc, C, M, pc, Calling X []) # frs)", "by(auto simp: conf_clinit_def distinct_clinit_def split: if_split_asm)"], ["proof (state)\nthis:\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling X []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling X []) # frs, sh)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, Calling X [])\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling X []) # frs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling X []) # frs, sh)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, Calling X [])\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling X []) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "using meth \\<Phi>_pc"], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (stk, loc, C, M, pc, Calling X []) # frs, sh)\n  conf_f P h sh (ST, LT) ins (stk, loc, C, M, pc, Calling X [])\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile>\\<^sub>s sh \\<surd>\n  conf_fs P h sh \\<Phi> C M (length Ts) T frs\n  conf_clinit P sh ((stk, loc, C, M, pc, Calling X []) # frs)\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Goto_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Goto branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba baa Tsa Ta mxsa mxl\\<^sub>0' is xta ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (stk, loc, C, M, nat (int pc + branch), No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = Goto branch; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, baa :  Tsa\\<rightarrow>Ta = (mxsa,\n                        mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, ba)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (Goto branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length a \\<and> d < mxs);\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, ba) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> a [\\<le>] ab;\n        P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((stk, loc, C, M, nat (int pc + branch), No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> stk [:\\<le>] ab \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             nat (int pc + branch) < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba baa Tsa Ta mxsa mxl\\<^sub>0' is xta ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (stk, loc, C, M, nat (int pc + branch), No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = Goto branch;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((stk, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, baa :  Tsa\\<rightarrow>Ta = (mxsa,\n                        mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, ba)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (Goto branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length a \\<and> d < mxs);\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, ba) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> a [\\<le>] ab;\n        P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] bb;\n        b = baa \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((stk, loc, C, M, nat (int pc + branch), No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> stk [:\\<le>] ab \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             nat (int pc + branch) < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (fastforce elim!: conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IfFalse_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IfFalse branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT z zs ab bb ac bc.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (zs, loc, C, M,\n                  if z = Bool False then nat (int pc + branch) else pc + 1,\n                  No_ics) #\n                 frs,\n                 sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = IfFalse branch; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Boolean # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (IfFalse branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        stk = z # zs; Suc pc < length ins;\n        P,h \\<turnstile> z :\\<le> Boolean; P,h \\<turnstile> zs [:\\<le>] ST;\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ac, bc)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] ac;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bc\\<rbrakk>\n       \\<Longrightarrow> (z = Bool False \\<longrightarrow>\n                          conf_clinit P sh\n                           ((zs, loc, C, M, nat (int pc + branch), No_ics) #\n                            frs) \\<and>\n                          (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n        mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ac \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bc \\<and>\n                              nat (int pc + branch) < length is \\<and>\n                              conf_fs P h sh \\<Phi> C M (length Ts) T\n                               frs)) \\<and>\n                         (z \\<noteq> Bool False \\<longrightarrow>\n                          conf_clinit P sh\n                           ((zs, loc, C, M, Suc pc, No_ics) # frs) \\<and>\n                          (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n        mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                              Suc pc < length is \\<and>\n                              conf_fs P h sh \\<Phi> C M (length Ts) T frs))", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT z zs ab bb ac bc.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (zs, loc, C, M,\n                  if z = Bool False then nat (int pc + branch) else pc + 1,\n                  No_ics) #\n                 frs,\n                 sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = IfFalse branch;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Boolean # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (IfFalse branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        stk = z # zs; Suc pc < length ins;\n        P,h \\<turnstile> z :\\<le> Boolean; P,h \\<turnstile> zs [:\\<le>] ST;\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ac, bc)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] ac;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bc;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> (z = Bool False \\<longrightarrow>\n                          conf_clinit P sh\n                           ((zs, loc, C, M, nat (int pc + branch), No_ics) #\n                            frs) \\<and>\n                          (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n        mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ac \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bc \\<and>\n                              nat (int pc + branch) < length is \\<and>\n                              conf_fs P h sh \\<Phi> C M (length Ts) T\n                               frs)) \\<and>\n                         (z \\<noteq> Bool False \\<longrightarrow>\n                          conf_clinit P sh\n                           ((zs, loc, C, M, Suc pc, No_ics) # frs) \\<and>\n                          (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n        mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                              Suc pc < length is \\<and>\n                              conf_fs P h sh \\<Phi> C M (length Ts) T frs))", "apply (fastforce elim!: conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma CmpEq_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = CmpEq;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta T\\<^sub>1 T\\<^sub>2 ST LT z bb\n       za zsa zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (Bool (za = z) # zsa, loc, C, M, Suc pc, No_ics) # frs,\n                 sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = CmpEq; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # za # zsa, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc =\n        \\<lfloor>(T\\<^sub>1 # T\\<^sub>2 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P CmpEq pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        \\<not> is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or>\n        is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # za # zsa;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> T\\<^sub>1;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Boolean # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> za :\\<le> T\\<^sub>2;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((Bool (za = z) # zsa, loc, C, M, Suc pc,\n                            No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta T\\<^sub>1 T\\<^sub>2 ST LT z bb\n       za zsa zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (Bool (za = z) # zsa, loc, C, M, Suc pc, No_ics) # frs,\n                 sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = CmpEq;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # za # zsa, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc =\n        \\<lfloor>(T\\<^sub>1 # T\\<^sub>2 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P CmpEq pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        \\<not> is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or>\n        is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # za # zsa;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> T\\<^sub>1;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Boolean # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> za :\\<le> T\\<^sub>2;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((Bool (za = z) # zsa, loc, C, M, Suc pc,\n                            No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (fastforce elim!: conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Pop_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Pop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc, C, M, Suc pc, No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = Pop; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Pop pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((zs, loc, C, M, Suc pc, No_ics) # frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc, C, M, Suc pc, No_ics) # frs, sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = Pop;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh ((z # zs, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Pop pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((zs, loc, C, M, Suc pc, No_ics) # frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (fastforce elim!: conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IAdd_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IAdd; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                  sh) [ok]\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (clarsimp simp: conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT zsa bb i ia zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (Intg (ia + i) # zsa, loc, C, M, Suc pc, No_ics) # frs,\n                 sh);\n        ics = No_ics; wf_prog wt P;\n        P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n        ins ! pc = IAdd; P \\<turnstile> h \\<surd>;\n        P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh\n         ((Intg i # Intg ia # zsa, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Integer # Integer # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P IAdd pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins; stk = Intg i # Intg ia # zsa;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Integer # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((Intg (ia + i) # zsa, loc, C, M, Suc pc,\n                            No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT zsa bb i ia zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (Intg (ia + i) # zsa, loc, C, M, Suc pc, No_ics) # frs,\n                 sh);\n        ics = No_ics; wf_prog wt P; ins ! pc = IAdd;\n        P \\<turnstile> h \\<surd>; P,h \\<turnstile>\\<^sub>s sh \\<surd>;\n        conf_clinit P sh\n         ((Intg i # Intg ia # zsa, loc, C, M, pc, No_ics) # frs);\n        P \\<turnstile> C sees M, ba :  Tsa\\<rightarrow>Ta = (mxsa,\n                       mxl\\<^sub>0', is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Integer # Integer # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h sh \\<Phi> C M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P IAdd pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins; stk = Intg i # Intg ia # zsa;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Integer # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs;\n        b = ba \\<and>\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> conf_clinit P sh\n                          ((Intg (ia + i) # zsa, loc, C, M, Suc pc,\n                            No_ics) #\n                           frs) \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs,\n       mxl\\<^sub>0, is, xt) in C) \\<and>\n                             P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                             P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                             Suc pc < length is \\<and>\n                             conf_fs P h sh \\<Phi> C M (length Ts) T frs)", "apply (fastforce elim!: conf_clinit_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Throw_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Throw; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>;\n  fst (exec_step P h stk loc C M pc ics frs sh) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(subgoal_tac \"ics = No_ics\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None\\<rbrakk>\n    \\<Longrightarrow> ics = No_ics\n 2. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply(cases ics, (auto)[4])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                 ins, xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok];\n     fst (exec_step P h stk loc C M pc ics frs sh) = None;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The next theorem collects the results of the sections above,\n  i.e.~exception handling, initialization procedure steps, and\n  the execution step for each instruction. It states type safety\n  for single step execution: in welltyped programs, a conforming\n  state is transformed into another conforming state when one\n  step of execution is performed.\n\\<close>"], ["", "lemma step_correct:\nfixes \\<sigma>' :: jvm_state\nassumes wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n and meth: \"P \\<turnstile> C sees M,b:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n and exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,ics)#frs, sh)\"\n and conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd>\"\nshows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from assms"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "have pc: \"pc < length ins\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. pc < length ins", "by(auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  pc < length ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wt_jvm_prog_impl_wt_instr[OF wtp meth]"], ["proof (chain)\npicking this:\n  ?pc < length ins \\<Longrightarrow>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! ?pc,?pc :: \\<Phi> C M\n  pc < length ins", "have wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\""], ["proof (prove)\nusing this:\n  ?pc < length ins \\<Longrightarrow>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! ?pc,?pc :: \\<Phi> C M\n  pc < length ins\n\ngoal (1 subgoal):\n 1. P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "by simp"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from conf"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]", "obtain ST LT where \\<Phi>: \"\\<Phi> C M ! pc = Some(ST,LT)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"fst (exec_step P h stk loc C M pc ics frs sh)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a.\n       fst (exec_step P h stk loc C M pc ics frs sh) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]", "case Some"], ["proof (state)\nthis:\n  fst (exec_step P h stk loc C M pc ics frs sh) = \\<lfloor>a_\\<rfloor>\n\ngoal (2 subgoals):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a.\n       fst (exec_step P h stk loc C M pc ics frs sh) =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(rule xcpt_correct[OF wtp meth wt Some exec conf])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case None"], ["proof (state)\nthis:\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "from wt_jvm_progD[OF wtp]"], ["proof (chain)\npicking this:\n  \\<exists>wt. wf_prog wt P", "obtain wf_md where wf: \"wf_prog wf_md P\""], ["proof (prove)\nusing this:\n  \\<exists>wt. wf_prog wt P\n\ngoal (1 subgoal):\n 1. (\\<And>wf_md.\n        wf_prog wf_md P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify"], ["proof (state)\nthis:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "assume [simp]: \"ics = No_ics\""], ["proof (state)\nthis:\n  ics = No_ics\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "from exec conf None"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  fst (exec_step P h stk loc C M pc ics frs sh) = None", "obtain\n           exec': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\"\n       and conf': \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,No_ics)#frs, sh)\\<surd>\"\n       and None': \"fst (exec_step P h stk loc C M pc No_ics frs sh) = None\""], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<lfloor>\\<sigma>'\\<rfloor> =\n              exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh);\n      P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok];\n      fst (exec_step P h stk loc C M pc No_ics frs sh) = None\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, No_ics) # frs, sh)\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, No_ics) # frs, sh) [ok]\n  fst (exec_step P h stk loc C M pc No_ics frs sh) = None\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"ins!pc\")"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       ins ! pc = Load x1 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       ins ! pc = Store x2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x101 x102.\n        ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n        P,\\<Phi> |- \\<sigma>' [ok]\nA total of 18 subgoals...", "case Load"], ["proof (state)\nthis:\n  ins ! pc = Load x1_\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       ins ! pc = Load x1 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       ins ! pc = Store x2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x101 x102.\n        ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n        P,\\<Phi> |- \\<sigma>' [ok]\nA total of 18 subgoals...", "from Load_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (17 subgoals):\n 1. \\<And>x2.\n       ins ! pc = Store x2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x111 x112 x113.\n        ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n        P,\\<Phi> |- \\<sigma>' [ok]\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>x2.\n       ins ! pc = Store x2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x111 x112 x113.\n        ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n        P,\\<Phi> |- \\<sigma>' [ok]\nA total of 17 subgoals...", "case Store"], ["proof (state)\nthis:\n  ins ! pc = Store x2_\n\ngoal (17 subgoals):\n 1. \\<And>x2.\n       ins ! pc = Store x2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x111 x112 x113.\n        ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n        P,\\<Phi> |- \\<sigma>' [ok]\nA total of 17 subgoals...", "from Store_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (16 subgoals):\n 1. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 16 subgoals...", "case Push"], ["proof (state)\nthis:\n  ins ! pc = Push x3_\n\ngoal (16 subgoals):\n 1. \\<And>x3.\n       ins ! pc = Push x3 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 16 subgoals...", "from Push_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (15 subgoals):\n 1. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "case (New C)"], ["proof (state)\nthis:\n  ins ! pc = New C\n\ngoal (15 subgoals):\n 1. \\<And>x4. ins ! pc = New x4 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"\\<exists>sfs. sh C = Some(sfs, Done)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case True"], ["proof (state)\nthis:\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with New_nInit_correct[OF wf meth New wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case False"], ["proof (state)\nthis:\n  \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with New_Init_correct[OF wf meth New wt exec' conf' None']"], ["proof (chain)\npicking this:\n  \\<forall>sfs.\n     sh C \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sfs.\n     sh C \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 14 subgoals...", "case Getfield"], ["proof (state)\nthis:\n  ins ! pc = Getfield x51_ x52_\n\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       ins ! pc = Getfield x51 x52 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 14 subgoals...", "from Getfield_correct[OF wf meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x15.\n        ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x15.\n        ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 13 subgoals...", "case (Getstatic C F D)"], ["proof (state)\nthis:\n  ins ! pc = Getstatic C F D\n\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       ins ! pc = Getstatic x61 x62 x63 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x15.\n        ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 13 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"\\<exists>sfs. sh (fst (field P D F)) = Some(sfs, Done)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case True"], ["proof (state)\nthis:\n  \\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<exists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Getstatic_nInit_correct[OF wf meth Getstatic wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case False"], ["proof (state)\nthis:\n  \\<nexists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Getstatic_Init_correct[OF wf meth Getstatic wt exec' conf' None']"], ["proof (chain)\npicking this:\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq>\n     \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq>\n     \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 12 subgoals...", "case Putfield"], ["proof (state)\nthis:\n  ins ! pc = Putfield x71_ x72_\n\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       ins ! pc = Putfield x71 x72 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 12 subgoals...", "from Putfield_correct[OF wf meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x17.\n        ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x17.\n        ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 11 subgoals...", "case (Putstatic C F D)"], ["proof (state)\nthis:\n  ins ! pc = Putstatic C F D\n\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       ins ! pc = Putstatic x81 x82 x83 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x17.\n        ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 11 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"\\<exists>sfs. sh (fst (field P D F)) = Some(sfs, Done)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case True"], ["proof (state)\nthis:\n  \\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<exists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Putstatic_nInit_correct[OF wf meth Putstatic wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case False"], ["proof (state)\nthis:\n  \\<nexists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (field P D F)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Putstatic_Init_correct[OF wf meth Putstatic wt exec' conf' None']"], ["proof (chain)\npicking this:\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq>\n     \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sfs.\n     sh (fst (field P D F)) \\<noteq>\n     \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh (fst (field P D F)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (10 subgoals):\n 1. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Checkcast"], ["proof (state)\nthis:\n  ins ! pc = Checkcast x9_\n\ngoal (10 subgoals):\n 1. \\<And>x9.\n       ins ! pc = Checkcast x9 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "from Checkcast_correct[OF wtp meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (9 subgoals):\n 1. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Invoke"], ["proof (state)\nthis:\n  ins ! pc = Invoke x101_ x102_\n\ngoal (9 subgoals):\n 1. \\<And>x101 x102.\n       ins ! pc = Invoke x101 x102 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Invoke_correct[OF wtp meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Invoke x101_ x102_", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Invoke x101_ x102_\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case (Invokestatic C M n)"], ["proof (state)\nthis:\n  ins ! pc = Invokestatic C M n\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "from wf_jvm_prog_nclinit[OF wtp meth wt pc \\<Phi> this]"], ["proof (chain)\npicking this:\n  M \\<noteq> clinit", "have ncl: \"M \\<noteq> clinit\""], ["proof (prove)\nusing this:\n  M \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. M \\<noteq> clinit", "by simp"], ["proof (state)\nthis:\n  M \\<noteq> clinit\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       ins ! pc = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"\\<exists>sfs. sh (fst (method P C M)) = Some(sfs, Done)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case True"], ["proof (state)\nthis:\n  \\<exists>sfs. sh (fst (method P C M)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<exists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<nexists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Invokestatic_nInit_correct[OF wtp meth Invokestatic ncl wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (method P C M)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh (fst (method P C M)) = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (method P C M)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<exists>sfs. sh (fst (method P C M)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "case False"], ["proof (state)\nthis:\n  \\<nexists>sfs. sh (fst (method P C M)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<nexists>sfs.\n       sh (fst (method P C M)) =\n       \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Invokestatic_Init_correct[OF wtp meth Invokestatic ncl wt exec' conf' None']"], ["proof (chain)\npicking this:\n  \\<forall>sfs.\n     sh (fst (method P C M)) \\<noteq>\n     \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh (fst (method P C M)) = \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sfs.\n     sh (fst (method P C M)) \\<noteq>\n     \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  \\<nexists>sfs. sh (fst (method P C M)) = \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (7 subgoals):\n 1. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Return"], ["proof (state)\nthis:\n  ins ! pc = Return\n\ngoal (7 subgoals):\n 1. ins ! pc = Return \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Return_correct[OF wtp meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Return", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Return\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (6 subgoals):\n 1. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Pop"], ["proof (state)\nthis:\n  ins ! pc = Pop\n\ngoal (6 subgoals):\n 1. ins ! pc = Pop \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Pop_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Pop", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Pop\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (5 subgoals):\n 1. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case IAdd"], ["proof (state)\nthis:\n  ins ! pc = IAdd\n\ngoal (5 subgoals):\n 1. ins ! pc = IAdd \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with IAdd_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = IAdd", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = IAdd\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (4 subgoals):\n 1. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Goto"], ["proof (state)\nthis:\n  ins ! pc = Goto x15_\n\ngoal (4 subgoals):\n 1. \\<And>x15.\n       ins ! pc = Goto x15 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Goto_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Goto x15_", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Goto x15_\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (3 subgoals):\n 1. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case CmpEq"], ["proof (state)\nthis:\n  ins ! pc = CmpEq\n\ngoal (3 subgoals):\n 1. ins ! pc = CmpEq \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with CmpEq_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = CmpEq", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = CmpEq\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (2 subgoals):\n 1. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case IfFalse"], ["proof (state)\nthis:\n  ins ! pc = IfFalse x17_\n\ngoal (2 subgoals):\n 1. \\<And>x17.\n       ins ! pc = IfFalse x17 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with IfFalse_correct[OF wf meth this wt exec conf]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = IfFalse x17_", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = IfFalse x17_\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Throw"], ["proof (state)\nthis:\n  ins ! pc = Throw\n\ngoal (1 subgoal):\n 1. ins ! pc = Throw \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Throw_correct[OF wf meth this exec conf None]"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Throw", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- \\<sigma>' [ok]\n  ins ! pc = Throw\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = No_ics \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ics = No_ics \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  ics = No_ics \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "fix Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "assume [simp]: \"ics = Called Cs\""], ["proof (state)\nthis:\n  ics = Called Cs\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case [simp]: Nil"], ["proof (state)\nthis:\n  Cs = []\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "from conf meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C", "obtain C1 where \"Called_context P C1 (ins ! pc)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs, sh) [ok]\n  P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n              xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>C1.\n        Called_context P C1 (ins ! pc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: conf_f_def2 intro!: Called_context_Called_set)"], ["proof (state)\nthis:\n  Called_context P C1 (ins ! pc)\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  Called_context P C1 (ins ! pc)", "have \"ins!pc \\<in> Called_set\""], ["proof (prove)\nusing this:\n  Called_context P C1 (ins ! pc)\n\ngoal (1 subgoal):\n 1. ins ! pc \\<in> Called_set", "by(rule Called_context_Called_set)"], ["proof (state)\nthis:\n  ins ! pc \\<in> Called_set\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  ins ! pc \\<in> Called_set", "show ?thesis"], ["proof (prove)\nusing this:\n  ins ! pc \\<in> Called_set\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases \"ins!pc\")"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x4.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x101 x102.\n        \\<lbrakk>ins ! pc \\<in> Called_set;\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 18 subgoals...", "case (New C)"], ["proof (state)\nthis:\n  ins ! pc = New C\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x4.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x61 x62 x63.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x101 x102.\n        \\<lbrakk>ins ! pc \\<in> Called_set;\n         ins ! pc = Invoke x101 x102\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 18 subgoals...", "from New_nInit_correct[OF wf meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>ins ! pc \\<in> Called_set;\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>ins ! pc \\<in> Called_set;\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 17 subgoals...", "case (Getstatic C F D)"], ["proof (state)\nthis:\n  ins ! pc = Getstatic C F D\n\ngoal (17 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x61 x62 x63.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getstatic x61 x62 x63\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>x111 x112 x113.\n        \\<lbrakk>ins ! pc \\<in> Called_set;\n         ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 17 subgoals...", "from Getstatic_nInit_correct[OF wf meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 16 subgoals...", "case (Putstatic C F D)"], ["proof (state)\nthis:\n  ins ! pc = Putstatic C F D\n\ngoal (16 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x81 x82 x83.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putstatic x81 x82 x83\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 16 subgoals...", "from Putstatic_nInit_correct[OF wf meth this wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (field P D F)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "case (Invokestatic C M n)"], ["proof (state)\nthis:\n  ins ! pc = Invokestatic C M n\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "from wf_jvm_prog_nclinit[OF wtp meth wt pc \\<Phi> this]"], ["proof (chain)\npicking this:\n  M \\<noteq> clinit", "have ncl: \"M \\<noteq> clinit\""], ["proof (prove)\nusing this:\n  M \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. M \\<noteq> clinit", "by simp"], ["proof (state)\nthis:\n  M \\<noteq> clinit\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>x111 x112 x113.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invokestatic x111 x112 x113\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "with Invokestatic_nInit_correct[OF wtp meth Invokestatic ncl wt exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (method P C M)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  M \\<noteq> clinit", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called [] \\<or>\n  ics = No_ics \\<and>\n  (\\<exists>sfs.\n      sh (fst (method P C M)) =\n      \\<lfloor>(sfs, Done)\\<rfloor>) \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  M \\<noteq> clinit\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>x2.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>x3.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>x51 x52.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>x71 x72.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Putfield x71 x72\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>x9.\n       \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Checkcast x9\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>x101 x102.\n       \\<lbrakk>ins ! pc \\<in> Called_set;\n        ins ! pc = Invoke x101 x102\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<lbrakk>ins ! pc \\<in> Called_set; ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 14 subgoals...", "qed(simp_all)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case (Cons C' Cs')"], ["proof (state)\nthis:\n  Cs = C' # Cs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Called_correct[OF wtp meth exec conf None]"], ["proof (chain)\npicking this:\n  ics = Called (?C' # ?Cs) \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  Cs = C' # Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called (?C' # ?Cs) \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  Cs = C' # Cs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = Called ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ics = Called ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  ics = Called ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "fix C' Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "assume [simp]: \"ics = Calling C' Cs\""], ["proof (state)\nthis:\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "with Calling_correct[OF wtp meth exec conf None]"], ["proof (chain)\npicking this:\n  ics = Calling ?C' ?Cs \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Calling C' Cs", "have ?thesis"], ["proof (prove)\nusing this:\n  ics = Calling ?C' ?Cs \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Calling C' Cs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "fix Cs a"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "assume [simp]: \"ics = Throwing Cs a\""], ["proof (state)\nthis:\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof(cases Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case Nil"], ["proof (state)\nthis:\n  Cs = []\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with exec None"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  Cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc, ics) # frs, sh)\n  fst (exec_step P h stk loc C M pc ics frs sh) = None\n  Cs = []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "case (Cons C' Cs')"], ["proof (state)\nthis:\n  Cs = C' # Cs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. Cs = a # list \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "with Throwing_correct[OF wtp meth exec conf None]"], ["proof (chain)\npicking this:\n  ics = Throwing (?C' # ?Cs) ?a \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  Cs = C' # Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Throwing (?C' # ?Cs) ?a \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  Cs = C' # Cs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. fst (exec_step P h stk loc C M pc ics frs sh) = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ics = No_ics \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Called ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = No_ics \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Called ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Calling ?C'2 ?Cs2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ics = Throwing ?Cs2 ?a2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by(cases ics) auto"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection \\<open> Main \\<close>"], ["", "lemma correct_state_impl_Some_method:\n  \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc,ics)#frs, sh)\\<surd> \n  \\<Longrightarrow> \\<exists>b m Ts T. P \\<turnstile> C sees M,b:Ts\\<rightarrow>T = m in C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (None, h, (stk, loc, C, M, pc, ics) # frs,\n                 sh) [ok] \\<Longrightarrow>\n    \\<exists>b m Ts T.\n       P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in C", "by fastforce"], ["", "lemma BV_correct_1 [rule_format]:\n\"\\<And>\\<sigma>. \\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> \\<sigma>\\<surd>\\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- \\<sigma> [ok]\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- \\<sigma> [ok]\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (simp only: split_tupled_all exec_1_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (a, aa, ab, b) [ok]\\<rbrakk>\n       \\<Longrightarrow> exec (P, a, aa, ab, b) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (rename_tac xp h frs sh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs sh.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (case_tac xp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = None\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (case_tac frs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs sh.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = None; frs = []\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh a list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = None;\n        frs = a # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (simp only: split_tupled_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        xp = None; frs = (a, aa, ab, ac, ad, b) # list\\<rbrakk>\n       \\<Longrightarrow> exec\n                          (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply hypsubst"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list,\n                     sh) [ok]\\<rbrakk>\n       \\<Longrightarrow> exec\n                          (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (frule correct_state_impl_Some_method)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        \\<exists>b m Ts T.\n           P \\<turnstile> ab sees ac, b :  Ts\\<rightarrow>T = m in ab\\<rbrakk>\n       \\<Longrightarrow> exec\n                          (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule step_correct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n 2. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> ?C14 xp h frs sh a aa ab ac ad b\n   list ba ae af ag bb Ts\n   T sees ?M14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts\n           T, ?b14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts\n               T :  ?Ts14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts\n                     T\\<rightarrow>?T14 xp h frs sh a aa ab ac ad b list ba\n                                    ae af ag bb Ts\n                                    T = (?mxs14 xp h frs sh a aa ab ac ad b\n    list ba ae af ag bb Ts T,\n   ?mxl\\<^sub>014 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n   ?ins14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n   ?xt14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts\n    T) in ?C14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T\n 3. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<sigma>'\\<rfloor> =\n                         exec\n                          (P, None,\n                           ?h14 xp h frs sh a aa ab ac ad b list ba ae af ag\n                            bb Ts T,\n                           (?stk14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?loc14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?C14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?M14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?pc14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?ics14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T) #\n                           ?frs14 xp h frs sh a aa ab ac ad b list ba ae af\n                            ag bb Ts T,\n                           ?sh14 xp h frs sh a aa ab ac ad b list ba ae af\n                            ag bb Ts T)\n 4. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (None,\n?h14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n(?stk14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?loc14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?C14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?M14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?pc14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?ics14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T) #\n?frs14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n?sh14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T) [ok]\n 5. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply assumption+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<sigma>'\\<rfloor> =\n                         exec\n                          (P, None,\n                           ?h14 xp h frs sh a aa ab ac ad b list ba ae af ag\n                            bb Ts T,\n                           (?stk14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?loc14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ab, ac,\n                            ?pc14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?ics14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T) #\n                           ?frs14 xp h frs sh a aa ab ac ad b list ba ae af\n                            ag bb Ts T,\n                           ?sh14 xp h frs sh a aa ab ac ad b list ba ae af\n                            ag bb Ts T)\n 2. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (None,\n?h14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n(?stk14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?loc14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T, ab, ac,\n ?pc14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?ics14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T) #\n?frs14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n?sh14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T) [ok]\n 3. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec\n                          (P, None,\n                           ?h14 xp h frs sh a aa ab ac ad b list ba ae af ag\n                            bb Ts T,\n                           (?stk14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?loc14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ab, ac,\n                            ?pc14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T,\n                            ?ics14 xp h frs sh a aa ab ac ad b list ba ae af\n                             ag bb Ts T) #\n                           ?frs14 xp h frs sh a aa ab ac ad b list ba ae af\n                            ag bb Ts T,\n                           ?sh14 xp h frs sh a aa ab ac ad b list ba ae af\n                            ag bb Ts T) =\n                         \\<lfloor>\\<sigma>'\\<rfloor>\n 2. \\<And>xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, ad, b) # list, sh) [ok];\n        P \\<turnstile> ab sees ac, ba :  Ts\\<rightarrow>T = (ae, af, ag,\n                       bb) in ab;\n        exec (P, None, h, (a, aa, ab, ac, ad, b) # list, sh) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (None,\n?h14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n(?stk14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?loc14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T, ab, ac,\n ?pc14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n ?ics14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T) #\n?frs14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T,\n?sh14 xp h frs sh a aa ab ac ad b list ba ae af ag bb Ts T) [ok]\n 3. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (case_tac frs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs sh a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>;\n        frs = []\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs sh a aa list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = \\<lfloor>a\\<rfloor>;\n        frs = aa # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs, sh) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "theorem progress:\n  \"\\<lbrakk> xp=None; frs\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs,sh) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xp = None; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile>\n                         (xp, h, frs, sh) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>'", "by (clarsimp simp: exec_1_iff neq_Nil_conv split_beta\n               simp del: split_paired_Ex)"], ["", "lemma progress_conform:\n  \"\\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> (xp,h,frs,sh)\\<surd>; xp=None; frs\\<noteq>[]\\<rbrakk> \n  \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs,sh) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<and> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = None; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs, sh) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs, sh) [ok]; xp = None; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs, sh) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "apply (drule progress)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs, sh) [ok]; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ?frs \\<noteq> []\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs, sh) [ok]; frs \\<noteq> [];\n     \\<exists>\\<sigma>'. ?P \\<turnstile>\n        (xp, ?h, ?frs, ?sh) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs, sh) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs, sh) [ok]; frs \\<noteq> [];\n     \\<exists>\\<sigma>'. ?P \\<turnstile>\n        (xp, ?h, frs, ?sh) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs, sh) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "apply (fast intro: BV_correct_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "theorem BV_correct [rule_format]:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>\\<surd> \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                      P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                      P,\\<Phi> |- \\<sigma>' [ok]", "apply (simp only: exec_all_def1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     (\\<sigma>, \\<sigma>') \\<in> (exec_1 P)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                      P,\\<Phi> |- \\<sigma>' [ok]", "apply (erule rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow> P,\\<Phi> |- \\<sigma> [ok]\n 2. \\<And>y z.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        (\\<sigma>, y) \\<in> (exec_1 P)\\<^sup>*;\n        P \\<turnstile> y -jvm\\<rightarrow>\\<^sub>1 z;\n        P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n        P,\\<Phi> |- y [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                         P,\\<Phi> |- z [ok]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        (\\<sigma>, y) \\<in> (exec_1 P)\\<^sup>*;\n        P \\<turnstile> y -jvm\\<rightarrow>\\<^sub>1 z;\n        P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n        P,\\<Phi> |- y [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                         P,\\<Phi> |- z [ok]", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac ad ae ba.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        (\\<sigma>, a, aa, ab, b) \\<in> (exec_1 P)\\<^sup>*;\n        P \\<turnstile> (a, aa, ab, b) -jvm\\<rightarrow>\\<^sub>1\n        (ac, ad, ae, ba);\n        P,\\<Phi> |- \\<sigma> [ok]; P,\\<Phi> |- (a, aa, ab, b) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (ac, ad, ae, ba) [ok]", "apply (erule (2) BV_correct_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma hconf_start:   \n  assumes wf: \"wf_prog wf_mb P\"\n  shows \"P \\<turnstile> (start_heap P) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_heap P \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_heap P \\<surd>", "apply (unfold hconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a obj.\n        start_heap P a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n        P,start_heap P \\<turnstile> obj \\<surd>) \\<and>\n    preallocated (start_heap P)", "apply (simp add: preallocated_start)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a obj.\n       start_heap P a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n       P,start_heap P \\<turnstile> obj \\<surd>", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       start_heap P a = \\<lfloor>(aa, b)\\<rfloor> \\<Longrightarrow>\n       P,start_heap P \\<turnstile> (aa, b) \\<surd>", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lfloor>(aa, b)\\<rfloor> = start_heap P a \\<Longrightarrow>\n       P,start_heap P \\<turnstile> (aa, b) \\<surd>", "apply (unfold start_heap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lfloor>(aa, b)\\<rfloor> =\n       [addr_of_sys_xcpt NullPointer \\<mapsto> blank P NullPointer,\n        addr_of_sys_xcpt ClassCast \\<mapsto> blank P ClassCast,\n        addr_of_sys_xcpt OutOfMemory \\<mapsto> blank P OutOfMemory,\n        addr_of_sys_xcpt NoClassDefFoundError \\<mapsto>\n        blank P NoClassDefFoundError,\n        addr_of_sys_xcpt IncompatibleClassChangeError \\<mapsto>\n        blank P IncompatibleClassChangeError,\n        addr_of_sys_xcpt NoSuchFieldError \\<mapsto>\n        blank P NoSuchFieldError, addr_of_sys_xcpt NoSuchMethodError \n        \\<mapsto> blank P NoSuchMethodError]\n        a \\<Longrightarrow>\n       P,[addr_of_sys_xcpt NullPointer \\<mapsto> blank P NullPointer,\n          addr_of_sys_xcpt ClassCast \\<mapsto> blank P ClassCast,\n          addr_of_sys_xcpt OutOfMemory \\<mapsto> blank P OutOfMemory,\n          addr_of_sys_xcpt NoClassDefFoundError \\<mapsto>\n          blank P NoClassDefFoundError,\n          addr_of_sys_xcpt IncompatibleClassChangeError \\<mapsto>\n          blank P IncompatibleClassChangeError,\n          addr_of_sys_xcpt NoSuchFieldError \\<mapsto>\n          blank P NoSuchFieldError, addr_of_sys_xcpt NoSuchMethodError \n          \\<mapsto> blank P NoSuchMethodError] \\<turnstile> (aa, b) \\<surd>", "apply (insert wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<lfloor>(aa, b)\\<rfloor> =\n                [addr_of_sys_xcpt NullPointer \\<mapsto> blank P NullPointer,\n                 addr_of_sys_xcpt ClassCast \\<mapsto> blank P ClassCast,\n                 addr_of_sys_xcpt OutOfMemory \\<mapsto> blank P OutOfMemory,\n                 addr_of_sys_xcpt NoClassDefFoundError \\<mapsto>\n                 blank P NoClassDefFoundError,\n                 addr_of_sys_xcpt IncompatibleClassChangeError \\<mapsto>\n                 blank P IncompatibleClassChangeError,\n                 addr_of_sys_xcpt NoSuchFieldError \\<mapsto>\n                 blank P NoSuchFieldError,\n                 addr_of_sys_xcpt NoSuchMethodError \\<mapsto>\n                 blank P NoSuchMethodError]\n                 a;\n        wf_prog wf_mb P\\<rbrakk>\n       \\<Longrightarrow> P,[addr_of_sys_xcpt NullPointer \\<mapsto>\n                            blank P NullPointer, addr_of_sys_xcpt ClassCast \n                            \\<mapsto> blank P ClassCast,\n                            addr_of_sys_xcpt OutOfMemory \\<mapsto>\n                            blank P OutOfMemory,\n                            addr_of_sys_xcpt NoClassDefFoundError \\<mapsto>\n                            blank P NoClassDefFoundError,\n                            addr_of_sys_xcpt IncompatibleClassChangeError \n                            \\<mapsto> blank P IncompatibleClassChangeError,\n                            addr_of_sys_xcpt NoSuchFieldError \\<mapsto>\n                            blank P NoSuchFieldError,\n                            addr_of_sys_xcpt NoSuchMethodError \\<mapsto>\n                            blank P\n                             NoSuchMethodError] \\<turnstile> (aa, b) \\<surd>", "apply (auto simp: fun_upd_apply is_class_xcpt split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma shconf_start:   \n  \"\\<not> is_class P Start \\<Longrightarrow> P,start_heap P \\<turnstile>\\<^sub>s start_sheap \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_class P Start \\<Longrightarrow>\n    P,start_heap\n       P \\<turnstile>\\<^sub>s [Start \\<mapsto> (Map.empty, Done)] \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_class P Start \\<Longrightarrow>\n    P,start_heap\n       P \\<turnstile>\\<^sub>s [Start \\<mapsto> (Map.empty, Done)] \\<surd>", "apply (unfold shconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_class P Start \\<Longrightarrow>\n    \\<forall>C sfs i.\n       [Start \\<mapsto> (Map.empty, Done)] C =\n       \\<lfloor>(sfs, i)\\<rfloor> \\<longrightarrow>\n       P,start_heap P,C \\<turnstile>\\<^sub>s sfs \\<surd>", "apply (clarsimp simp: preallocated_start fun_upd_apply soconf_def has_field_is_class)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma BV_correct_initial: \n  shows \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not>is_class P Start;\n     P \\<turnstile> C sees M,Static:[]\\<rightarrow>Void = m in C; M \\<noteq> clinit;\n     \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m \\<rbrakk>\n  \\<Longrightarrow> start_prog P C M,\\<Phi>' \\<turnstile> start_state P \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit;\n     \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit;\n     \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]", "apply(subgoal_tac \"is_class P Object\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit;\n     \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\\<rbrakk>\n    \\<Longrightarrow> is_class P Object", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit;\n     \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\\<rbrakk>\n    \\<Longrightarrow> is_class P Object\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]", "apply(simp add: wf_jvm_prog_phi_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]", "apply(subgoal_tac \"\\<exists>Mm. P \\<turnstile> Object sees_methods Mm\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object;\n     \\<exists>Mm. P \\<turnstile> Object sees_methods Mm\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Mm. P \\<turnstile> Object sees_methods Mm", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Mm. P \\<turnstile> Object sees_methods Mm\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object;\n     \\<exists>Mm. P \\<turnstile> Object sees_methods Mm\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]", "apply(fastforce simp: is_class_def dest: sees_methods_Object)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; \\<not> is_class P Start;\n     P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n     M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n     is_class P Object;\n     \\<exists>Mm. P \\<turnstile> Object sees_methods Mm\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C M),\\<Phi>' |- start_state P [ok]", "apply (cases m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (start_class C M),\\<Phi>' |- start_state P [ok]", "apply (unfold  start_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (start_class C\n                            M),\\<Phi>' |- (None, start_heap P,\n     [([], [], Start, start_m, 0, No_ics)],\n     [Start \\<mapsto> (Map.empty, Done)]) [ok]", "apply (unfold correct_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> case (None, start_heap P,\n                               [([], [], Start, start_m, 0, No_ics)],\n                               [Start \\<mapsto> (Map.empty, Done)]) of\n                         (None, h, frs, sh) \\<Rightarrow>\n                           case frs of [] \\<Rightarrow> True\n                           | f # fs \\<Rightarrow>\n                               class_add P\n                                (start_class C\n                                  M) \\<turnstile> h \\<surd> \\<and>\n                               class_add P\n                                (start_class C\n                                  M),h \\<turnstile>\\<^sub>s sh \\<surd> \\<and>\n                               conf_clinit (class_add P (start_class C M))\n                                sh frs \\<and>\n                               (let (stk, loc, Ca, Ma, pc, ics) = f\n                                in \\<exists>b Ts T mxs mxl\\<^sub>0 is xt\n\\<tau>.\nclass_add P\n (start_class C\n   M) \\<turnstile> Ca sees Ma, b :  Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                  is, xt) in Ca \\<and>\n\\<Phi>' Ca Ma ! pc = \\<lfloor>\\<tau>\\<rfloor> \\<and>\nconf_f (class_add P (start_class C M)) h sh \\<tau> is f \\<and>\nconf_fs (class_add P (start_class C M)) h sh \\<Phi>' Ca Ma (length Ts) T fs)\n                         | (\\<lfloor>x\\<rfloor>, h, frs, sh) \\<Rightarrow>\n                             frs = []", "apply (simp del: defs1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]) \\<turnstile> start_heap P \\<surd> \\<and>\n                         class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]),start_heap\n                                    P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                      (Map.empty, Done)] \\<surd> \\<and>\n                         conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)] \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 class_add P\n                                  (Start, Object, [],\n                                   [start_method C M,\n                                    (clinit, Static, [], Void, Suc 0, 0,\n                                     [Push Unit, Return],\n                                     [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                         mxl\\<^sub>0, is, xt) in Start) \\<and>\n                             conf_f\n                              (class_add P\n                                (Start, Object, [],\n                                 [start_method C M,\n                                  (clinit, Static, [], Void, Suc 0, 0,\n                                   [Push Unit, Return], [])]))\n                              (start_heap P)\n                              [Start \\<mapsto> (Map.empty, Done)] ([], [])\n                              is ([], [], Start, start_m, 0, No_ics))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]) \\<turnstile> start_heap P \\<surd>\n 2. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]),start_heap\n                                    P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                      (Map.empty, Done)] \\<surd> \\<and>\n                         conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)] \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 class_add P\n                                  (Start, Object, [],\n                                   [start_method C M,\n                                    (clinit, Static, [], Void, Suc 0, 0,\n                                     [Push Unit, Return],\n                                     [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                         mxl\\<^sub>0, is, xt) in Start) \\<and>\n                             conf_f\n                              (class_add P\n                                (Start, Object, [],\n                                 [start_method C M,\n                                  (clinit, Static, [], Void, Suc 0, 0,\n                                   [Push Unit, Return], [])]))\n                              (start_heap P)\n                              [Start \\<mapsto> (Map.empty, Done)] ([], [])\n                              is ([], [], Start, start_m, 0, No_ics))", "apply (simp add: wf_jvm_prog_phi_def class_add_hconf_wf[OF _ hconf_start] start_heap_nStart)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]),start_heap\n                                    P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                      (Map.empty, Done)] \\<surd> \\<and>\n                         conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)] \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 class_add P\n                                  (Start, Object, [],\n                                   [start_method C M,\n                                    (clinit, Static, [], Void, Suc 0, 0,\n                                     [Push Unit, Return],\n                                     [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                         mxl\\<^sub>0, is, xt) in Start) \\<and>\n                             conf_f\n                              (class_add P\n                                (Start, Object, [],\n                                 [start_method C M,\n                                  (clinit, Static, [], Void, Suc 0, 0,\n                                   [Push Unit, Return], [])]))\n                              (start_heap P)\n                              [Start \\<mapsto> (Map.empty, Done)] ([], [])\n                              is ([], [], Start, start_m, 0, No_ics))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]),start_heap\n                                    P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                      (Map.empty, Done)] \\<surd>\n 2. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)] \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 class_add P\n                                  (Start, Object, [],\n                                   [start_method C M,\n                                    (clinit, Static, [], Void, Suc 0, 0,\n                                     [Push Unit, Return],\n                                     [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                         mxl\\<^sub>0, is, xt) in Start) \\<and>\n                             conf_f\n                              (class_add P\n                                (Start, Object, [],\n                                 [start_method C M,\n                                  (clinit, Static, [], Void, Suc 0, 0,\n                                   [Push Unit, Return], [])]))\n                              (start_heap P)\n                              [Start \\<mapsto> (Map.empty, Done)] ([], [])\n                              is ([], [], Start, start_m, 0, No_ics))", "using start_prog_start_shconf"], ["proof (prove)\nusing this:\n  class_add ?P\n   (start_class ?C\n     ?M),start_heap\n          ?P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                                   (Map.empty, Done)] \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> class_add P\n                          (Start, Object, [],\n                           [start_method C M,\n                            (clinit, Static, [], Void, Suc 0, 0,\n                             [Push Unit, Return],\n                             [])]),start_heap\n                                    P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                      (Map.empty, Done)] \\<surd>\n 2. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)] \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 class_add P\n                                  (Start, Object, [],\n                                   [start_method C M,\n                                    (clinit, Static, [], Void, Suc 0, 0,\n                                     [Push Unit, Return],\n                                     [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                         mxl\\<^sub>0, is, xt) in Start) \\<and>\n                             conf_f\n                              (class_add P\n                                (Start, Object, [],\n                                 [start_method C M,\n                                  (clinit, Static, [], Void, Suc 0, 0,\n                                   [Push Unit, Return], [])]))\n                              (start_heap P)\n                              [Start \\<mapsto> (Map.empty, Done)] ([], [])\n                              is ([], [], Start, start_m, 0, No_ics))", "apply(simp add: wf_jvm_prog_phi_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)] \\<and>\n                         (\\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 class_add P\n                                  (Start, Object, [],\n                                   [start_method C M,\n                                    (clinit, Static, [], Void, Suc 0, 0,\n                                     [Push Unit, Return],\n                                     [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                         mxl\\<^sub>0, is, xt) in Start) \\<and>\n                             conf_f\n                              (class_add P\n                                (Start, Object, [],\n                                 [start_method C M,\n                                  (clinit, Static, [], Void, Suc 0, 0,\n                                   [Push Unit, Return], [])]))\n                              (start_heap P)\n                              [Start \\<mapsto> (Map.empty, Done)] ([], [])\n                              is ([], [], Start, start_m, 0, No_ics))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> conf_clinit\n                          (class_add P\n                            (Start, Object, [],\n                             [start_method C M,\n                              (clinit, Static, [], Void, Suc 0, 0,\n                               [Push Unit, Return], [])]))\n                          [Start \\<mapsto> (Map.empty, Done)]\n                          [([], [], Start, start_m, 0, No_ics)]\n 2. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                class_add P\n                                 (Start, Object, [],\n                                  [start_method C M,\n                                   (clinit, Static, [], Void, Suc 0, 0,\n                                    [Push Unit, Return],\n                                    [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                        mxl\\<^sub>0, is, xt) in Start) \\<and>\n                            conf_f\n                             (class_add P\n                               (Start, Object, [],\n                                [start_method C M,\n                                 (clinit, Static, [], Void, Suc 0, 0,\n                                  [Push Unit, Return], [])]))\n                             (start_heap P)\n                             [Start \\<mapsto> (Map.empty, Done)] ([], []) is\n                             ([], [], Start, start_m, 0, No_ics)", "apply(simp add: conf_clinit_def distinct_clinit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        \\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                class_add P\n                                 (Start, Object, [],\n                                  [start_method C M,\n                                   (clinit, Static, [], Void, Suc 0, 0,\n                                    [Push Unit, Return],\n                                    [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                        mxl\\<^sub>0, is, xt) in Start) \\<and>\n                            conf_f\n                             (class_add P\n                               (Start, Object, [],\n                                [start_method C M,\n                                 (clinit, Static, [], Void, Suc 0, 0,\n                                  [Push Unit, Return], [])]))\n                             (start_heap P)\n                             [Start \\<mapsto> (Map.empty, Done)] ([], []) is\n                             ([], [], Start, start_m, 0, No_ics)", "apply (drule wt_jvm_prog_impl_wt_start, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d);\n        0 < length c \\<and> wt_start P C Static [] b (\\<Phi> C M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                class_add P\n                                 (Start, Object, [],\n                                  [start_method C M,\n                                   (clinit, Static, [], Void, Suc 0, 0,\n                                    [Push Unit, Return],\n                                    [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                        mxl\\<^sub>0, is, xt) in Start) \\<and>\n                            conf_f\n                             (class_add P\n                               (Start, Object, [],\n                                [start_method C M,\n                                 (clinit, Static, [], Void, Suc 0, 0,\n                                  [Push Unit, Return], [])]))\n                             (start_heap P)\n                             [Start \\<mapsto> (Map.empty, Done)] ([], []) is\n                             ([], [], Start, start_m, 0, No_ics)", "apply (unfold conf_f_def wt_start_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>\\<not> is_class P Start;\n        P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = (a, b, c,\n                            d) in C;\n        M \\<noteq> clinit; \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n        is_class P Object;\n        \\<exists>Mm. P \\<turnstile> Object sees_methods Mm;\n        m = (a, b, c, d);\n        0 < length c \\<and>\n        (case Static of\n         Static \\<Rightarrow>\n           P \\<turnstile> \\<lfloor>([],\n                                    map OK [] @\n                                    replicate b\n                                     Err)\\<rfloor> \\<le>' \\<Phi> C M ! 0\n         | NonStatic \\<Rightarrow>\n             P \\<turnstile> \\<lfloor>([],\nOK (Class C) #\nmap OK [] @ replicate b Err)\\<rfloor> \\<le>' \\<Phi> C M ! 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                class_add P\n                                 (Start, Object, [],\n                                  [start_method C M,\n                                   (clinit, Static, [], Void, Suc 0, 0,\n                                    [Push Unit, Return],\n                                    [])]) \\<turnstile> Start sees start_m, b :  Ts\\<rightarrow>T = (mxs,\n                        mxl\\<^sub>0, is, xt) in Start) \\<and>\n                            (case ([], []) of\n                             (ST, LT) \\<Rightarrow>\n                               \\<lambda>is (stk, loc, Ca, Ma, pc, ics).\n                                  class_add P\n                                   (Start, Object, [],\n                                    [start_method C M,\n                                     (clinit, Static, [], Void, Suc 0, 0,\n[Push Unit, Return], [])]),start_heap P \\<turnstile> stk [:\\<le>] ST \\<and>\n                                  class_add P\n                                   (Start, Object, [],\n                                    [start_method C M,\n                                     (clinit, Static, [], Void, Suc 0, 0,\n[Push Unit, Return],\n[])]),start_heap P \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\n                                  pc < length is \\<and>\n                                  class_add P\n                                   (Start, Object, [],\n                                    [start_method C M,\n                                     (clinit, Static, [], Void, Suc 0, 0,\n[Push Unit, Return],\n[])]),start_heap\n       P,[Start \\<mapsto>\n          (Map.empty, Done)] \\<turnstile>\\<^sub>i (Ca, Ma, pc, ics))\n                             is ([], [], Start, start_m, 0, No_ics)", "apply (fastforce dest: start_prog_Start_sees_start_method)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc add: list_to_set_comprehension]]"], ["", "(*>*)"], ["", "theorem typesafe:\n  assumes welltyped:   \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes nstart:      \"\\<not> is_class P Start\"\n  assumes main_method: \"P \\<turnstile> C sees M,Static:[]\\<rightarrow>Void = m in C\"\n  assumes nclinit:     \"M \\<noteq> clinit\"\n  assumes \\<Phi>:           \"\\<And>C. C \\<noteq> Start \\<Longrightarrow> \\<Phi>' C = \\<Phi> C\"\n  assumes \\<Phi>':          \"\\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\" \"\\<Phi>' Start clinit = start_\\<phi>\\<^sub>m\"\n  assumes Obj_start_m:\n    \"(\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void)\"\n  shows \"start_prog P C M \\<turnstile> start_state P -jvm\\<rightarrow> \\<sigma>  \\<Longrightarrow>  start_prog P C M,\\<Phi>' \\<turnstile> \\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "from welltyped nstart main_method nclinit \\<Phi>'(1)"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  \\<not> is_class P Start\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C\n  M \\<noteq> clinit\n  \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m", "have \"start_prog P C M,\\<Phi>' \\<turnstile> start_state P \\<surd>\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  \\<not> is_class P Start\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in C\n  M \\<noteq> clinit\n  \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M),\\<Phi>' |- start_state P [ok]", "by (rule BV_correct_initial)"], ["proof (state)\nthis:\n  class_add P (start_class C M),\\<Phi>' |- start_state P [ok]\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "moreover"], ["proof (state)\nthis:\n  class_add P (start_class C M),\\<Phi>' |- start_state P [ok]\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "assume \"start_prog P C M \\<turnstile> start_state P -jvm\\<rightarrow> \\<sigma>\""], ["proof (state)\nthis:\n  class_add P (start_class C M) \\<turnstile> start_state P -jvm\\<rightarrow>\n  \\<sigma>\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "moreover"], ["proof (state)\nthis:\n  class_add P (start_class C M) \\<turnstile> start_state P -jvm\\<rightarrow>\n  \\<sigma>\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "from start_prog_wf_jvm_prog_phi[OF welltyped nstart main_method nclinit \\<Phi> \\<Phi>' Obj_start_m]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>C. C \\<noteq> Start \\<Longrightarrow> C \\<noteq> Start;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = ?m'1 b'\n                                Ts' T' m'\n                                D' in ?D'1 b' Ts' T' m' D'\\<rbrakk>\n  \\<Longrightarrow> wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub>\n                     (class_add P (start_class C M))", "have \"wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub>(start_prog P C M)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>C. C \\<noteq> Start \\<Longrightarrow> C \\<noteq> Start;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = ?m'1 b'\n                                Ts' T' m'\n                                D' in ?D'1 b' Ts' T' m' D'\\<rbrakk>\n  \\<Longrightarrow> wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub>\n                     (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "by simp"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile>\n    start_state P -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "ultimately"], ["proof (chain)\npicking this:\n  class_add P (start_class C M),\\<Phi>' |- start_state P [ok]\n  class_add P (start_class C M) \\<turnstile> start_state P -jvm\\<rightarrow>\n  \\<sigma>\n  wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "show \"start_prog P C M,\\<Phi>' \\<turnstile> \\<sigma> \\<surd>\""], ["proof (prove)\nusing this:\n  class_add P (start_class C M),\\<Phi>' |- start_state P [ok]\n  class_add P (start_class C M) \\<turnstile> start_state P -jvm\\<rightarrow>\n  \\<sigma>\n  wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "using welltyped"], ["proof (prove)\nusing this:\n  class_add P (start_class C M),\\<Phi>' |- start_state P [ok]\n  class_add P (start_class C M) \\<turnstile> start_state P -jvm\\<rightarrow>\n  \\<sigma>\n  wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]", "by - (rule BV_correct)"], ["proof (state)\nthis:\n  class_add P (start_class C M),\\<Phi>' |- \\<sigma> [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}