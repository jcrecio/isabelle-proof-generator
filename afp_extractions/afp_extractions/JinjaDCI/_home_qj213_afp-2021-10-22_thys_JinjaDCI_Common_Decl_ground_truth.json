{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/Common/Decl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma class_cons: \"\\<lbrakk> C \\<noteq> fst x \\<rbrakk> \\<Longrightarrow> class (x # P) C = class P C\"", "lemma finite_is_class: \"finite {C. is_class P C}\"", "lemma is_type_simps [simp]:\n  \"is_type P Void \\<and> is_type P Boolean \\<and> is_type P Integer \\<and>\n  is_type P NT \\<and> is_type P (Class C) = is_class P C\"", "lemma class_exists_equiv:\n \"(\\<exists>x. fst x = cn \\<and> x \\<in> set P) = (class P cn \\<noteq> None)\"", "lemma class_exists_equiv2:\n \"(\\<exists>x. fst x = cn \\<and> x \\<in> set (P1 @ P2)) = (class P1 cn \\<noteq> None \\<or> class P2 cn \\<noteq> None)\""], "translations": [["", "lemma class_cons: \"\\<lbrakk> C \\<noteq> fst x \\<rbrakk> \\<Longrightarrow> class (x # P) C = class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> fst x \\<Longrightarrow> class (x # P) C = class P C", "by (simp add: class_def)"], ["", "definition is_class :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> bool\"\nwhere\n  \"is_class P C  \\<equiv>  class P C \\<noteq> None\""], ["", "lemma finite_is_class: \"finite {C. is_class P C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "have \"{C. is_class P C} = dom (map_of P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {C. is_class P C} = dom (map_of P)", "by (simp add: is_class_def class_def dom_def)"], ["proof (state)\nthis:\n  {C. is_class P C} = dom (map_of P)\n\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {C. is_class P C} = dom (map_of P)\n\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "by (simp add: finite_dom_map_of)"], ["proof (state)\nthis:\n  finite {C. is_class P C}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "definition is_type :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere\n  \"is_type P T  \\<equiv>\n  (case T of Void \\<Rightarrow> True | Boolean \\<Rightarrow> True | Integer \\<Rightarrow> True | NT \\<Rightarrow> True\n   | Class C \\<Rightarrow> is_class P C)\""], ["", "lemma is_type_simps [simp]:\n  \"is_type P Void \\<and> is_type P Boolean \\<and> is_type P Integer \\<and>\n  is_type P NT \\<and> is_type P (Class C) = is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P Void \\<and>\n    is_type P Boolean \\<and>\n    is_type P Integer \\<and>\n    is_type P NT \\<and> is_type P (Class C) = is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P Void \\<and>\n    is_type P Boolean \\<and>\n    is_type P Integer \\<and>\n    is_type P NT \\<and> is_type P (Class C) = is_class P C", "by(simp add:is_type_def)"], ["", "(*>*)"], ["", "abbreviation\n  \"types P == Collect (is_type P)\""], ["", "lemma class_exists_equiv:\n \"(\\<exists>x. fst x = cn \\<and> x \\<in> set P) = (class P cn \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. fst x = cn \\<and> x \\<in> set P) =\n    (class P cn \\<noteq> None)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. fst x = cn \\<and> x \\<in> set P \\<Longrightarrow>\n    class P cn \\<noteq> None\n 2. class P cn \\<noteq> None \\<Longrightarrow>\n    \\<exists>x. fst x = cn \\<and> x \\<in> set P", "assume \"\\<exists>x. fst x = cn \\<and> x \\<in> set P\""], ["proof (state)\nthis:\n  \\<exists>x. fst x = cn \\<and> x \\<in> set P\n\ngoal (2 subgoals):\n 1. \\<exists>x. fst x = cn \\<and> x \\<in> set P \\<Longrightarrow>\n    class P cn \\<noteq> None\n 2. class P cn \\<noteq> None \\<Longrightarrow>\n    \\<exists>x. fst x = cn \\<and> x \\<in> set P", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. fst x = cn \\<and> x \\<in> set P", "show \"class P cn \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<exists>x. fst x = cn \\<and> x \\<in> set P\n\ngoal (1 subgoal):\n 1. class P cn \\<noteq> None", "by (metis class_def image_eqI map_of_eq_None_iff)"], ["proof (state)\nthis:\n  class P cn \\<noteq> None\n\ngoal (1 subgoal):\n 1. class P cn \\<noteq> None \\<Longrightarrow>\n    \\<exists>x. fst x = cn \\<and> x \\<in> set P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. class P cn \\<noteq> None \\<Longrightarrow>\n    \\<exists>x. fst x = cn \\<and> x \\<in> set P", "assume \"class P cn \\<noteq> None\""], ["proof (state)\nthis:\n  class P cn \\<noteq> None\n\ngoal (1 subgoal):\n 1. class P cn \\<noteq> None \\<Longrightarrow>\n    \\<exists>x. fst x = cn \\<and> x \\<in> set P", "then"], ["proof (chain)\npicking this:\n  class P cn \\<noteq> None", "show \"\\<exists>x. fst x = cn \\<and> x \\<in> set P\""], ["proof (prove)\nusing this:\n  class P cn \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>x. fst x = cn \\<and> x \\<in> set P", "by (metis class_def fst_conv map_of_SomeD option.exhaust)"], ["proof (state)\nthis:\n  \\<exists>x. fst x = cn \\<and> x \\<in> set P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma class_exists_equiv2:\n \"(\\<exists>x. fst x = cn \\<and> x \\<in> set (P1 @ P2)) = (class P1 cn \\<noteq> None \\<or> class P2 cn \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. fst x = cn \\<and> x \\<in> set (P1 @ P2)) =\n    (class P1 cn \\<noteq> None \\<or> class P2 cn \\<noteq> None)", "by (simp only: class_exists_equiv [where P = \"P1@P2\"], simp add: class_def)"], ["", "end"]]}