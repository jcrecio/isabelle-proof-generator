{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/J/BigStep.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemmas eval_evals_induct = eval_evals.induct [split_format (complete)]\n  and eval_evals_inducts = eval_evals.inducts [split_format (complete)]", "lemma eval_final: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow> final e'\"\n and evals_final: \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> finals es'\"", "lemma eval_finalId:  \"final e \\<Longrightarrow> P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e,s\\<rangle>\"", "lemma eval_final_same: \"\\<lbrakk> P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>; final e \\<rbrakk> \\<Longrightarrow> e = e' \\<and> s = s'\"", "lemma eval_finalsId:\nassumes finals: \"finals es\" shows \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es,s\\<rangle>\"", "lemma evals_finals_same:\nassumes finals: \"finals es\"\nshows \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> es = es' \\<and> s = s'\"", "lemma evals_length: \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> length es = length es'\"", "theorem eval_hext: \"P \\<turnstile> \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"\nand evals_hext:  \"P \\<turnstile> \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"", "lemma eval_lcl_incr: \"P \\<turnstile> \\<langle>e,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0)\\<rangle> \\<Rightarrow> \\<langle>e',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"\n and evals_lcl_incr: \"P \\<turnstile> \\<langle>es,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"", "lemma\nshows init_ri_same_loc: \"P \\<turnstile> \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>\n   \\<Longrightarrow> (\\<And>C Cs b M a. e = INIT C (Cs,b) \\<leftarrow> unit \\<or> e = C\\<bullet>\\<^sub>sM([]) \\<or> e = RI (C,Throw a) ; Cs \\<leftarrow> unit\n          \\<or> e = RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n           \\<Longrightarrow> l = l')\"\n  and \"P \\<turnstile> \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle> \\<Longrightarrow> True\"", "lemma init_same_loc: \"P \\<turnstile> \\<langle>INIT C (Cs,b) \\<leftarrow> unit,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle> \\<Longrightarrow> l = l'\"", "lemma assumes wf: \"wwf_J_prog P\"\nshows eval_proc_pres': \"P \\<turnstile> \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_init C e \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\"\n  and evals_proc_pres': \"P \\<turnstile> \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_inits C es \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\"", "lemma init_NilE:\nassumes init: \"P \\<turnstile> \\<langle>INIT C (Nil,b) \\<leftarrow> unit,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\nshows \"e' = unit \\<and> s' = s\"", "lemma init_ProcessingE:\nassumes shC: \"sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\"\n and init: \"P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\nshows \"e' = unit \\<and> s' = (h,l,sh)\"", "lemma rinit_throwE:\n\"P \\<turnstile> \\<langle>RI (C,throw e) ; Cs \\<leftarrow> e\\<^sub>0,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\n   \\<Longrightarrow> \\<exists>a s\\<^sub>t. e' = throw a \\<and> P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,s\\<^sub>t\\<rangle>\"", "lemma rinit_ValE:\nassumes ri: \"P \\<turnstile> \\<langle>RI (C,e) ; Cs \\<leftarrow> unit,s\\<rangle> \\<Rightarrow> \\<langle>Val v',s'\\<rangle>\"\nshows \"\\<exists>v'' s''. P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>Val v'',s''\\<rangle>\"", "lemma lass_val_of_eval:\n \"\\<lbrakk> lass_val_of e = \\<lfloor>a\\<rfloor>; P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h', l', sh')\\<rangle> \\<rbrakk>\n  \\<Longrightarrow> e' = unit \\<and> h' = h \\<and> l' = l(fst a\\<mapsto>snd a) \\<and> sh' = sh\"", "lemma eval_throw_nonVal:\nassumes eval: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,s'\\<rangle>\"\nshows \"val_of e = None\"", "lemma eval_throw_nonLAss:\nassumes eval: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,s'\\<rangle>\"\nshows \"lass_val_of e = None\""], "translations": [["", "lemmas eval_evals_induct = eval_evals.induct [split_format (complete)]\n  and eval_evals_inducts = eval_evals.inducts [split_format (complete)]"], ["", "inductive_cases eval_cases [cases set]:\n \"P \\<turnstile> \\<langle>new C,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>Cast C e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>Var v,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>V:=e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e\\<bullet>F{D},s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D},s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e\\<^sub>1\\<bullet>F{D}:=e\\<^sub>2,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sF{D}:=e\\<^sub>2,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e\\<bullet>M(es),s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>C\\<bullet>\\<^sub>sM(es),s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>{V:T;e\\<^sub>1},s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e\\<^sub>1;;e\\<^sub>2,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>if (e) e\\<^sub>1 else e\\<^sub>2,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>while (b) c,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>try e\\<^sub>1 catch(C V) e\\<^sub>2,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>INIT C (Cs,b) \\<leftarrow> e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>RI (C,e);Cs \\<leftarrow> e\\<^sub>0,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\""], ["", "inductive_cases evals_cases [cases set]:\n \"P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>] \\<langle>e',s'\\<rangle>\"\n \"P \\<turnstile> \\<langle>e#es,s\\<rangle> [\\<Rightarrow>] \\<langle>e',s'\\<rangle>\""], ["", "(*>*)"], ["", "subsection \"Final expressions\""], ["", "lemma eval_final: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow> final e'\"\n and evals_final: \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> finals es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     final e') &&&\n    (P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     finals es')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     final e') &&&\n    (P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     finals es')", "by(induct rule:eval_evals.inducts, simp_all)"], ["", "(*>*)"], ["", "text\\<open> Only used later, in the small to big translation, but is already a\ngood sanity check: \\<close>"], ["", "lemma eval_finalId:  \"final e \\<Longrightarrow> P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e,s\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e,s\\<rangle>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e,s\\<rangle>", "by (erule finalE) (iprover intro: eval_evals.intros)+"], ["", "(*>*)"], ["", "lemma eval_final_same: \"\\<lbrakk> P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>; final e \\<rbrakk> \\<Longrightarrow> e = e' \\<and> s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                            \\<langle>e',s'\\<rangle>;\n     final e\\<rbrakk>\n    \\<Longrightarrow> e = e' \\<and> s = s'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                            \\<langle>e',s'\\<rangle>;\n     final e\\<rbrakk>\n    \\<Longrightarrow> e = e' \\<and> s = s'", "by(auto elim!: finalE eval_cases)"], ["", "(*>*)"], ["", "lemma eval_finalsId:\nassumes finals: \"finals es\" shows \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es,s\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es,s\\<rangle>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es,s\\<rangle>", "using finals"], ["proof (prove)\nusing this:\n  finals es\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es,s\\<rangle>", "proof (induct es type: list)"], ["proof (state)\ngoal (2 subgoals):\n 1. finals [] \\<Longrightarrow>\n    P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>[],s\\<rangle>\n 2. \\<And>a list.\n       \\<lbrakk>finals list \\<Longrightarrow>\n                P \\<turnstile> \\<langle>list,s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>list,s\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>a # list,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>a # list,s\\<rangle>", "case Nil"], ["proof (state)\nthis:\n  finals []\n\ngoal (2 subgoals):\n 1. finals [] \\<Longrightarrow>\n    P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>[],s\\<rangle>\n 2. \\<And>a list.\n       \\<lbrakk>finals list \\<Longrightarrow>\n                P \\<turnstile> \\<langle>list,s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>list,s\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>a # list,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>a # list,s\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>[],s\\<rangle>", "by (rule eval_evals.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>[],s\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>finals list \\<Longrightarrow>\n                P \\<turnstile> \\<langle>list,s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>list,s\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>a # list,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>a # list,s\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>finals list \\<Longrightarrow>\n                P \\<turnstile> \\<langle>list,s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>list,s\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>a # list,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>a # list,s\\<rangle>", "case (Cons e es)"], ["proof (state)\nthis:\n  finals es \\<Longrightarrow>\n  P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es,s\\<rangle>\n  finals (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>finals list \\<Longrightarrow>\n                P \\<turnstile> \\<langle>list,s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>list,s\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>a # list,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>a # list,s\\<rangle>", "have hyp: \"finals es \\<Longrightarrow> P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es,s\\<rangle>\"\n   and finals: \"finals (e # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finals es \\<Longrightarrow>\n     P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es,s\\<rangle>) &&&\n    finals (e # es)", "by fact+"], ["proof (state)\nthis:\n  finals es \\<Longrightarrow>\n  P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es,s\\<rangle>\n  finals (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>finals list \\<Longrightarrow>\n                P \\<turnstile> \\<langle>list,s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>list,s\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>a # list,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>a # list,s\\<rangle>", "show \"P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>] \\<langle>e # es,s\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "assume \"final e\""], ["proof (state)\nthis:\n  final e\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  final e\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "proof (cases rule: finalE)"], ["proof (state)\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "assume e: \"e = Val v\""], ["proof (state)\nthis:\n  e = Val v\n\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "have \"P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow> \\<langle>Val v,s\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow>\n                   \\<langle>Val v,s\\<rangle>", "by (simp add: eval_finalId)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<rangle>\n\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<rangle>\n\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "from finals e"], ["proof (chain)\npicking this:\n  finals (e # es)\n  e = Val v", "have \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es,s\\<rangle>\""], ["proof (prove)\nusing this:\n  finals (e # es)\n  e = Val v\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es,s\\<rangle>", "by(fast intro:hyp)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es,s\\<rangle>\n\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es,s\\<rangle>", "have \"P \\<turnstile> \\<langle>Val v#es,s\\<rangle> [\\<Rightarrow>] \\<langle>Val v#es,s\\<rangle>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>Val v,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es,s\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>Val v # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>Val v # es,s\\<rangle>", "by (rule eval_evals.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Val v # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>Val v # es,s\\<rangle>\n\ngoal (3 subgoals):\n 1. final e \\<Longrightarrow> final ?e1\n 2. \\<And>v.\n       \\<lbrakk>final e; ?e1 = Val v\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>final e; ?e1 = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "with e"], ["proof (chain)\npicking this:\n  e = Val v\n  P \\<turnstile> \\<langle>Val v # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>Val v # es,s\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  e = Val v\n  P \\<turnstile> \\<langle>Val v # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>Val v # es,s\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>e # es,s\\<rangle>\n\ngoal (2 subgoals):\n 1. final e \\<Longrightarrow> final e\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. final e \\<Longrightarrow> final e\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. final e \\<Longrightarrow> final e\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "assume e: \"e = Throw a\""], ["proof (state)\nthis:\n  e = Throw a\n\ngoal (2 subgoals):\n 1. final e \\<Longrightarrow> final e\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "have \"P \\<turnstile> \\<langle>Throw a,s\\<rangle> \\<Rightarrow> \\<langle>Throw a,s\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>Throw a,s\\<rangle> \\<Rightarrow>\n                   \\<langle>Throw a,s\\<rangle>", "by (simp add: eval_finalId)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Throw a,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Throw a,s\\<rangle>\n\ngoal (2 subgoals):\n 1. final e \\<Longrightarrow> final e\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "hence \"P \\<turnstile> \\<langle>Throw a#es,s\\<rangle> [\\<Rightarrow>] \\<langle>Throw a#es,s\\<rangle>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>Throw a,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Throw a,s\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>Throw a # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>Throw a # es,s\\<rangle>", "by (rule eval_evals.intros)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>Throw a # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>Throw a # es,s\\<rangle>\n\ngoal (2 subgoals):\n 1. final e \\<Longrightarrow> final e\n 2. \\<And>a.\n       \\<lbrakk>final e; e = Throw a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<langle>e # es,\n   s\\<rangle> [\\<Rightarrow>]\n  \\<langle>e # es,s\\<rangle>", "with e"], ["proof (chain)\npicking this:\n  e = Throw a\n  P \\<turnstile> \\<langle>Throw a # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>Throw a # es,s\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  e = Throw a\n  P \\<turnstile> \\<langle>Throw a # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>Throw a # es,s\\<rangle>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>e # es,s\\<rangle>\n\ngoal (1 subgoal):\n 1. final e \\<Longrightarrow> final e", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>e # es,s\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> final e \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> final e \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "assume \"\\<not> final e\""], ["proof (state)\nthis:\n  \\<not> final e\n\ngoal (1 subgoal):\n 1. \\<not> final e \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "with not_finals_ConsI finals"], ["proof (chain)\npicking this:\n  \\<not> final ?e \\<Longrightarrow> \\<not> finals (?e # ?es)\n  finals (e # es)\n  \\<not> final e", "have False"], ["proof (prove)\nusing this:\n  \\<not> final ?e \\<Longrightarrow> \\<not> finals (?e # ?es)\n  finals (e # es)\n  \\<not> final e\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> final e \\<Longrightarrow>\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>e # es,s\\<rangle>", ".."], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>e # es,s\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>e # es,s\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma evals_finals_same:\nassumes finals: \"finals es\"\nshows \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> es = es' \\<and> s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    es = es' \\<and> s = s'", "using finals"], ["proof (prove)\nusing this:\n  finals es\n\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    es = es' \\<and> s = s'", "proof (induct es arbitrary: es' type: list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       \\<lbrakk>P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>es',s'\\<rangle>;\n        finals []\\<rbrakk>\n       \\<Longrightarrow> [] = es' \\<and> s = s'\n 2. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "case Nil"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals []\n\ngoal (2 subgoals):\n 1. \\<And>es'.\n       \\<lbrakk>P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                               \\<langle>es',s'\\<rangle>;\n        finals []\\<rbrakk>\n       \\<Longrightarrow> [] = es' \\<and> s = s'\n 2. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals []", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals []\n\ngoal (1 subgoal):\n 1. [] = es' \\<and> s = s'", "using evals_cases(1)"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>[],s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals []\n  \\<lbrakk>?P \\<turnstile> \\<langle>[],?s\\<rangle> [\\<Rightarrow>]\n                           \\<langle>?e',?s'\\<rangle>;\n   \\<lbrakk>?e' = []; ?s' = ?s\\<rbrakk> \\<Longrightarrow> ?Pa\\<rbrakk>\n  \\<Longrightarrow> ?Pa\n\ngoal (1 subgoal):\n 1. [] = es' \\<and> s = s'", "by blast"], ["proof (state)\nthis:\n  [] = es' \\<and> s = s'\n\ngoal (1 subgoal):\n 1. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "case (Cons e es)"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                          \\<langle>?es',s'\\<rangle>;\n   finals es\\<rbrakk>\n  \\<Longrightarrow> es = ?es' \\<and> s = s'\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "have IH: \"\\<And>es'. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> finals es \\<Longrightarrow> es = es' \\<and> s = s'\"\n   and step: \"P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle>\" and finals: \"finals (e # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es'.\n        \\<lbrakk>P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                                \\<langle>es',s'\\<rangle>;\n         finals es\\<rbrakk>\n        \\<Longrightarrow> es = es' \\<and> s = s') &&&\n    P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es',s'\\<rangle> &&&\n    finals (e # es)", "by fact+"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                          \\<langle>?es',s'\\<rangle>;\n   finals es\\<rbrakk>\n  \\<Longrightarrow> es = ?es' \\<and> s = s'\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                          \\<langle>?es',s'\\<rangle>;\n   finals es\\<rbrakk>\n  \\<Longrightarrow> es = ?es' \\<and> s = s'\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals (e # es)", "obtain e' es'' where es': \"es' = e'#es''\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                          \\<langle>?es',s'\\<rangle>;\n   finals es\\<rbrakk>\n  \\<Longrightarrow> es = ?es' \\<and> s = s'\n  P \\<turnstile> \\<langle>e # es,s\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es',s'\\<rangle>\n  finals (e # es)\n\ngoal (1 subgoal):\n 1. (\\<And>e' es''.\n        es' = e' # es'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson Cons.prems(1) evals_cases(2))"], ["proof (state)\nthis:\n  es' = e' # es''\n\ngoal (1 subgoal):\n 1. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "have fe: \"final e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final e", "using finals not_finals_ConsI"], ["proof (prove)\nusing this:\n  finals (e # es)\n  \\<not> final ?e \\<Longrightarrow> \\<not> finals (?e # ?es)\n\ngoal (1 subgoal):\n 1. final e", "by auto"], ["proof (state)\nthis:\n  final e\n\ngoal (1 subgoal):\n 1. \\<And>a list es'.\n       \\<lbrakk>\\<And>es'.\n                   \\<lbrakk>P \\<turnstile> \\<langle>list,\n      s\\<rangle> [\\<Rightarrow>]\n     \\<langle>es',s'\\<rangle>;\n                    finals list\\<rbrakk>\n                   \\<Longrightarrow> list = es' \\<and> s = s';\n        P \\<turnstile> \\<langle>a # list,s\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>;\n        finals (a # list)\\<rbrakk>\n       \\<Longrightarrow> a # list = es' \\<and> s = s'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. e # es = es' \\<and> s = s'", "proof(rule evals_cases(2)[OF step])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v s\\<^sub>1 es'.\n       \\<lbrakk>es' = Val v # es';\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v,s\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'\n 2. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "fix v s\\<^sub>1 es1"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v s\\<^sub>1 es'.\n       \\<lbrakk>es' = Val v # es';\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v,s\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'\n 2. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "assume es1: \"es' = Val v # es1\"\n      and estep: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>Val v,s\\<^sub>1\\<rangle>\" and esstep: \"P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>] \\<langle>es1,s'\\<rangle>\""], ["proof (state)\nthis:\n  es' = Val v # es1\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<^sub>1\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es1,s'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>v s\\<^sub>1 es'.\n       \\<lbrakk>es' = Val v # es';\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v,s\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'\n 2. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  es' = Val v # es1\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<^sub>1\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es1,s'\\<rangle>", "have \"e = Val v\""], ["proof (prove)\nusing this:\n  es' = Val v # es1\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<^sub>1\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es1,s'\\<rangle>\n\ngoal (1 subgoal):\n 1. e = Val v", "using eval_final_same fe"], ["proof (prove)\nusing this:\n  es' = Val v # es1\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<^sub>1\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es1,s'\\<rangle>\n  \\<lbrakk>?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   final ?e\\<rbrakk>\n  \\<Longrightarrow> ?e = ?e' \\<and> ?s = ?s'\n  final e\n\ngoal (1 subgoal):\n 1. e = Val v", "by auto"], ["proof (state)\nthis:\n  e = Val v\n\ngoal (2 subgoals):\n 1. \\<And>v s\\<^sub>1 es'.\n       \\<lbrakk>es' = Val v # es';\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v,s\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'\n 2. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  e = Val v", "have \"finals es\""], ["proof (prove)\nusing this:\n  e = Val v\n\ngoal (1 subgoal):\n 1. finals es", "using es' not_finals_ConsI2 finals"], ["proof (prove)\nusing this:\n  e = Val v\n  es' = e' # es''\n  \\<lbrakk>?e = Val ?v; \\<not> finals ?es\\<rbrakk>\n  \\<Longrightarrow> \\<not> finals (?e # ?es)\n  finals (e # es)\n\ngoal (1 subgoal):\n 1. finals es", "by blast"], ["proof (state)\nthis:\n  finals es\n\ngoal (2 subgoals):\n 1. \\<And>v s\\<^sub>1 es'.\n       \\<lbrakk>es' = Val v # es';\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v,s\\<^sub>1\\<rangle>;\n        P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                       \\<langle>es',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'\n 2. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  finals es", "show ?thesis"], ["proof (prove)\nusing this:\n  finals es\n\ngoal (1 subgoal):\n 1. e # es = es' \\<and> s = s'", "using es' IH estep esstep es1 eval_final_same fe"], ["proof (prove)\nusing this:\n  finals es\n  es' = e' # es''\n  \\<lbrakk>P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                          \\<langle>?es',s'\\<rangle>;\n   finals es\\<rbrakk>\n  \\<Longrightarrow> es = ?es' \\<and> s = s'\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,s\\<^sub>1\\<rangle>\n  P \\<turnstile> \\<langle>es,s\\<^sub>1\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es1,s'\\<rangle>\n  es' = Val v # es1\n  \\<lbrakk>?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   final ?e\\<rbrakk>\n  \\<Longrightarrow> ?e = ?e' \\<and> ?s = ?s'\n  final e\n\ngoal (1 subgoal):\n 1. e # es = es' \\<and> s = s'", "by blast"], ["proof (state)\nthis:\n  e # es = es' \\<and> s = s'\n\ngoal (1 subgoal):\n 1. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "fix e'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "assume es1: \"es' = throw e' # es\" and estep: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>throw e',s'\\<rangle>\""], ["proof (state)\nthis:\n  es' = throw e' # es\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  es' = throw e' # es\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw e',s'\\<rangle>", "have \"e = throw e'\""], ["proof (prove)\nusing this:\n  es' = throw e' # es\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. e = throw e'", "using eval_final_same fe"], ["proof (prove)\nusing this:\n  es' = throw e' # es\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw e',s'\\<rangle>\n  \\<lbrakk>?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   final ?e\\<rbrakk>\n  \\<Longrightarrow> ?e = ?e' \\<and> ?s = ?s'\n  final e\n\ngoal (1 subgoal):\n 1. e = throw e'", "by auto"], ["proof (state)\nthis:\n  e = throw e'\n\ngoal (1 subgoal):\n 1. \\<And>e'.\n       \\<lbrakk>es' = throw e' # es;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> e # es = es' \\<and> s = s'", "then"], ["proof (chain)\npicking this:\n  e = throw e'", "show ?thesis"], ["proof (prove)\nusing this:\n  e = throw e'\n\ngoal (1 subgoal):\n 1. e # es = es' \\<and> s = s'", "using es' estep es1 eval_final_same fe"], ["proof (prove)\nusing this:\n  e = throw e'\n  es' = e'__ # es''\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw e',s'\\<rangle>\n  es' = throw e' # es\n  \\<lbrakk>?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   final ?e\\<rbrakk>\n  \\<Longrightarrow> ?e = ?e' \\<and> ?s = ?s'\n  final e\n\ngoal (1 subgoal):\n 1. e # es = es' \\<and> s = s'", "by blast"], ["proof (state)\nthis:\n  e # es = es' \\<and> s = s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e # es = es' \\<and> s = s'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection \"Property preservation\""], ["", "lemma evals_length: \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> length es = length es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    length es = length es'", "by(induct es arbitrary:es' s s', auto elim: evals_cases)"], ["", "corollary evals_empty: \"P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> (es = []) = (es' = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>es,s\\<rangle> [\\<Rightarrow>]\n                   \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    (es = []) = (es' = [])", "by(drule evals_length, fastforce)"], ["", "(****)"], ["", "theorem eval_hext: \"P \\<turnstile> \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"\nand evals_hext:  \"P \\<turnstile> \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',(h', l', sh')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h') &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',(h', l', sh')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',(h', l', sh')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h') &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',(h', l', sh')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h')", "proof (induct rule: eval_evals_inducts)"], ["proof (state)\ngoal (80 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h''\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>v a aa b. a \\<unlhd> a\nA total of 80 subgoals...", "case New"], ["proof (state)\nthis:\n  sh_ C_ = \\<lfloor>(sfs_, Done)\\<rfloor>\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  P \\<turnstile> C_ has_fields FDTs_\n  h'_ = h_(a_ \\<mapsto> blank P C_)\n\ngoal (80 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h''\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>v a aa b. a \\<unlhd> a\nA total of 80 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  sh_ C_ = \\<lfloor>(sfs_, Done)\\<rfloor>\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  P \\<turnstile> C_ has_fields FDTs_\n  h'_ = h_(a_ \\<mapsto> blank P C_)\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h'_", "by(fastforce intro!: hext_new intro:LeastI simp:new_Addr_def\n                split:if_split_asm simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h'_\n\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h''\n 3. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 5. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 6. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 7. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 8. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>v a aa b. a \\<unlhd> a\n 10. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n        bop v.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>Val v\\<^sub>1,\n                                 (ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab;\n         P \\<turnstile> \\<langle>e\\<^sub>2,\n                         (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                        \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n         ab \\<unlhd> ad;\n         binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ad\nA total of 79 subgoals...", "next"], ["proof (state)\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h''\n 3. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 5. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 6. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 7. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 8. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>v a aa b. a \\<unlhd> a\n 10. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n        bop v.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>Val v\\<^sub>1,\n                                 (ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab;\n         P \\<turnstile> \\<langle>e\\<^sub>2,\n                         (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                        \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n         ab \\<unlhd> ad;\n         binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ad\nA total of 79 subgoals...", "case NewInit"], ["proof (state)\nthis:\n  \\<nexists>sfs. sh_ C_ = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C_ ([C_],False) \\<leftarrow> unit,\n                  (h_, l_, sh_)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v'_,(h'_, l'_, sh'_)\\<rangle>\n  h_ \\<unlhd> h'_\n  new_Addr h'_ = \\<lfloor>a_\\<rfloor>\n  P \\<turnstile> C_ has_fields FDTs_\n  h''_ = h'_(a_ \\<mapsto> blank P C_)\n\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h''\n 3. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 4. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 5. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 6. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 7. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 8. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>v a aa b. a \\<unlhd> a\n 10. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n        bop v.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>Val v\\<^sub>1,\n                                 (ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab;\n         P \\<turnstile> \\<langle>e\\<^sub>2,\n                         (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                        \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n         ab \\<unlhd> ad;\n         binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ad\nA total of 79 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<nexists>sfs. sh_ C_ = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C_ ([C_],False) \\<leftarrow> unit,\n                  (h_, l_, sh_)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v'_,(h'_, l'_, sh'_)\\<rangle>\n  h_ \\<unlhd> h'_\n  new_Addr h'_ = \\<lfloor>a_\\<rfloor>\n  P \\<turnstile> C_ has_fields FDTs_\n  h''_ = h'_(a_ \\<mapsto> blank P C_)\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h''_", "by (meson hext_new hext_trans new_Addr_SomeD)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h''_\n\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 4. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 5. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 7. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>v a aa b. a \\<unlhd> a\n 9. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n       bop v.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                (a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v\\<^sub>1,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab;\n        P \\<turnstile> \\<langle>e\\<^sub>2,\n                        (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n        ab \\<unlhd> ad;\n        binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ad\n 10. \\<And>e\\<^sub>1 a aa b e ab ac ba bop e\\<^sub>2.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>throw e,(ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ab\nA total of 78 subgoals...", "next"], ["proof (state)\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 4. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 5. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 7. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>v a aa b. a \\<unlhd> a\n 9. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n       bop v.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                (a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v\\<^sub>1,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab;\n        P \\<turnstile> \\<langle>e\\<^sub>2,\n                        (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n        ab \\<unlhd> ad;\n        binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ad\n 10. \\<And>e\\<^sub>1 a aa b e ab ac ba bop e\\<^sub>2.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>throw e,(ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ab\nA total of 78 subgoals...", "case FAss"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  a___ \\<unlhd> ac___\n  P \\<turnstile> \\<langle>e\\<^sub>2_,(ac___, a_, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  ac___ \\<unlhd> h\\<^sub>2_\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ has F_,NonStatic:t_ in D_\n  fs'_ = fs_((F_, D_) \\<mapsto> v_)\n  h\\<^sub>2'_ = h\\<^sub>2_(ab___ \\<mapsto> (C_, fs'_))\n\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 4. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 5. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 7. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>v a aa b. a \\<unlhd> a\n 9. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n       bop v.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                (a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v\\<^sub>1,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab;\n        P \\<turnstile> \\<langle>e\\<^sub>2,\n                        (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n        ab \\<unlhd> ad;\n        binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ad\n 10. \\<And>e\\<^sub>1 a aa b e ab ac ba bop e\\<^sub>2.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>throw e,(ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ab\nA total of 78 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  a___ \\<unlhd> ac___\n  P \\<turnstile> \\<langle>e\\<^sub>2_,(ac___, a_, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  ac___ \\<unlhd> h\\<^sub>2_\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ has F_,NonStatic:t_ in D_\n  fs'_ = fs_((F_, D_) \\<mapsto> v_)\n  h\\<^sub>2'_ = h\\<^sub>2_(ab___ \\<mapsto> (C_, fs'_))\n\ngoal (1 subgoal):\n 1. a___ \\<unlhd> h\\<^sub>2'_", "by(auto simp:sym[THEN hext_upd_obj] simp del:fun_upd_apply\n            elim!: hext_trans)"], ["proof (state)\nthis:\n  a___ \\<unlhd> h\\<^sub>2'_\n\ngoal (77 subgoals):\n 1. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        h \\<unlhd> h'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 3. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        h \\<unlhd> aa; is_class P C\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> aa\n 4. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 5. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        a \\<unlhd> h; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 7. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>v a aa b. a \\<unlhd> a\n 9. \\<And>e\\<^sub>1 a aa b v\\<^sub>1 ab ac ba e\\<^sub>2 v\\<^sub>2 ad ae bb\n       bop v.\n       \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                (a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v\\<^sub>1,(ab, ac, ba)\\<rangle>;\n        a \\<unlhd> ab;\n        P \\<turnstile> \\<langle>e\\<^sub>2,\n                        (ab, ac, ba)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v\\<^sub>2,(ad, ae, bb)\\<rangle>;\n        ab \\<unlhd> ad;\n        binop (bop, v\\<^sub>1, v\\<^sub>2) = \\<lfloor>v\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ad\n 10. \\<And>e\\<^sub>1 a aa b e ab ac ba bop e\\<^sub>2.\n        \\<lbrakk>P \\<turnstile> \\<langle>e\\<^sub>1,\n                                 (a, aa, b)\\<rangle> \\<Rightarrow>\n                                \\<langle>throw e,(ab, ac, ba)\\<rangle>;\n         a \\<unlhd> ab\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> ab\nA total of 77 subgoals...", "qed (auto elim!: hext_trans)"], ["", "(*>*)"], ["", "lemma eval_lcl_incr: \"P \\<turnstile> \\<langle>e,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0)\\<rangle> \\<Rightarrow> \\<langle>e',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"\n and evals_lcl_incr: \"P \\<turnstile> \\<langle>es,(h\\<^sub>0,l\\<^sub>0,sh\\<^sub>0)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h\\<^sub>1,l\\<^sub>1,sh\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,\n                     (h\\<^sub>0, l\\<^sub>0,\n                      sh\\<^sub>0)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',\n                     (h\\<^sub>1, l\\<^sub>1,\n                      sh\\<^sub>1)\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1) &&&\n    (P \\<turnstile> \\<langle>es,\n                     (h\\<^sub>0, l\\<^sub>0,\n                      sh\\<^sub>0)\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',\n                     (h\\<^sub>1, l\\<^sub>1,\n                      sh\\<^sub>1)\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,\n                     (h\\<^sub>0, l\\<^sub>0,\n                      sh\\<^sub>0)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',\n                     (h\\<^sub>1, l\\<^sub>1,\n                      sh\\<^sub>1)\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1) &&&\n    (P \\<turnstile> \\<langle>es,\n                     (h\\<^sub>0, l\\<^sub>0,\n                      sh\\<^sub>0)\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',\n                     (h\\<^sub>1, l\\<^sub>1,\n                      sh\\<^sub>1)\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1)", "proof (induct rule: eval_evals_inducts)"], ["proof (state)\ngoal (80 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 80 subgoals...", "case BinOp"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v\\<^sub>1_,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>e\\<^sub>2_,\n                  (ab___, ac___, ba___)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v\\<^sub>2_,(ad___, a_, b_)\\<rangle>\n  dom ac___ \\<subseteq> dom a_\n  binop (bop_, v\\<^sub>1_, v\\<^sub>2_) = \\<lfloor>v_\\<rfloor>\n\ngoal (80 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 80 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom a_", "by(rule subset_trans)(rule BinOp.hyps)+"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom a_\n\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 79 subgoals...", "next"], ["proof (state)\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 79 subgoals...", "case Call"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  dom aa___ \\<subseteq> dom a_\n  P \\<turnstile> \\<langle>ps_,(ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  dom a_ \\<subseteq> dom l\\<^sub>2_\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [this \\<mapsto> Addr ab___, pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  dom l\\<^sub>2'_ \\<subseteq> dom l\\<^sub>3_\n\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 79 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  dom aa___ \\<subseteq> dom a_\n  P \\<turnstile> \\<langle>ps_,(ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  dom a_ \\<subseteq> dom l\\<^sub>2_\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [this \\<mapsto> Addr ab___, pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  dom l\\<^sub>2'_ \\<subseteq> dom l\\<^sub>3_\n\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom l\\<^sub>2_", "by(simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom l\\<^sub>2_\n\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 78 subgoals...", "next"], ["proof (state)\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 78 subgoals...", "case Seq"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>0_,\n                  (a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v_,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (ab___, ac___, ba___)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>2_,(ad___, a_, b_)\\<rangle>\n  dom ac___ \\<subseteq> dom a_\n\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 78 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom a_", "by(rule subset_trans)(rule Seq.hyps)+"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom a_\n\ngoal (77 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 77 subgoals...", "next"], ["proof (state)\ngoal (77 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 77 subgoals...", "case CondT"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>true,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (ab___, ac___, ba___)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(ad___, a_, b_)\\<rangle>\n  dom ac___ \\<subseteq> dom a_\n\ngoal (77 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 77 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom a_", "by(rule subset_trans)(rule CondT.hyps)+"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom a_\n\ngoal (76 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 76 subgoals...", "next"], ["proof (state)\ngoal (76 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 76 subgoals...", "case CondF"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>false,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>e\\<^sub>2_,\n                  (ab___, ac___, ba___)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(ad___, a_, b_)\\<rangle>\n  dom ac___ \\<subseteq> dom a_\n\ngoal (76 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 76 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom a_", "by(rule subset_trans)(rule CondF.hyps)+"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom a_\n\ngoal (75 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 75 subgoals...", "next"], ["proof (state)\ngoal (75 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 75 subgoals...", "case WhileT"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>true,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>c_,(ab___, ac___, ba___)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v\\<^sub>1_,(ad___, ae___, bb___)\\<rangle>\n  dom ac___ \\<subseteq> dom ae___\n  P \\<turnstile> \\<langle>while (e_) c_,\n                  (ad___, ae___, bb___)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>3_,(af___, a_, b_)\\<rangle>\n  dom ae___ \\<subseteq> dom a_\n\ngoal (75 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 75 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>true,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>c_,(ab___, ac___, ba___)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v\\<^sub>1_,(ad___, ae___, bb___)\\<rangle>\n  dom ac___ \\<subseteq> dom ae___\n  P \\<turnstile> \\<langle>while (e_) c_,\n                  (ad___, ae___, bb___)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>3_,(af___, a_, b_)\\<rangle>\n  dom ae___ \\<subseteq> dom a_\n\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom a_", "by(blast)"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom a_\n\ngoal (74 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 74 subgoals...", "next"], ["proof (state)\ngoal (74 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 74 subgoals...", "case TryCatch"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (a___, aa___, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>Throw a_,\n                  (h\\<^sub>1_, l\\<^sub>1_, sh\\<^sub>1_)\\<rangle>\n  dom aa___ \\<subseteq> dom l\\<^sub>1_\n  h\\<^sub>1_ a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* C_\n  P \\<turnstile> \\<langle>e\\<^sub>2_,\n                  (h\\<^sub>1_, l\\<^sub>1_(V_ \\<mapsto> Addr a_),\n                   sh\\<^sub>1_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>2'_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  dom (l\\<^sub>1_(V_ \\<mapsto> Addr a_)) \\<subseteq> dom l\\<^sub>2_\n\ngoal (74 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 74 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e\\<^sub>1_,\n                  (a___, aa___, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>Throw a_,\n                  (h\\<^sub>1_, l\\<^sub>1_, sh\\<^sub>1_)\\<rangle>\n  dom aa___ \\<subseteq> dom l\\<^sub>1_\n  h\\<^sub>1_ a_ = \\<lfloor>(D_, fs_)\\<rfloor>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* C_\n  P \\<turnstile> \\<langle>e\\<^sub>2_,\n                  (h\\<^sub>1_, l\\<^sub>1_(V_ \\<mapsto> Addr a_),\n                   sh\\<^sub>1_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>2'_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  dom (l\\<^sub>1_(V_ \\<mapsto> Addr a_)) \\<subseteq> dom l\\<^sub>2_\n\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom (l\\<^sub>2_(V_ := l\\<^sub>1_ V_))", "by(clarsimp simp:dom_def split:if_split_asm) blast"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom (l\\<^sub>2_(V_ := l\\<^sub>1_ V_))\n\ngoal (73 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 73 subgoals...", "next"], ["proof (state)\ngoal (73 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 73 subgoals...", "case Cons"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v_,(ab___, ac___, ba___)\\<rangle>\n  dom aa___ \\<subseteq> dom ac___\n  P \\<turnstile> \\<langle>es_,(ab___, ac___, ba___)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>es'_,(ad___, a_, b_)\\<rangle>\n  dom ac___ \\<subseteq> dom a_\n\ngoal (73 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 73 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom aa___ \\<subseteq> dom a_", "by(rule subset_trans)(rule Cons.hyps)+"], ["proof (state)\nthis:\n  dom aa___ \\<subseteq> dom a_\n\ngoal (72 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 72 subgoals...", "next"], ["proof (state)\ngoal (72 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 72 subgoals...", "case Block"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e\\<^sub>0_,\n                  (h\\<^sub>0_, l\\<^sub>0_(V_ := None),\n                   sh\\<^sub>0_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>1_,\n                  (h\\<^sub>1_, l\\<^sub>1_, sh\\<^sub>1_)\\<rangle>\n  dom (l\\<^sub>0_(V_ := None)) \\<subseteq> dom l\\<^sub>1_\n\ngoal (72 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 72 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e\\<^sub>0_,\n                  (h\\<^sub>0_, l\\<^sub>0_(V_ := None),\n                   sh\\<^sub>0_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>1_,\n                  (h\\<^sub>1_, l\\<^sub>1_, sh\\<^sub>1_)\\<rangle>\n  dom (l\\<^sub>0_(V_ := None)) \\<subseteq> dom l\\<^sub>1_\n\ngoal (1 subgoal):\n 1. dom l\\<^sub>0_ \\<subseteq> dom (l\\<^sub>1_(V_ := l\\<^sub>0_ V_))", "by(auto simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  dom l\\<^sub>0_ \\<subseteq> dom (l\\<^sub>1_(V_ := l\\<^sub>0_ V_))\n\ngoal (71 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 2. \\<And>sh C sfs h l.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C)\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 4. \\<And>sh C h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        dom l \\<subseteq> dom l'; new_Addr h' = None; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom l'\n 5. \\<And>sh C h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        dom l \\<subseteq> dom ab; is_class P C\\<rbrakk>\n       \\<Longrightarrow> dom l \\<subseteq> dom ab\n 6. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 7. \\<And>e a aa b ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 8. \\<And>e a aa b ab h l sh D fs C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        dom aa \\<subseteq> dom l; h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom l\n 9. \\<And>e a aa b e' ab ac ba C.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        dom aa \\<subseteq> dom ac\\<rbrakk>\n       \\<Longrightarrow> dom aa \\<subseteq> dom ac\n 10. \\<And>v a aa b. dom aa \\<subseteq> dom aa\nA total of 71 subgoals...", "qed auto"], ["", "(*>*)"], ["", "lemma\nshows init_ri_same_loc: \"P \\<turnstile> \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>\n   \\<Longrightarrow> (\\<And>C Cs b M a. e = INIT C (Cs,b) \\<leftarrow> unit \\<or> e = C\\<bullet>\\<^sub>sM([]) \\<or> e = RI (C,Throw a) ; Cs \\<leftarrow> unit\n          \\<or> e = RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n           \\<Longrightarrow> l = l')\"\n  and \"P \\<turnstile> \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle> \\<Longrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',(h', l', sh')\\<rangle> \\<Longrightarrow>\n     (\\<And>C Cs b M a.\n         e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n         e = C\\<bullet>\\<^sub>sM([]) \\<or>\n         e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n         e =\n         RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n         l = l')) &&&\n    (P \\<turnstile> \\<langle>es,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                    \\<langle>es',(h', l', sh')\\<rangle> \\<Longrightarrow>\n     True)", "proof(induct rule: eval_evals_inducts)"], ["proof (state)\ngoal (80 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l Ca Cs b M aa.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 2. \\<And>sh C sfs h l Ca Cs b M a.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h'' Ca Cs b M aa.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 4. \\<And>sh C h l v' h' l' sh' Ca Cs b M a.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = None; is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 5. \\<And>sh C h l a aa ab b Ca Cs ba M ac.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = ab;\n        is_class P C;\n        new C = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = ab\n 6. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 7. \\<And>e a aa b ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 8. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 9. \\<And>e a aa b e' ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 10. \\<And>v a aa b C Cs ba M ab.\n        Val v = INIT C (Cs,ba) \\<leftarrow> unit \\<or>\n        Val v = C\\<bullet>\\<^sub>sM([]) \\<or>\n        Val v = RI (C,Throw ab) ; Cs \\<leftarrow> unit \\<or>\n        Val v =\n        RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n        aa = aa\nA total of 80 subgoals...", "case (RInitInitFail e h l sh a')"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a',(h'_, l'_, sh'_)\\<rangle>\n  e = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  P \\<turnstile> \\<langle>RI (D_,throw a') ; Cs_ \\<leftarrow> e_,\n                  (h'_, l'_, sh''_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>1_,(a___, a_, b_)\\<rangle>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l'_ = a_\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n\ngoal (80 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l Ca Cs b M aa.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 2. \\<And>sh C sfs h l Ca Cs b M a.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h'' Ca Cs b M aa.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 4. \\<And>sh C h l v' h' l' sh' Ca Cs b M a.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = None; is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 5. \\<And>sh C h l a aa ab b Ca Cs ba M ac.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = ab;\n        is_class P C;\n        new C = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = ab\n 6. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 7. \\<And>e a aa b ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 8. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 9. \\<And>e a aa b e' ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 10. \\<And>v a aa b C Cs ba M ab.\n        Val v = INIT C (Cs,ba) \\<leftarrow> unit \\<or>\n        Val v = C\\<bullet>\\<^sub>sM([]) \\<or>\n        Val v = RI (C,Throw ab) ; Cs \\<leftarrow> unit \\<or>\n        Val v =\n        RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n        aa = aa\nA total of 80 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a',(h'_, l'_, sh'_)\\<rangle>\n  e = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  P \\<turnstile> \\<langle>RI (D_,throw a') ; Cs_ \\<leftarrow> e_,\n                  (h'_, l'_, sh''_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>1_,(a___, a_, b_)\\<rangle>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l'_ = a_\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a',(h'_, l'_, sh'_)\\<rangle>\n  e = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  P \\<turnstile> \\<langle>RI (D_,throw a') ; Cs_ \\<leftarrow> e_,\n                  (h'_, l'_, sh''_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>1_,(a___, a_, b_)\\<rangle>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l'_ = a_\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n\ngoal (1 subgoal):\n 1. l = a_", "using eval_final[of _ _ _ \"throw a'\"]"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a',(h'_, l'_, sh'_)\\<rangle>\n  e = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  P \\<turnstile> \\<langle>RI (D_,throw a') ; Cs_ \\<leftarrow> e_,\n                  (h'_, l'_, sh''_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e\\<^sub>1_,(a___, a_, b_)\\<rangle>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  RI (D_,throw a') ; Cs_ \\<leftarrow> e_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  l'_ = a_\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e) ; D_ # Cs_ \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n  ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                  \\<langle>throw a',?s'\\<rangle> \\<Longrightarrow>\n  final (throw a')\n\ngoal (1 subgoal):\n 1. l = a_", "by(fastforce dest: eval_final_same[of _ \"Throw a\"])"], ["proof (state)\nthis:\n  l = a_\n\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l Ca Cs b M aa.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 2. \\<And>sh C sfs h l Ca Cs b M a.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h'' Ca Cs b M aa.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 4. \\<And>sh C h l v' h' l' sh' Ca Cs b M a.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = None; is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 5. \\<And>sh C h l a aa ab b Ca Cs ba M ac.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = ab;\n        is_class P C;\n        new C = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = ab\n 6. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 7. \\<And>e a aa b ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 8. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 9. \\<And>e a aa b e' ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 10. \\<And>v a aa b C Cs ba M ab.\n        Val v = INIT C (Cs,ba) \\<leftarrow> unit \\<or>\n        Val v = C\\<bullet>\\<^sub>sM([]) \\<or>\n        Val v = RI (C,Throw ab) ; Cs \\<leftarrow> unit \\<or>\n        Val v =\n        RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n        aa = aa\nA total of 79 subgoals...", "next"], ["proof (state)\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l Ca Cs b M aa.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 2. \\<And>sh C sfs h l Ca Cs b M a.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h'' Ca Cs b M aa.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 4. \\<And>sh C h l v' h' l' sh' Ca Cs b M a.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = None; is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 5. \\<And>sh C h l a aa ab b Ca Cs ba M ac.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = ab;\n        is_class P C;\n        new C = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = ab\n 6. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 7. \\<And>e a aa b ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 8. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 9. \\<And>e a aa b e' ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 10. \\<And>v a aa b C Cs ba M ab.\n        Val v = INIT C (Cs,ba) \\<leftarrow> unit \\<or>\n        Val v = C\\<bullet>\\<^sub>sM([]) \\<or>\n        Val v = RI (C,Throw ab) ; Cs \\<leftarrow> unit \\<or>\n        Val v =\n        RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n        aa = aa\nA total of 79 subgoals...", "case RInitFailFinal"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e'_,(a___, aa___, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a_,(h'_, l'_, sh'_)\\<rangle>\n  e'_ = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e'_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e'_ = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e'_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  aa___ = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  RI (C_,e'_) ; [] \\<leftarrow> e_ = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n\ngoal (79 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l Ca Cs b M aa.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 2. \\<And>sh C sfs h l Ca Cs b M a.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h'' Ca Cs b M aa.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 4. \\<And>sh C h l v' h' l' sh' Ca Cs b M a.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = None; is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 5. \\<And>sh C h l a aa ab b Ca Cs ba M ac.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = ab;\n        is_class P C;\n        new C = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = ab\n 6. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 7. \\<And>e a aa b ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 8. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 9. \\<And>e a aa b e' ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 10. \\<And>v a aa b C Cs ba M ab.\n        Val v = INIT C (Cs,ba) \\<leftarrow> unit \\<or>\n        Val v = C\\<bullet>\\<^sub>sM([]) \\<or>\n        Val v = RI (C,Throw ab) ; Cs \\<leftarrow> unit \\<or>\n        Val v =\n        RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n        aa = aa\nA total of 79 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e'_,(a___, aa___, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a_,(h'_, l'_, sh'_)\\<rangle>\n  e'_ = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e'_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e'_ = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e'_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  aa___ = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  RI (C_,e'_) ; [] \\<leftarrow> e_ = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e'_,(a___, aa___, b_)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a_,(h'_, l'_, sh'_)\\<rangle>\n  e'_ = INIT ?C (?Cs,?b) \\<leftarrow> unit \\<or>\n  e'_ = ?C\\<bullet>\\<^sub>s?M([]) \\<or>\n  e'_ = RI (?C,Throw ?a) ; ?Cs \\<leftarrow> unit \\<or>\n  e'_ =\n  RI (?C,?C\\<bullet>\\<^sub>sclinit([])) ; ?Cs \\<leftarrow> unit \\<Longrightarrow>\n  aa___ = l'_\n  sh'_ C_ = \\<lfloor>(sfs_, i_)\\<rfloor>\n  sh''_ = sh'_(C_ \\<mapsto> (sfs_, Error))\n  RI (C_,e'_) ; [] \\<leftarrow> e_ = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ = C\\<bullet>\\<^sub>sM([]) \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ =\n  RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n  RI (C_,e'_) ; [] \\<leftarrow> e_ =\n  RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\n\ngoal (1 subgoal):\n 1. aa___ = l'_", "by(auto dest: eval_final_same)"], ["proof (state)\nthis:\n  aa___ = l'_\n\ngoal (78 subgoals):\n 1. \\<And>sh C sfs h a FDTs h' l Ca Cs b M aa.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h' = h(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 2. \\<And>sh C sfs h l Ca Cs b M a.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l\n 3. \\<And>sh C h l v' h' l' sh' a FDTs h'' Ca Cs b M aa.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = \\<lfloor>a\\<rfloor>; P \\<turnstile> C has_fields FDTs;\n        h'' = h'(a \\<mapsto> blank P C);\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw aa) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 4. \\<And>sh C h l v' h' l' sh' Ca Cs b M a.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = l';\n        new_Addr h' = None; is_class P C;\n        new C = INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = l'\n 5. \\<And>sh C h l a aa ab b Ca Cs ba M ac.\n       \\<lbrakk>\\<nexists>sfs. sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<And>Ca Cs b M a.\n           INIT C ([C],False) \\<leftarrow> unit =\n           INIT Ca (Cs,b) \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           Ca\\<bullet>\\<^sub>sM([]) \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           INIT C ([C],False) \\<leftarrow> unit =\n           RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           l = ab;\n        is_class P C;\n        new C = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        new C = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        new C = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        new C =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> l = ab\n 6. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 7. \\<And>e a aa b ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 8. \\<And>e a aa b ab h l sh D fs C Ca Cs ba M ac.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = l;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, C) \\<notin> (subcls1 P)\\<^sup>*;\n        Cast C e = INIT Ca (Cs,ba) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ac) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = l\n 9. \\<And>e a aa b e' ab ac ba C Ca Cs bb M ad.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<And>C Cs b M a.\n           e = INIT C (Cs,b) \\<leftarrow> unit \\<or>\n           e = C\\<bullet>\\<^sub>sM([]) \\<or>\n           e = RI (C,Throw a) ; Cs \\<leftarrow> unit \\<or>\n           e =\n           RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n           aa = ac;\n        Cast C e = INIT Ca (Cs,bb) \\<leftarrow> unit \\<or>\n        Cast C e = Ca\\<bullet>\\<^sub>sM([]) \\<or>\n        Cast C e = RI (Ca,Throw ad) ; Cs \\<leftarrow> unit \\<or>\n        Cast C e =\n        RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit\\<rbrakk>\n       \\<Longrightarrow> aa = ac\n 10. \\<And>v a aa b C Cs ba M ab.\n        Val v = INIT C (Cs,ba) \\<leftarrow> unit \\<or>\n        Val v = C\\<bullet>\\<^sub>sM([]) \\<or>\n        Val v = RI (C,Throw ab) ; Cs \\<leftarrow> unit \\<or>\n        Val v =\n        RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit \\<Longrightarrow>\n        aa = aa\nA total of 78 subgoals...", "qed(auto dest: evals_cases eval_cases(17) eval_final_same)"], ["", "lemma init_same_loc: \"P \\<turnstile> \\<langle>INIT C (Cs,b) \\<leftarrow> unit,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle> \\<Longrightarrow> l = l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>INIT C (Cs,b) \\<leftarrow> unit,\n                    (h, l, sh)\\<rangle> \\<Rightarrow>\n                   \\<langle>e',(h', l', sh')\\<rangle> \\<Longrightarrow>\n    l = l'", "by(simp add: init_ri_same_loc)"], ["", "(****)"], ["", "lemma assumes wf: \"wwf_J_prog P\"\nshows eval_proc_pres': \"P \\<turnstile> \\<langle>e,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_init C e \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\"\n  and evals_proc_pres': \"P \\<turnstile> \\<langle>es,(h,l,sh)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l',sh')\\<rangle>\n  \\<Longrightarrow> not_inits C es \\<Longrightarrow> \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow> \\<exists>sfs'. sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                             \\<langle>e',(h', l', sh')\\<rangle>;\n      not_init C e;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>) &&&\n    (\\<lbrakk>P \\<turnstile> \\<langle>es,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                             \\<langle>es',(h', l', sh')\\<rangle>;\n      not_inits C es;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                             \\<langle>e',(h', l', sh')\\<rangle>;\n      not_init C e;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>) &&&\n    (\\<lbrakk>P \\<turnstile> \\<langle>es,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                             \\<langle>es',(h', l', sh')\\<rangle>;\n      not_inits C es;\n      \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>sfs'.\n                          sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>)", "proof(induct rule:eval_evals_inducts)"], ["proof (state)\ngoal (80 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 80 subgoals...", "case Call"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>ps_,(ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [this \\<mapsto> Addr ab___, pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(ps_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (80 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 80 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>ps_,(ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [this \\<mapsto> Addr ab___, pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(ps_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>ps_,(ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [this \\<mapsto> Addr ab___, pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(ps_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using sees_wwf_nsub_RI[OF wf Call.hyps(6)] nsub_RI_not_init"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e_,(a___, aa___, b___)\\<rangle> \\<Rightarrow>\n                 \\<langle>addr ab___,(ac___, a_, b_)\\<rangle>\n  \\<lbrakk>not_init C e_;\n   \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>ps_,(ac___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  h\\<^sub>2_ ab___ = \\<lfloor>(C_, fs_)\\<rfloor>\n  P \\<turnstile> C_ sees M_, NonStatic :  Ts_\\<rightarrow>T_ = (pns_,\n                          body_) in D_\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [this \\<mapsto> Addr ab___, pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (e_\\<bullet>M_(ps_))\n  \\<exists>sfs. b___ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body_\n  \\<not> sub_RI ?e \\<Longrightarrow> not_init ?C ?e\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (79 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 79 subgoals...", "next"], ["proof (state)\ngoal (79 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 79 subgoals...", "case (SCallInit ps h l sh vs h\\<^sub>1 l\\<^sub>1 sh\\<^sub>1 C' M Ts T pns body D v' h\\<^sub>2 l\\<^sub>2 sh\\<^sub>2 l\\<^sub>2' e' h\\<^sub>3 l\\<^sub>3 sh\\<^sub>3)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = (pns, body) in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile> \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',(h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length pns\n  l\\<^sub>2' = [pns [\\<mapsto>] vs]\n  P \\<turnstile> \\<langle>body,\n                  (h\\<^sub>2, l\\<^sub>2', sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',(h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (79 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 79 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = (pns, body) in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile> \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',(h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length pns\n  l\\<^sub>2' = [pns [\\<mapsto>] vs]\n  P \\<turnstile> \\<langle>body,\n                  (h\\<^sub>2, l\\<^sub>2', sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',(h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = (pns, body) in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile> \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',(h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length pns\n  l\\<^sub>2' = [pns [\\<mapsto>] vs]\n  P \\<turnstile> \\<langle>body,\n                  (h\\<^sub>2, l\\<^sub>2', sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',(h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using SCallInit sees_wwf_nsub_RI[OF wf SCallInit.hyps(3)] nsub_RI_not_init[of body]"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = (pns, body) in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile> \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',(h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length pns\n  l\\<^sub>2' = [pns [\\<mapsto>] vs]\n  P \\<turnstile> \\<langle>body,\n                  (h\\<^sub>2, l\\<^sub>2', sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',(h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>ps,(h, l, sh)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle>\n  \\<lbrakk>not_inits C ps;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>1 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C' sees M, Static :  Ts\\<rightarrow>T = (pns, body) in D\n  \\<nexists>sfs. sh\\<^sub>1 D = \\<lfloor>(sfs, Done)\\<rfloor>\n  M \\<noteq> clinit\n  P \\<turnstile> \\<langle>INIT D ([D],False) \\<leftarrow> unit,\n                  (h\\<^sub>1, l\\<^sub>1, sh\\<^sub>1)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',(h\\<^sub>2, l\\<^sub>2, sh\\<^sub>2)\\<rangle>\n  \\<lbrakk>not_init C (INIT D ([D],False) \\<leftarrow> unit);\n   \\<exists>sfs. sh\\<^sub>1 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  length vs = length pns\n  l\\<^sub>2' = [pns [\\<mapsto>] vs]\n  P \\<turnstile> \\<langle>body,\n                  (h\\<^sub>2, l\\<^sub>2', sh\\<^sub>2)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',(h\\<^sub>3, l\\<^sub>3, sh\\<^sub>3)\\<rangle>\n  \\<lbrakk>not_init C body;\n   \\<exists>sfs. sh\\<^sub>2 C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C'\\<bullet>\\<^sub>sM(ps))\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body\n  \\<not> sub_RI body \\<Longrightarrow> not_init ?C body\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. sh\\<^sub>3 C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (78 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 78 subgoals...", "next"], ["proof (state)\ngoal (78 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 78 subgoals...", "case SCall"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>ps_,(a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (78 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 78 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>ps_,(a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>ps_,(a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using sees_wwf_nsub_RI[OF wf SCall.hyps(3)] nsub_RI_not_init"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>ps_,(a___, a_, b_)\\<rangle> [\\<Rightarrow>]\n                 \\<langle>map Val vs_,\n                  (h\\<^sub>2_, l\\<^sub>2_, sh\\<^sub>2_)\\<rangle>\n  \\<lbrakk>not_inits C ps_;\n   \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>2_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  P \\<turnstile> C_ sees M_, Static :  Ts_\\<rightarrow>T_ = (pns_,\n                       body_) in D_\n  sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Done)\\<rfloor> \\<or>\n  M_ = clinit \\<and> sh\\<^sub>2_ D_ = \\<lfloor>(sfs_, Processing)\\<rfloor>\n  length vs_ = length pns_\n  l\\<^sub>2'_ = [pns_ [\\<mapsto>] vs_]\n  P \\<turnstile> \\<langle>body_,\n                  (h\\<^sub>2_, l\\<^sub>2'_,\n                   sh\\<^sub>2_)\\<rangle> \\<Rightarrow>\n                 \\<langle>e'_,(h\\<^sub>3_, l\\<^sub>3_, sh\\<^sub>3_)\\<rangle>\n  \\<lbrakk>not_init C body_;\n   \\<exists>sfs.\n      sh\\<^sub>2_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (C_\\<bullet>\\<^sub>sM_(ps_))\n  \\<exists>sfs. b_ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  \\<not> sub_RI body_\n  \\<not> sub_RI ?e \\<Longrightarrow> not_init ?C ?e\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. sh\\<^sub>3_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (77 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 77 subgoals...", "next"], ["proof (state)\ngoal (77 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 77 subgoals...", "case (InitNone sh C1 C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C1 = None\n  P \\<turnstile> \\<langle>INIT C' (C1 # Cs,False) \\<leftarrow> h,\n                  (l, e', sh(C1 \\<mapsto>\n                   (sblank P C1, Prepared)))\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs.\n      (sh(C1 \\<mapsto> (sblank P C1, Prepared))) C =\n      \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (77 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 77 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = None\n  P \\<turnstile> \\<langle>INIT C' (C1 # Cs,False) \\<leftarrow> h,\n                  (l, e', sh(C1 \\<mapsto>\n                   (sblank P C1, Prepared)))\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs.\n      (sh(C1 \\<mapsto> (sblank P C1, Prepared))) C =\n      \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = None\n  P \\<turnstile> \\<langle>INIT C' (C1 # Cs,False) \\<leftarrow> h,\n                  (l, e', sh(C1 \\<mapsto>\n                   (sblank P C1, Prepared)))\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs.\n      (sh(C1 \\<mapsto> (sblank P C1, Prepared))) C =\n      \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (76 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 76 subgoals...", "next"], ["proof (state)\ngoal (76 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 76 subgoals...", "case (InitDone sh C sfs C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (76 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 76 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (75 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 75 subgoals...", "next"], ["proof (state)\ngoal (75 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 75 subgoals...", "case (InitProcessing sh C sfs C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (75 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 75 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (74 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 74 subgoals...", "next"], ["proof (state)\ngoal (74 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 74 subgoals...", "case (InitError sh C1 sfs Cs h l e' a a b C')"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>(sfs, Error)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (C1,THROW\n                                  NoClassDefFoundError) ; Cs \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, C')\\<rangle>\n  \\<lbrakk>not_init C\n            (RI (C1,THROW NoClassDefFoundError) ; Cs \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C'_ (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (74 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 74 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>(sfs, Error)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (C1,THROW\n                                  NoClassDefFoundError) ; Cs \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, C')\\<rangle>\n  \\<lbrakk>not_init C\n            (RI (C1,THROW NoClassDefFoundError) ; Cs \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C'_ (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>(sfs, Error)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (C1,THROW\n                                  NoClassDefFoundError) ; Cs \\<leftarrow> h,\n                  (l, e', sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, C')\\<rangle>\n  \\<lbrakk>not_init C\n            (RI (C1,THROW NoClassDefFoundError) ; Cs \\<leftarrow> h);\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C'_ (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. C' C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. C' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (73 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 73 subgoals...", "next"], ["proof (state)\ngoal (73 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 73 subgoals...", "case (InitObject sh C1 sfs sh' C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 = Object\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile> \\<langle>INIT C' (C1 # Cs,True) \\<leftarrow> h,\n                  (l, e', sh')\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (73 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 73 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 = Object\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile> \\<langle>INIT C' (C1 # Cs,True) \\<leftarrow> h,\n                  (l, e', sh')\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 = Object\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile> \\<langle>INIT C' (C1 # Cs,True) \\<leftarrow> h,\n                  (l, e', sh')\\<rangle> \\<Rightarrow>\n                 \\<langle>a__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (C1 # Cs,True) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (72 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 72 subgoals...", "next"], ["proof (state)\ngoal (72 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 72 subgoals...", "case (InitNonObject sh C1 sfs D a b sh' C' Cs h l e' a a b)"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 \\<noteq> Object\n  class P C1 = \\<lfloor>(D, a__, b__)\\<rfloor>\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile> \\<langle>INIT C' (D # C1 # Cs,False) \\<leftarrow> h,\n                  (l, e', sh')\\<rangle> \\<Rightarrow>\n                 \\<langle>aa__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (D # C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (72 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 72 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 \\<noteq> Object\n  class P C1 = \\<lfloor>(D, a__, b__)\\<rfloor>\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile> \\<langle>INIT C' (D # C1 # Cs,False) \\<leftarrow> h,\n                  (l, e', sh')\\<rangle> \\<Rightarrow>\n                 \\<langle>aa__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (D # C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  C1 \\<noteq> Object\n  class P C1 = \\<lfloor>(D, a__, b__)\\<rfloor>\n  sh' = sh(C1 \\<mapsto> (sfs, Processing))\n  P \\<turnstile> \\<langle>INIT C' (D # C1 # Cs,False) \\<leftarrow> h,\n                  (l, e', sh')\\<rangle> \\<Rightarrow>\n                 \\<langle>aa__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (D # C1 # Cs,False) \\<leftarrow> h);\n   \\<exists>sfs. sh' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (INIT C' (C1 # Cs,False) \\<leftarrow> h)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases \"C = C1\") auto"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (71 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 71 subgoals...", "next"], ["proof (state)\ngoal (71 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 71 subgoals...", "case (RInit e a a b v h' l' sh' C sfs i sh'' C' Cs e\\<^sub>1 a a b)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(a__, aa__, b__)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>ab__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C,e) ; Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (71 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 71 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e,(a__, aa__, b__)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>ab__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C,e) ; Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(a__, aa__, b__)\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C \\<mapsto> (sfs, Done))\n  C' = last (C # Cs)\n  P \\<turnstile> \\<langle>INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>ab__,(a, b, b_)\\<rangle>\n  \\<lbrakk>not_init C (INIT C' (Cs,True) \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C,e) ; Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. b__ C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (70 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 70 subgoals...", "next"], ["proof (state)\ngoal (70 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 70 subgoals...", "case (RInitInitFail e h l sh a h' l' sh' C1 sfs i sh'' D Cs e\\<^sub>1 h1 l1 sh1)"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (70 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 70 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "using eval_final"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  \\<lbrakk>not_init C e;\n   \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  sh' C1 = \\<lfloor>(sfs, i)\\<rfloor>\n  sh'' = sh'(C1 \\<mapsto> (sfs, Error))\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1,\n                  (h', l', sh'')\\<rangle> \\<Rightarrow>\n                 \\<langle>h1,(l1, sh1, b_)\\<rangle>\n  \\<lbrakk>not_init C (RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>1);\n   \\<exists>sfs. sh'' C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sfs'.\n                       b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n  not_init C (RI (C1,e) ; D # Cs \\<leftarrow> e\\<^sub>1)\n  \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                  \\<langle>?e',?s'\\<rangle> \\<Longrightarrow>\n  final ?e'\n\ngoal (1 subgoal):\n 1. \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>sfs'. b_ C = \\<lfloor>(sfs', Processing)\\<rfloor>\n\ngoal (69 subgoals):\n 1. \\<And>sh Ca sfs h a FDTs h' l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>; P \\<turnstile> Ca has_fields FDTs;\n        h' = h(a \\<mapsto> blank P Ca); not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 2. \\<And>sh Ca sfs h l.\n       \\<lbrakk>sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>; new_Addr h = None;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 3. \\<And>sh Ca h l v' h' l' sh' a FDTs h''.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = \\<lfloor>a\\<rfloor>;\n        P \\<turnstile> Ca has_fields FDTs; h'' = h'(a \\<mapsto> blank P Ca);\n        not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 4. \\<And>sh Ca h l v' h' l' sh'.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',(h', l', sh')\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        new_Addr h' = None; is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh' C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 5. \\<And>sh Ca h l a aa ab b.\n       \\<lbrakk>\\<nexists>sfs. sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT Ca ([Ca],False) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(aa, ab, b)\\<rangle>;\n        \\<lbrakk>not_init C (INIT Ca ([Ca],False) \\<leftarrow> unit);\n         \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        is_class P Ca; not_init C (new Ca);\n        \\<exists>sfs. sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            b C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 6. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        P \\<turnstile> D \\<preceq>\\<^sup>* Ca; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 7. \\<And>e a aa b ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>null,(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 8. \\<And>e a aa b ab h l sh D fs Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>addr ab,(h, l, sh)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             sh C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        h ab = \\<lfloor>(D, fs)\\<rfloor>;\n        (D, Ca) \\<notin> (subcls1 P)\\<^sup>*; not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            sh C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 9. \\<And>e a aa b e' ab ac ba Ca.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,(a, aa, b)\\<rangle> \\<Rightarrow>\n                               \\<langle>throw e',(ab, ac, ba)\\<rangle>;\n        \\<lbrakk>not_init C e;\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             ba C = \\<lfloor>(sfs', Processing)\\<rfloor>;\n        not_init C (Cast Ca e);\n        \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sfs'.\n                            ba C = \\<lfloor>(sfs', Processing)\\<rfloor>\n 10. \\<And>v a aa b.\n        \\<lbrakk>not_init C (Val v);\n         \\<exists>sfs. b C = \\<lfloor>(sfs, Processing)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> \\<exists>sfs'.\n                             b C = \\<lfloor>(sfs', Processing)\\<rfloor>\nA total of 69 subgoals...", "qed(auto)"], ["", "(************************************************)"], ["", "subsection\\<open>Init Elimination rules\\<close>"], ["", "lemma init_NilE:\nassumes init: \"P \\<turnstile> \\<langle>INIT C (Nil,b) \\<leftarrow> unit,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\nshows \"e' = unit \\<and> s' = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e' = unit \\<and> s' = s", "proof(rule eval_cases(19)[OF init]) \\<comment> \\<open> Init \\<close>"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>[] = [];\n     P \\<turnstile> \\<langle>unit,s\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = s\n 2. \\<And>sh Ca Cs h l.\n       \\<lbrakk>s = (h, l, sh); sh Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (h, l, sh(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = Ca # Cs; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s\n 3. \\<And>sh Ca sfs Cs h l.\n       \\<lbrakk>s = (h, l, sh); sh Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = Ca # Cs; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s\n 4. \\<And>sh Ca sfs Cs h l.\n       \\<lbrakk>s = (h, l, sh); sh Ca = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = Ca # Cs; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s\n 5. \\<And>sh C sfs Cs h l.\n       \\<lbrakk>s = (h, l, sh); sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (C,THROW\n NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = C # Cs; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s\n 6. \\<And>sh sfs Cs h l.\n       \\<lbrakk>s = (h, l, sh);\n        sh Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (h, l, sh(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = Object # Cs; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s\n 7. \\<And>sh Ca sfs D r Cs h l.\n       \\<lbrakk>s = (h, l, sh); sh Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        Ca \\<noteq> Object; class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (h, l, sh(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = Ca # Cs; \\<not> b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s\n 8. \\<And>C Cs h l sh.\n       \\<lbrakk>s = (h, l, sh);\n        P \\<turnstile> \\<langle>RI (C,C\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (h, l, sh)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [] = C # Cs; b\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = s", "qed(auto dest: eval_final_same)"], ["", "lemma init_ProcessingE:\nassumes shC: \"sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\"\n and init: \"P \\<turnstile> \\<langle>INIT C ([C],False) \\<leftarrow> unit,(h,l,sh)\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\nshows \"e' = unit \\<and> s' = (h,l,sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e' = unit \\<and> s' = (h, l, sh)", "proof(rule eval_cases(19)[OF init]) \\<comment> \\<open> Init \\<close>"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 8. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "fix sha Ca sfs Cs ha la"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 8. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "assume \"(h, l, sh) = (ha, la, sha)\" and \"sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>\"\n   and \"P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,(ha, la, sha)\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\" and \"[C] = Ca # Cs\""], ["proof (state)\nthis:\n  (h, l, sh) = (ha, la, sha)\n  sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                  (ha, la, sha)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  [C] = Ca # Cs\n\ngoal (8 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 8. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "then"], ["proof (chain)\npicking this:\n  (h, l, sh) = (ha, la, sha)\n  sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                  (ha, la, sha)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  [C] = Ca # Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  (h, l, sh) = (ha, la, sha)\n  sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                  (ha, la, sha)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  [C] = Ca # Cs\n\ngoal (1 subgoal):\n 1. e' = unit \\<and> s' = (h, l, sh)", "using init_NilE"], ["proof (prove)\nusing this:\n  (h, l, sh) = (ha, la, sha)\n  sha Ca = \\<lfloor>(sfs, Processing)\\<rfloor>\n  P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                  (ha, la, sha)\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  [C] = Ca # Cs\n  ?P \\<turnstile> \\<langle>INIT ?C ([],?b) \\<leftarrow> unit,\n                   ?s\\<rangle> \\<Rightarrow>\n                  \\<langle>?e',?s'\\<rangle> \\<Longrightarrow>\n  ?e' = unit \\<and> ?s' = ?s\n\ngoal (1 subgoal):\n 1. e' = unit \\<and> s' = (h, l, sh)", "by simp"], ["proof (state)\nthis:\n  e' = unit \\<and> s' = (h, l, sh)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "fix sha sfs Cs ha la"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "assume \"(h, l, sh) = (ha, la, sha)\" and \"sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>\"\n     and \"[C] = Object # Cs\""], ["proof (state)\nthis:\n  (h, l, sh) = (ha, la, sha)\n  sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  [C] = Object # Cs\n\ngoal (7 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Object # Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha(Object \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Object # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 7. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "then"], ["proof (chain)\npicking this:\n  (h, l, sh) = (ha, la, sha)\n  sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  [C] = Object # Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  (h, l, sh) = (ha, la, sha)\n  sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  [C] = Object # Cs\n\ngoal (1 subgoal):\n 1. e' = unit \\<and> s' = (h, l, sh)", "using shC"], ["proof (prove)\nusing this:\n  (h, l, sh) = (ha, la, sha)\n  sha Object = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  [C] = Object # Cs\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n\ngoal (1 subgoal):\n 1. e' = unit \\<and> s' = (h, l, sh)", "by clarsimp"], ["proof (state)\nthis:\n  e' = unit \\<and> s' = (h, l, sh)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>[C] = [];\n     P \\<turnstile> \\<langle>unit,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',s'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 2. \\<And>sha Ca Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha); sha Ca = None;\n        P \\<turnstile> \\<langle>INIT C (Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sblank P Ca, Prepared)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 3. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Done)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (Cs,True) \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 4. \\<And>sha Ca sfs Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Error)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (Ca,THROW\n  NoClassDefFoundError) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 5. \\<And>sha Ca sfs D r Cs ha la.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        sha Ca = \\<lfloor>(sfs, Prepared)\\<rfloor>; Ca \\<noteq> Object;\n        class P Ca = \\<lfloor>(D, r)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT C (D #\n  Ca # Cs,False) \\<leftarrow> unit,\n                        (ha, la, sha(Ca \\<mapsto>\n                         (sfs, Processing)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; \\<not> False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)\n 6. \\<And>Ca Cs ha la sha.\n       \\<lbrakk>(h, l, sh) = (ha, la, sha);\n        P \\<turnstile> \\<langle>RI (Ca,Ca\\<bullet>\\<^sub>sclinit([])) ; Cs \\<leftarrow> unit,\n                        (ha, la, sha)\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>;\n        [C] = Ca # Cs; False\\<rbrakk>\n       \\<Longrightarrow> e' = unit \\<and> s' = (h, l, sh)", "qed(auto simp: assms)"], ["", "lemma rinit_throwE:\n\"P \\<turnstile> \\<langle>RI (C,throw e) ; Cs \\<leftarrow> e\\<^sub>0,s\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\n   \\<Longrightarrow> \\<exists>a s\\<^sub>t. e' = throw a \\<and> P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,s\\<^sub>t\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<langle>RI (C,throw e) ; Cs \\<leftarrow> e\\<^sub>0,\n                    s\\<rangle> \\<Rightarrow>\n                   \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n    \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "proof(induct Cs arbitrary: C e s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C e s.\n       P \\<turnstile> \\<langle>RI (C,throw e) ; [] \\<leftarrow> e\\<^sub>0,\n                       s\\<rangle> \\<Rightarrow>\n                      \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n       \\<exists>a s\\<^sub>t.\n          e' = throw a \\<and>\n          P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                         \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a Cs C e s.\n       \\<lbrakk>\\<And>C e s.\n                   P \\<turnstile> \\<langle>RI (C,throw\n            e) ; Cs \\<leftarrow> e\\<^sub>0,\n                                   s\\<rangle> \\<Rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n                   \\<exists>a s\\<^sub>t.\n                      e' = throw a \\<and>\n                      P \\<turnstile> \\<langle>throw e,\ns\\<rangle> \\<Rightarrow>\n                                     \\<langle>throw a,s\\<^sub>t\\<rangle>;\n        P \\<turnstile> \\<langle>RI (C,throw\n e) ; a # Cs \\<leftarrow> e\\<^sub>0,\n                        s\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "case Nil"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>RI (C,throw e) ; [] \\<leftarrow> e\\<^sub>0,\n                  s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>C e s.\n       P \\<turnstile> \\<langle>RI (C,throw e) ; [] \\<leftarrow> e\\<^sub>0,\n                       s\\<rangle> \\<Rightarrow>\n                      \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n       \\<exists>a s\\<^sub>t.\n          e' = throw a \\<and>\n          P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                         \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a Cs C e s.\n       \\<lbrakk>\\<And>C e s.\n                   P \\<turnstile> \\<langle>RI (C,throw\n            e) ; Cs \\<leftarrow> e\\<^sub>0,\n                                   s\\<rangle> \\<Rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n                   \\<exists>a s\\<^sub>t.\n                      e' = throw a \\<and>\n                      P \\<turnstile> \\<langle>throw e,\ns\\<rangle> \\<Rightarrow>\n                                     \\<langle>throw a,s\\<^sub>t\\<rangle>;\n        P \\<turnstile> \\<langle>RI (C,throw\n e) ; a # Cs \\<leftarrow> e\\<^sub>0,\n                        s\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>RI (C,throw e) ; [] \\<leftarrow> e\\<^sub>0,\n                  s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>RI (C,throw e) ; [] \\<leftarrow> e\\<^sub>0,\n                  s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "proof(rule eval_cases(20)) \\<comment> \\<open> RI \\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if [] = [] then C\nelse last []) ([],True) \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>[] = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>[] = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "fix v h' l' sh'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if [] = [] then C\nelse last []) ([],True) \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>[] = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>[] = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "assume \"P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow> \\<langle>Val v,(h', l', sh')\\<rangle>\""], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if [] = [] then C\nelse last []) ([],True) \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>[] = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>[] = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "using eval_cases(17)"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>?P \\<turnstile> \\<langle>throw ?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   \\<And>a.\n      \\<lbrakk>?e' = Throw a;\n       ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                       \\<langle>addr a,?s'\\<rangle>\\<rbrakk>\n      \\<Longrightarrow> ?Pa;\n   \\<lbrakk>?e' = THROW NullPointer;\n    ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                    \\<langle>null,?s'\\<rangle>\\<rbrakk>\n   \\<Longrightarrow> ?Pa;\n   \\<And>e'.\n      \\<lbrakk>?e' = throw e';\n       ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',?s'\\<rangle>\\<rbrakk>\n      \\<Longrightarrow> ?Pa\\<rbrakk>\n  \\<Longrightarrow> ?Pa\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>[] = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>[] = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "qed(auto)"], ["proof (state)\nthis:\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C e s.\n       \\<lbrakk>\\<And>C e s.\n                   P \\<turnstile> \\<langle>RI (C,throw\n            e) ; Cs \\<leftarrow> e\\<^sub>0,\n                                   s\\<rangle> \\<Rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n                   \\<exists>a s\\<^sub>t.\n                      e' = throw a \\<and>\n                      P \\<turnstile> \\<langle>throw e,\ns\\<rangle> \\<Rightarrow>\n                                     \\<langle>throw a,s\\<^sub>t\\<rangle>;\n        P \\<turnstile> \\<langle>RI (C,throw\n e) ; a # Cs \\<leftarrow> e\\<^sub>0,\n                        s\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs C e s.\n       \\<lbrakk>\\<And>C e s.\n                   P \\<turnstile> \\<langle>RI (C,throw\n            e) ; Cs \\<leftarrow> e\\<^sub>0,\n                                   s\\<rangle> \\<Rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n                   \\<exists>a s\\<^sub>t.\n                      e' = throw a \\<and>\n                      P \\<turnstile> \\<langle>throw e,\ns\\<rangle> \\<Rightarrow>\n                                     \\<langle>throw a,s\\<^sub>t\\<rangle>;\n        P \\<turnstile> \\<langle>RI (C,throw\n e) ; a # Cs \\<leftarrow> e\\<^sub>0,\n                        s\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "case (Cons C' Cs')"], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>RI (?C,throw ?e) ; Cs' \\<leftarrow> e\\<^sub>0,\n                  ?s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw ?e,?s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n  P \\<turnstile> \\<langle>RI (C,throw e) ; C' # Cs' \\<leftarrow> e\\<^sub>0,\n                  s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C e s.\n       \\<lbrakk>\\<And>C e s.\n                   P \\<turnstile> \\<langle>RI (C,throw\n            e) ; Cs \\<leftarrow> e\\<^sub>0,\n                                   s\\<rangle> \\<Rightarrow>\n                                  \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n                   \\<exists>a s\\<^sub>t.\n                      e' = throw a \\<and>\n                      P \\<turnstile> \\<langle>throw e,\ns\\<rangle> \\<Rightarrow>\n                                     \\<langle>throw a,s\\<^sub>t\\<rangle>;\n        P \\<turnstile> \\<langle>RI (C,throw\n e) ; a # Cs \\<leftarrow> e\\<^sub>0,\n                        s\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>RI (C,throw e) ; C' # Cs' \\<leftarrow> e\\<^sub>0,\n                  s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "proof(rule eval_cases(20)) \\<comment> \\<open> RI \\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if C' # Cs' = [] then C\nelse last (C' # Cs')) (C' # Cs',True) \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "fix v h' l' sh'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if C' # Cs' = [] then C\nelse last (C' # Cs')) (C' # Cs',True) \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "assume \"P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow> \\<langle>Val v,(h', l', sh')\\<rangle>\""], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if C' # Cs' = [] then C\nelse last (C' # Cs')) (C' # Cs',True) \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "using eval_cases(17)"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v,(h', l', sh')\\<rangle>\n  \\<lbrakk>?P \\<turnstile> \\<langle>throw ?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   \\<And>a.\n      \\<lbrakk>?e' = Throw a;\n       ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                       \\<langle>addr a,?s'\\<rangle>\\<rbrakk>\n      \\<Longrightarrow> ?Pa;\n   \\<lbrakk>?e' = THROW NullPointer;\n    ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                    \\<langle>null,?s'\\<rangle>\\<rbrakk>\n   \\<Longrightarrow> ?Pa;\n   \\<And>e'.\n      \\<lbrakk>?e' = throw e';\n       ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw e',?s'\\<rangle>\\<rbrakk>\n      \\<Longrightarrow> ?Pa\\<rbrakk>\n  \\<Longrightarrow> ?Pa\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "fix a h' l' sh' sfs i D Cs''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "assume e''step: \"P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,(h', l', sh')\\<rangle>\"\n       and shC: \"sh' C = \\<lfloor>(sfs, i)\\<rfloor>\"\n       and riD: \"P \\<turnstile> \\<langle>RI (D,throw a) ; Cs'' \\<leftarrow> e\\<^sub>0,(h', l', sh'(C \\<mapsto> (sfs, Error)))\\<rangle> \\<Rightarrow> \\<langle>e',s'\\<rangle>\"\n       and \"C' # Cs' = D # Cs''\""], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs'' \\<leftarrow> e\\<^sub>0,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  C' # Cs' = D # Cs''\n\ngoal (2 subgoals):\n 1. \\<And>a h' l' sh' sfs i D Cs.\n       \\<lbrakk>C' # Cs' = D # Cs;\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Cs \\<leftarrow> e\\<^sub>0,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>e',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>\n 2. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs'' \\<leftarrow> e\\<^sub>0,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  C' # Cs' = D # Cs''", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs'' \\<leftarrow> e\\<^sub>0,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  C' # Cs' = D # Cs''\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "using Cons.hyps eval_final eval_final_same"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,(h', l', sh')\\<rangle>\n  sh' C = \\<lfloor>(sfs, i)\\<rfloor>\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs'' \\<leftarrow> e\\<^sub>0,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle>\n  C' # Cs' = D # Cs''\n  P \\<turnstile> \\<langle>RI (?C,throw ?e) ; Cs' \\<leftarrow> e\\<^sub>0,\n                  ?s\\<rangle> \\<Rightarrow>\n                 \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw ?e,?s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n  ?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                  \\<langle>?e',?s'\\<rangle> \\<Longrightarrow>\n  final ?e'\n  \\<lbrakk>?P \\<turnstile> \\<langle>?e,?s\\<rangle> \\<Rightarrow>\n                           \\<langle>?e',?s'\\<rangle>;\n   final ?e\\<rbrakk>\n  \\<Longrightarrow> ?e = ?e' \\<and> ?s = ?s'\n\ngoal (1 subgoal):\n 1. \\<exists>a s\\<^sub>t.\n       e' = throw a \\<and>\n       P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>throw a,s\\<^sub>t\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>C' # Cs' = []; e' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a s\\<^sub>t.\n                            e' = throw a \\<and>\n                            P \\<turnstile> \\<langle>throw e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>throw a,s\\<^sub>t\\<rangle>", "qed(simp)"], ["proof (state)\nthis:\n  \\<exists>a s\\<^sub>t.\n     e' = throw a \\<and>\n     P \\<turnstile> \\<langle>throw e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>throw a,s\\<^sub>t\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rinit_ValE:\nassumes ri: \"P \\<turnstile> \\<langle>RI (C,e) ; Cs \\<leftarrow> unit,s\\<rangle> \\<Rightarrow> \\<langle>Val v',s'\\<rangle>\"\nshows \"\\<exists>v'' s''. P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>Val v'',s''\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v'' s''.\n       P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>Val v'',s''\\<rangle>", "proof(rule eval_cases(20)[OF ri]) \\<comment> \\<open> RI \\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if Cs = [] then C\nelse last Cs) (Cs,True) \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Csa.\n       \\<lbrakk>Cs = D # Csa;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Csa \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>Cs = []; Val v' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>", "fix a h' l' sh' sfs i D Cs'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if Cs = [] then C\nelse last Cs) (Cs,True) \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Csa.\n       \\<lbrakk>Cs = D # Csa;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Csa \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>Cs = []; Val v' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>", "assume \"P \\<turnstile> \\<langle>RI (D,throw a) ; Cs' \\<leftarrow> unit,(h', l', sh'(C \\<mapsto> (sfs, Error)))\\<rangle> \\<Rightarrow> \\<langle>Val v',s'\\<rangle>\""], ["proof (state)\nthis:\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs' \\<leftarrow> unit,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',s'\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if Cs = [] then C\nelse last Cs) (Cs,True) \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 2. \\<And>a h' l' sh' sfs i D Csa.\n       \\<lbrakk>Cs = D # Csa;\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>RI (D,throw a) ; Csa \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Error)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 3. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>Cs = []; Val v' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs' \\<leftarrow> unit,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',s'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs' \\<leftarrow> unit,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>v'' s''.\n       P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>Val v'',s''\\<rangle>", "using rinit_throwE"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>RI (D,throw a) ; Cs' \\<leftarrow> unit,\n                  (h', l', sh'(C \\<mapsto>\n                   (sfs, Error)))\\<rangle> \\<Rightarrow>\n                 \\<langle>Val v',s'\\<rangle>\n  ?P \\<turnstile> \\<langle>RI (?C,throw ?e) ; ?Cs \\<leftarrow> ?e\\<^sub>0,\n                   ?s\\<rangle> \\<Rightarrow>\n                  \\<langle>?e',?s'\\<rangle> \\<Longrightarrow>\n  \\<exists>a s\\<^sub>t.\n     ?e' = throw a \\<and>\n     ?P \\<turnstile> \\<langle>throw ?e,?s\\<rangle> \\<Rightarrow>\n                     \\<langle>throw a,s\\<^sub>t\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>v'' s''.\n       P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                      \\<langle>Val v'',s''\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<exists>v'' s''.\n     P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                    \\<langle>Val v'',s''\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>v h' l' sh' sfs i.\n       \\<lbrakk>P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                               \\<langle>Val v,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>;\n        P \\<turnstile> \\<langle>INIT (if Cs = [] then C\nelse last Cs) (Cs,True) \\<leftarrow> unit,\n                        (h', l', sh'(C \\<mapsto>\n                         (sfs, Done)))\\<rangle> \\<Rightarrow>\n                       \\<langle>Val v',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>\n 2. \\<And>a h' l' sh' sfs i.\n       \\<lbrakk>Cs = []; Val v' = throw a;\n        s' = (h', l', sh'(C \\<mapsto> (sfs, Error)));\n        P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                       \\<langle>throw a,(h', l', sh')\\<rangle>;\n        sh' C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'' s''.\n                            P \\<turnstile> \\<langle>e,\n      s\\<rangle> \\<Rightarrow>\n     \\<langle>Val v'',s''\\<rangle>", "qed(auto)"], ["", "subsection \"Some specific evaluations\""], ["", "lemma lass_val_of_eval:\n \"\\<lbrakk> lass_val_of e = \\<lfloor>a\\<rfloor>; P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow> \\<langle>e',(h', l', sh')\\<rangle> \\<rbrakk>\n  \\<Longrightarrow> e' = unit \\<and> h' = h \\<and> l' = l(fst a\\<mapsto>snd a) \\<and> sh' = sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lass_val_of e = \\<lfloor>a\\<rfloor>;\n     P \\<turnstile> \\<langle>e,(h, l, sh)\\<rangle> \\<Rightarrow>\n                    \\<langle>e',(h', l', sh')\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> e' = unit \\<and>\n                      h' = h \\<and>\n                      l' = l(fst a \\<mapsto> snd a) \\<and> sh' = sh", "by(drule lass_val_of_spec, auto elim: eval.cases)"], ["", "lemma eval_throw_nonVal:\nassumes eval: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,s'\\<rangle>\"\nshows \"val_of e = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of e = None", "proof(cases \"val_of e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. val_of e = None \\<Longrightarrow> val_of e = None\n 2. \\<And>a.\n       val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow> val_of e = None", "case (Some v)"], ["proof (state)\nthis:\n  val_of e = \\<lfloor>v\\<rfloor>\n\ngoal (2 subgoals):\n 1. val_of e = None \\<Longrightarrow> val_of e = None\n 2. \\<And>a.\n       val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow> val_of e = None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of e = None", "using eval"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,s'\\<rangle>\n\ngoal (1 subgoal):\n 1. val_of e = None", "by(auto simp: val_of_spec[OF Some] intro: eval.cases)"], ["proof (state)\nthis:\n  val_of e = None\n\ngoal (1 subgoal):\n 1. val_of e = None \\<Longrightarrow> val_of e = None", "qed(simp)"], ["", "lemma eval_throw_nonLAss:\nassumes eval: \"P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow> \\<langle>throw a,s'\\<rangle>\"\nshows \"lass_val_of e = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lass_val_of e = None", "proof(cases \"lass_val_of e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lass_val_of e = None \\<Longrightarrow> lass_val_of e = None\n 2. \\<And>a.\n       lass_val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       lass_val_of e = None", "case (Some v)"], ["proof (state)\nthis:\n  lass_val_of e = \\<lfloor>v\\<rfloor>\n\ngoal (2 subgoals):\n 1. lass_val_of e = None \\<Longrightarrow> lass_val_of e = None\n 2. \\<And>a.\n       lass_val_of e = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       lass_val_of e = None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lass_val_of e = None", "using eval"], ["proof (prove)\nusing this:\n  P \\<turnstile> \\<langle>e,s\\<rangle> \\<Rightarrow>\n                 \\<langle>throw a,s'\\<rangle>\n\ngoal (1 subgoal):\n 1. lass_val_of e = None", "by(auto simp: lass_val_of_spec[OF Some] intro: eval.cases)"], ["proof (state)\nthis:\n  lass_val_of e = None\n\ngoal (1 subgoal):\n 1. lass_val_of e = None \\<Longrightarrow> lass_val_of e = None", "qed(simp)"], ["", "end"]]}