{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/BV/StartProg.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemmas wt_defs = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def", "lemma \\<Phi>_start: \"\\<And>C. C \\<noteq> Start \\<Longrightarrow> \\<Phi>_start \\<Phi> C = \\<Phi> C\"\n \"\\<Phi>_start \\<Phi> Start start_m = start_\\<phi>\\<^sub>m\" \"\\<Phi>_start \\<Phi> Start clinit = start_\\<phi>\\<^sub>m\"", "lemma check_types_\\<phi>\\<^sub>m: \"check_types (start_prog P C M) 1 0 (map OK start_\\<phi>\\<^sub>m)\"", "lemma preallocated_start_state: \"start_state P = \\<sigma> \\<Longrightarrow> preallocated (fst(snd \\<sigma>))\"", "lemma start_prog_Start_super: \"start_prog P C M \\<turnstile> Start \\<prec>\\<^sup>1 Object\"", "lemma start_prog_Start_fields:\n \"start_prog P C M \\<turnstile> Start has_fields FDTs \\<Longrightarrow> map_of FDTs (F, Start) = None\"", "lemma start_prog_Start_soconf:\n \"(start_prog P C M),h,Start \\<turnstile>\\<^sub>s Map.empty \\<surd>\"", "lemma start_prog_start_shconf:\n \"start_prog P C M,start_heap P \\<turnstile>\\<^sub>s start_sheap \\<surd>\"", "lemma start_wt_method:\nassumes \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and \"M \\<noteq> clinit\" and \"\\<not> is_class P Start\"\nshows \"wt_method (start_prog P C M) Start Static [] Void 1 0 [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m\"\n (is \"wt_method ?P ?C ?b ?Ts ?T\\<^sub>r ?mxs ?mxl\\<^sub>0 ?is ?xt ?\\<tau>s\")", "lemma start_clinit_wt_method:\nassumes \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and \"M \\<noteq> clinit\" and \"\\<not> is_class P Start\"\nshows \"wt_method (start_prog P C M) Start Static [] Void 1 0 [Push Unit,Return] [] start_\\<phi>\\<^sub>m\"\n (is \"wt_method ?P ?C ?b ?Ts ?T\\<^sub>r ?mxs ?mxl\\<^sub>0 ?is ?xt ?\\<tau>s\")", "lemma start_class_wf:\nassumes \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\"\n and \"M \\<noteq> clinit\" and \"\\<not> is_class P Start\"\n and \"\\<Phi> Start start_m = start_\\<phi>\\<^sub>m\" and \"\\<Phi> Start clinit = start_\\<phi>\\<^sub>m\"\n and \"is_class P Object\"\n and \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\n and \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees clinit, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\nshows \"wf_cdecl (\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n       (start_prog P C M) (start_class C M)\"", "lemma start_prog_wf_jvm_prog_phi:\nassumes wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n and nstart: \"\\<not> is_class P Start\"\n and meth: \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and nclinit: \"M \\<noteq> clinit\"\n and \\<Phi>: \"\\<And>C. C \\<noteq> Start \\<Longrightarrow> \\<Phi>' C = \\<Phi> C\"\n and \\<Phi>': \"\\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\" \"\\<Phi>' Start clinit = start_\\<phi>\\<^sub>m\"\n and Obj_start_m: \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\nshows \"wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (start_prog P C M)\"", "lemma start_prog_wf_jvm_prog:\nassumes wf: \"wf_jvm_prog P\"\n and nstart: \"\\<not> is_class P Start\"\n and meth: \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and nclinit: \"M \\<noteq> clinit\"\n and Obj_start_m: \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\nshows \"wf_jvm_prog (start_prog P C M)\"", "lemma start_prog_Start_sees_methods:\n \"P \\<turnstile> Object sees_methods Mm\n \\<Longrightarrow> start_prog P C M \\<turnstile>\n  Start sees_methods Mm ++ (map_option (\\<lambda>m. (m,Start)) \\<circ> map_of [start_method C M, start_clinit])\"", "lemma start_prog_Start_sees_start_method:\n \"P \\<turnstile> Object sees_methods Mm\n  \\<Longrightarrow> start_prog P C M \\<turnstile>\n         Start sees start_m, Static : []\\<rightarrow>Void = (1, 0, [Invokestatic C M 0,Return], []) in Start\"", "lemma wf_start_prog_Start_sees_start_method:\nassumes wf: \"wf_prog wf_md P\"\nshows \"start_prog P C M \\<turnstile>\n         Start sees start_m, Static : []\\<rightarrow>Void = (1, 0, [Invokestatic C M 0,Return], []) in Start\"", "lemma start_prog_start_m_instrs:\nassumes wf: \"wf_prog wf_md P\"\nshows \"(instrs_of (start_prog P C M) Start start_m) = [Invokestatic C M 0, Return]\""], "translations": [["", "lemmas wt_defs = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def"], ["", "declare wt_defs [simp] \\<comment> \\<open> removed from @{text simp} at the end of file \\<close>"], ["", "declare start_class_def [simp]"], ["", "subsection \"Types\""], ["", "abbreviation start_\\<phi>\\<^sub>m :: \"ty\\<^sub>m\" where\n\"start_\\<phi>\\<^sub>m \\<equiv> [Some([],[]),Some([Void],[])]\""], ["", "fun \\<Phi>_start :: \"ty\\<^sub>P \\<Rightarrow> ty\\<^sub>P\" where\n\"\\<Phi>_start \\<Phi> C M = (if C=Start \\<and> (M=start_m \\<or> M=clinit) then start_\\<phi>\\<^sub>m else \\<Phi> C M)\""], ["", "lemma \\<Phi>_start: \"\\<And>C. C \\<noteq> Start \\<Longrightarrow> \\<Phi>_start \\<Phi> C = \\<Phi> C\"\n \"\\<Phi>_start \\<Phi> Start start_m = start_\\<phi>\\<^sub>m\" \"\\<Phi>_start \\<Phi> Start clinit = start_\\<phi>\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        C \\<noteq> Start \\<Longrightarrow>\n        \\<Phi>_start \\<Phi> C = \\<Phi> C) &&&\n    \\<Phi>_start \\<Phi> Start start_m = start_\\<phi>\\<^sub>m &&&\n    \\<Phi>_start \\<Phi> Start clinit = start_\\<phi>\\<^sub>m", "by auto"], ["", "lemma check_types_\\<phi>\\<^sub>m: \"check_types (start_prog P C M) 1 0 (map OK start_\\<phi>\\<^sub>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_types (class_add P (start_class C M)) 1 0\n     (map OK start_\\<phi>\\<^sub>m)", "by (auto simp: check_types_def JVM_states_unfold)"], ["", "(***************************************************************************************)"], ["", "subsection \"Some simple properties\""], ["", "lemma preallocated_start_state: \"start_state P = \\<sigma> \\<Longrightarrow> preallocated (fst(snd \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_state P = \\<sigma> \\<Longrightarrow>\n    preallocated (fst (snd \\<sigma>))", "using preallocated_start[of P]"], ["proof (prove)\nusing this:\n  preallocated (start_heap P)\n\ngoal (1 subgoal):\n 1. start_state P = \\<sigma> \\<Longrightarrow>\n    preallocated (fst (snd \\<sigma>))", "by(auto simp: start_state_def split_beta)"], ["", "lemma start_prog_Start_super: \"start_prog P C M \\<turnstile> Start \\<prec>\\<^sup>1 Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P (start_class C M) \\<turnstile> Start \\<prec>\\<^sup>1 Object", "by(auto intro!: subcls1I simp: class_def fun_upd_apply)"], ["", "lemma start_prog_Start_fields:\n \"start_prog P C M \\<turnstile> Start has_fields FDTs \\<Longrightarrow> map_of FDTs (F, Start) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C M) \\<turnstile> Start has_fields FDTs \\<Longrightarrow>\n    map_of FDTs (F, Start) = None", "by(drule Fields.cases, auto simp: class_def fun_upd_apply Object_fields)"], ["", "lemma start_prog_Start_soconf:\n \"(start_prog P C M),h,Start \\<turnstile>\\<^sub>s Map.empty \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C M),h,Start \\<turnstile>\\<^sub>s Map.empty \\<surd>", "by(simp add: soconf_def has_field_def start_prog_Start_fields)"], ["", "lemma start_prog_start_shconf:\n \"start_prog P C M,start_heap P \\<turnstile>\\<^sub>s start_sheap \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),start_heap\n           P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                                   (Map.empty, Done)] \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),start_heap\n           P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                                   (Map.empty, Done)] \\<surd>", "using start_prog_Start_soconf"], ["proof (prove)\nusing this:\n  class_add ?P\n   (start_class ?C ?M),?h,Start \\<turnstile>\\<^sub>s Map.empty \\<surd>\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),start_heap\n           P \\<turnstile>\\<^sub>s [Start \\<mapsto>\n                                   (Map.empty, Done)] \\<surd>", "by (simp add: shconf_def fun_upd_apply)"], ["", "(*>*)\n\n(************************************)"], ["", "subsection \"Well-typed and well-formed\""], ["", "lemma start_wt_method:\nassumes \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and \"M \\<noteq> clinit\" and \"\\<not> is_class P Start\"\nshows \"wt_method (start_prog P C M) Start Static [] Void 1 0 [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m\"\n (is \"wt_method ?P ?C ?b ?Ts ?T\\<^sub>r ?mxs ?mxl\\<^sub>0 ?is ?xt ?\\<tau>s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "let ?cdec = \"(Object, [], [start_method C M, start_clinit])\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "obtain mxs mxl ins xt where m: \"m = (mxs,mxl,ins,xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mxs mxl ins xt.\n        m = (mxs, mxl, ins, xt) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (mxs, mxl, ins, xt)\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "have ca_sees: \"class_add P (Start, ?cdec) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (Start, Object, [],\n      [start_method C M,\n       start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D", "by(rule class_add_sees_method[OF assms(1,3)])"], ["proof (state)\nthis:\n  class_add P\n   (Start, Object, [],\n    [start_method C M,\n     start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "have \"\\<And>pc. pc < size ?is \\<Longrightarrow> ?P,?T\\<^sub>r,?mxs,size ?is,?xt \\<turnstile> ?is!pc,pc :: ?\\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Invokestatic C M 0,\n                      Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Invokestatic C M 0,\n                      Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "fix pc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Invokestatic C M 0,\n                      Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "assume pc: \"pc < size ?is\""], ["proof (state)\nthis:\n  pc < length [Invokestatic C M 0, Return]\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Invokestatic C M 0,\n                      Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "then"], ["proof (chain)\npicking this:\n  pc < length [Invokestatic C M 0, Return]", "show \"?P,?T\\<^sub>r,?mxs,size ?is,?xt \\<turnstile> ?is!pc,pc :: ?\\<tau>s\""], ["proof (prove)\nusing this:\n  pc < length [Invokestatic C M 0, Return]\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),Void,1,length\n                  [Invokestatic C M 0,\n                   Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n     pc,pc :: start_\\<phi>\\<^sub>m", "proof(cases \"pc = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length [Invokestatic C M 0, Return]; pc = 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m\n 2. \\<lbrakk>pc < length [Invokestatic C M 0, Return];\n     pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "case True"], ["proof (state)\nthis:\n  pc = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length [Invokestatic C M 0, Return]; pc = 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m\n 2. \\<lbrakk>pc < length [Invokestatic C M 0, Return];\n     pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "with assms m ca_sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  m = (mxs, mxl, ins, xt)\n  class_add P\n   (Start, Object, [],\n    [start_method C M,\n     start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  pc = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  m = (mxs, mxl, ins, xt)\n  class_add P\n   (Start, Object, [],\n    [start_method C M,\n     start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  pc = 0\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),Void,1,length\n                  [Invokestatic C M 0,\n                   Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n     pc,pc :: start_\\<phi>\\<^sub>m", "by(fastforce simp: wt_method_def wt_start_def relevant_entries_def\n                          is_relevant_entry_def xcpt_eff_def)"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Invokestatic C M 0,\n                 Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n   pc,pc :: start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length [Invokestatic C M 0, Return];\n     pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length [Invokestatic C M 0, Return];\n     pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "case False"], ["proof (state)\nthis:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length [Invokestatic C M 0, Return];\n     pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Invokestatic C M 0,\n                                     Return],[] \\<turnstile> [Invokestatic C\n                         M 0,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "with pc"], ["proof (chain)\npicking this:\n  pc < length [Invokestatic C M 0, Return]\n  pc \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  pc < length [Invokestatic C M 0, Return]\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),Void,1,length\n                  [Invokestatic C M 0,\n                   Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n     pc,pc :: start_\\<phi>\\<^sub>m", "by(simp add: wt_method_def wt_start_def relevant_entries_def\n                    is_relevant_entry_def xcpt_eff_def)"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Invokestatic C M 0,\n                 Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n   pc,pc :: start_\\<phi>\\<^sub>m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Invokestatic C M 0,\n                 Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n   pc,pc :: start_\\<phi>\\<^sub>m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?pc1 < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Invokestatic C M 0,\n                 Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n   ?pc1,?pc1 :: start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "with assms check_types_\\<phi>\\<^sub>m"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  check_types (class_add ?P (start_class ?C ?M)) 1 0\n   (map OK start_\\<phi>\\<^sub>m)\n  ?pc1 < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Invokestatic C M 0,\n                 Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n   ?pc1,?pc1 :: start_\\<phi>\\<^sub>m", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  check_types (class_add ?P (start_class ?C ?M)) 1 0\n   (map OK start_\\<phi>\\<^sub>m)\n  ?pc1 < length [Invokestatic C M 0, Return] \\<Longrightarrow>\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Invokestatic C M 0,\n                 Return],[] \\<turnstile> [Invokestatic C M 0, Return] !\n   ?pc1,?pc1 :: start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m", "by(simp add: wt_method_def wt_start_def)"], ["proof (state)\nthis:\n  wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n   [Invokestatic C M 0, Return] [] start_\\<phi>\\<^sub>m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_clinit_wt_method:\nassumes \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and \"M \\<noteq> clinit\" and \"\\<not> is_class P Start\"\nshows \"wt_method (start_prog P C M) Start Static [] Void 1 0 [Push Unit,Return] [] start_\\<phi>\\<^sub>m\"\n (is \"wt_method ?P ?C ?b ?Ts ?T\\<^sub>r ?mxs ?mxl\\<^sub>0 ?is ?xt ?\\<tau>s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "let ?cdec = \"(Object, [], [start_method C M, start_clinit])\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "obtain mxs mxl ins xt where m: \"m = (mxs,mxl,ins,xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mxs mxl ins xt.\n        m = (mxs, mxl, ins, xt) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (mxs, mxl, ins, xt)\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "have ca_sees: \"class_add P (Start, ?cdec) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (Start, Object, [],\n      [start_method C M,\n       start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D", "by(rule class_add_sees_method[OF assms(1,3)])"], ["proof (state)\nthis:\n  class_add P\n   (Start, Object, [],\n    [start_method C M,\n     start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "have \"\\<And>pc. pc < size ?is \\<Longrightarrow> ?P,?T\\<^sub>r,?mxs,size ?is,?xt \\<turnstile> ?is!pc,pc :: ?\\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Push Unit, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Push Unit,\n                      Return],[] \\<turnstile> [Push Unit, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Push Unit, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Push Unit,\n                      Return],[] \\<turnstile> [Push Unit, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "fix pc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Push Unit, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Push Unit,\n                      Return],[] \\<turnstile> [Push Unit, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "assume pc: \"pc < size ?is\""], ["proof (state)\nthis:\n  pc < length [Push Unit, Return]\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       pc < length [Push Unit, Return] \\<Longrightarrow>\n       class_add P\n        (start_class C\n          M),Void,1,length\n                     [Push Unit,\n                      Return],[] \\<turnstile> [Push Unit, Return] !\n        pc,pc :: start_\\<phi>\\<^sub>m", "then"], ["proof (chain)\npicking this:\n  pc < length [Push Unit, Return]", "show \"?P,?T\\<^sub>r,?mxs,size ?is,?xt \\<turnstile> ?is!pc,pc :: ?\\<tau>s\""], ["proof (prove)\nusing this:\n  pc < length [Push Unit, Return]\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),Void,1,length\n                  [Push Unit,\n                   Return],[] \\<turnstile> [Push Unit, Return] !\n     pc,pc :: start_\\<phi>\\<^sub>m", "proof(cases \"pc = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length [Push Unit, Return]; pc = 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m\n 2. \\<lbrakk>pc < length [Push Unit, Return]; pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "case True"], ["proof (state)\nthis:\n  pc = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length [Push Unit, Return]; pc = 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m\n 2. \\<lbrakk>pc < length [Push Unit, Return]; pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "with assms m ca_sees"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  m = (mxs, mxl, ins, xt)\n  class_add P\n   (Start, Object, [],\n    [start_method C M,\n     start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  pc = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  m = (mxs, mxl, ins, xt)\n  class_add P\n   (Start, Object, [],\n    [start_method C M,\n     start_clinit]) \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  pc = 0\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),Void,1,length\n                  [Push Unit,\n                   Return],[] \\<turnstile> [Push Unit, Return] !\n     pc,pc :: start_\\<phi>\\<^sub>m", "by(fastforce simp: wt_method_def wt_start_def relevant_entries_def\n                          is_relevant_entry_def xcpt_eff_def)"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Push Unit,\n                 Return],[] \\<turnstile> [Push Unit, Return] !\n   pc,pc :: start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length [Push Unit, Return]; pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length [Push Unit, Return]; pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "case False"], ["proof (state)\nthis:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length [Push Unit, Return]; pc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> class_add P\n                       (start_class C\n                         M),Void,1,length\n                                    [Push Unit,\n                                     Return],[] \\<turnstile> [Push Unit,\n                        Return] !\n                       pc,pc :: start_\\<phi>\\<^sub>m", "with pc"], ["proof (chain)\npicking this:\n  pc < length [Push Unit, Return]\n  pc \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  pc < length [Push Unit, Return]\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M),Void,1,length\n                  [Push Unit,\n                   Return],[] \\<turnstile> [Push Unit, Return] !\n     pc,pc :: start_\\<phi>\\<^sub>m", "by(simp add: wt_method_def wt_start_def relevant_entries_def\n                    is_relevant_entry_def xcpt_eff_def)"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Push Unit,\n                 Return],[] \\<turnstile> [Push Unit, Return] !\n   pc,pc :: start_\\<phi>\\<^sub>m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Push Unit,\n                 Return],[] \\<turnstile> [Push Unit, Return] !\n   pc,pc :: start_\\<phi>\\<^sub>m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?pc1 < length [Push Unit, Return] \\<Longrightarrow>\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Push Unit,\n                 Return],[] \\<turnstile> [Push Unit, Return] !\n   ?pc1,?pc1 :: start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "with assms check_types_\\<phi>\\<^sub>m"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  check_types (class_add ?P (start_class ?C ?M)) 1 0\n   (map OK start_\\<phi>\\<^sub>m)\n  ?pc1 < length [Push Unit, Return] \\<Longrightarrow>\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Push Unit,\n                 Return],[] \\<turnstile> [Push Unit, Return] !\n   ?pc1,?pc1 :: start_\\<phi>\\<^sub>m", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  check_types (class_add ?P (start_class ?C ?M)) 1 0\n   (map OK start_\\<phi>\\<^sub>m)\n  ?pc1 < length [Push Unit, Return] \\<Longrightarrow>\n  class_add P\n   (start_class C\n     M),Void,1,length\n                [Push Unit,\n                 Return],[] \\<turnstile> [Push Unit, Return] !\n   ?pc1,?pc1 :: start_\\<phi>\\<^sub>m\n\ngoal (1 subgoal):\n 1. wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n     [Push Unit, Return] [] start_\\<phi>\\<^sub>m", "by(simp add: wt_method_def wt_start_def)"], ["proof (state)\nthis:\n  wt_method (class_add P (start_class C M)) Start Static [] Void 1 0\n   [Push Unit, Return] [] start_\\<phi>\\<^sub>m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_class_wf:\nassumes \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\"\n and \"M \\<noteq> clinit\" and \"\\<not> is_class P Start\"\n and \"\\<Phi> Start start_m = start_\\<phi>\\<^sub>m\" and \"\\<Phi> Start clinit = start_\\<phi>\\<^sub>m\"\n and \"is_class P Object\"\n and \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\n and \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees clinit, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\nshows \"wf_cdecl (\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n       (start_prog P C M) (start_class C M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n     (class_add P (start_class C M)) (start_class C M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n     (class_add P (start_class C M)) (start_class C M)", "from assms start_wt_method start_clinit_wt_method class_add_sees_method_rev_Obj[where P=P and C=Start]"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  \\<Phi> Start start_m = start_\\<phi>\\<^sub>m\n  \\<Phi> Start clinit = start_\\<phi>\\<^sub>m\n  is_class P Object\n  P \\<turnstile> Object sees start_m, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D' \\<Longrightarrow>\n  ?b' = Static \\<and> ?Ts' = [] \\<and> ?T' = Void\n  P \\<turnstile> Object sees clinit, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D' \\<Longrightarrow>\n  ?b' = Static \\<and> ?Ts' = [] \\<and> ?T' = Void\n  \\<lbrakk>?P \\<turnstile> ?C sees ?M, Static :  []\\<rightarrow>Void = ?m in ?D;\n   ?M \\<noteq> clinit; \\<not> is_class ?P Start\\<rbrakk>\n  \\<Longrightarrow> wt_method (class_add ?P (start_class ?C ?M)) Start\n                     Static [] Void 1 0 [Invokestatic ?C ?M 0, Return] []\n                     start_\\<phi>\\<^sub>m\n  \\<lbrakk>?P \\<turnstile> ?C sees ?M, Static :  []\\<rightarrow>Void = ?m in ?D;\n   ?M \\<noteq> clinit; \\<not> is_class ?P Start\\<rbrakk>\n  \\<Longrightarrow> wt_method (class_add ?P (start_class ?C ?M)) Start\n                     Static [] Void 1 0 [Push Unit, Return] []\n                     start_\\<phi>\\<^sub>m\n  \\<lbrakk>class_add P\n            (Start,\n             ?cdec) \\<turnstile> Object sees ?M\\<^sub>0, ?b :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   Start \\<noteq> Object\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees ?M\\<^sub>0, ?b :  ?Ts\\<rightarrow>?T = ?m in ?D", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  \\<Phi> Start start_m = start_\\<phi>\\<^sub>m\n  \\<Phi> Start clinit = start_\\<phi>\\<^sub>m\n  is_class P Object\n  P \\<turnstile> Object sees start_m, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D' \\<Longrightarrow>\n  ?b' = Static \\<and> ?Ts' = [] \\<and> ?T' = Void\n  P \\<turnstile> Object sees clinit, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D' \\<Longrightarrow>\n  ?b' = Static \\<and> ?Ts' = [] \\<and> ?T' = Void\n  \\<lbrakk>?P \\<turnstile> ?C sees ?M, Static :  []\\<rightarrow>Void = ?m in ?D;\n   ?M \\<noteq> clinit; \\<not> is_class ?P Start\\<rbrakk>\n  \\<Longrightarrow> wt_method (class_add ?P (start_class ?C ?M)) Start\n                     Static [] Void 1 0 [Invokestatic ?C ?M 0, Return] []\n                     start_\\<phi>\\<^sub>m\n  \\<lbrakk>?P \\<turnstile> ?C sees ?M, Static :  []\\<rightarrow>Void = ?m in ?D;\n   ?M \\<noteq> clinit; \\<not> is_class ?P Start\\<rbrakk>\n  \\<Longrightarrow> wt_method (class_add ?P (start_class ?C ?M)) Start\n                     Static [] Void 1 0 [Push Unit, Return] []\n                     start_\\<phi>\\<^sub>m\n  \\<lbrakk>class_add P\n            (Start,\n             ?cdec) \\<turnstile> Object sees ?M\\<^sub>0, ?b :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   Start \\<noteq> Object\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees ?M\\<^sub>0, ?b :  ?Ts\\<rightarrow>?T = ?m in ?D\n\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n     (class_add P (start_class C M)) (start_class C M)", "by(auto simp: start_method_def wf_cdecl_def wf_fdecl_def wf_mdecl_def\n                  is_class_def class_def fun_upd_apply wf_clinit_def) fast+"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   (class_add P (start_class C M)) (start_class C M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_prog_wf_jvm_prog_phi:\nassumes wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n and nstart: \"\\<not> is_class P Start\"\n and meth: \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and nclinit: \"M \\<noteq> clinit\"\n and \\<Phi>: \"\\<And>C. C \\<noteq> Start \\<Longrightarrow> \\<Phi>' C = \\<Phi> C\"\n and \\<Phi>': \"\\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\" \"\\<Phi>' Start clinit = start_\\<phi>\\<^sub>m\"\n and Obj_start_m: \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\nshows \"wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (start_prog P C M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "let ?wf_md = \"(\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "let ?wf_md' = \"(\\<lambda>P C (M,b,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)). wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from wtp"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "have wf: \"wf_prog ?wf_md P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n     P", "by(simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from wf_subcls_nCls'[OF wf nstart]"], ["proof (chain)\npicking this:\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, Start) \\<notin> (subcls1 P)\\<^sup>*", "have nsp: \"\\<And>cd D'. cd \\<in> set P \\<Longrightarrow> \\<not>P \\<turnstile> fst cd \\<preceq>\\<^sup>* Start\""], ["proof (prove)\nusing this:\n  ?cd \\<in> set P \\<Longrightarrow>\n  (fst ?cd, Start) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>cd D'.\n       cd \\<in> set P \\<Longrightarrow>\n       (fst cd, Start) \\<notin> (subcls1 P)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  ?cd2 \\<in> set P \\<Longrightarrow>\n  (fst ?cd2, Start) \\<notin> (subcls1 P)\\<^sup>*\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "have wf_md':\n    \"\\<And>C\\<^sub>0 S fs ms m. (C\\<^sub>0, S, fs, ms) \\<in> set P \\<Longrightarrow> m \\<in> set ms \\<Longrightarrow> ?wf_md' (start_prog P C M) C\\<^sub>0 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 S fs ms m.\n       \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> case m of\n                         (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method (class_add P (start_class C M))\n                            C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (\\<Phi>' C\\<^sub>0 Ma)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 S fs ms m.\n       \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> case m of\n                         (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method (class_add P (start_class C M))\n                            C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (\\<Phi>' C\\<^sub>0 Ma)", "fix C\\<^sub>0 S fs ms m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 S fs ms m.\n       \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> case m of\n                         (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method (class_add P (start_class C M))\n                            C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (\\<Phi>' C\\<^sub>0 Ma)", "assume asms: \"(C\\<^sub>0, S, fs, ms) \\<in> set P\" \"m \\<in> set ms\""], ["proof (state)\nthis:\n  (C\\<^sub>0, S, fs, ms) \\<in> set P\n  m \\<in> set ms\n\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 S fs ms m.\n       \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> case m of\n                         (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method (class_add P (start_class C M))\n                            C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (\\<Phi>' C\\<^sub>0 Ma)", "with nstart"], ["proof (chain)\npicking this:\n  \\<not> is_class P Start\n  (C\\<^sub>0, S, fs, ms) \\<in> set P\n  m \\<in> set ms", "have ns: \"C\\<^sub>0 \\<noteq> Start\""], ["proof (prove)\nusing this:\n  \\<not> is_class P Start\n  (C\\<^sub>0, S, fs, ms) \\<in> set P\n  m \\<in> set ms\n\ngoal (1 subgoal):\n 1. C\\<^sub>0 \\<noteq> Start", "by(auto simp: is_class_def class_def dest: weak_map_of_SomeI)"], ["proof (state)\nthis:\n  C\\<^sub>0 \\<noteq> Start\n\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 S fs ms m.\n       \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> case m of\n                         (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method (class_add P (start_class C M))\n                            C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (\\<Phi>' C\\<^sub>0 Ma)", "from wf asms"], ["proof (chain)\npicking this:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P\n  (C\\<^sub>0, S, fs, ms) \\<in> set P\n  m \\<in> set ms", "have \"?wf_md P C\\<^sub>0 m\""], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P\n  (C\\<^sub>0, S, fs, ms) \\<in> set P\n  m \\<in> set ms\n\ngoal (1 subgoal):\n 1. case m of\n    (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n      wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n       (\\<Phi> C\\<^sub>0 M)", "by(auto simp: wf_prog_def wf_cdecl_def wf_mdecl_def)"], ["proof (state)\nthis:\n  case m of\n  (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n    wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n     (\\<Phi> C\\<^sub>0 M)\n\ngoal (1 subgoal):\n 1. \\<And>C\\<^sub>0 S fs ms m.\n       \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> case m of\n                         (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method (class_add P (start_class C M))\n                            C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (\\<Phi>' C\\<^sub>0 Ma)", "with \\<Phi>[OF ns] class_add_wt_method[OF _ wf nstart]"], ["proof (chain)\npicking this:\n  \\<Phi>' C\\<^sub>0 = \\<Phi> C\\<^sub>0\n  wt_method P ?C\\<^sub>0 ?b ?Ts ?T\\<^sub>r ?mxs ?mxl\\<^sub>0 ?is ?xt\n   (?\\<Phi> ?C\\<^sub>0 ?M\\<^sub>0) \\<Longrightarrow>\n  wt_method (class_add P (Start, ?cdec)) ?C\\<^sub>0 ?b ?Ts ?T\\<^sub>r ?mxs\n   ?mxl\\<^sub>0 ?is ?xt (?\\<Phi> ?C\\<^sub>0 ?M\\<^sub>0)\n  case m of\n  (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n    wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n     (\\<Phi> C\\<^sub>0 M)", "show \"?wf_md' (start_prog P C M) C\\<^sub>0 m\""], ["proof (prove)\nusing this:\n  \\<Phi>' C\\<^sub>0 = \\<Phi> C\\<^sub>0\n  wt_method P ?C\\<^sub>0 ?b ?Ts ?T\\<^sub>r ?mxs ?mxl\\<^sub>0 ?is ?xt\n   (?\\<Phi> ?C\\<^sub>0 ?M\\<^sub>0) \\<Longrightarrow>\n  wt_method (class_add P (Start, ?cdec)) ?C\\<^sub>0 ?b ?Ts ?T\\<^sub>r ?mxs\n   ?mxl\\<^sub>0 ?is ?xt (?\\<Phi> ?C\\<^sub>0 ?M\\<^sub>0)\n  case m of\n  (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n    wt_method P C\\<^sub>0 b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n     (\\<Phi> C\\<^sub>0 M)\n\ngoal (1 subgoal):\n 1. case m of\n    (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n      wt_method (class_add P (start_class C M)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n       mxl\\<^sub>0 is xt (\\<Phi>' C\\<^sub>0 Ma)", "by fastforce"], ["proof (state)\nthis:\n  case m of\n  (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n    wt_method (class_add P (start_class C M)) C\\<^sub>0 b Ts T\\<^sub>r mxs\n     mxl\\<^sub>0 is xt (\\<Phi>' C\\<^sub>0 Ma)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?C\\<^sub>03, ?S3, ?fs3, ?ms3) \\<in> set P;\n   ?m3 \\<in> set ?ms3\\<rbrakk>\n  \\<Longrightarrow> case ?m3 of\n                    (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                     xt) \\<Rightarrow>\n                      wt_method (class_add P (start_class C M)) ?C\\<^sub>03\n                       b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                       (\\<Phi>' ?C\\<^sub>03 Ma)\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from wtp"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "have a1: \"is_class P Object\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. is_class P Object", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  is_class P Object\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "with wf_sees_clinit[where P=P and C=Object] wtp"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_prog ?wf_md P; class P Object = \\<lfloor>?a\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       P \\<turnstile> Object sees clinit, Static :  []\\<rightarrow>Void = m in Object\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  is_class P Object", "have a2: \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees clinit, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_prog ?wf_md P; class P Object = \\<lfloor>?a\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       P \\<turnstile> Object sees clinit, Static :  []\\<rightarrow>Void = m in Object\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  is_class P Object\n\ngoal (1 subgoal):\n 1. \\<And>b' Ts' T' m' D'.\n       P \\<turnstile> Object sees clinit, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n       b' = Static \\<and> Ts' = [] \\<and> T' = Void", "by(fastforce simp: wf_jvm_prog_phi_def is_class_def dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> Object sees clinit, ?b'3 :  ?Ts'3\\<rightarrow>?T'3 = ?m'3 in ?D'3 \\<Longrightarrow>\n  ?b'3 = Static \\<and> ?Ts'3 = [] \\<and> ?T'3 = Void\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from wf"], ["proof (chain)\npicking this:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P", "have dist: \"distinct_fst P\""], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P\n\ngoal (1 subgoal):\n 1. distinct_fst P", "by (simp add: wf_prog_def)"], ["proof (state)\nthis:\n  distinct_fst P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "with class_add_distinct_fst[OF _ nstart]"], ["proof (chain)\npicking this:\n  distinct_fst P \\<Longrightarrow> distinct_fst (class_add P (Start, ?cdec))\n  distinct_fst P", "have \"distinct_fst (start_prog P C M)\""], ["proof (prove)\nusing this:\n  distinct_fst P \\<Longrightarrow> distinct_fst (class_add P (Start, ?cdec))\n  distinct_fst P\n\ngoal (1 subgoal):\n 1. distinct_fst (class_add P (start_class C M))", "by simp"], ["proof (state)\nthis:\n  distinct_fst (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "moreover"], ["proof (state)\nthis:\n  distinct_fst (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from wf"], ["proof (chain)\npicking this:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P", "have \"wf_syscls (start_prog P C M)\""], ["proof (prove)\nusing this:\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P\n\ngoal (1 subgoal):\n 1. wf_syscls (class_add P (start_class C M))", "by(simp add: wf_prog_def wf_syscls_def)"], ["proof (state)\nthis:\n  wf_syscls (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "moreover"], ["proof (state)\nthis:\n  wf_syscls (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from class_add_wf_cdecl'[where wf_md'=\"?wf_md'\", OF _ _ nsp dist] wf_md' nstart wf"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_cdecl ?wf_md P ?cd; ?cd \\<in> set P; ?cd \\<in> set P;\n   \\<And>C\\<^sub>0 S fs ms m.\n      \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n      \\<Longrightarrow> case m of\n                        (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                         xt) \\<Rightarrow>\n                          wt_method (class_add P (Start, ?cdec)) C\\<^sub>0 b\n                           Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                           (\\<Phi>' C\\<^sub>0 M);\n   \\<not> is_class P Start\\<rbrakk>\n  \\<Longrightarrow> wf_cdecl\n                     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0,\n                         is, xt).\n                         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                          (\\<Phi>' C M))\n                     (class_add P (Start, ?cdec)) ?cd\n  \\<lbrakk>(?C\\<^sub>03, ?S3, ?fs3, ?ms3) \\<in> set P;\n   ?m3 \\<in> set ?ms3\\<rbrakk>\n  \\<Longrightarrow> case ?m3 of\n                    (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                     xt) \\<Rightarrow>\n                      wt_method (class_add P (start_class C M)) ?C\\<^sub>03\n                       b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                       (\\<Phi>' ?C\\<^sub>03 Ma)\n  \\<not> is_class P Start\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P", "have \"\\<And>c. c \\<in> set P \\<Longrightarrow> wf_cdecl ?wf_md' (start_prog P C M) c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_cdecl ?wf_md P ?cd; ?cd \\<in> set P; ?cd \\<in> set P;\n   \\<And>C\\<^sub>0 S fs ms m.\n      \\<lbrakk>(C\\<^sub>0, S, fs, ms) \\<in> set P; m \\<in> set ms\\<rbrakk>\n      \\<Longrightarrow> case m of\n                        (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                         xt) \\<Rightarrow>\n                          wt_method (class_add P (Start, ?cdec)) C\\<^sub>0 b\n                           Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                           (\\<Phi>' C\\<^sub>0 M);\n   \\<not> is_class P Start\\<rbrakk>\n  \\<Longrightarrow> wf_cdecl\n                     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0,\n                         is, xt).\n                         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                          (\\<Phi>' C M))\n                     (class_add P (Start, ?cdec)) ?cd\n  \\<lbrakk>(?C\\<^sub>03, ?S3, ?fs3, ?ms3) \\<in> set P;\n   ?m3 \\<in> set ?ms3\\<rbrakk>\n  \\<Longrightarrow> case ?m3 of\n                    (Ma, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                     xt) \\<Rightarrow>\n                      wt_method (class_add P (start_class C M)) ?C\\<^sub>03\n                       b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                       (\\<Phi>' ?C\\<^sub>03 Ma)\n  \\<not> is_class P Start\n  wf_prog\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n   P\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set P \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n             (\\<Phi>' C M))\n        (class_add P (start_class C M)) c", "by(fastforce simp: wf_prog_def)"], ["proof (state)\nthis:\n  ?c3 \\<in> set P \\<Longrightarrow>\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) ?c3\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "moreover"], ["proof (state)\nthis:\n  ?c3 \\<in> set P \\<Longrightarrow>\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) ?c3\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "from start_class_wf[OF meth] nclinit nstart \\<Phi>' a1 Obj_start_m a2"], ["proof (chain)\npicking this:\n  \\<lbrakk>M \\<noteq> clinit; \\<not> is_class P Start;\n   ?\\<Phi> Start start_m = start_\\<phi>\\<^sub>m;\n   ?\\<Phi> Start clinit = start_\\<phi>\\<^sub>m; is_class P Object;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      b' = Static \\<and> Ts' = [] \\<and> T' = Void;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees clinit, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      b' = Static \\<and> Ts' = [] \\<and> T' = Void\\<rbrakk>\n  \\<Longrightarrow> wf_cdecl\n                     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0,\n                         is, xt).\n                         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                          (?\\<Phi> C M))\n                     (class_add P (start_class C M)) (start_class C M)\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\n  \\<Phi>' Start clinit = start_\\<phi>\\<^sub>m\n  is_class P Object\n  P \\<turnstile> Object sees start_m, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D' \\<Longrightarrow>\n  ?b' = Static \\<and> ?Ts' = [] \\<and> ?T' = Void\n  P \\<turnstile> Object sees clinit, ?b'3 :  ?Ts'3\\<rightarrow>?T'3 = ?m'3 in ?D'3 \\<Longrightarrow>\n  ?b'3 = Static \\<and> ?Ts'3 = [] \\<and> ?T'3 = Void", "have \"wf_cdecl ?wf_md' (start_prog P C M) (start_class C M)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<noteq> clinit; \\<not> is_class P Start;\n   ?\\<Phi> Start start_m = start_\\<phi>\\<^sub>m;\n   ?\\<Phi> Start clinit = start_\\<phi>\\<^sub>m; is_class P Object;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      b' = Static \\<and> Ts' = [] \\<and> T' = Void;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees clinit, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      b' = Static \\<and> Ts' = [] \\<and> T' = Void\\<rbrakk>\n  \\<Longrightarrow> wf_cdecl\n                     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0,\n                         is, xt).\n                         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                          (?\\<Phi> C M))\n                     (class_add P (start_class C M)) (start_class C M)\n  M \\<noteq> clinit\n  \\<not> is_class P Start\n  \\<Phi>' Start start_m = start_\\<phi>\\<^sub>m\n  \\<Phi>' Start clinit = start_\\<phi>\\<^sub>m\n  is_class P Object\n  P \\<turnstile> Object sees start_m, ?b' :  ?Ts'\\<rightarrow>?T' = ?m' in ?D' \\<Longrightarrow>\n  ?b' = Static \\<and> ?Ts' = [] \\<and> ?T' = Void\n  P \\<turnstile> Object sees clinit, ?b'3 :  ?Ts'3\\<rightarrow>?T'3 = ?m'3 in ?D'3 \\<Longrightarrow>\n  ?b'3 = Static \\<and> ?Ts'3 = [] \\<and> ?T'3 = Void\n\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n     (class_add P (start_class C M)) (start_class C M)", "by simp"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) (start_class C M)\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "ultimately"], ["proof (chain)\npicking this:\n  distinct_fst (class_add P (start_class C M))\n  wf_syscls (class_add P (start_class C M))\n  ?c3 \\<in> set P \\<Longrightarrow>\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) ?c3\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) (start_class C M)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct_fst (class_add P (start_class C M))\n  wf_syscls (class_add P (start_class C M))\n  ?c3 \\<in> set P \\<Longrightarrow>\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) ?c3\n  wf_cdecl\n   (\\<lambda>P C (M, b, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C b Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi>' C M))\n   (class_add P (start_class C M)) (start_class C M)\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))", "by(simp add: wf_jvm_prog_phi_def wf_prog_def)"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>'\\<^esub> (class_add P (start_class C M))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_prog_wf_jvm_prog:\nassumes wf: \"wf_jvm_prog P\"\n and nstart: \"\\<not> is_class P Start\"\n and meth: \"P \\<turnstile> C sees M, Static :  []\\<rightarrow>Void = m in D\" and nclinit: \"M \\<noteq> clinit\"\n and Obj_start_m: \"\\<And>b' Ts' T' m' D'. P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D'\n         \\<Longrightarrow> b' = Static \\<and> Ts' = [] \\<and> T' = Void\"\nshows \"wf_jvm_prog (start_prog P C M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog (class_add P (start_class C M))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_jvm_prog (class_add P (start_class C M))", "from wf"], ["proof (chain)\npicking this:\n  wf_jvm_prog P", "obtain \\<Phi> where wtp: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog P\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp: wf_jvm_prog_def)"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog (class_add P (start_class C M))", "let ?\\<Phi>' = \"\\<lambda>C f. if C = Start \\<and> (f = start_m \\<or> f = clinit) then start_\\<phi>\\<^sub>m else \\<Phi> C f\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_jvm_prog (class_add P (start_class C M))", "from start_prog_wf_jvm_prog_phi[OF wtp nstart meth nclinit _ _ _ Obj_start_m]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>C.\n              C \\<noteq> Start \\<Longrightarrow> ?\\<Phi>' C = \\<Phi> C;\n   ?\\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n   ?\\<Phi>' Start clinit = start_\\<phi>\\<^sub>m;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = ?m'1 b'\n                                Ts' T' m'\n                                D' in ?D'1 b' Ts' T' m' D'\\<rbrakk>\n  \\<Longrightarrow> wf_jvm_prog\\<^bsub>?\\<Phi>'\\<^esub>\n                     (class_add P (start_class C M))", "have\n    \"wf_jvm_prog\\<^bsub>?\\<Phi>'\\<^esub> (start_prog P C M)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>C.\n              C \\<noteq> Start \\<Longrightarrow> ?\\<Phi>' C = \\<Phi> C;\n   ?\\<Phi>' Start start_m = start_\\<phi>\\<^sub>m;\n   ?\\<Phi>' Start clinit = start_\\<phi>\\<^sub>m;\n   \\<And>b' Ts' T' m' D'.\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = m' in D' \\<Longrightarrow>\n      P \\<turnstile> Object sees start_m, b' :  Ts'\\<rightarrow>T' = ?m'1 b'\n                                Ts' T' m'\n                                D' in ?D'1 b' Ts' T' m' D'\\<rbrakk>\n  \\<Longrightarrow> wf_jvm_prog\\<^bsub>?\\<Phi>'\\<^esub>\n                     (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<lambda>C f.\n                          if C = Start \\<and> (f = start_m \\<or> f = clinit)\n                          then start_\\<phi>\\<^sub>m else \\<Phi> C f\\<^esub>\n     (class_add P (start_class C M))", "by simp"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<lambda>C f.\n                        if C = Start \\<and> (f = start_m \\<or> f = clinit)\n                        then start_\\<phi>\\<^sub>m else \\<Phi> C f\\<^esub>\n   (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog (class_add P (start_class C M))", "then"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<lambda>C f.\n                        if C = Start \\<and> (f = start_m \\<or> f = clinit)\n                        then start_\\<phi>\\<^sub>m else \\<Phi> C f\\<^esub>\n   (class_add P (start_class C M))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<lambda>C f.\n                        if C = Start \\<and> (f = start_m \\<or> f = clinit)\n                        then start_\\<phi>\\<^sub>m else \\<Phi> C f\\<^esub>\n   (class_add P (start_class C M))\n\ngoal (1 subgoal):\n 1. wf_jvm_prog (class_add P (start_class C M))", "by(auto simp: wf_jvm_prog_def)"], ["proof (state)\nthis:\n  wf_jvm_prog (class_add P (start_class C M))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*****************************************************************************)"], ["", "subsection \"Methods and instructions\""], ["", "lemma start_prog_Start_sees_methods:\n \"P \\<turnstile> Object sees_methods Mm\n \\<Longrightarrow> start_prog P C M \\<turnstile>\n  Start sees_methods Mm ++ (map_option (\\<lambda>m. (m,Start)) \\<circ> map_of [start_method C M, start_clinit])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm \\<Longrightarrow>\n    class_add P\n     (start_class C\n       M) \\<turnstile> Start sees_methods Mm ++\n    (map_option (\\<lambda>m. (m, Start)) \\<circ>\n     map_of [start_method C M, start_clinit])", "by (auto simp: class_def fun_upd_apply\n          dest!: class_add_sees_methods_Obj[where P=P and C=Start] intro: sees_methods_rec)"], ["", "lemma start_prog_Start_sees_start_method:\n \"P \\<turnstile> Object sees_methods Mm\n  \\<Longrightarrow> start_prog P C M \\<turnstile>\n         Start sees start_m, Static : []\\<rightarrow>Void = (1, 0, [Invokestatic C M 0,Return], []) in Start\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object sees_methods Mm \\<Longrightarrow>\n    class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "by(auto simp: start_method_def Method_def fun_upd_apply\n         dest!: start_prog_Start_sees_methods)"], ["", "lemma wf_start_prog_Start_sees_start_method:\nassumes wf: \"wf_prog wf_md P\"\nshows \"start_prog P C M \\<turnstile>\n         Start sees start_m, Static : []\\<rightarrow>Void = (1, 0, [Invokestatic C M 0,Return], []) in Start\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "from wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P", "have \"is_class P Object\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. is_class P Object", "by simp"], ["proof (state)\nthis:\n  is_class P Object\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "with sees_methods_Object"], ["proof (chain)\npicking this:\n  \\<lbrakk>class ?P Object = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor>;\n   ?Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ?ms\\<rbrakk>\n  \\<Longrightarrow> ?P \\<turnstile> Object sees_methods ?Mm\n  is_class P Object", "obtain Mm where \"P \\<turnstile> Object sees_methods Mm\""], ["proof (prove)\nusing this:\n  \\<lbrakk>class ?P Object = \\<lfloor>(?D, ?fs, ?ms)\\<rfloor>;\n   ?Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ?ms\\<rbrakk>\n  \\<Longrightarrow> ?P \\<turnstile> Object sees_methods ?Mm\n  is_class P Object\n\ngoal (1 subgoal):\n 1. (\\<And>Mm.\n        P \\<turnstile> Object sees_methods Mm \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp: is_class_def dest: sees_methods_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> Object sees_methods Mm\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> Object sees_methods Mm", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> Object sees_methods Mm\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "by(rule start_prog_Start_sees_start_method)"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n                                    0, [Invokestatic C M 0, Return],\n                                    []) in Start\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_prog_start_m_instrs:\nassumes wf: \"wf_prog wf_md P\"\nshows \"(instrs_of (start_prog P C M) Start start_m) = [Invokestatic C M 0, Return]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. instrs_of (class_add P (start_class C M)) Start start_m =\n    [Invokestatic C M 0, Return]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. instrs_of (class_add P (start_class C M)) Start start_m =\n    [Invokestatic C M 0, Return]", "from wf_start_prog_Start_sees_start_method[OF wf]"], ["proof (chain)\npicking this:\n  class_add P\n   (start_class ?C\n     ?M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n                                     0, [Invokestatic ?C ?M 0, Return],\n                                     []) in Start", "have \"start_prog P C M \\<turnstile> Start sees start_m, Static :\n           []\\<rightarrow>Void = (1,0,[Invokestatic C M 0,Return],[]) in Start\""], ["proof (prove)\nusing this:\n  class_add P\n   (start_class ?C\n     ?M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n                                     0, [Invokestatic ?C ?M 0, Return],\n                                     []) in Start\n\ngoal (1 subgoal):\n 1. class_add P\n     (start_class C\n       M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n0, [Invokestatic C M 0, Return], []) in Start", "by simp"], ["proof (state)\nthis:\n  class_add P\n   (start_class C\n     M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n                                    0, [Invokestatic C M 0, Return],\n                                    []) in Start\n\ngoal (1 subgoal):\n 1. instrs_of (class_add P (start_class C M)) Start start_m =\n    [Invokestatic C M 0, Return]", "then"], ["proof (chain)\npicking this:\n  class_add P\n   (start_class C\n     M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n                                    0, [Invokestatic C M 0, Return],\n                                    []) in Start", "show ?thesis"], ["proof (prove)\nusing this:\n  class_add P\n   (start_class C\n     M) \\<turnstile> Start sees start_m, Static :  []\\<rightarrow>Void = (1,\n                                    0, [Invokestatic C M 0, Return],\n                                    []) in Start\n\ngoal (1 subgoal):\n 1. instrs_of (class_add P (start_class C M)) Start start_m =\n    [Invokestatic C M 0, Return]", "by simp"], ["proof (state)\nthis:\n  instrs_of (class_add P (start_class C M)) Start start_m =\n  [Invokestatic C M 0, Return]\n\ngoal:\nNo subgoals!", "qed"], ["", "(******************************************************************)"], ["", "declare wt_defs [simp del]"], ["", "end"]]}