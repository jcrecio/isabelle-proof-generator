{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/Common/Objects.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma [simp]: \"obj_ty (C,fs) = Class C\"", "lemma new_Addr_SomeD:\n  \"new_Addr h = Some a \\<Longrightarrow> h a = None\"", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Boolean) = (\\<exists>b. v = Bool b)\"", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Integer) = (\\<exists>i. v = Intg i)\"", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some NT) = (v = Null)\"", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some(Class C)) = (\\<exists>a fs. v = Addr a \\<and> h a = Some(C,fs))\"", "lemma [simp]: \"h a = Some(C,fs) \\<Longrightarrow> typeof\\<^bsub>(h(a\\<mapsto>(C,fs')))\\<^esub> v = typeof\\<^bsub>h\\<^esub> v\"", "lemma typeof_lit_typeof:\n  \"typeof v = Some T \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> v = Some T\"", "lemma typeof_lit_is_type: \n  \"typeof v = Some T \\<Longrightarrow> is_type P T\"", "lemma hextI: \"\\<forall>a C fs. h a = Some(C,fs) \\<longrightarrow> (\\<exists>fs'. h' a = Some(C,fs')) \\<Longrightarrow> h \\<unlhd> h'\"", "lemma hext_objD: \"\\<lbrakk> h \\<unlhd> h'; h a = Some(C,fs) \\<rbrakk> \\<Longrightarrow> \\<exists>fs'. h' a = Some(C,fs')\"", "lemma hext_refl [iff]: \"h \\<unlhd> h\"", "lemma hext_new [simp]: \"h a = None \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>x)\"", "lemma hext_trans: \"\\<lbrakk> h \\<unlhd> h'; h' \\<unlhd> h'' \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h''\"", "lemma hext_upd_obj: \"h a = Some (C,fs) \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>(C,fs'))\"", "lemma hext_typeof_mono: \"\\<lbrakk> h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = Some T \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = Some T\"", "lemma iprog_Done[simp]: \"(Done \\<le>\\<^sub>i i) = (i = Done)\"", "lemma iprog_Error[simp]: \"(Error \\<le>\\<^sub>i i) = (i = Error)\"", "lemma iprog_Processing[simp]: \"(Processing \\<le>\\<^sub>i i) = (i = Done \\<or> i = Error \\<or> i = Processing)\"", "lemma iprog_trans: \"\\<lbrakk> i \\<le>\\<^sub>i i'; i' \\<le>\\<^sub>i i'' \\<rbrakk> \\<Longrightarrow> i \\<le>\\<^sub>i i''\"", "lemma shextI: \"\\<forall>C sfs i. sh C = Some(sfs,i) \\<longrightarrow> (\\<exists>sfs' i'. sh' C = Some(sfs',i') \\<and> i \\<le>\\<^sub>i i') \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh'\"", "lemma shext_objD: \"\\<lbrakk> sh \\<unlhd>\\<^sub>s sh'; sh C = Some(sfs,i) \\<rbrakk> \\<Longrightarrow> \\<exists>sfs' i'. sh' C = Some(sfs', i') \\<and> i \\<le>\\<^sub>i i'\"", "lemma shext_refl [iff]: \"sh \\<unlhd>\\<^sub>s sh\"", "lemma shext_new [simp]: \"sh C = None \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C\\<mapsto>x)\"", "lemma shext_trans: \"\\<lbrakk> sh \\<unlhd>\\<^sub>s sh'; sh' \\<unlhd>\\<^sub>s sh'' \\<rbrakk> \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh''\"", "lemma shext_upd_obj: \"\\<lbrakk> sh C = Some (sfs,i); i \\<le>\\<^sub>i i' \\<rbrakk> \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C\\<mapsto>(sfs',i'))\""], "translations": [["", "lemma [simp]: \"obj_ty (C,fs) = Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (C, fs) = Class C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (C, fs) = Class C", "by (simp add: obj_ty_def)"], ["", "(*>*)\n\n(* replaced all vname, cname in below with `char list' and \\<rightharpoonup> with returned option\n  so that pretty printing works  -SM *)"], ["", "translations\n  (type) \"fields\" <= (type) \"char list \\<times> char list \\<Rightarrow> val option\"\n  (type) \"obj\" <= (type) \"char list \\<times> fields\"\n  (type) \"sfields\" <= (type) \"char list \\<Rightarrow> val option\""], ["", "subsection\\<open> Heap \\<close>"], ["", "type_synonym heap  = \"addr \\<rightharpoonup> obj\""], ["", "(* replaced addr with nat and \\<rightharpoonup> with returned option so that pretty printing works  -SM *)"], ["", "translations\n (type) \"heap\" <= (type) \"nat \\<Rightarrow> obj option\""], ["", "abbreviation\n  cname_of :: \"heap \\<Rightarrow> addr \\<Rightarrow> cname\" where\n  \"cname_of hp a == fst (the (hp a))\""], ["", "definition new_Addr  :: \"heap \\<Rightarrow> addr option\"\nwhere\n  \"new_Addr h  \\<equiv>  if \\<exists>a. h a = None then Some(LEAST a. h a = None) else None\""], ["", "definition cast_ok :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> heap \\<Rightarrow> val \\<Rightarrow> bool\"\nwhere\n  \"cast_ok P C h v  \\<equiv>  v = Null \\<or> P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\""], ["", "definition hext :: \"heap \\<Rightarrow> heap \\<Rightarrow> bool\" (\"_ \\<unlhd> _\" [51,51] 50)\nwhere\n  \"h \\<unlhd> h'  \\<equiv>  \\<forall>a C fs. h a = Some(C,fs) \\<longrightarrow> (\\<exists>fs'. h' a = Some(C,fs'))\""], ["", "primrec typeof_h :: \"heap \\<Rightarrow> val \\<Rightarrow> ty option\"  (\"typeof\\<^bsub>_\\<^esub>\")\nwhere\n  \"typeof\\<^bsub>h\\<^esub>  Unit    = Some Void\"\n| \"typeof\\<^bsub>h\\<^esub>  Null    = Some NT\"\n| \"typeof\\<^bsub>h\\<^esub> (Bool b) = Some Boolean\"\n| \"typeof\\<^bsub>h\\<^esub> (Intg i) = Some Integer\"\n| \"typeof\\<^bsub>h\\<^esub> (Addr a) = (case h a of None \\<Rightarrow> None | Some(C,fs) \\<Rightarrow> Some(Class C))\""], ["", "lemma new_Addr_SomeD:\n  \"new_Addr h = Some a \\<Longrightarrow> h a = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_Addr h = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h a = None", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_Addr h = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h a = None", "by(fastforce simp: new_Addr_def split:if_splits intro:LeastI)"], ["", "(*>*)"], ["", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Boolean) = (\\<exists>b. v = Bool b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Boolean\\<rfloor>) =\n    (\\<exists>b. v = Bool b)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Boolean\\<rfloor>) =\n    (\\<exists>b. v = Bool b)", "by(induct v) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some Integer) = (\\<exists>i. v = Intg i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Integer\\<rfloor>) =\n    (\\<exists>i. v = Intg i)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Integer\\<rfloor>) =\n    (\\<exists>i. v = Intg i)", "by(cases v) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some NT) = (v = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>NT\\<rfloor>) = (v = Null)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>NT\\<rfloor>) = (v = Null)", "by(cases v) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"(typeof\\<^bsub>h\\<^esub> v = Some(Class C)) = (\\<exists>a fs. v = Addr a \\<and> h a = Some(C,fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Class C\\<rfloor>) =\n    (\\<exists>a fs. v = Addr a \\<and> h a = \\<lfloor>(C, fs)\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof\\<^bsub>h\\<^esub> v = \\<lfloor>Class C\\<rfloor>) =\n    (\\<exists>a fs. v = Addr a \\<and> h a = \\<lfloor>(C, fs)\\<rfloor>)", "by(cases v) auto"], ["", "(*>*)"], ["", "lemma [simp]: \"h a = Some(C,fs) \\<Longrightarrow> typeof\\<^bsub>(h(a\\<mapsto>(C,fs')))\\<^esub> v = typeof\\<^bsub>h\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> v =\n    typeof\\<^bsub>h\\<^esub> v", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> v =\n    typeof\\<^bsub>h\\<^esub> v", "by(induct v) (auto simp:fun_upd_apply)"], ["", "(*>*)"], ["", "text\\<open> For literal values the first parameter of @{term typeof} can be\nset to @{term empty} because they do not contain addresses: \\<close>"], ["", "abbreviation\n  typeof :: \"val \\<Rightarrow> ty option\" where\n  \"typeof v == typeof_h Map.empty v\""], ["", "lemma typeof_lit_typeof:\n  \"typeof v = Some T \\<Longrightarrow> typeof\\<^bsub>h\\<^esub> v = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>", "by(cases v) auto"], ["", "(*>*)"], ["", "lemma typeof_lit_is_type: \n  \"typeof v = Some T \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow> is_type P T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow> is_type P T", "by (induct v) (auto simp:is_type_def)"], ["", "(*>*)"], ["", "subsection \\<open> Heap extension @{text\"\\<unlhd>\"} \\<close>"], ["", "lemma hextI: \"\\<forall>a C fs. h a = Some(C,fs) \\<longrightarrow> (\\<exists>fs'. h' a = Some(C,fs')) \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a C fs.\n       h a = \\<lfloor>(C, fs)\\<rfloor> \\<longrightarrow>\n       (\\<exists>fs'. h' a = \\<lfloor>(C, fs')\\<rfloor>) \\<Longrightarrow>\n    h \\<unlhd> h'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a C fs.\n       h a = \\<lfloor>(C, fs)\\<rfloor> \\<longrightarrow>\n       (\\<exists>fs'. h' a = \\<lfloor>(C, fs')\\<rfloor>) \\<Longrightarrow>\n    h \\<unlhd> h'", "by(auto simp: hext_def)"], ["", "(*>*)"], ["", "lemma hext_objD: \"\\<lbrakk> h \\<unlhd> h'; h a = Some(C,fs) \\<rbrakk> \\<Longrightarrow> \\<exists>fs'. h' a = Some(C,fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h a = \\<lfloor>(C, fs)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>fs'. h' a = \\<lfloor>(C, fs')\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h a = \\<lfloor>(C, fs)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>fs'. h' a = \\<lfloor>(C, fs')\\<rfloor>", "by(auto simp: hext_def)"], ["", "(*>*)"], ["", "lemma hext_refl [iff]: \"h \\<unlhd> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h", "by (rule hextI) fast"], ["", "(*>*)"], ["", "lemma hext_new [simp]: \"h a = None \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = None \\<Longrightarrow> h \\<unlhd> h(a \\<mapsto> x)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = None \\<Longrightarrow> h \\<unlhd> h(a \\<mapsto> x)", "by (rule hextI) (auto simp:fun_upd_apply)"], ["", "(*>*)"], ["", "lemma hext_trans: \"\\<lbrakk> h \\<unlhd> h'; h' \\<unlhd> h'' \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h' \\<unlhd> h''\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h' \\<unlhd> h''\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h''", "by (rule hextI) (fast dest: hext_objD)"], ["", "(*>*)"], ["", "lemma hext_upd_obj: \"h a = Some (C,fs) \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>(C,fs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    h \\<unlhd> h(a \\<mapsto> (C, fs'))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    h \\<unlhd> h(a \\<mapsto> (C, fs'))", "by (rule hextI) (auto simp:fun_upd_apply)"], ["", "(*>*)"], ["", "lemma hext_typeof_mono: \"\\<lbrakk> h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = Some T \\<rbrakk> \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h';\n     typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h';\n     typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "proof(cases v)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Unit\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 2. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Null\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 5. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Addr x5\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "case Addr"], ["proof (state)\nthis:\n  v = Addr x5_\n\ngoal (5 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Unit\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 2. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Null\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 5. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Addr x5\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "assume \"h \\<unlhd> h'\" and \"typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\""], ["proof (state)\nthis:\n  h \\<unlhd> h'\n  typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\n\ngoal (5 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Unit\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 2. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Null\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 5. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Addr x5\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  h \\<unlhd> h'\n  typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\n\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "using Addr"], ["proof (prove)\nusing this:\n  h \\<unlhd> h'\n  typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\n  v = Addr x5_\n\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "by(fastforce simp:hext_def)"], ["proof (state)\nthis:\n  typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Unit\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 2. \\<lbrakk>h \\<unlhd> h'; typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Null\\<rbrakk>\n    \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> typeof\\<^bsub>h'\\<^esub> v = \\<lfloor>T\\<rfloor>", "qed simp_all"], ["", "(*>*)"], ["", "subsection\\<open> Static field information function \\<close>"], ["", "datatype init_state = Done | Processing | Prepared | Error\n\t\\<comment> \\<open>@{term Done} = initialized\\<close>\n\t\\<comment> \\<open>@{term Processing} = currently being initialized\\<close>\n\t\\<comment> \\<open>@{term Prepared} = uninitialized and not currently being initialized\\<close>\n\t\\<comment> \\<open>@{term Error} = previous initialization attempt resulted in erroneous state\\<close>"], ["", "inductive iprog :: \"init_state \\<Rightarrow> init_state \\<Rightarrow> bool\" (\"_ \\<le>\\<^sub>i _\" [51,51] 50)\nwhere\n  [simp]: \"Prepared \\<le>\\<^sub>i i\"\n| [simp]: \"Processing \\<le>\\<^sub>i Done\"\n| [simp]: \"Processing \\<le>\\<^sub>i Error\"\n| [simp]: \"i \\<le>\\<^sub>i i\""], ["", "lemma iprog_Done[simp]: \"(Done \\<le>\\<^sub>i i) = (i = Done)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Done \\<le>\\<^sub>i i) = (i = Done)", "by(simp only: iprog.simps, simp)"], ["", "lemma iprog_Error[simp]: \"(Error \\<le>\\<^sub>i i) = (i = Error)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Error \\<le>\\<^sub>i i) = (i = Error)", "by(simp only: iprog.simps, simp)"], ["", "lemma iprog_Processing[simp]: \"(Processing \\<le>\\<^sub>i i) = (i = Done \\<or> i = Error \\<or> i = Processing)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Processing \\<le>\\<^sub>i i) =\n    (i = Done \\<or> i = Error \\<or> i = Processing)", "by(simp only: iprog.simps, simp)"], ["", "lemma iprog_trans: \"\\<lbrakk> i \\<le>\\<^sub>i i'; i' \\<le>\\<^sub>i i'' \\<rbrakk> \\<Longrightarrow> i \\<le>\\<^sub>i i''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le>\\<^sub>i i'; i' \\<le>\\<^sub>i i''\\<rbrakk>\n    \\<Longrightarrow> i \\<le>\\<^sub>i i''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le>\\<^sub>i i'; i' \\<le>\\<^sub>i i''\\<rbrakk>\n    \\<Longrightarrow> i \\<le>\\<^sub>i i''", "by(case_tac i; case_tac i') simp_all"], ["", "(*>*)"], ["", "subsection\\<open> Static Heap \\<close>"], ["", "text \\<open>The static heap (sheap) is used for storing information about static\n field values and initialization status for classes.\\<close>"], ["", "type_synonym\n  sheap = \"cname \\<rightharpoonup> sfields \\<times> init_state\""], ["", "translations\n (type) \"sheap\" <= (type) \"char list \\<Rightarrow> (sfields \\<times> init_state) option\""], ["", "definition shext :: \"sheap \\<Rightarrow> sheap \\<Rightarrow> bool\" (\"_ \\<unlhd>\\<^sub>s _\" [51,51] 50)\nwhere\n  \"sh \\<unlhd>\\<^sub>s sh'  \\<equiv>  \\<forall>C sfs i. sh C = Some(sfs,i) \\<longrightarrow> (\\<exists>sfs' i'. sh' C = Some(sfs',i') \\<and> i \\<le>\\<^sub>i i')\""], ["", "lemma shextI: \"\\<forall>C sfs i. sh C = Some(sfs,i) \\<longrightarrow> (\\<exists>sfs' i'. sh' C = Some(sfs',i') \\<and> i \\<le>\\<^sub>i i') \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C sfs i.\n       sh C = \\<lfloor>(sfs, i)\\<rfloor> \\<longrightarrow>\n       (\\<exists>sfs' i'.\n           sh' C = \\<lfloor>(sfs', i')\\<rfloor> \\<and>\n           i \\<le>\\<^sub>i i') \\<Longrightarrow>\n    sh \\<unlhd>\\<^sub>s sh'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C sfs i.\n       sh C = \\<lfloor>(sfs, i)\\<rfloor> \\<longrightarrow>\n       (\\<exists>sfs' i'.\n           sh' C = \\<lfloor>(sfs', i')\\<rfloor> \\<and>\n           i \\<le>\\<^sub>i i') \\<Longrightarrow>\n    sh \\<unlhd>\\<^sub>s sh'", "by(auto simp: shext_def)"], ["", "(*>*)"], ["", "lemma shext_objD: \"\\<lbrakk> sh \\<unlhd>\\<^sub>s sh'; sh C = Some(sfs,i) \\<rbrakk> \\<Longrightarrow> \\<exists>sfs' i'. sh' C = Some(sfs', i') \\<and> i \\<le>\\<^sub>i i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sh \\<unlhd>\\<^sub>s sh';\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sfs' i'.\n                         sh' C = \\<lfloor>(sfs', i')\\<rfloor> \\<and>\n                         i \\<le>\\<^sub>i i'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sh \\<unlhd>\\<^sub>s sh';\n     sh C = \\<lfloor>(sfs, i)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sfs' i'.\n                         sh' C = \\<lfloor>(sfs', i')\\<rfloor> \\<and>\n                         i \\<le>\\<^sub>i i'", "by(auto simp: shext_def)"], ["", "(*>*)"], ["", "lemma shext_refl [iff]: \"sh \\<unlhd>\\<^sub>s sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sh \\<unlhd>\\<^sub>s sh", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sh \\<unlhd>\\<^sub>s sh", "by (rule shextI) auto"], ["", "(*>*)"], ["", "lemma shext_new [simp]: \"sh C = None \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C\\<mapsto>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sh C = None \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C \\<mapsto> x)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sh C = None \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C \\<mapsto> x)", "by (rule shextI) (auto simp:fun_upd_apply)"], ["", "(*>*)"], ["", "lemma shext_trans: \"\\<lbrakk> sh \\<unlhd>\\<^sub>s sh'; sh' \\<unlhd>\\<^sub>s sh'' \\<rbrakk> \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sh \\<unlhd>\\<^sub>s sh'; sh' \\<unlhd>\\<^sub>s sh''\\<rbrakk>\n    \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sh \\<unlhd>\\<^sub>s sh'; sh' \\<unlhd>\\<^sub>s sh''\\<rbrakk>\n    \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh''", "by (rule shextI) (fast dest: iprog_trans shext_objD)"], ["", "(*>*)"], ["", "lemma shext_upd_obj: \"\\<lbrakk> sh C = Some (sfs,i); i \\<le>\\<^sub>i i' \\<rbrakk> \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C\\<mapsto>(sfs',i'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sh C = \\<lfloor>(sfs, i)\\<rfloor>; i \\<le>\\<^sub>i i'\\<rbrakk>\n    \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C \\<mapsto> (sfs', i'))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sh C = \\<lfloor>(sfs, i)\\<rfloor>; i \\<le>\\<^sub>i i'\\<rbrakk>\n    \\<Longrightarrow> sh \\<unlhd>\\<^sub>s sh(C \\<mapsto> (sfs', i'))", "by (rule shextI) (auto simp:fun_upd_apply)"], ["", "(*>*)"], ["", "end"]]}