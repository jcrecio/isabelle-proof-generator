{"file_name": "/home/qj213/afp-2021-10-22/thys/JinjaDCI/BV/Effect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JinjaDCI", "problem_names": ["lemma eff_None:\n  \"eff i P pc xt None = []\"", "lemma eff_Some:\n  \"eff i P pc xt (Some \\<tau>) = norm_eff i P pc \\<tau> @ xcpt_eff i P pc \\<tau> xt\"", "lemma app_Some:\n  \"app i P mxs T\\<^sub>r pc mpc xt (Some \\<tau>) = \n  (app\\<^sub>i (i,P,pc,mxs,T\\<^sub>r,\\<tau>) \\<and> xcpt_app i P pc mxs xt \\<tau> \\<and> \n  (\\<forall>(pc',s') \\<in> set (eff i P pc xt (Some \\<tau>)). pc' < mpc))\"", "lemma length_cases2:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l ST LT. P (l#ST,LT)\"\n  shows \"P s\"", "lemma length_cases3:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l ST LT. P (l#ST,LT)\"\n  shows \"P s\"", "lemma length_cases4:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' LT. P ([l,l'],LT)\"\n  assumes \"\\<And>l l' ST LT. P (l#l'#ST,LT)\"\n  shows \"P s\"", "lemma appNone[simp]: \"app i P mxs T\\<^sub>r pc mpc et None = True\"", "lemma appLoad[simp]:\n\"app\\<^sub>i (Load idx, P, T\\<^sub>r, mxs, pc, s) = (\\<exists>ST LT. s = (ST,LT) \\<and> idx < length LT \\<and> LT!idx \\<noteq> Err \\<and> length ST < mxs)\"", "lemma appStore[simp]:\n\"app\\<^sub>i (Store idx,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT) \\<and> idx < length LT)\"", "lemma appPush[simp]:\n\"app\\<^sub>i (Push v,P,pc,mxs,T\\<^sub>r,s) =\n (\\<exists>ST LT. s = (ST,LT) \\<and> length ST < mxs \\<and> typeof v \\<noteq> None)\"", "lemma appGetField[simp]:\n\"app\\<^sub>i (Getfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> oT vT ST LT. s = (oT#ST, LT) \\<and> \n  P \\<turnstile> C sees F,NonStatic:vT in C \\<and> P \\<turnstile> oT \\<le> (Class C))\"", "lemma appGetStatic[simp]:\n\"app\\<^sub>i (Getstatic C F D,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT ST LT. s = (ST, LT) \\<and> length ST < mxs \\<and> P \\<turnstile> C sees F,Static:vT in D)\"", "lemma appPutField[simp]:\n\"app\\<^sub>i (Putfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT vT' oT ST LT. s = (vT#oT#ST, LT) \\<and>\n  P \\<turnstile> C sees F,NonStatic:vT' in C \\<and> P \\<turnstile> oT \\<le> (Class C) \\<and> P \\<turnstile> vT \\<le> vT')\"", "lemma appPutstatic[simp]:\n\"app\\<^sub>i (Putstatic C F D,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT vT' ST LT. s = (vT#ST, LT) \\<and>\n  P \\<turnstile> C sees F,Static:vT' in D \\<and> P \\<turnstile> vT \\<le> vT')\"", "lemma appNew[simp]:\n  \"app\\<^sub>i (New C,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s=(ST,LT) \\<and> is_class P C \\<and> length ST < mxs)\"", "lemma appCheckcast[simp]: \n  \"app\\<^sub>i (Checkcast C,P,pc,mxs,T\\<^sub>r,s) =  \n  (\\<exists>T ST LT. s = (T#ST,LT) \\<and> is_class P C \\<and> is_refT T)\"", "lemma app\\<^sub>iPop[simp]: \n\"app\\<^sub>i (Pop,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT))\"", "lemma appIAdd[simp]:\n\"app\\<^sub>i (IAdd,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ST LT. s = (Integer#Integer#ST,LT))\"", "lemma appIfFalse [simp]:\n\"app\\<^sub>i (IfFalse b,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s = (Boolean#ST,LT) \\<and> 0 \\<le> int pc + b)\"", "lemma appCmpEq[simp]:\n\"app\\<^sub>i (CmpEq,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST LT. s = (T\\<^sub>1#T\\<^sub>2#ST,LT) \\<and> (\\<not>is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or> is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2))\"", "lemma appReturn[simp]:\n\"app\\<^sub>i (Return,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s = (T#ST,LT) \\<and> P \\<turnstile> T \\<le> T\\<^sub>r)\"", "lemma appThrow[simp]:\n  \"app\\<^sub>i (Throw,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> is_refT T)\"", "lemma effNone: \n  \"(pc', s') \\<in> set (eff i P pc et None) \\<Longrightarrow> s' = None\"", "lemma relevant_entries_append [simp]:\n  \"relevant_entries P i pc (xt @ xt') = relevant_entries P i pc xt @ relevant_entries P i pc xt'\"", "lemma xcpt_app_append [iff]:\n  \"xcpt_app i P pc mxs (xt@xt') \\<tau> = (xcpt_app i P pc mxs xt \\<tau> \\<and> xcpt_app i P pc mxs xt' \\<tau>)\"", "lemma xcpt_eff_append [simp]:\n  \"xcpt_eff i P pc \\<tau> (xt@xt') = xcpt_eff i P pc \\<tau> xt @ xcpt_eff i P pc \\<tau> xt'\"", "lemma app_append [simp]:\n  \"app i P pc T mxs mpc (xt@xt') \\<tau> = (app i P pc T mxs mpc xt \\<tau> \\<and> app i P pc T mxs mpc xt' \\<tau>)\""], "translations": [["", "lemma eff_None:\n  \"eff i P pc xt None = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eff i P pc xt None = []", "by (simp add: eff_def)"], ["", "lemma eff_Some:\n  \"eff i P pc xt (Some \\<tau>) = norm_eff i P pc \\<tau> @ xcpt_eff i P pc \\<tau> xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eff i P pc xt \\<lfloor>\\<tau>\\<rfloor> =\n    norm_eff i P pc \\<tau> @ xcpt_eff i P pc \\<tau> xt", "by (simp add: eff_def)"], ["", "(* FIXME: getfield, \\<exists>T D. P \\<turnstile> C sees F:T in D \\<and> .. *)"], ["", "text \"Conditions under which eff is applicable:\""], ["", "fun app\\<^sub>i :: \"instr \\<times> 'm prog \\<times> pc \\<times> nat \\<times> ty \\<times> ty\\<^sub>i \\<Rightarrow> bool\" where\n  app\\<^sub>i_Load:\n    \"app\\<^sub>i (Load n, P, pc, mxs, T\\<^sub>r, (ST,LT)) = \n    (n < length LT \\<and> LT ! n \\<noteq> Err \\<and> length ST < mxs)\"\n| app\\<^sub>i_Store:\n    \"app\\<^sub>i (Store n, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) = \n    (n < length LT)\"\n| app\\<^sub>i_Push:\n    \"app\\<^sub>i (Push v, P, pc, mxs, T\\<^sub>r, (ST,LT)) = \n     (length ST < mxs \\<and> typeof v \\<noteq> None)\"\n| app\\<^sub>i_Getfield:\n    \"app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) = \n    (\\<exists>T\\<^sub>f. P \\<turnstile> C sees F,NonStatic:T\\<^sub>f in C \\<and> P \\<turnstile> T \\<le> Class C)\"\n| app\\<^sub>i_Getstatic:\n    \"app\\<^sub>i (Getstatic C F D, P, pc, mxs, T\\<^sub>r, (ST, LT)) = \n     (length ST < mxs \\<and> (\\<exists>T\\<^sub>f. P \\<turnstile> C sees F,Static:T\\<^sub>f in D))\"\n| app\\<^sub>i_Putfield:\n    \"app\\<^sub>i (Putfield F C, P, pc, mxs, T\\<^sub>r, (T\\<^sub>1#T\\<^sub>2#ST, LT)) = \n    (\\<exists>T\\<^sub>f. P \\<turnstile> C sees F,NonStatic:T\\<^sub>f in C \\<and> P \\<turnstile> T\\<^sub>2 \\<le> (Class C) \\<and> P \\<turnstile> T\\<^sub>1 \\<le> T\\<^sub>f)\" \n| app\\<^sub>i_Putstatic:\n    \"app\\<^sub>i (Putstatic C F D, P, pc, mxs, T\\<^sub>r, (T#ST, LT)) = \n    (\\<exists>T\\<^sub>f. P \\<turnstile> C sees F,Static:T\\<^sub>f in D \\<and> P \\<turnstile> T \\<le> T\\<^sub>f)\" \n| app\\<^sub>i_New:\n    \"app\\<^sub>i (New C, P, pc, mxs, T\\<^sub>r, (ST,LT)) = \n    (is_class P C \\<and> length ST < mxs)\"\n| app\\<^sub>i_Checkcast:\n    \"app\\<^sub>i (Checkcast C, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    (is_class P C \\<and> is_refT T)\"\n| app\\<^sub>i_Pop:\n    \"app\\<^sub>i (Pop, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    True\"\n| app\\<^sub>i_IAdd:\n    \"app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, (T\\<^sub>1#T\\<^sub>2#ST,LT)) = (T\\<^sub>1 = T\\<^sub>2 \\<and> T\\<^sub>1 = Integer)\"\n| app\\<^sub>i_CmpEq:\n    \"app\\<^sub>i (CmpEq, P, pc, mxs, T\\<^sub>r, (T\\<^sub>1#T\\<^sub>2#ST,LT)) =\n    (T\\<^sub>1 = T\\<^sub>2 \\<or> is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2)\"\n| app\\<^sub>i_IfFalse:\n    \"app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, (Boolean#ST,LT)) = \n    (0 \\<le> int pc + b)\"\n| app\\<^sub>i_Goto:\n    \"app\\<^sub>i (Goto b, P, pc, mxs, T\\<^sub>r, s) = \n    (0 \\<le> int pc + b)\"\n| app\\<^sub>i_Return:\n    \"app\\<^sub>i (Return, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    (P \\<turnstile> T \\<le> T\\<^sub>r)\"\n| app\\<^sub>i_Throw:\n    \"app\\<^sub>i (Throw, P, pc, mxs, T\\<^sub>r, (T#ST,LT)) = \n    is_refT T\"\n| app\\<^sub>i_Invoke:\n    \"app\\<^sub>i (Invoke M n, P, pc, mxs, T\\<^sub>r, (ST,LT)) =\n    (n < length ST \\<and> \n    (ST!n \\<noteq> NT \\<longrightarrow>\n      (\\<exists>C D Ts T m. ST!n = Class C \\<and> P \\<turnstile> C sees M,NonStatic:Ts \\<rightarrow> T = m in D \\<and>\n                    P \\<turnstile> rev (take n ST) [\\<le>] Ts)))\"\n| app\\<^sub>i_Invokestatic:\n    \"app\\<^sub>i (Invokestatic C M n, P, pc, mxs, T\\<^sub>r, (ST,LT)) =\n    (length ST - n < mxs \\<and> n \\<le> length ST \\<and> M \\<noteq> clinit \\<and>\n      (\\<exists>D Ts T m. P \\<turnstile> C sees M,Static:Ts \\<rightarrow> T = m in D \\<and>\n                    P \\<turnstile> rev (take n ST) [\\<le>] Ts))\"\n    \n| app\\<^sub>i_default:\n    \"app\\<^sub>i (i,P, pc,mxs,T\\<^sub>r,s) = False\""], ["", "definition xcpt_app :: \"instr \\<Rightarrow> 'm prog \\<Rightarrow> pc \\<Rightarrow> nat \\<Rightarrow> ex_table \\<Rightarrow> ty\\<^sub>i \\<Rightarrow> bool\" where\n  \"xcpt_app i P pc mxs xt \\<tau> \\<longleftrightarrow> (\\<forall>(f,t,C,h,d) \\<in> set (relevant_entries P i pc xt). is_class P C \\<and> d \\<le> size (fst \\<tau>) \\<and> d < mxs)\""], ["", "definition app :: \"instr \\<Rightarrow> 'm prog \\<Rightarrow> nat \\<Rightarrow> ty \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> ex_table \\<Rightarrow> ty\\<^sub>i' \\<Rightarrow> bool\" where\n  \"app i P mxs T\\<^sub>r pc mpc xt t = (case t of None \\<Rightarrow> True | Some \\<tau> \\<Rightarrow> \n  app\\<^sub>i (i,P,pc,mxs,T\\<^sub>r,\\<tau>) \\<and> xcpt_app i P pc mxs xt \\<tau> \\<and> \n  (\\<forall>(pc',\\<tau>') \\<in> set (eff i P pc xt t). pc' < mpc))\""], ["", "lemma app_Some:\n  \"app i P mxs T\\<^sub>r pc mpc xt (Some \\<tau>) = \n  (app\\<^sub>i (i,P,pc,mxs,T\\<^sub>r,\\<tau>) \\<and> xcpt_app i P pc mxs xt \\<tau> \\<and> \n  (\\<forall>(pc',s') \\<in> set (eff i P pc xt (Some \\<tau>)). pc' < mpc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i P mxs T\\<^sub>r pc mpc xt \\<lfloor>\\<tau>\\<rfloor> =\n    (app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, \\<tau>) \\<and>\n     xcpt_app i P pc mxs xt \\<tau> \\<and>\n     (\\<forall>(pc', s')\\<in>set (eff i P pc xt \\<lfloor>\\<tau>\\<rfloor>).\n         pc' < mpc))", "by (simp add: app_def)"], ["", "locale eff = jvm_method +\n  fixes eff\\<^sub>i and app\\<^sub>i and eff and app \n  fixes norm_eff and xcpt_app and xcpt_eff\n\n  fixes mpc\n  defines \"mpc \\<equiv> size is\"\n\n  defines \"eff\\<^sub>i i \\<tau> \\<equiv> Effect.eff\\<^sub>i (i,P,\\<tau>)\"\n  notes eff\\<^sub>i_simps [simp] = Effect.eff\\<^sub>i.simps [where P = P, folded eff\\<^sub>i_def]\n\n  defines \"app\\<^sub>i i pc \\<tau> \\<equiv> Effect.app\\<^sub>i (i, P, pc, mxs, T\\<^sub>r, \\<tau>)\"\n  notes app\\<^sub>i_simps [simp] = Effect.app\\<^sub>i.simps [where P=P and mxs=mxs and T\\<^sub>r=T\\<^sub>r, folded app\\<^sub>i_def]\n\n  defines \"xcpt_eff i pc \\<tau> \\<equiv> Effect.xcpt_eff i P pc \\<tau> xt\"\n  notes xcpt_eff = Effect.xcpt_eff_def [of _ P _ _ xt, folded xcpt_eff_def]\n\n  defines \"norm_eff i pc \\<tau> \\<equiv> Effect.norm_eff i P pc \\<tau>\"\n  notes norm_eff = Effect.norm_eff_def [of _ P, folded norm_eff_def eff\\<^sub>i_def]\n\n  defines \"eff i pc \\<equiv> Effect.eff i P pc xt\"\n  notes eff = Effect.eff_def [of _ P  _ xt, folded eff_def norm_eff_def xcpt_eff_def]\n\n  defines \"xcpt_app i pc \\<tau> \\<equiv> Effect.xcpt_app i P pc mxs xt \\<tau>\"\n  notes xcpt_app = Effect.xcpt_app_def [of _ P _ mxs xt, folded xcpt_app_def]\n\n  defines \"app i pc \\<equiv> Effect.app i P mxs T\\<^sub>r pc mpc xt\"\n  notes app = Effect.app_def [of _ P mxs T\\<^sub>r _ mpc xt, folded app_def xcpt_app_def app\\<^sub>i_def eff_def]"], ["", "lemma length_cases2:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l ST LT. P (l#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "by (cases s, cases \"fst s\") (auto intro!: assms)"], ["", "lemma length_cases3:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l ST LT. P (l#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P s", "obtain xs LT where s: \"s = (xs,LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs LT. s = (xs, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s)"], ["proof (state)\nthis:\n  s = (xs, LT)\n\ngoal (1 subgoal):\n 1. P s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P s\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P s\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "with assms s"], ["proof (chain)\npicking this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P (?l # ?ST, ?LT)\n  s = (xs, LT)\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P (?l # ?ST, ?LT)\n  s = (xs, LT)\n  xs = []\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "fix l xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "assume \"xs = l#xs'\""], ["proof (state)\nthis:\n  xs = l # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "with assms s"], ["proof (chain)\npicking this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P (?l # ?ST, ?LT)\n  s = (xs, LT)\n  xs = l # xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P (?l # ?ST, ?LT)\n  s = (xs, LT)\n  xs = l # xs'\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma length_cases4:\n  assumes \"\\<And>LT. P ([],LT)\"\n  assumes \"\\<And>l LT. P ([l],LT)\"\n  assumes \"\\<And>l l' LT. P ([l,l'],LT)\"\n  assumes \"\\<And>l l' ST LT. P (l#l'#ST,LT)\"\n  shows \"P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P s", "obtain xs LT where s: \"s = (xs,LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs LT. s = (xs, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s)"], ["proof (state)\nthis:\n  s = (xs, LT)\n\ngoal (1 subgoal):\n 1. P s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P s\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P s\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "with assms s"], ["proof (chain)\npicking this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P ([?l, ?l'], ?LT)\n  P (?l # ?l' # ?ST, ?LT)\n  s = (xs, LT)\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P ([?l, ?l'], ?LT)\n  P (?l # ?l' # ?ST, ?LT)\n  s = (xs, LT)\n  xs = []\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "fix l xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "assume xs: \"xs = l#xs'\""], ["proof (state)\nthis:\n  xs = l # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P s", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = l # xs'\n\ngoal (1 subgoal):\n 1. P s", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = l # xs'; xs' = []\\<rbrakk> \\<Longrightarrow> P s\n 2. \\<And>a list.\n       \\<lbrakk>xs = l # xs'; xs' = a # list\\<rbrakk> \\<Longrightarrow> P s", "case Nil"], ["proof (state)\nthis:\n  xs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = l # xs'; xs' = []\\<rbrakk> \\<Longrightarrow> P s\n 2. \\<And>a list.\n       \\<lbrakk>xs = l # xs'; xs' = a # list\\<rbrakk> \\<Longrightarrow> P s", "with assms s xs"], ["proof (chain)\npicking this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P ([?l, ?l'], ?LT)\n  P (?l # ?l' # ?ST, ?LT)\n  s = (xs, LT)\n  xs = l # xs'\n  xs' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P ([?l, ?l'], ?LT)\n  P (?l # ?l' # ?ST, ?LT)\n  s = (xs, LT)\n  xs = l # xs'\n  xs' = []\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = l # xs'; xs' = a # list\\<rbrakk> \\<Longrightarrow> P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = l # xs'; xs' = a # list\\<rbrakk> \\<Longrightarrow> P s", "fix l' ST"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = l # xs'; xs' = a # list\\<rbrakk> \\<Longrightarrow> P s", "assume \"xs' = l'#ST\""], ["proof (state)\nthis:\n  xs' = l' # ST\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = l # xs'; xs' = a # list\\<rbrakk> \\<Longrightarrow> P s", "with assms s xs"], ["proof (chain)\npicking this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P ([?l, ?l'], ?LT)\n  P (?l # ?l' # ?ST, ?LT)\n  s = (xs, LT)\n  xs = l # xs'\n  xs' = l' # ST", "show ?thesis"], ["proof (prove)\nusing this:\n  P ([], ?LT)\n  P ([?l], ?LT)\n  P ([?l, ?l'], ?LT)\n  P (?l # ?l' # ?ST, ?LT)\n  s = (xs, LT)\n  xs = l # xs'\n  xs' = l' # ST\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text \\<open> \n\\medskip\nsimp rules for @{term app}\n\\<close>"], ["", "lemma appNone[simp]: \"app i P mxs T\\<^sub>r pc mpc et None = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i P mxs T\\<^sub>r pc mpc et None = True", "by (simp add: app_def)"], ["", "lemma appLoad[simp]:\n\"app\\<^sub>i (Load idx, P, T\\<^sub>r, mxs, pc, s) = (\\<exists>ST LT. s = (ST,LT) \\<and> idx < length LT \\<and> LT!idx \\<noteq> Err \\<and> length ST < mxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Load idx, P, T\\<^sub>r, mxs, pc, s) =\n    (\\<exists>ST LT.\n        s = (ST, LT) \\<and>\n        idx < length LT \\<and> LT ! idx \\<noteq> Err \\<and> length ST < mxs)", "by (cases s, simp)"], ["", "lemma appStore[simp]:\n\"app\\<^sub>i (Store idx,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT) \\<and> idx < length LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Store idx, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ts ST LT. s = (ts # ST, LT) \\<and> idx < length LT)", "by (rule length_cases2, auto)"], ["", "lemma appPush[simp]:\n\"app\\<^sub>i (Push v,P,pc,mxs,T\\<^sub>r,s) =\n (\\<exists>ST LT. s = (ST,LT) \\<and> length ST < mxs \\<and> typeof v \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Push v, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT.\n        s = (ST, LT) \\<and> length ST < mxs \\<and> typeof v \\<noteq> None)", "by (cases s, simp)"], ["", "lemma appGetField[simp]:\n\"app\\<^sub>i (Getfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> oT vT ST LT. s = (oT#ST, LT) \\<and> \n  P \\<turnstile> C sees F,NonStatic:vT in C \\<and> P \\<turnstile> oT \\<le> (Class C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Getfield F C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>oT vT ST LT.\n        s = (oT # ST, LT) \\<and>\n        P \\<turnstile> C sees F,NonStatic:vT in C \\<and>\n        subtype P oT (Class C))", "by (rule length_cases2 [of _ s]) auto"], ["", "lemma appGetStatic[simp]:\n\"app\\<^sub>i (Getstatic C F D,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT ST LT. s = (ST, LT) \\<and> length ST < mxs \\<and> P \\<turnstile> C sees F,Static:vT in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Getstatic C F D, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>vT ST LT.\n        s = (ST, LT) \\<and>\n        length ST < mxs \\<and> P \\<turnstile> C sees F,Static:vT in D)", "by (rule length_cases2 [of _ s]) auto"], ["", "lemma appPutField[simp]:\n\"app\\<^sub>i (Putfield F C,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT vT' oT ST LT. s = (vT#oT#ST, LT) \\<and>\n  P \\<turnstile> C sees F,NonStatic:vT' in C \\<and> P \\<turnstile> oT \\<le> (Class C) \\<and> P \\<turnstile> vT \\<le> vT')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Putfield F C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>vT vT' oT ST LT.\n        s = (vT # oT # ST, LT) \\<and>\n        P \\<turnstile> C sees F,NonStatic:vT' in C \\<and>\n        subtype P oT (Class C) \\<and> subtype P vT vT')", "by (rule length_cases4 [of _ s], auto)"], ["", "lemma appPutstatic[simp]:\n\"app\\<^sub>i (Putstatic C F D,P,pc,mxs,T\\<^sub>r,s) = \n (\\<exists> vT vT' ST LT. s = (vT#ST, LT) \\<and>\n  P \\<turnstile> C sees F,Static:vT' in D \\<and> P \\<turnstile> vT \\<le> vT')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Putstatic C F D, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>vT vT' ST LT.\n        s = (vT # ST, LT) \\<and>\n        P \\<turnstile> C sees F,Static:vT' in D \\<and> subtype P vT vT')", "by (rule length_cases4 [of _ s], auto)"], ["", "lemma appNew[simp]:\n  \"app\\<^sub>i (New C,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s=(ST,LT) \\<and> is_class P C \\<and> length ST < mxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (New C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT.\n        s = (ST, LT) \\<and> is_class P C \\<and> length ST < mxs)", "by (cases s, simp)"], ["", "lemma appCheckcast[simp]: \n  \"app\\<^sub>i (Checkcast C,P,pc,mxs,T\\<^sub>r,s) =  \n  (\\<exists>T ST LT. s = (T#ST,LT) \\<and> is_class P C \\<and> is_refT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Checkcast C, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT.\n        s = (T # ST, LT) \\<and> is_class P C \\<and> is_refT T)", "by (cases s, cases \"fst s\", simp add: app_def) (cases \"hd (fst s)\", auto)"], ["", "lemma app\\<^sub>iPop[simp]: \n\"app\\<^sub>i (Pop,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ts ST LT. s = (ts#ST,LT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Pop, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ts ST LT. s = (ts # ST, LT))", "by (rule length_cases2, auto)"], ["", "lemma appIAdd[simp]:\n\"app\\<^sub>i (IAdd,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>ST LT. s = (Integer#Integer#ST,LT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "obtain ST LT where [simp]: \"s = (ST,LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ST LT. s = (ST, LT) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s)"], ["proof (state)\nthis:\n  s = (ST, LT)\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "have \"ST = [] \\<or> (\\<exists>T. ST = [T]) \\<or> (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1#T\\<^sub>2#ST')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST = [] \\<or>\n    (\\<exists>T. ST = [T]) \\<or>\n    (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')", "by (cases ST, auto, case_tac list, auto)"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "{"], ["proof (state)\nthis:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "assume \"ST = []\""], ["proof (state)\nthis:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = []\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "by simp"], ["proof (state)\nthis:\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "}"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "moreover"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "{"], ["proof (state)\nthis:\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "assume \"ST = [T]\""], ["proof (state)\nthis:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = [T]\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "by (cases T, auto)"], ["proof (state)\nthis:\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "}"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "moreover"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "{"], ["proof (state)\nthis:\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "fix T\\<^sub>1 T\\<^sub>2 ST'"], ["proof (state)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "assume \"ST = T\\<^sub>1#T\\<^sub>2#ST'\""], ["proof (state)\nthis:\n  ST = T\\<^sub>1 # T\\<^sub>2 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "hence ?thesis"], ["proof (prove)\nusing this:\n  ST = T\\<^sub>1 # T\\<^sub>2 # ST'\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "by (cases T\\<^sub>1, auto)"], ["proof (state)\nthis:\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "}"], ["proof (state)\nthis:\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "ultimately"], ["proof (chain)\npicking this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "show ?thesis"], ["proof (prove)\nusing this:\n  ST = [] \\<or>\n  (\\<exists>T. ST = [T]) \\<or>\n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST'. ST = T\\<^sub>1 # T\\<^sub>2 # ST')\n  ST = [] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n  ST = [?T2] \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n  ST = ?T\\<^sub>12 # ?T\\<^sub>22 # ?ST'2 \\<Longrightarrow>\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal (1 subgoal):\n 1. app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Integer # Integer # ST, LT))", "by blast"], ["proof (state)\nthis:\n  app\\<^sub>i (IAdd, P, pc, mxs, T\\<^sub>r, s) =\n  (\\<exists>ST LT. s = (Integer # Integer # ST, LT))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma appIfFalse [simp]:\n\"app\\<^sub>i (IfFalse b,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>ST LT. s = (Boolean#ST,LT) \\<and> 0 \\<le> int pc + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Boolean # ST, LT) \\<and> 0 \\<le> int pc + b)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>ST LT. s = (Boolean # ST, LT) \\<and> 0 \\<le> int pc + b)", "apply (rule length_cases2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>LT.\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, [], LT) =\n       (\\<exists>ST LTa.\n           ([], LT) = (Boolean # ST, LTa) \\<and> 0 \\<le> int pc + b)\n 2. \\<And>l ST LT.\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ST LT.\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)", "apply (case_tac l)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l ST LT.\n       l = Void \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 2. \\<And>l ST LT.\n       l = Boolean \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 3. \\<And>l ST LT.\n       l = Integer \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 4. \\<And>l ST LT.\n       l = NT \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)\n 5. \\<And>l ST LT x5.\n       l = Class x5 \\<Longrightarrow>\n       app\\<^sub>i (IfFalse b, P, pc, mxs, T\\<^sub>r, l # ST, LT) =\n       (\\<exists>STa LTa.\n           (l # ST, LT) = (Boolean # STa, LTa) \\<and> 0 \\<le> int pc + b)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma appCmpEq[simp]:\n\"app\\<^sub>i (CmpEq,P,pc,mxs,T\\<^sub>r,s) = \n  (\\<exists>T\\<^sub>1 T\\<^sub>2 ST LT. s = (T\\<^sub>1#T\\<^sub>2#ST,LT) \\<and> (\\<not>is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or> is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (CmpEq, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T\\<^sub>1 T\\<^sub>2 ST LT.\n        s = (T\\<^sub>1 # T\\<^sub>2 # ST, LT) \\<and>\n        (\\<not> is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or>\n         is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2))", "by (rule length_cases4, auto)"], ["", "lemma appReturn[simp]:\n\"app\\<^sub>i (Return,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s = (T#ST,LT) \\<and> P \\<turnstile> T \\<le> T\\<^sub>r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Return, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT. s = (T # ST, LT) \\<and> subtype P T T\\<^sub>r)", "by (rule length_cases2, auto)"], ["", "lemma appThrow[simp]:\n  \"app\\<^sub>i (Throw,P,pc,mxs,T\\<^sub>r,s) = (\\<exists>T ST LT. s=(T#ST,LT) \\<and> is_refT T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app\\<^sub>i (Throw, P, pc, mxs, T\\<^sub>r, s) =\n    (\\<exists>T ST LT. s = (T # ST, LT) \\<and> is_refT T)", "by (rule length_cases2, auto)"], ["", "lemma effNone: \n  \"(pc', s') \\<in> set (eff i P pc et None) \\<Longrightarrow> s' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pc', s') \\<in> set (eff i P pc et None) \\<Longrightarrow> s' = None", "by (auto simp add: eff_def xcpt_eff_def norm_eff_def)"], ["", "text \\<open> some helpers to make the specification directly executable: \\<close>"], ["", "lemma relevant_entries_append [simp]:\n  \"relevant_entries P i pc (xt @ xt') = relevant_entries P i pc xt @ relevant_entries P i pc xt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relevant_entries P i pc (xt @ xt') =\n    relevant_entries P i pc xt @ relevant_entries P i pc xt'", "by (unfold relevant_entries_def) simp"], ["", "lemma xcpt_app_append [iff]:\n  \"xcpt_app i P pc mxs (xt@xt') \\<tau> = (xcpt_app i P pc mxs xt \\<tau> \\<and> xcpt_app i P pc mxs xt' \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xcpt_app i P pc mxs (xt @ xt') \\<tau> =\n    (xcpt_app i P pc mxs xt \\<tau> \\<and> xcpt_app i P pc mxs xt' \\<tau>)", "by (unfold xcpt_app_def) fastforce"], ["", "lemma xcpt_eff_append [simp]:\n  \"xcpt_eff i P pc \\<tau> (xt@xt') = xcpt_eff i P pc \\<tau> xt @ xcpt_eff i P pc \\<tau> xt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xcpt_eff i P pc \\<tau> (xt @ xt') =\n    xcpt_eff i P pc \\<tau> xt @ xcpt_eff i P pc \\<tau> xt'", "by (unfold xcpt_eff_def, cases \\<tau>) simp"], ["", "lemma app_append [simp]:\n  \"app i P pc T mxs mpc (xt@xt') \\<tau> = (app i P pc T mxs mpc xt \\<tau> \\<and> app i P pc T mxs mpc xt' \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app i P pc T mxs mpc (xt @ xt') \\<tau> =\n    (app i P pc T mxs mpc xt \\<tau> \\<and> app i P pc T mxs mpc xt' \\<tau>)", "by (unfold app_def eff_def) auto"], ["", "end"]]}