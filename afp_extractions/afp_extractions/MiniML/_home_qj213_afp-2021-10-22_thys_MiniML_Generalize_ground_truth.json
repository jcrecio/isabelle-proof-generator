{"file_name": "/home/qj213/afp-2021-10-22/thys/MiniML/Generalize.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MiniML", "problem_names": ["lemma gen_eq_on_free_tv: \n    \"free_tv A = free_tv B \\<Longrightarrow> gen A t = gen B t\"", "lemma gen_without_effect [simp]:\n    \"(free_tv t) \\<subseteq> (free_tv sch) \\<Longrightarrow> gen sch t = (mk_scheme t)\"", "lemma free_tv_gen [simp]: \n  \"free_tv (gen ($ S A) t) = free_tv t Int free_tv ($ S A)\"", "lemma free_tv_gen_cons [simp]: \n  \"free_tv (gen ($ S A) t # $ S A) = free_tv ($ S A)\"", "lemma bound_tv_gen [simp]: \n  \"bound_tv (gen A t1) = (free_tv t1) - (free_tv A)\"", "lemma new_tv_compatible_gen: \"new_tv n t \\<Longrightarrow> new_tv n (gen A t)\"", "lemma gen_eq_gen_ML: \"gen A t = gen_ML A t\"", "lemma gen_subst_commutes [rule_format]: \n  \"(free_tv S) Int ((free_tv t) - (free_tv A)) = {}  \n      \\<longrightarrow> gen ($ S A) ($ S t) = $ S (gen A t)\"", "lemma bound_typ_inst_gen [simp]:\n    \"free_tv(t::typ) \\<subseteq> free_tv(A) \\<Longrightarrow> bound_typ_inst S (gen A t) = t\"", "lemma gen_bound_typ_instance: \n  \"gen ($ S A) ($ S t) \\<le> $ S (gen A t)\"", "lemma free_tv_subset_gen_le: \n  \"free_tv B \\<subseteq> free_tv A \\<Longrightarrow> gen A t \\<le> gen B t\"", "lemma gen_t_le_gen_alpha_t [rule_format, simp]: \n  \"new_tv n A \\<longrightarrow>  \n   gen A t \\<le> gen A ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x)) t)\""], "translations": [["", "lemma gen_eq_on_free_tv: \n    \"free_tv A = free_tv B \\<Longrightarrow> gen A t = gen B t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv A = free_tv B \\<Longrightarrow> gen A t = gen B t", "by (induct t) simp_all"], ["", "lemma gen_without_effect [simp]:\n    \"(free_tv t) \\<subseteq> (free_tv sch) \\<Longrightarrow> gen sch t = (mk_scheme t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv t \\<subseteq> free_tv sch \\<Longrightarrow>\n    gen sch t = mk_scheme t", "by (induct t) auto"], ["", "lemma free_tv_gen [simp]: \n  \"free_tv (gen ($ S A) t) = free_tv t Int free_tv ($ S A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv (gen ($ S A) t) = free_tv t \\<inter> free_tv ($ S A)", "by (induct t) auto"], ["", "lemma free_tv_gen_cons [simp]: \n  \"free_tv (gen ($ S A) t # $ S A) = free_tv ($ S A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv (gen ($ S A) t # $ S A) = free_tv ($ S A)", "by fastforce"], ["", "lemma bound_tv_gen [simp]: \n  \"bound_tv (gen A t1) = (free_tv t1) - (free_tv A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_tv (gen A t1) = free_tv t1 - free_tv A", "by (induct t1) auto"], ["", "lemma new_tv_compatible_gen: \"new_tv n t \\<Longrightarrow> new_tv n (gen A t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_tv n t \\<Longrightarrow> new_tv n (gen A t)", "by (induct t) auto"], ["", "lemma gen_eq_gen_ML: \"gen A t = gen_ML A t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen A t = gen_ML A t", "apply (unfold gen_ML_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen A t = gen_ML_aux (free_tv_ML A) t", "apply (induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. gen A (TVar x) = gen_ML_aux (free_tv_ML A) (TVar x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>gen A t1 = gen_ML_aux (free_tv_ML A) t1;\n        gen A t2 = gen_ML_aux (free_tv_ML A) t2\\<rbrakk>\n       \\<Longrightarrow> gen A (t1 -> t2) =\n                         gen_ML_aux (free_tv_ML A) (t1 -> t2)", "apply (simp add: free_tv_ML_scheme_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>gen A t1 = gen_ML_aux (free_tv_ML A) t1;\n        gen A t2 = gen_ML_aux (free_tv_ML A) t2\\<rbrakk>\n       \\<Longrightarrow> gen A (t1 -> t2) =\n                         gen_ML_aux (free_tv_ML A) (t1 -> t2)", "apply (simp add: free_tv_ML_scheme_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_subst_commutes [rule_format]: \n  \"(free_tv S) Int ((free_tv t) - (free_tv A)) = {}  \n      \\<longrightarrow> gen ($ S A) ($ S t) = $ S (gen A t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv S \\<inter> (free_tv t - free_tv A) = {} \\<longrightarrow>\n    gen ($ S A) ($ S t) = $ S (gen A t)", "apply (induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       free_tv S \\<inter> (free_tv (TVar x) - free_tv A) =\n       {} \\<longrightarrow>\n       gen ($ S A) ($ S (TVar x)) = $ S (gen A (TVar x))\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (intro strip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       free_tv S \\<inter> (free_tv (TVar x) - free_tv A) =\n       {} \\<Longrightarrow>\n       gen ($ S A) ($ S (TVar x)) = $ S (gen A (TVar x))\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (rename_tac nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       free_tv S \\<inter> (free_tv (TVar nat) - free_tv A) =\n       {} \\<Longrightarrow>\n       gen ($ S A) ($ S (TVar nat)) = $ S (gen A (TVar nat))\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (case_tac \"nat : (free_tv A) \")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> (free_tv (TVar nat) - free_tv A) = {};\n        nat \\<in> free_tv A\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) ($ S (TVar nat)) =\n                         $ S (gen A (TVar nat))\n 2. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> (free_tv (TVar nat) - free_tv A) = {};\n        nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) ($ S (TVar nat)) =\n                         $ S (gen A (TVar nat))\n 3. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (simp (no_asm_simp))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> (free_tv (TVar nat) - free_tv A) = {};\n        nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) ($ S (TVar nat)) =\n                         $ S (gen A (TVar nat))\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> ({nat} - free_tv A) = {};\n        nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) (S nat) = BVar nat\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (subgoal_tac \"nat \\<notin> free_tv S\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> ({nat} - free_tv A) = {};\n        nat \\<notin> free_tv A; nat \\<notin> free_tv S\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) (S nat) = BVar nat\n 2. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> ({nat} - free_tv A) = {};\n        nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv S\n 3. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> ({nat} - free_tv A) = {};\n        nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv S\n 2. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> ({nat} - free_tv A) = {};\n        nat \\<notin> free_tv A; nat \\<notin> free_tv S\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) (S nat) = BVar nat\n 3. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (fast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>free_tv S \\<inter> ({nat} - free_tv A) = {};\n        nat \\<notin> free_tv A; nat \\<notin> free_tv S\\<rbrakk>\n       \\<Longrightarrow> gen ($ S A) (S nat) = BVar nat\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (simp add: free_tv_subst dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>({n. S n \\<noteq> TVar n} \\<union> cod S) \\<inter>\n                ({nat} - free_tv A) =\n                {};\n        nat \\<notin> free_tv A;\n        S nat = TVar nat \\<and> nat \\<notin> cod S\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv ($ S A)\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply (cut_tac free_tv_app_subst_scheme_list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>({n. S n \\<noteq> TVar n} \\<union> cod S) \\<inter>\n                ({nat} - free_tv A) =\n                {};\n        nat \\<notin> free_tv A; S nat = TVar nat \\<and> nat \\<notin> cod S;\n        free_tv ($ (?S23 nat) (?A23 nat))\n        \\<subseteq> cod (?S23 nat) \\<union> free_tv (?A23 nat)\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv ($ S A)\n 2. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv (t1 -> t2) - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S (t1 -> t2)) =\n                         $ S (gen A (t1 -> t2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>free_tv S \\<inter> (free_tv t1 - free_tv A) =\n                {} \\<longrightarrow>\n                gen ($ S A) ($ S t1) = $ S (gen A t1);\n        free_tv S \\<inter> (free_tv t2 - free_tv A) = {} \\<longrightarrow>\n        gen ($ S A) ($ S t2) = $ S (gen A t2)\\<rbrakk>\n       \\<Longrightarrow> free_tv S \\<inter>\n                         (free_tv t1 \\<union> free_tv t2 - free_tv A) =\n                         {} \\<longrightarrow>\n                         gen ($ S A) ($ S t1) = $ S (gen A t1) \\<and>\n                         gen ($ S A) ($ S t2) = $ S (gen A t2)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bound_typ_inst_gen [simp]:\n    \"free_tv(t::typ) \\<subseteq> free_tv(A) \\<Longrightarrow> bound_typ_inst S (gen A t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv t \\<subseteq> free_tv A \\<Longrightarrow>\n    bound_typ_inst S (gen A t) = t", "by (induct t) simp_all"], ["", "lemma gen_bound_typ_instance: \n  \"gen ($ S A) ($ S t) \\<le> $ S (gen A t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen ($ S A) ($ S t) \\<le> $ S (gen A t)", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ta.\n       (\\<exists>Sa.\n           ta = bound_typ_inst Sa (gen ($ S A) ($ S t))) \\<longrightarrow>\n       (\\<exists>Sa. ta = bound_typ_inst Sa ($ S (gen A t)))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta Sa.\n       \\<exists>Sb.\n          bound_typ_inst Sa (gen ($ S A) ($ S t)) =\n          bound_typ_inst Sb ($ S (gen A t))", "apply (rename_tac \"R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta R.\n       \\<exists>Sa.\n          bound_typ_inst R (gen ($ S A) ($ S t)) =\n          bound_typ_inst Sa ($ S (gen A t))", "apply (rule_tac x = \" (\\<lambda>a. bound_typ_inst R (gen ($S A) (S a))) \" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta R.\n       bound_typ_inst R (gen ($ S A) ($ S t)) =\n       bound_typ_inst (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n        ($ S (gen A t))", "apply (induct_tac \"t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t R x.\n       bound_typ_inst R (gen ($ S A) ($ S (TVar x))) =\n       bound_typ_inst (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n        ($ S (gen A (TVar x)))\n 2. \\<And>t R x1a x2.\n       \\<lbrakk>bound_typ_inst R (gen ($ S A) ($ S x1a)) =\n                bound_typ_inst\n                 (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n                 ($ S (gen A x1a));\n        bound_typ_inst R (gen ($ S A) ($ S x2)) =\n        bound_typ_inst (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n         ($ S (gen A x2))\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst R (gen ($ S A) ($ S (x1a -> x2))) =\n                         bound_typ_inst\n                          (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n                          ($ S (gen A (x1a -> x2)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t R x1a x2.\n       \\<lbrakk>bound_typ_inst R (gen ($ S A) ($ S x1a)) =\n                bound_typ_inst\n                 (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n                 ($ S (gen A x1a));\n        bound_typ_inst R (gen ($ S A) ($ S x2)) =\n        bound_typ_inst (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n         ($ S (gen A x2))\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst R (gen ($ S A) ($ S (x1a -> x2))) =\n                         bound_typ_inst\n                          (\\<lambda>a. bound_typ_inst R (gen ($ S A) (S a)))\n                          ($ S (gen A (x1a -> x2)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma free_tv_subset_gen_le: \n  \"free_tv B \\<subseteq> free_tv A \\<Longrightarrow> gen A t \\<le> gen B t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv B \\<subseteq> free_tv A \\<Longrightarrow> gen A t \\<le> gen B t", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. free_tv B \\<subseteq> free_tv A \\<Longrightarrow>\n    \\<forall>ta.\n       (\\<exists>S. ta = bound_typ_inst S (gen A t)) \\<longrightarrow>\n       (\\<exists>S. ta = bound_typ_inst S (gen B t))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta S.\n       free_tv B \\<subseteq> free_tv A \\<Longrightarrow>\n       \\<exists>Sa. bound_typ_inst S (gen A t) = bound_typ_inst Sa (gen B t)", "apply (rename_tac \"S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta S.\n       free_tv B \\<subseteq> free_tv A \\<Longrightarrow>\n       \\<exists>Sa. bound_typ_inst S (gen A t) = bound_typ_inst Sa (gen B t)", "apply (rule_tac x = \"\\<lambda>b. if b:free_tv A then TVar b else S b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta S.\n       free_tv B \\<subseteq> free_tv A \\<Longrightarrow>\n       bound_typ_inst S (gen A t) =\n       bound_typ_inst\n        (\\<lambda>b. if b \\<in> free_tv A then TVar b else S b) (gen B t)", "apply (induct_tac \"t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t S x.\n       free_tv B \\<subseteq> free_tv A \\<Longrightarrow>\n       bound_typ_inst S (gen A (TVar x)) =\n       bound_typ_inst\n        (\\<lambda>b. if b \\<in> free_tv A then TVar b else S b)\n        (gen B (TVar x))\n 2. \\<And>t S x1a x2.\n       \\<lbrakk>free_tv B \\<subseteq> free_tv A;\n        bound_typ_inst S (gen A x1a) =\n        bound_typ_inst\n         (\\<lambda>b. if b \\<in> free_tv A then TVar b else S b)\n         (gen B x1a);\n        bound_typ_inst S (gen A x2) =\n        bound_typ_inst\n         (\\<lambda>b. if b \\<in> free_tv A then TVar b else S b)\n         (gen B x2)\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (x1a -> x2)) =\n                         bound_typ_inst\n                          (\\<lambda>b.\n                              if b \\<in> free_tv A then TVar b else S b)\n                          (gen B (x1a -> x2))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t S x1a x2.\n       \\<lbrakk>free_tv B \\<subseteq> free_tv A;\n        bound_typ_inst S (gen A x1a) =\n        bound_typ_inst\n         (\\<lambda>b. if b \\<in> free_tv A then TVar b else S b)\n         (gen B x1a);\n        bound_typ_inst S (gen A x2) =\n        bound_typ_inst\n         (\\<lambda>b. if b \\<in> free_tv A then TVar b else S b)\n         (gen B x2)\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (x1a -> x2)) =\n                         bound_typ_inst\n                          (\\<lambda>b.\n                              if b \\<in> free_tv A then TVar b else S b)\n                          (gen B (x1a -> x2))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_t_le_gen_alpha_t [rule_format, simp]: \n  \"new_tv n A \\<longrightarrow>  \n   gen A t \\<le> gen A ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x)) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_tv n A \\<longrightarrow>\n    gen A t\n    \\<le> gen A\n           ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x)) t)", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_tv n A \\<longrightarrow>\n    (\\<forall>ta.\n        (\\<exists>S. ta = bound_typ_inst S (gen A t)) \\<longrightarrow>\n        (\\<exists>S.\n            ta =\n            bound_typ_inst S\n             (gen A\n               ($ (\\<lambda>x.\n                      TVar (if x \\<in> free_tv A then x else n + x))\n                 t))))", "apply (intro strip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta.\n       \\<lbrakk>new_tv n A;\n        \\<exists>S. ta = bound_typ_inst S (gen A t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            ta =\n                            bound_typ_inst S\n                             (gen A\n                               ($ (\\<lambda>x.\nTVar (if x \\<in> free_tv A then x else n + x))\n                                 t))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta S.\n       \\<lbrakk>new_tv n A; ta = bound_typ_inst S (gen A t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            ta =\n                            bound_typ_inst S\n                             (gen A\n                               ($ (\\<lambda>x.\nTVar (if x \\<in> free_tv A then x else n + x))\n                                 t))", "apply (hypsubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta S.\n       new_tv n A \\<Longrightarrow>\n       \\<exists>Sa.\n          bound_typ_inst S (gen A t) =\n          bound_typ_inst Sa\n           (gen A\n             ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n               t))", "apply (rule_tac x = \" (\\<lambda>x. S (if n \\<le> x then x - n else x))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta S.\n       new_tv n A \\<Longrightarrow>\n       bound_typ_inst S (gen A t) =\n       bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n        (gen A\n          ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x)) t))", "apply (induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t S.\n       new_tv n A \\<Longrightarrow>\n       bound_typ_inst S (gen A (TVar x)) =\n       bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n        (gen A\n          ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n            (TVar x)))\n 2. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x S.\n       new_tv n A \\<Longrightarrow>\n       x \\<notin> free_tv A \\<longrightarrow>\n       n + x \\<in> free_tv A \\<longrightarrow> S x = TVar (n + x)\n 2. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (rename_tac nat S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat S.\n       new_tv n A \\<Longrightarrow>\n       nat \\<notin> free_tv A \\<longrightarrow>\n       n + nat \\<in> free_tv A \\<longrightarrow> S nat = TVar (n + nat)\n 2. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (case_tac \"nat \\<in> free_tv A\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<in> free_tv A\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv A \\<longrightarrow>\n                         n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv A \\<longrightarrow>\n                         n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 3. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (simp (no_asm_simp))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> nat \\<notin> free_tv A \\<longrightarrow>\n                         n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (simp (no_asm_simp))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (subgoal_tac \"n \\<le> n + nat\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A; n \\<le> n + nat\\<rbrakk>\n       \\<Longrightarrow> n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n + nat\n 3. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (frule_tac t = \"A\" in new_tv_le)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A; n \\<le> n + nat\\<rbrakk>\n       \\<Longrightarrow> new_tv n A\n 2. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A; n \\<le> n + nat;\n        new_tv (n + nat) A\\<rbrakk>\n       \\<Longrightarrow> n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 3. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n + nat\n 4. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A; n \\<le> n + nat;\n        new_tv (n + nat) A\\<rbrakk>\n       \\<Longrightarrow> n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n + nat\n 3. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (drule new_tv_not_free_tv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>nat \\<notin> free_tv A; n \\<le> n + nat; new_tv (n + nat) A;\n        n \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n + nat\n 3. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (drule new_tv_not_free_tv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>nat \\<notin> free_tv A; n \\<le> n + nat;\n        n \\<notin> free_tv A; n + nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n + nat \\<in> free_tv A \\<longrightarrow>\n                         S nat = TVar (n + nat)\n 2. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n + nat\n 3. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (simp add: diff_add_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat S.\n       \\<lbrakk>new_tv n A; nat \\<notin> free_tv A\\<rbrakk>\n       \\<Longrightarrow> n \\<le> n + nat\n 2. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply (simp add: le_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2 t S.\n       \\<lbrakk>\\<And>t S.\n                   new_tv n A \\<Longrightarrow>\n                   bound_typ_inst S (gen A t1) =\n                   bound_typ_inst\n                    (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                    (gen A\n                      ($ (\\<lambda>x.\n                             TVar (if x \\<in> free_tv A then x else n + x))\n                        t1));\n        \\<And>t S.\n           new_tv n A \\<Longrightarrow>\n           bound_typ_inst S (gen A t2) =\n           bound_typ_inst (\\<lambda>x. S (if n \\<le> x then x - n else x))\n            (gen A\n              ($ (\\<lambda>x. TVar (if x \\<in> free_tv A then x else n + x))\n                t2));\n        new_tv n A\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S (gen A (t1 -> t2)) =\n                         bound_typ_inst\n                          (\\<lambda>x. S (if n \\<le> x then x - n else x))\n                          (gen A\n                            ($ (\\<lambda>x.\n                                   TVar\n                                    (if x \\<in> free_tv A then x\n                                     else n + x))\n                              (t1 -> t2)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}