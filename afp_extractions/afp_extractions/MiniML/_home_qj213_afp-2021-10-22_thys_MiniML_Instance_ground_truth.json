{"file_name": "/home/qj213/afp-2021-10-22/thys/MiniML/Instance.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MiniML", "problem_names": ["lemma bound_typ_inst_mk_scheme [simp]: \"bound_typ_inst S (mk_scheme t) = t\"", "lemma bound_typ_inst_composed_subst [simp]:\n    \"bound_typ_inst ($S \\<circ> R) ($S sch) = $S (bound_typ_inst R sch)\"", "lemma bound_typ_inst_eq:\n    \"S = S' \\<Longrightarrow> sch = sch' \\<Longrightarrow> bound_typ_inst S sch = bound_typ_inst S' sch'\"", "lemma bound_scheme_inst_mk_scheme [simp]:\n    \"bound_scheme_inst B (mk_scheme t) = mk_scheme t\"", "lemma substitution_lemma: \"$S (bound_scheme_inst B sch) = (bound_scheme_inst ($S \\<circ> B) ($ S sch))\"", "lemma bound_scheme_inst_type [rule_format]: \"\\<forall>t. mk_scheme t = bound_scheme_inst B sch \\<longrightarrow>  \n          (\\<exists>S. \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x))\"", "lemma subst_to_scheme_inverse: \n  \"new_tv n sch \\<Longrightarrow>\n    subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)  \n      (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch) = sch\"", "lemma aux: \"t = t' \\<Longrightarrow>  \n      subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) t =  \n      subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) t'\"", "lemma aux2: \"new_tv n sch \\<Longrightarrow>\n  subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) (bound_typ_inst S sch) =  \n    bound_scheme_inst ((subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)) \\<circ> S) sch\"", "lemma le_type_scheme_def2:\n  fixes sch sch' :: type_scheme\n  shows \"(sch' \\<le> sch) = (\\<exists>B. sch' = bound_scheme_inst B sch)\"", "lemma le_type_eq_is_bound_typ_instance [rule_format]: \"(mk_scheme t) \\<le> sch = t <| sch\"", "lemma le_env_Cons [iff]: \n  \"(sch # A \\<le> sch' # B) = (sch \\<le> (sch'::type_scheme) \\<and> A \\<le> B)\"", "lemma is_bound_typ_instance_closed_subst: \"t <| sch \\<Longrightarrow> $S t <| $S sch\"", "lemma S_compatible_le_scheme:\n  fixes sch sch' :: type_scheme\n  shows \"sch' \\<le> sch \\<Longrightarrow> $S sch' \\<le> $ S sch\"", "lemma S_compatible_le_scheme_lists: \n  fixes A A' :: \"type_scheme list\"\n  shows \"A' \\<le> A \\<Longrightarrow> $S A' \\<le> $ S A\"", "lemma bound_typ_instance_trans: \"[| t <| sch; sch \\<le> sch' |] ==> t <| sch'\"", "lemma le_type_scheme_refl [iff]: \"sch \\<le> (sch::type_scheme)\"", "lemma le_env_refl [iff]: \"A \\<le> (A::type_scheme list)\"", "lemma bound_typ_instance_BVar [iff]: \"sch \\<le> BVar n\"", "lemma le_FVar [simp]: \"(sch \\<le> FVar n) = (sch = FVar n)\"", "lemma not_FVar_le_Fun [iff]: \"~(FVar n \\<le> sch1 =-> sch2)\"", "lemma not_BVar_le_Fun [iff]: \"~(BVar n \\<le> sch1 =-> sch2)\"", "lemma Fun_le_FunD: \n  \"(sch1 =-> sch2 \\<le> sch1' =-> sch2') \\<Longrightarrow> sch1 \\<le> sch1' \\<and> sch2 \\<le> sch2'\"", "lemma scheme_le_Fun: \"(sch' \\<le> sch1 =-> sch2) \\<Longrightarrow> \\<exists>sch'1 sch'2. sch' = sch'1 =-> sch'2\"", "lemma le_type_scheme_free_tv [rule_format]:\n  \"\\<forall>sch'::type_scheme. sch \\<le> sch' \\<longrightarrow> free_tv sch' \\<le> free_tv sch\"", "lemma le_env_free_tv [rule_format]:\n  \"\\<forall>A::type_scheme list. A \\<le> B \\<longrightarrow> free_tv B \\<le> free_tv A\""], "translations": [["", "lemma bound_typ_inst_mk_scheme [simp]: \"bound_typ_inst S (mk_scheme t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_typ_inst S (mk_scheme t) = t", "by (induct t) simp_all"], ["", "lemma bound_typ_inst_composed_subst [simp]:\n    \"bound_typ_inst ($S \\<circ> R) ($S sch) = $S (bound_typ_inst R sch)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_typ_inst ($ S \\<circ> R) ($ S sch) = $ S (bound_typ_inst R sch)", "by (induct sch) simp_all"], ["", "lemma bound_typ_inst_eq:\n    \"S = S' \\<Longrightarrow> sch = sch' \\<Longrightarrow> bound_typ_inst S sch = bound_typ_inst S' sch'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S = S'; sch = sch'\\<rbrakk>\n    \\<Longrightarrow> bound_typ_inst S sch = bound_typ_inst S' sch'", "by simp"], ["", "lemma bound_scheme_inst_mk_scheme [simp]:\n    \"bound_scheme_inst B (mk_scheme t) = mk_scheme t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_scheme_inst B (mk_scheme t) = mk_scheme t", "by (induct t) simp_all"], ["", "lemma substitution_lemma: \"$S (bound_scheme_inst B sch) = (bound_scheme_inst ($S \\<circ> B) ($ S sch))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. $ S (bound_scheme_inst B sch) =\n    bound_scheme_inst ($ S \\<circ> B) ($ S sch)", "by (induct sch) simp_all"], ["", "lemma bound_scheme_inst_type [rule_format]: \"\\<forall>t. mk_scheme t = bound_scheme_inst B sch \\<longrightarrow>  \n          (\\<exists>S. \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       mk_scheme t = bound_scheme_inst B sch \\<longrightarrow>\n       (\\<exists>S. \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x))", "apply (induct_tac \"sch\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<forall>t.\n          mk_scheme t = bound_scheme_inst B (FVar x) \\<longrightarrow>\n          (\\<exists>S.\n              \\<forall>x\\<in>bound_tv (FVar x). B x = mk_scheme (S x))\n 2. \\<And>x.\n       \\<forall>t.\n          mk_scheme t = bound_scheme_inst B (BVar x) \\<longrightarrow>\n          (\\<exists>S.\n              \\<forall>x\\<in>bound_tv (BVar x). B x = mk_scheme (S x))\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S.\n               \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t.\n                            mk_scheme t =\n                            bound_scheme_inst B\n                             (x1a =-> x2a) \\<longrightarrow>\n                            (\\<exists>S.\n                                \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                                   B x = mk_scheme (S x))", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>t.\n          mk_scheme t = bound_scheme_inst B (BVar x) \\<longrightarrow>\n          (\\<exists>S.\n              \\<forall>x\\<in>bound_tv (BVar x). B x = mk_scheme (S x))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S.\n               \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t.\n                            mk_scheme t =\n                            bound_scheme_inst B\n                             (x1a =-> x2a) \\<longrightarrow>\n                            (\\<exists>S.\n                                \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                                   B x = mk_scheme (S x))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       mk_scheme t = bound_scheme_inst B (BVar x) \\<Longrightarrow>\n       \\<exists>S. \\<forall>x\\<in>bound_tv (BVar x). B x = mk_scheme (S x)\n 2. \\<And>x1a x2a t.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S. \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x));\n        mk_scheme t = bound_scheme_inst B (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                               B x = mk_scheme (S x)", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       mk_scheme t = bound_scheme_inst B (BVar x) \\<Longrightarrow>\n       \\<forall>xa\\<in>bound_tv (BVar x). B xa = mk_scheme (?S12 x t xa)\n 2. \\<And>x1a x2a t.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S. \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x));\n        mk_scheme t = bound_scheme_inst B (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                               B x = mk_scheme (S x)", "apply (rule ballI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t xa.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B (BVar x);\n        xa \\<in> bound_tv (BVar x)\\<rbrakk>\n       \\<Longrightarrow> B xa = mk_scheme (?S12 x t xa)\n 2. \\<And>x1a x2a t.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S. \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x));\n        mk_scheme t = bound_scheme_inst B (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                               B x = mk_scheme (S x)", "apply (rule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t xa.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B (BVar x);\n        xa \\<in> bound_tv (BVar x)\\<rbrakk>\n       \\<Longrightarrow> mk_scheme (?S12 x t xa) = B xa\n 2. \\<And>x1a x2a t.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S. \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x));\n        mk_scheme t = bound_scheme_inst B (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                               B x = mk_scheme (S x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a t.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t = bound_scheme_inst B x1a \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv x1a. B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B x2a \\<longrightarrow>\n           (\\<exists>S. \\<forall>x\\<in>bound_tv x2a. B x = mk_scheme (S x));\n        mk_scheme t = bound_scheme_inst B (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                               B x = mk_scheme (S x)", "apply (rename_tac type_scheme1 type_scheme2 t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t.\n       \\<lbrakk>\\<forall>t.\n                   mk_scheme t =\n                   bound_scheme_inst B type_scheme1 \\<longrightarrow>\n                   (\\<exists>S.\n                       \\<forall>x\\<in>bound_tv type_scheme1.\n                          B x = mk_scheme (S x));\n        \\<forall>t.\n           mk_scheme t = bound_scheme_inst B type_scheme2 \\<longrightarrow>\n           (\\<exists>S.\n               \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        mk_scheme t =\n        bound_scheme_inst B (type_scheme1 =-> type_scheme2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv\n      (type_scheme1 =-> type_scheme2).\n                               B x = mk_scheme (S x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t.\n       \\<lbrakk>(\\<exists>t.\n                    mk_scheme t =\n                    bound_scheme_inst B type_scheme1) \\<longrightarrow>\n                (\\<exists>S.\n                    \\<forall>x\\<in>bound_tv type_scheme1.\n                       B x = mk_scheme (S x));\n        (\\<exists>t.\n            mk_scheme t =\n            bound_scheme_inst B type_scheme2) \\<longrightarrow>\n        (\\<exists>S.\n            \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        mk_scheme t =\n        bound_scheme_inst B type_scheme1 =->\n        bound_scheme_inst B type_scheme2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (drule mk_scheme_Fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t.\n       \\<lbrakk>(\\<exists>t.\n                    mk_scheme t =\n                    bound_scheme_inst B type_scheme1) \\<longrightarrow>\n                (\\<exists>S.\n                    \\<forall>x\\<in>bound_tv type_scheme1.\n                       B x = mk_scheme (S x));\n        (\\<exists>t.\n            mk_scheme t =\n            bound_scheme_inst B type_scheme2) \\<longrightarrow>\n        (\\<exists>S.\n            \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        \\<exists>t1 t2.\n           bound_scheme_inst B type_scheme1 = mk_scheme t1 \\<and>\n           bound_scheme_inst B type_scheme2 = mk_scheme t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2.\n       \\<lbrakk>(\\<exists>t.\n                    mk_scheme t =\n                    bound_scheme_inst B type_scheme1) \\<longrightarrow>\n                (\\<exists>S.\n                    \\<forall>x\\<in>bound_tv type_scheme1.\n                       B x = mk_scheme (S x));\n        (\\<exists>t.\n            mk_scheme t =\n            bound_scheme_inst B type_scheme2) \\<longrightarrow>\n        (\\<exists>S.\n            \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        bound_scheme_inst B type_scheme1 = mk_scheme t1 \\<and>\n        bound_scheme_inst B type_scheme2 = mk_scheme t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2.\n       \\<lbrakk>(\\<exists>t.\n                    mk_scheme t =\n                    bound_scheme_inst B type_scheme1) \\<longrightarrow>\n                (\\<exists>S.\n                    \\<forall>x\\<in>bound_tv type_scheme1.\n                       B x = mk_scheme (S x));\n        (\\<exists>t.\n            mk_scheme t =\n            bound_scheme_inst B type_scheme2) \\<longrightarrow>\n        (\\<exists>S.\n            \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        bound_scheme_inst B type_scheme1 = mk_scheme t1;\n        bound_scheme_inst B type_scheme2 = mk_scheme t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2.\n       \\<lbrakk>(\\<exists>t.\n                    mk_scheme t =\n                    bound_scheme_inst B type_scheme1) \\<longrightarrow>\n                (\\<exists>S.\n                    \\<forall>x\\<in>bound_tv type_scheme1.\n                       B x = mk_scheme (S x));\n        (\\<exists>t.\n            mk_scheme t =\n            bound_scheme_inst B type_scheme2) \\<longrightarrow>\n        (\\<exists>S.\n            \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        bound_scheme_inst B type_scheme2 = mk_scheme t2;\n        mk_scheme t1 = bound_scheme_inst B type_scheme1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2.\n       \\<lbrakk>(\\<exists>t.\n                    mk_scheme t =\n                    bound_scheme_inst B type_scheme1) \\<longrightarrow>\n                (\\<exists>S.\n                    \\<forall>x\\<in>bound_tv type_scheme1.\n                       B x = mk_scheme (S x));\n        (\\<exists>t.\n            mk_scheme t =\n            bound_scheme_inst B type_scheme2) \\<longrightarrow>\n        (\\<exists>S.\n            \\<forall>x\\<in>bound_tv type_scheme2. B x = mk_scheme (S x));\n        mk_scheme t1 = bound_scheme_inst B type_scheme1;\n        mk_scheme t2 = bound_scheme_inst B type_scheme2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (drule mp, fast)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2.\n       \\<lbrakk>mk_scheme t1 = bound_scheme_inst B type_scheme1;\n        mk_scheme t2 = bound_scheme_inst B type_scheme2;\n        \\<exists>S.\n           \\<forall>x\\<in>bound_tv type_scheme1. B x = mk_scheme (S x);\n        \\<exists>S.\n           \\<forall>x\\<in>bound_tv type_scheme2.\n              B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2 S Sa.\n       \\<lbrakk>mk_scheme t1 = bound_scheme_inst B type_scheme1;\n        mk_scheme t2 = bound_scheme_inst B type_scheme2;\n        \\<forall>x\\<in>bound_tv type_scheme1. B x = mk_scheme (S x);\n        \\<forall>x\\<in>bound_tv type_scheme2.\n           B x = mk_scheme (Sa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (rename_tac S1 S2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2 S1 S2.\n       \\<lbrakk>mk_scheme t1 = bound_scheme_inst B type_scheme1;\n        mk_scheme t2 = bound_scheme_inst B type_scheme2;\n        \\<forall>x\\<in>bound_tv type_scheme1. B x = mk_scheme (S1 x);\n        \\<forall>x\\<in>bound_tv type_scheme2.\n           B x = mk_scheme (S2 x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n     bound_tv type_scheme2.\n                               B x = mk_scheme (S x)", "apply (rule_tac x = \"\\<lambda>x. if x:bound_tv type_scheme1 then (S1 x) else (S2 x) \" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>type_scheme1 type_scheme2 t t1 t2 S1 S2.\n       \\<lbrakk>mk_scheme t1 = bound_scheme_inst B type_scheme1;\n        mk_scheme t2 = bound_scheme_inst B type_scheme2;\n        \\<forall>x\\<in>bound_tv type_scheme1. B x = mk_scheme (S1 x);\n        \\<forall>x\\<in>bound_tv type_scheme2.\n           B x = mk_scheme (S2 x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>bound_tv type_scheme1 \\<union>\n  bound_tv type_scheme2.\n                            B x =\n                            mk_scheme\n                             (if x \\<in> bound_tv type_scheme1 then S1 x\n                              else S2 x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_to_scheme_inverse: \n  \"new_tv n sch \\<Longrightarrow>\n    subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)  \n      (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch) = sch\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_tv n sch \\<Longrightarrow>\n    subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n     (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch) =\n    sch", "apply (induct sch)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       new_tv n (FVar x) \\<Longrightarrow>\n       subst_to_scheme\n        (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n        (bound_typ_inst (\\<lambda>k. TVar (k + n)) (FVar x)) =\n       FVar x\n 2. \\<And>x.\n       new_tv n (BVar x) \\<Longrightarrow>\n       subst_to_scheme\n        (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n        (bound_typ_inst (\\<lambda>k. TVar (k + n)) (BVar x)) =\n       BVar x\n 3. \\<And>sch1 sch2.\n       \\<lbrakk>new_tv n sch1 \\<Longrightarrow>\n                subst_to_scheme\n                 (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n                 (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch1) =\n                sch1;\n        new_tv n sch2 \\<Longrightarrow>\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch2) =\n        sch2;\n        new_tv n (sch1 =-> sch2)\\<rbrakk>\n       \\<Longrightarrow> subst_to_scheme\n                          (\\<lambda>k.\n                              if n \\<le> k then BVar (k - n) else FVar k)\n                          (bound_typ_inst (\\<lambda>k. TVar (k + n))\n                            (sch1 =-> sch2)) =\n                         sch1 =-> sch2", "apply (simp add: not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       new_tv n (BVar x) \\<Longrightarrow>\n       subst_to_scheme\n        (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n        (bound_typ_inst (\\<lambda>k. TVar (k + n)) (BVar x)) =\n       BVar x\n 2. \\<And>sch1 sch2.\n       \\<lbrakk>new_tv n sch1 \\<Longrightarrow>\n                subst_to_scheme\n                 (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n                 (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch1) =\n                sch1;\n        new_tv n sch2 \\<Longrightarrow>\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch2) =\n        sch2;\n        new_tv n (sch1 =-> sch2)\\<rbrakk>\n       \\<Longrightarrow> subst_to_scheme\n                          (\\<lambda>k.\n                              if n \\<le> k then BVar (k - n) else FVar k)\n                          (bound_typ_inst (\\<lambda>k. TVar (k + n))\n                            (sch1 =-> sch2)) =\n                         sch1 =-> sch2", "apply (simp add: le_add2 diff_add_inverse2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sch1 sch2.\n       \\<lbrakk>new_tv n sch1 \\<Longrightarrow>\n                subst_to_scheme\n                 (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n                 (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch1) =\n                sch1;\n        new_tv n sch2 \\<Longrightarrow>\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch2) =\n        sch2;\n        new_tv n (sch1 =-> sch2)\\<rbrakk>\n       \\<Longrightarrow> subst_to_scheme\n                          (\\<lambda>k.\n                              if n \\<le> k then BVar (k - n) else FVar k)\n                          (bound_typ_inst (\\<lambda>k. TVar (k + n))\n                            (sch1 =-> sch2)) =\n                         sch1 =-> sch2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aux: \"t = t' \\<Longrightarrow>  \n      subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) t =  \n      subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = t' \\<Longrightarrow>\n    subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n     t =\n    subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n     t'", "by blast"], ["", "lemma aux2: \"new_tv n sch \\<Longrightarrow>\n  subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) (bound_typ_inst S sch) =  \n    bound_scheme_inst ((subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)) \\<circ> S) sch\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_tv n sch \\<Longrightarrow>\n    subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n     (bound_typ_inst S sch) =\n    bound_scheme_inst\n     (subst_to_scheme\n       (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k) \\<circ>\n      S)\n     sch", "by (induct sch) auto"], ["", "lemma le_type_scheme_def2:\n  fixes sch sch' :: type_scheme\n  shows \"(sch' \\<le> sch) = (\\<exists>B. sch' = bound_scheme_inst B sch)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sch' \\<le> sch) = (\\<exists>B. sch' = bound_scheme_inst B sch)", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n        (\\<exists>S. t = bound_typ_inst S sch)) =\n    (\\<exists>B. sch' = bound_scheme_inst B sch)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch) \\<Longrightarrow>\n    \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (cut_tac sch = \"sch\" in fresh_variable_type_schemes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t.\n                (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                (\\<exists>S. t = bound_typ_inst S sch);\n     \\<exists>n. new_tv n sch\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (cut_tac sch = \"sch'\" in fresh_variable_type_schemes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t.\n                (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                (\\<exists>S. t = bound_typ_inst S sch);\n     \\<exists>n. new_tv n sch; \\<exists>n. new_tv n sch'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (drule make_one_new_out_of_two)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>t.\n                (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                (\\<exists>S. t = bound_typ_inst S sch);\n     \\<exists>n. new_tv n sch'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n2. new_tv n2 ?y7\n 2. \\<lbrakk>\\<forall>t.\n                (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                (\\<exists>S. t = bound_typ_inst S sch);\n     \\<exists>n. new_tv n sch';\n     \\<exists>n. new_tv n sch \\<and> new_tv n ?y7\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 3. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t.\n                (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                (\\<exists>S. t = bound_typ_inst S sch);\n     \\<exists>n. new_tv n sch';\n     \\<exists>n. new_tv n sch \\<and> new_tv n sch'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (erule_tac V = \"\\<exists>n. new_tv n sch'\" in thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t.\n                (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                (\\<exists>S. t = bound_typ_inst S sch);\n     \\<exists>n. new_tv n sch \\<and> new_tv n sch'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>t.\n                   (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n                   (\\<exists>S. t = bound_typ_inst S sch);\n        new_tv n sch \\<and> new_tv n sch'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (erule allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>new_tv n sch \\<and> new_tv n sch';\n        (\\<exists>S. ?t13 n = bound_typ_inst S sch') \\<longrightarrow>\n        (\\<exists>S. ?t13 n = bound_typ_inst S sch)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       new_tv n sch \\<and> new_tv n sch' \\<Longrightarrow>\n       \\<exists>S. ?t13 n = bound_typ_inst S sch'\n 2. \\<And>n.\n       \\<lbrakk>new_tv n sch \\<and> new_tv n sch';\n        \\<exists>S. ?t13 n = bound_typ_inst S sch\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 3. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (rule_tac x = \" (\\<lambda>k. TVar (k + n))\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       new_tv n sch \\<and> new_tv n sch' \\<Longrightarrow>\n       ?t13 n = bound_typ_inst (\\<lambda>k. TVar (k + n)) sch'\n 2. \\<And>n.\n       \\<lbrakk>new_tv n sch \\<and> new_tv n sch';\n        \\<exists>S. ?t13 n = bound_typ_inst S sch\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 3. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>new_tv n sch \\<and> new_tv n sch';\n        \\<exists>S.\n           bound_typ_inst (\\<lambda>k. TVar (k + n)) sch' =\n           bound_typ_inst S sch\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>new_tv n sch \\<and> new_tv n sch';\n        bound_typ_inst (\\<lambda>k. TVar (k + n)) sch' =\n        bound_typ_inst S sch\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (erule conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>bound_typ_inst (\\<lambda>k. TVar (k + n)) sch' =\n                bound_typ_inst S sch;\n        new_tv n sch; new_tv n sch'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (drule_tac n = \"n\" in aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>new_tv n sch; new_tv n sch';\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst (\\<lambda>k. TVar (k + n)) sch') =\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst S sch)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. sch' = bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (simp add: subst_to_scheme_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>new_tv n sch;\n        new_tv n\n         (subst_to_scheme\n           (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n           (bound_typ_inst S sch));\n        sch' =\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst S sch)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            subst_to_scheme\n                             (\\<lambda>k.\n                                 if n \\<le> k then BVar (k - n) else FVar k)\n                             (bound_typ_inst S sch) =\n                            bound_scheme_inst B sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (rule_tac x = \" (subst_to_scheme (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)) \\<circ> S\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>new_tv n sch;\n        new_tv n\n         (subst_to_scheme\n           (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n           (bound_typ_inst S sch));\n        sch' =\n        subst_to_scheme\n         (\\<lambda>k. if n \\<le> k then BVar (k - n) else FVar k)\n         (bound_typ_inst S sch)\\<rbrakk>\n       \\<Longrightarrow> subst_to_scheme\n                          (\\<lambda>k.\n                              if n \\<le> k then BVar (k - n) else FVar k)\n                          (bound_typ_inst S sch) =\n                         bound_scheme_inst\n                          (subst_to_scheme\n                            (\\<lambda>k.\n                                if n \\<le> k then BVar (k - n)\n                                else FVar k) \\<circ>\n                           S)\n                          sch\n 2. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply (simp (no_asm_simp) add: aux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch') \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S sch)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B t S.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       \\<exists>Sa.\n          bound_typ_inst S (bound_scheme_inst B sch) = bound_typ_inst Sa sch", "apply (rule_tac x = \"\\<lambda>n. bound_typ_inst S (B n) \" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B t S.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       bound_typ_inst S (bound_scheme_inst B sch) =\n       bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) sch", "apply (induct_tac \"sch\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B t S x.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       bound_typ_inst S (bound_scheme_inst B (FVar x)) =\n       bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) (FVar x)\n 2. \\<And>B t S x.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       bound_typ_inst S (bound_scheme_inst B (BVar x)) =\n       bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) (BVar x)\n 3. \\<And>B t S x1a x2a.\n       \\<lbrakk>sch' = bound_scheme_inst B sch;\n        bound_typ_inst S (bound_scheme_inst B x1a) =\n        bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) x1a;\n        bound_typ_inst S (bound_scheme_inst B x2a) =\n        bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) x2a\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S\n                          (bound_scheme_inst B (x1a =-> x2a)) =\n                         bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n))\n                          (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B t S x.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       bound_typ_inst S (bound_scheme_inst B (BVar x)) =\n       bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) (BVar x)\n 2. \\<And>B t S x1a x2a.\n       \\<lbrakk>sch' = bound_scheme_inst B sch;\n        bound_typ_inst S (bound_scheme_inst B x1a) =\n        bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) x1a;\n        bound_typ_inst S (bound_scheme_inst B x2a) =\n        bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) x2a\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S\n                          (bound_scheme_inst B (x1a =-> x2a)) =\n                         bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n))\n                          (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B t S x1a x2a.\n       \\<lbrakk>sch' = bound_scheme_inst B sch;\n        bound_typ_inst S (bound_scheme_inst B x1a) =\n        bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) x1a;\n        bound_typ_inst S (bound_scheme_inst B x2a) =\n        bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n)) x2a\\<rbrakk>\n       \\<Longrightarrow> bound_typ_inst S\n                          (bound_scheme_inst B (x1a =-> x2a)) =\n                         bound_typ_inst (\\<lambda>n. bound_typ_inst S (B n))\n                          (x1a =-> x2a)", "apply (simp (no_asm_simp))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_type_eq_is_bound_typ_instance [rule_format]: \"(mk_scheme t) \\<le> sch = t <| sch\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_scheme t \\<le> sch) = t <| sch", "apply (unfold is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_scheme t \\<le> sch) = (\\<exists>S. t = bound_typ_inst S sch)", "apply (simp (no_asm) add: le_type_scheme_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>B. mk_scheme t = bound_scheme_inst B sch) =\n    (\\<exists>S. t = bound_typ_inst S sch)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>B. mk_scheme t = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<exists>S. t = bound_typ_inst S sch\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B.\n       mk_scheme t = bound_scheme_inst B sch \\<Longrightarrow>\n       \\<exists>S. t = bound_typ_inst S sch\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (frule bound_scheme_inst_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B sch;\n        \\<exists>S.\n           \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. t = bound_typ_inst S sch\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B sch;\n        \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S. t = bound_typ_inst S sch\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B sch;\n        \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> t = bound_typ_inst (?S9 B S) sch\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (rule mk_scheme_injective)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B sch;\n        \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> mk_scheme t =\n                         mk_scheme (bound_typ_inst (?S9 B S) sch)\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>mk_scheme t = bound_scheme_inst B sch;\n        \\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> bound_scheme_inst B sch =\n                         mk_scheme (bound_typ_inst (?S9 B S) sch)\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> bound_scheme_inst B sch =\n                         mk_scheme (bound_typ_inst (?S9 B S) sch)\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (rule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> ?P13 B S \\<longrightarrow>\n                         bound_scheme_inst B sch =\n                         mk_scheme (bound_typ_inst (?S9 B S) sch)\n 2. \\<And>B S.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> ?P13 B S\n 3. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> ?P13 B S\n 2. \\<And>B S.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> ?P13 B S \\<longrightarrow>\n                         bound_scheme_inst B sch =\n                         mk_scheme (bound_typ_inst (?S9 B S) sch)\n 3. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv sch.\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B sch =\n                         mk_scheme (bound_typ_inst (?S9 B S) sch)\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (induct_tac \"sch\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>B S x.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (FVar x).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (FVar x) =\n                         mk_scheme\n                          (bound_typ_inst (?S17 B S (FVar x)) (FVar x))\n 2. \\<And>B S x.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (BVar x).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (BVar x) =\n                         mk_scheme\n                          (bound_typ_inst (?S17 B S (BVar x)) (BVar x))\n 3. \\<And>B S x1a x2a.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch;\n        (\\<forall>x\\<in>bound_tv x1a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x1a =\n        mk_scheme (bound_typ_inst (?S17 B S x1a) x1a);\n        (\\<forall>x\\<in>bound_tv x2a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x2a =\n        mk_scheme (bound_typ_inst (?S17 B S x2a) x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (x1a =-> x2a) =\n                         mk_scheme\n                          (bound_typ_inst (?S17 B S (x1a =-> x2a))\n                            (x1a =-> x2a))\n 4. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (simp (no_asm))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B S x.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (BVar x).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (BVar x) =\n                         mk_scheme\n                          (bound_typ_inst (?S17 B S (BVar x)) (BVar x))\n 2. \\<And>B S x1a x2a.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch;\n        (\\<forall>x\\<in>bound_tv x1a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x1a =\n        mk_scheme (bound_typ_inst (?S17 B S x1a) x1a);\n        (\\<forall>x\\<in>bound_tv x2a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x2a =\n        mk_scheme (bound_typ_inst (?S17 B S x2a) x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (x1a =-> x2a) =\n                         mk_scheme\n                          (bound_typ_inst (?S17 B S (x1a =-> x2a))\n                            (x1a =-> x2a))\n 3. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B S x.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch\\<rbrakk>\n       \\<Longrightarrow> B x = mk_scheme (S x) \\<longrightarrow>\n                         mk_scheme (S x) = mk_scheme (?S17 B S (BVar x) x)\n 2. \\<And>B S x1a x2a.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch;\n        (\\<forall>x\\<in>bound_tv x1a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x1a =\n        mk_scheme (bound_typ_inst (?S17 B S x1a) x1a);\n        (\\<forall>x\\<in>bound_tv x2a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x2a =\n        mk_scheme (bound_typ_inst (?S17 B S x2a) x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (x1a =-> x2a) =\n                         mk_scheme\n                          (bound_typ_inst (?S17 B S (x1a =-> x2a))\n                            (x1a =-> x2a))\n 3. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S x1a x2a.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch;\n        (\\<forall>x\\<in>bound_tv x1a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x1a = mk_scheme (bound_typ_inst S x1a);\n        (\\<forall>x\\<in>bound_tv x2a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x2a = mk_scheme (bound_typ_inst S x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>bound_tv (x1a =-> x2a).\n                             B x = mk_scheme (S x)) \\<longrightarrow>\n                         bound_scheme_inst B (x1a =-> x2a) =\n                         mk_scheme (bound_typ_inst S (x1a =-> x2a))\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (intro strip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B S x1a x2a.\n       \\<lbrakk>\\<forall>x\\<in>bound_tv sch. B x = mk_scheme (S x);\n        mk_scheme t = bound_scheme_inst B sch;\n        (\\<forall>x\\<in>bound_tv x1a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x1a = mk_scheme (bound_typ_inst S x1a);\n        (\\<forall>x\\<in>bound_tv x2a.\n            B x = mk_scheme (S x)) \\<longrightarrow>\n        bound_scheme_inst B x2a = mk_scheme (bound_typ_inst S x2a);\n        \\<forall>x\\<in>bound_tv (x1a =-> x2a).\n           B x = mk_scheme (S x)\\<rbrakk>\n       \\<Longrightarrow> bound_scheme_inst B (x1a =-> x2a) =\n                         mk_scheme (bound_typ_inst S (x1a =-> x2a))\n 2. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       t = bound_typ_inst S sch \\<Longrightarrow>\n       \\<exists>B. mk_scheme t = bound_scheme_inst B sch", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       t = bound_typ_inst S sch \\<Longrightarrow>\n       \\<exists>B.\n          mk_scheme (bound_typ_inst S sch) = bound_scheme_inst B sch", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       t = bound_typ_inst S sch \\<Longrightarrow>\n       mk_scheme (bound_typ_inst S sch) = bound_scheme_inst (?B38 S) sch", "apply (induct_tac \"sch\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S x.\n       t = bound_typ_inst S sch \\<Longrightarrow>\n       mk_scheme (bound_typ_inst S (FVar x)) =\n       bound_scheme_inst (?B41 S (FVar x)) (FVar x)\n 2. \\<And>S x.\n       t = bound_typ_inst S sch \\<Longrightarrow>\n       mk_scheme (bound_typ_inst S (BVar x)) =\n       bound_scheme_inst (?B41 S (BVar x)) (BVar x)\n 3. \\<And>S x1a x2a.\n       \\<lbrakk>t = bound_typ_inst S sch;\n        mk_scheme (bound_typ_inst S x1a) =\n        bound_scheme_inst (?B41 S x1a) x1a;\n        mk_scheme (bound_typ_inst S x2a) =\n        bound_scheme_inst (?B41 S x2a) x2a\\<rbrakk>\n       \\<Longrightarrow> mk_scheme (bound_typ_inst S (x1a =-> x2a)) =\n                         bound_scheme_inst (?B41 S (x1a =-> x2a))\n                          (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x.\n       t = bound_typ_inst S sch \\<Longrightarrow>\n       mk_scheme (bound_typ_inst S (BVar x)) =\n       bound_scheme_inst (?B41 S (BVar x)) (BVar x)\n 2. \\<And>S x1a x2a.\n       \\<lbrakk>t = bound_typ_inst S sch;\n        mk_scheme (bound_typ_inst S x1a) =\n        bound_scheme_inst (?B41 S x1a) x1a;\n        mk_scheme (bound_typ_inst S x2a) =\n        bound_scheme_inst (?B41 S x2a) x2a\\<rbrakk>\n       \\<Longrightarrow> mk_scheme (bound_typ_inst S (x1a =-> x2a)) =\n                         bound_scheme_inst (?B41 S (x1a =-> x2a))\n                          (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x1a x2a.\n       \\<lbrakk>t = bound_typ_inst S sch;\n        mk_scheme (bound_typ_inst S x1a) =\n        bound_scheme_inst (\\<lambda>a. mk_scheme (S a)) x1a;\n        mk_scheme (bound_typ_inst S x2a) =\n        bound_scheme_inst (\\<lambda>a. mk_scheme (S a)) x2a\\<rbrakk>\n       \\<Longrightarrow> mk_scheme (bound_typ_inst S (x1a =-> x2a)) =\n                         bound_scheme_inst (\\<lambda>a. mk_scheme (S a))\n                          (x1a =-> x2a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_env_Cons [iff]: \n  \"(sch # A \\<le> sch' # B) = (sch \\<le> (sch'::type_scheme) \\<and> A \\<le> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sch # A \\<le> sch' # B) = (sch \\<le> sch' \\<and> A \\<le> B)", "apply (unfold le_env_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (sch' # B) = length (sch # A) \\<and>\n     (\\<forall>i<length (sch # A). (sch # A) ! i \\<le> (sch' # B) ! i)) =\n    (sch \\<le> sch' \\<and>\n     length B = length A \\<and> (\\<forall>i<length A. A ! i \\<le> B ! i))", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length B = length A \\<and>\n     (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)) =\n    (sch \\<le> sch' \\<and>\n     length B = length A \\<and> (\\<forall>i<length A. A ! i \\<le> B ! i))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length B = length A \\<and>\n    (\\<forall>i<Suc (length A).\n        (sch # A) ! i \\<le> (sch' # B) ! i) \\<Longrightarrow>\n    sch \\<le> sch' \\<and>\n    length B = length A \\<and> (\\<forall>i<length A. A ! i \\<le> B ! i)\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length B = length A;\n     \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i\\<rbrakk>\n    \\<Longrightarrow> sch \\<le> sch' \\<and>\n                      length B = length A \\<and>\n                      (\\<forall>i<length A. A ! i \\<le> B ! i)\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length B = length A;\n     \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i\\<rbrakk>\n    \\<Longrightarrow> sch \\<le> sch'\n 2. \\<lbrakk>length B = length A;\n     \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i\\<rbrakk>\n    \\<Longrightarrow> length B = length A \\<and>\n                      (\\<forall>i<length A. A ! i \\<le> B ! i)\n 3. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply (erule_tac x = \"0\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length B = length A;\n     0 < Suc (length A) \\<longrightarrow>\n     (sch # A) ! 0 \\<le> (sch' # B) ! 0\\<rbrakk>\n    \\<Longrightarrow> sch \\<le> sch'\n 2. \\<lbrakk>length B = length A;\n     \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i\\<rbrakk>\n    \\<Longrightarrow> length B = length A \\<and>\n                      (\\<forall>i<length A. A ! i \\<le> B ! i)\n 3. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length B = length A;\n     \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i\\<rbrakk>\n    \\<Longrightarrow> length B = length A \\<and>\n                      (\\<forall>i<length A. A ! i \\<le> B ! i)\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply (rule conjI, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length B = length A;\n     \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length A. A ! i \\<le> B ! i\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length B = length A;\n        \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i;\n        i < length A\\<rbrakk>\n       \\<Longrightarrow> A ! i \\<le> B ! i\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply (erule_tac x = \"Suc i\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>length B = length A; i < length A;\n        Suc i < Suc (length A) \\<longrightarrow>\n        (sch # A) ! Suc i \\<le> (sch' # B) ! Suc i\\<rbrakk>\n       \\<Longrightarrow> A ! i \\<le> B ! i\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A \\<and>\n    (\\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    length B = length A\n 2. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. sch \\<le> sch' \\<and>\n    length B = length A \\<and>\n    (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n    \\<forall>i<Suc (length A). (sch # A) ! i \\<le> (sch' # B) ! i", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       sch \\<le> sch' \\<and>\n       length B = length A \\<and>\n       (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n       i < Suc (length A) \\<longrightarrow>\n       (sch # A) ! i \\<le> (sch' # B) ! i", "apply (induct_tac \"i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       sch \\<le> sch' \\<and>\n       length B = length A \\<and>\n       (\\<forall>i<length A. A ! i \\<le> B ! i) \\<Longrightarrow>\n       0 < Suc (length A) \\<longrightarrow>\n       (sch # A) ! 0 \\<le> (sch' # B) ! 0\n 2. \\<And>i n.\n       \\<lbrakk>sch \\<le> sch' \\<and>\n                length B = length A \\<and>\n                (\\<forall>i<length A. A ! i \\<le> B ! i);\n        n < Suc (length A) \\<longrightarrow>\n        (sch # A) ! n \\<le> (sch' # B) ! n\\<rbrakk>\n       \\<Longrightarrow> Suc n < Suc (length A) \\<longrightarrow>\n                         (sch # A) ! Suc n \\<le> (sch' # B) ! Suc n", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_bound_typ_instance_closed_subst: \"t <| sch \\<Longrightarrow> $S t <| $S sch\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t <| sch \\<Longrightarrow> $ S t <| $ S sch", "apply (unfold is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n    \\<exists>Sa. $ S t = bound_typ_inst Sa ($ S sch)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa.\n       t = bound_typ_inst Sa sch \\<Longrightarrow>\n       \\<exists>Sa. $ S t = bound_typ_inst Sa ($ S sch)", "apply (rename_tac \"SA\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>SA.\n       t = bound_typ_inst SA sch \\<Longrightarrow>\n       \\<exists>Sa. $ S t = bound_typ_inst Sa ($ S sch)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>SA.\n       t = bound_typ_inst SA sch \\<Longrightarrow>\n       \\<exists>Sa.\n          $ S (bound_typ_inst SA sch) = bound_typ_inst Sa ($ S sch)", "apply (rule_tac x = \"$S \\<circ> SA\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>SA.\n       t = bound_typ_inst SA sch \\<Longrightarrow>\n       $ S (bound_typ_inst SA sch) =\n       bound_typ_inst ($ S \\<circ> SA) ($ S sch)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma S_compatible_le_scheme:\n  fixes sch sch' :: type_scheme\n  shows \"sch' \\<le> sch \\<Longrightarrow> $S sch' \\<le> $ S sch\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sch' \\<le> sch \\<Longrightarrow> $ S sch' \\<le> $ S sch", "apply (simp add: le_type_scheme_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. sch' = bound_scheme_inst B sch \\<Longrightarrow>\n    \\<exists>B. $ S sch' = bound_scheme_inst B ($ S sch)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       \\<exists>B. $ S sch' = bound_scheme_inst B ($ S sch)", "apply (simp add: substitution_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       sch' = bound_scheme_inst B sch \\<Longrightarrow>\n       \\<exists>Ba.\n          bound_scheme_inst ($ S \\<circ> B) ($ S sch) =\n          bound_scheme_inst Ba ($ S sch)", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma S_compatible_le_scheme_lists: \n  fixes A A' :: \"type_scheme list\"\n  shows \"A' \\<le> A \\<Longrightarrow> $S A' \\<le> $ S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<le> A \\<Longrightarrow> $ S A' \\<le> $ S A", "apply (unfold le_env_def app_subst_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length A = length A' \\<and>\n    (\\<forall>i<length A'. A' ! i \\<le> A ! i) \\<Longrightarrow>\n    length (map ($ S) A) = length (map ($ S) A') \\<and>\n    (\\<forall>i<length (map ($ S) A').\n        map ($ S) A' ! i \\<le> map ($ S) A ! i)", "apply (simp cong add: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length A = length A' \\<and>\n    (\\<forall>i<length A'. A' ! i \\<le> A ! i) \\<Longrightarrow>\n    \\<forall>i<length A'. $ S (A' ! i) \\<le> $ S (A ! i)", "apply (fast intro!: S_compatible_le_scheme)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bound_typ_instance_trans: \"[| t <| sch; sch \\<le> sch' |] ==> t <| sch'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t <| sch; sch \\<le> sch'\\<rbrakk> \\<Longrightarrow> t <| sch'", "unfolding le_type_scheme_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t <| sch;\n     \\<forall>t. t <| sch \\<longrightarrow> t <| sch'\\<rbrakk>\n    \\<Longrightarrow> t <| sch'", "by blast"], ["", "lemma le_type_scheme_refl [iff]: \"sch \\<le> (sch::type_scheme)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sch \\<le> sch", "unfolding le_type_scheme_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t. t <| sch \\<longrightarrow> t <| sch", "by blast"], ["", "lemma le_env_refl [iff]: \"A \\<le> (A::type_scheme list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> A", "unfolding le_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length A = length A \\<and> (\\<forall>i<length A. A ! i \\<le> A ! i)", "by blast"], ["", "lemma bound_typ_instance_BVar [iff]: \"sch \\<le> BVar n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sch \\<le> BVar n", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S sch) \\<longrightarrow>\n       (\\<exists>S. t = bound_typ_inst S (BVar n))", "apply (intro strip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n       \\<exists>S. t = bound_typ_inst S (BVar n)", "apply (rule_tac x = \"\\<lambda>a. t\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<exists>S. t = bound_typ_inst S sch \\<Longrightarrow>\n       t = bound_typ_inst (\\<lambda>a. t) (BVar n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_FVar [simp]: \"(sch \\<le> FVar n) = (sch = FVar n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sch \\<le> FVar n) = (sch = FVar n)", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        (\\<exists>S. t = bound_typ_inst S sch) \\<longrightarrow>\n        (\\<exists>S. t = bound_typ_inst S (FVar n))) =\n    (sch = FVar n)", "apply (induct_tac \"sch\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       (\\<forall>t.\n           (\\<exists>S. t = bound_typ_inst S (FVar x)) \\<longrightarrow>\n           (\\<exists>S. t = bound_typ_inst S (FVar n))) =\n       (FVar x = FVar n)\n 2. \\<And>x.\n       (\\<forall>t.\n           (\\<exists>S. t = bound_typ_inst S (BVar x)) \\<longrightarrow>\n           (\\<exists>S. t = bound_typ_inst S (FVar n))) =\n       (BVar x = FVar n)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>(\\<forall>t.\n                    (\\<exists>S. t = bound_typ_inst S x1a) \\<longrightarrow>\n                    (\\<exists>S. t = bound_typ_inst S (FVar n))) =\n                (x1a = FVar n);\n        (\\<forall>t.\n            (\\<exists>S. t = bound_typ_inst S x2a) \\<longrightarrow>\n            (\\<exists>S. t = bound_typ_inst S (FVar n))) =\n        (x2a = FVar n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>t.\n                             (\\<exists>S.\n                                 t =\n                                 bound_typ_inst S\n                                  (x1a =-> x2a)) \\<longrightarrow>\n                             (\\<exists>S. t = bound_typ_inst S (FVar n))) =\n                         (x1a =-> x2a = FVar n)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_FVar_le_Fun [iff]: \"~(FVar n \\<le> sch1 =-> sch2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> FVar n \\<le> sch1 =-> sch2", "unfolding le_type_scheme_def is_bound_typ_instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               (\\<exists>S. t = bound_typ_inst S (FVar n)) \\<longrightarrow>\n               (\\<exists>S. t = bound_typ_inst S (sch1 =-> sch2)))", "by simp"], ["", "lemma not_BVar_le_Fun [iff]: \"~(BVar n \\<le> sch1 =-> sch2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> BVar n \\<le> sch1 =-> sch2", "apply (unfold le_type_scheme_def is_bound_typ_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               (\\<exists>S. t = bound_typ_inst S (BVar n)) \\<longrightarrow>\n               (\\<exists>S. t = bound_typ_inst S (sch1 =-> sch2)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<exists>S. t = S n) \\<and>\n       (\\<forall>S.\n           t \\<noteq> bound_typ_inst S sch1 -> bound_typ_inst S sch2)", "apply (rule_tac x = \"TVar n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>S. TVar n = S n) \\<and>\n    (\\<forall>S.\n        TVar n \\<noteq> bound_typ_inst S sch1 -> bound_typ_inst S sch2)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Fun_le_FunD: \n  \"(sch1 =-> sch2 \\<le> sch1' =-> sch2') \\<Longrightarrow> sch1 \\<le> sch1' \\<and> sch2 \\<le> sch2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sch1 =-> sch2 \\<le> sch1' =-> sch2' \\<Longrightarrow>\n    sch1 \\<le> sch1' \\<and> sch2 \\<le> sch2'", "unfolding le_type_scheme_def is_bound_typ_instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       (\\<exists>S. t = bound_typ_inst S (sch1 =-> sch2)) \\<longrightarrow>\n       (\\<exists>S.\n           t = bound_typ_inst S (sch1' =-> sch2')) \\<Longrightarrow>\n    (\\<forall>t.\n        (\\<exists>S. t = bound_typ_inst S sch1) \\<longrightarrow>\n        (\\<exists>S. t = bound_typ_inst S sch1')) \\<and>\n    (\\<forall>t.\n        (\\<exists>S. t = bound_typ_inst S sch2) \\<longrightarrow>\n        (\\<exists>S. t = bound_typ_inst S sch2'))", "by fastforce"], ["", "lemma scheme_le_Fun: \"(sch' \\<le> sch1 =-> sch2) \\<Longrightarrow> \\<exists>sch'1 sch'2. sch' = sch'1 =-> sch'2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sch' \\<le> sch1 =-> sch2 \\<Longrightarrow>\n    \\<exists>sch'1 sch'2. sch' = sch'1 =-> sch'2", "by (induct sch') auto"], ["", "lemma le_type_scheme_free_tv [rule_format]:\n  \"\\<forall>sch'::type_scheme. sch \\<le> sch' \\<longrightarrow> free_tv sch' \\<le> free_tv sch\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sch'\\<ge>sch. free_tv sch' \\<subseteq> free_tv sch", "apply (induct_tac \"sch\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<forall>sch'\\<ge>FVar x. free_tv sch' \\<subseteq> free_tv (FVar x)\n 2. \\<And>x.\n       \\<forall>sch'\\<ge>BVar x. free_tv sch' \\<subseteq> free_tv (BVar x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (rule allI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x sch'.\n       FVar x \\<le> sch' \\<longrightarrow>\n       free_tv sch' \\<subseteq> free_tv (FVar x)\n 2. \\<And>x.\n       \\<forall>sch'\\<ge>BVar x. free_tv sch' \\<subseteq> free_tv (BVar x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (induct_tac \"sch'\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x sch' xa.\n       FVar x \\<le> FVar xa \\<longrightarrow>\n       free_tv (FVar xa) \\<subseteq> free_tv (FVar x)\n 2. \\<And>x sch' xa.\n       FVar x \\<le> BVar xa \\<longrightarrow>\n       free_tv (BVar xa) \\<subseteq> free_tv (FVar x)\n 3. \\<And>x sch' x1a x2a.\n       \\<lbrakk>FVar x \\<le> x1a \\<longrightarrow>\n                free_tv x1a \\<subseteq> free_tv (FVar x);\n        FVar x \\<le> x2a \\<longrightarrow>\n        free_tv x2a \\<subseteq> free_tv (FVar x)\\<rbrakk>\n       \\<Longrightarrow> FVar x \\<le> x1a =-> x2a \\<longrightarrow>\n                         free_tv (x1a =-> x2a) \\<subseteq> free_tv (FVar x)\n 4. \\<And>x.\n       \\<forall>sch'\\<ge>BVar x. free_tv sch' \\<subseteq> free_tv (BVar x)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x sch' xa.\n       FVar x \\<le> BVar xa \\<longrightarrow>\n       free_tv (BVar xa) \\<subseteq> free_tv (FVar x)\n 2. \\<And>x sch' x1a x2a.\n       \\<lbrakk>FVar x \\<le> x1a \\<longrightarrow>\n                free_tv x1a \\<subseteq> free_tv (FVar x);\n        FVar x \\<le> x2a \\<longrightarrow>\n        free_tv x2a \\<subseteq> free_tv (FVar x)\\<rbrakk>\n       \\<Longrightarrow> FVar x \\<le> x1a =-> x2a \\<longrightarrow>\n                         free_tv (x1a =-> x2a) \\<subseteq> free_tv (FVar x)\n 3. \\<And>x.\n       \\<forall>sch'\\<ge>BVar x. free_tv sch' \\<subseteq> free_tv (BVar x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x sch' x1a x2a.\n       \\<lbrakk>FVar x \\<le> x1a \\<longrightarrow>\n                free_tv x1a \\<subseteq> free_tv (FVar x);\n        FVar x \\<le> x2a \\<longrightarrow>\n        free_tv x2a \\<subseteq> free_tv (FVar x)\\<rbrakk>\n       \\<Longrightarrow> FVar x \\<le> x1a =-> x2a \\<longrightarrow>\n                         free_tv (x1a =-> x2a) \\<subseteq> free_tv (FVar x)\n 2. \\<And>x.\n       \\<forall>sch'\\<ge>BVar x. free_tv sch' \\<subseteq> free_tv (BVar x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>sch'\\<ge>BVar x. free_tv sch' \\<subseteq> free_tv (BVar x)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (rule allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x sch'.\n       BVar x \\<le> sch' \\<longrightarrow>\n       free_tv sch' \\<subseteq> free_tv (BVar x)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (induct_tac \"sch'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x sch' xa.\n       BVar x \\<le> FVar xa \\<longrightarrow>\n       free_tv (FVar xa) \\<subseteq> free_tv (BVar x)\n 2. \\<And>x sch' xa.\n       BVar x \\<le> BVar xa \\<longrightarrow>\n       free_tv (BVar xa) \\<subseteq> free_tv (BVar x)\n 3. \\<And>x sch' x1a x2a.\n       \\<lbrakk>BVar x \\<le> x1a \\<longrightarrow>\n                free_tv x1a \\<subseteq> free_tv (BVar x);\n        BVar x \\<le> x2a \\<longrightarrow>\n        free_tv x2a \\<subseteq> free_tv (BVar x)\\<rbrakk>\n       \\<Longrightarrow> BVar x \\<le> x1a =-> x2a \\<longrightarrow>\n                         free_tv (x1a =-> x2a) \\<subseteq> free_tv (BVar x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x sch' xa.\n       BVar x \\<le> BVar xa \\<longrightarrow>\n       free_tv (BVar xa) \\<subseteq> free_tv (BVar x)\n 2. \\<And>x sch' x1a x2a.\n       \\<lbrakk>BVar x \\<le> x1a \\<longrightarrow>\n                free_tv x1a \\<subseteq> free_tv (BVar x);\n        BVar x \\<le> x2a \\<longrightarrow>\n        free_tv x2a \\<subseteq> free_tv (BVar x)\\<rbrakk>\n       \\<Longrightarrow> BVar x \\<le> x1a =-> x2a \\<longrightarrow>\n                         free_tv (x1a =-> x2a) \\<subseteq> free_tv (BVar x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x sch' x1a x2a.\n       \\<lbrakk>BVar x \\<le> x1a \\<longrightarrow>\n                free_tv x1a \\<subseteq> free_tv (BVar x);\n        BVar x \\<le> x2a \\<longrightarrow>\n        free_tv x2a \\<subseteq> free_tv (BVar x)\\<rbrakk>\n       \\<Longrightarrow> BVar x \\<le> x1a =-> x2a \\<longrightarrow>\n                         free_tv (x1a =-> x2a) \\<subseteq> free_tv (BVar x)\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sch'\\<ge>x1a =-> x2a.\n                            free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a sch'.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> sch' \\<longrightarrow>\n                         free_tv sch' \\<subseteq> free_tv (x1a =-> x2a)", "apply (induct_tac \"sch'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x2a sch' x.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> FVar x \\<longrightarrow>\n                         free_tv (FVar x) \\<subseteq> free_tv (x1a =-> x2a)\n 2. \\<And>x1a x2a sch' x.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> BVar x \\<longrightarrow>\n                         free_tv (BVar x) \\<subseteq> free_tv (x1a =-> x2a)\n 3. \\<And>x1a x2a sch' x1aa x2aa.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa \\<longrightarrow>\n        free_tv x1aa \\<subseteq> free_tv (x1a =-> x2a);\n        x1a =-> x2a \\<le> x2aa \\<longrightarrow>\n        free_tv x2aa \\<subseteq> free_tv (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> x1aa =-> x2aa \\<longrightarrow>\n                         free_tv (x1aa =-> x2aa)\n                         \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2a sch' x.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> BVar x \\<longrightarrow>\n                         free_tv (BVar x) \\<subseteq> free_tv (x1a =-> x2a)\n 2. \\<And>x1a x2a sch' x1aa x2aa.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa \\<longrightarrow>\n        free_tv x1aa \\<subseteq> free_tv (x1a =-> x2a);\n        x1a =-> x2a \\<le> x2aa \\<longrightarrow>\n        free_tv x2aa \\<subseteq> free_tv (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> x1aa =-> x2aa \\<longrightarrow>\n                         free_tv (x1aa =-> x2aa)\n                         \\<subseteq> free_tv (x1a =-> x2a)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a sch' x1aa x2aa.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa \\<longrightarrow>\n        free_tv x1aa \\<subseteq> free_tv (x1a =-> x2a);\n        x1a =-> x2a \\<le> x2aa \\<longrightarrow>\n        free_tv x2aa \\<subseteq> free_tv (x1a =-> x2a)\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> x1aa =-> x2aa \\<longrightarrow>\n                         free_tv (x1aa =-> x2aa)\n                         \\<subseteq> free_tv (x1a =-> x2a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x1aa x2aa.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa \\<longrightarrow>\n        free_tv x1aa \\<subseteq> free_tv x1a \\<union> free_tv x2a;\n        x1a =-> x2a \\<le> x2aa \\<longrightarrow>\n        free_tv x2aa \\<subseteq> free_tv x1a \\<union> free_tv x2a\\<rbrakk>\n       \\<Longrightarrow> x1a =-> x2a \\<le> x1aa =-> x2aa \\<longrightarrow>\n                         free_tv x1aa\n                         \\<subseteq> free_tv x1a \\<union> free_tv x2a \\<and>\n                         free_tv x2aa\n                         \\<subseteq> free_tv x1a \\<union> free_tv x2a", "apply (intro strip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x1aa x2aa.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa \\<longrightarrow>\n        free_tv x1aa \\<subseteq> free_tv x1a \\<union> free_tv x2a;\n        x1a =-> x2a \\<le> x2aa \\<longrightarrow>\n        free_tv x2aa \\<subseteq> free_tv x1a \\<union> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa =-> x2aa\\<rbrakk>\n       \\<Longrightarrow> free_tv x1aa\n                         \\<subseteq> free_tv x1a \\<union> free_tv x2a \\<and>\n                         free_tv x2aa\n                         \\<subseteq> free_tv x1a \\<union> free_tv x2a", "apply (drule Fun_le_FunD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x1aa x2aa.\n       \\<lbrakk>\\<forall>sch'\\<ge>x1a. free_tv sch' \\<subseteq> free_tv x1a;\n        \\<forall>sch'\\<ge>x2a. free_tv sch' \\<subseteq> free_tv x2a;\n        x1a =-> x2a \\<le> x1aa \\<longrightarrow>\n        free_tv x1aa \\<subseteq> free_tv x1a \\<union> free_tv x2a;\n        x1a =-> x2a \\<le> x2aa \\<longrightarrow>\n        free_tv x2aa \\<subseteq> free_tv x1a \\<union> free_tv x2a;\n        x1a \\<le> x1aa \\<and> x2a \\<le> x2aa\\<rbrakk>\n       \\<Longrightarrow> free_tv x1aa\n                         \\<subseteq> free_tv x1a \\<union> free_tv x2a \\<and>\n                         free_tv x2aa\n                         \\<subseteq> free_tv x1a \\<union> free_tv x2a", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_env_free_tv [rule_format]:\n  \"\\<forall>A::type_scheme list. A \\<le> B \\<longrightarrow> free_tv B \\<le> free_tv A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<le>B. free_tv B \\<subseteq> free_tv A", "apply (induct_tac \"B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>A\\<le>[]. free_tv [] \\<subseteq> free_tv A\n 2. \\<And>a list.\n       \\<forall>A\\<le>list.\n          free_tv list \\<subseteq> free_tv A \\<Longrightarrow>\n       \\<forall>A\\<le>a # list. free_tv (a # list) \\<subseteq> free_tv A", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<forall>A\\<le>list.\n          free_tv list \\<subseteq> free_tv A \\<Longrightarrow>\n       \\<forall>A\\<le>a # list. free_tv (a # list) \\<subseteq> free_tv A", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list A.\n       \\<forall>A\\<le>list.\n          free_tv list \\<subseteq> free_tv A \\<Longrightarrow>\n       A \\<le> a # list \\<longrightarrow>\n       free_tv (a # list) \\<subseteq> free_tv A", "apply (induct_tac \"A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list A.\n       \\<forall>A\\<le>list.\n          free_tv list \\<subseteq> free_tv A \\<Longrightarrow>\n       [] \\<le> a # list \\<longrightarrow>\n       free_tv (a # list) \\<subseteq> free_tv []\n 2. \\<And>a list A aa lista.\n       \\<lbrakk>\\<forall>A\\<le>list. free_tv list \\<subseteq> free_tv A;\n        lista \\<le> a # list \\<longrightarrow>\n        free_tv (a # list) \\<subseteq> free_tv lista\\<rbrakk>\n       \\<Longrightarrow> aa # lista \\<le> a # list \\<longrightarrow>\n                         free_tv (a # list) \\<subseteq> free_tv (aa # lista)", "apply (simp (no_asm) add: le_env_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list A aa lista.\n       \\<lbrakk>\\<forall>A\\<le>list. free_tv list \\<subseteq> free_tv A;\n        lista \\<le> a # list \\<longrightarrow>\n        free_tv (a # list) \\<subseteq> free_tv lista\\<rbrakk>\n       \\<Longrightarrow> aa # lista \\<le> a # list \\<longrightarrow>\n                         free_tv (a # list) \\<subseteq> free_tv (aa # lista)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>\\<forall>A\\<le>list. free_tv list \\<subseteq> free_tv A;\n        lista \\<le> a # list \\<longrightarrow>\n        free_tv (a # list) \\<subseteq> free_tv lista\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> a \\<and>\n                         lista \\<le> list \\<longrightarrow>\n                         free_tv a\n                         \\<subseteq> free_tv aa \\<union>\n                                     free_tv lista \\<and>\n                         free_tv list\n                         \\<subseteq> free_tv aa \\<union> free_tv lista", "apply (fast dest: le_type_scheme_free_tv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}