{"file_name": "/home/qj213/afp-2021-10-22/thys/Kleene_Algebra/Kleene_Algebra_Models.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kleene_Algebra", "problem_names": ["lemma power_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> (x ^ n) \\<cdot> z \\<le> y\"", "lemma power_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> (x ^ n) \\<le> y\"", "lemma Un_0_Suc: \"(\\<Union>n. f n) = f 0 \\<union> (\\<Union>n. f (Suc n))\"", "lemma star_elim: \"x \\<in> X\\<^sup>\\<star> \\<longleftrightarrow> (\\<exists>k. x \\<in> X ^ k)\"", "lemma star_contl: \"X \\<cdot> Y\\<^sup>\\<star> = (\\<Union>n. X \\<cdot> Y ^ n)\"", "lemma star_contr: \"X\\<^sup>\\<star> \\<cdot> Y = (\\<Union>n. X ^ n \\<cdot> Y)\"", "lemma power_is_relpow: \"rel_dioid.power X n = X ^^ n\"", "lemma rel_star_def: \"X^* = (\\<Union>n. rel_dioid.power X n)\"", "lemma rel_star_contl: \"X O Y^* = (\\<Union>n. X O rel_dioid.power Y n)\"", "lemma rel_star_contr: \"X^* O Y = (\\<Union>n. (rel_dioid.power X n) O Y)\"", "lemma t_star_elim: \"x \\<in> t_star X \\<longleftrightarrow> (\\<exists>n. x \\<in> trace_dioid.power X n)\"", "lemma t_star_contl: \"t_prod X (t_star Y) = (\\<Union>n. t_prod X (trace_dioid.power Y n))\"", "lemma t_star_contr: \"t_prod (t_star X) Y = (\\<Union>n. t_prod (trace_dioid.power X n) Y)\"", "lemma p_star_elim: \"x \\<in> p_star X \\<longleftrightarrow> (\\<exists>n. x \\<in> path_dioid.power X n)\"", "lemma p_star_contl: \"p_prod X (p_star Y) = (\\<Union>n. p_prod X (path_dioid.power Y n))\"", "lemma p_star_contr: \"p_prod (p_star X) Y = (\\<Union>n. p_prod (path_dioid.power X n) Y)\"", "lemma pp_star_elim: \"x \\<in> pp_star X \\<longleftrightarrow> (\\<exists>n. x \\<in> ppath_dioid.power X n)\"", "lemma pp_star_contl: \"pp_prod X (pp_star Y) = (\\<Union>n. pp_prod X (ppath_dioid.power Y n))\"", "lemma pp_star_contr: \"pp_prod (pp_star X) Y = (\\<Union>n. pp_prod (ppath_dioid.power X n) Y)\""], "translations": [["", "lemma power_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> (x ^ n) \\<cdot> z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ n \\<cdot> z \\<le> y", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ 0 \\<cdot> z \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "case 0"], ["proof (state)\nthis:\n  z + x \\<cdot> y \\<le> y\n\ngoal (2 subgoals):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ 0 \\<cdot> z \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ 0 \\<cdot> z \\<le> y", "using \"0.prems\""], ["proof (prove)\nusing this:\n  z + x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. x ^ 0 \\<cdot> z \\<le> y", "by auto"], ["proof (state)\nthis:\n  x ^ 0 \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "case Suc"], ["proof (state)\nthis:\n  z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ n_ \\<cdot> z \\<le> y\n  z + x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "thus ?case"], ["proof (prove)\nusing this:\n  z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ n_ \\<cdot> z \\<le> y\n  z + x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. x ^ Suc n_ \\<cdot> z \\<le> y", "by (auto, metis mult.assoc mult_isol order_trans)"], ["proof (state)\nthis:\n  x ^ Suc n_ \\<cdot> z \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> (x ^ n) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ 0 \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "case 0"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y\n\ngoal (2 subgoals):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ 0 \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ 0 \\<le> y", "using \"0.prems\""], ["proof (prove)\nusing this:\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ 0 \\<le> y", "by auto"], ["proof (state)\nthis:\n  z \\<cdot> x ^ 0 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "case Suc"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n_ \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "{"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n_ \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "assume \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y\"\n      and \"z + y \\<cdot> x \\<le> y\""], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "hence \"z \\<cdot> x ^ n \\<le> y\""], ["proof (prove)\nusing this:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ n \\<le> y", "by auto"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "also"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n", "by (metis mult.assoc power_Suc)"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"... = (z \\<cdot> x ^ n) \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x", "by (metis mult.assoc power_commutes)"], ["proof (state)\nthis:\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"... \\<le> y \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x", "by (metis calculation(1) mult_isor)"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"... \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<cdot> x \\<le> y", "using \\<open>z + y \\<cdot> x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. y \\<cdot> x \\<le> y", "by auto"], ["proof (state)\nthis:\n  y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  z \\<cdot> x ^ n \\<le> y\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n  y \\<cdot> x \\<le> y", "have \"z \\<cdot> x ^ Suc n \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<cdot> x ^ n \\<le> y\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n  y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ Suc n \\<le> y", "by auto"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n           z \\<cdot> x ^ ?nb3 \\<le> y;\n   z + y \\<cdot> x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> z \\<cdot> x ^ Suc ?nb3 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n           z \\<cdot> x ^ ?nb3 \\<le> y;\n   z + y \\<cdot> x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> z \\<cdot> x ^ Suc ?nb3 \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ Suc n_ \\<le> y", "by (metis Suc)"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n_ \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* dioid_one_zero *)"], ["", "subsection \\<open>The Powerset Kleene Algebra over a Monoid\\<close>"], ["", "text \\<open>We now show that the powerset dioid forms a Kleene\nalgebra. The Kleene star is defined as in language theory.\\<close>"], ["", "lemma Un_0_Suc: \"(\\<Union>n. f n) = f 0 \\<union> (\\<Union>n. f (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range f) = f 0 \\<union> (\\<Union>n. f (Suc n))", "by auto (metis not0_implies_Suc)"], ["", "instantiation set :: (monoid_mult) kleene_algebra\nbegin"], ["", "definition star_def: \"X\\<^sup>\\<star> = (\\<Union>n. X ^ n)\""], ["", "lemma star_elim: \"x \\<in> X\\<^sup>\\<star> \\<longleftrightarrow> (\\<exists>k. x \\<in> X ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> X\\<^sup>\\<star>) = (\\<exists>k. x \\<in> X ^ k)", "by (simp add: star_def)"], ["", "lemma star_contl: \"X \\<cdot> Y\\<^sup>\\<star> = (\\<Union>n. X \\<cdot> Y ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<cdot> Y\\<^sup>\\<star> = (\\<Union>n. X \\<cdot> Y ^ n)", "by (auto simp add: star_elim c_prod_def)"], ["", "lemma star_contr: \"X\\<^sup>\\<star> \\<cdot> Y = (\\<Union>n. X ^ n \\<cdot> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sup>\\<star> \\<cdot> Y = (\\<Union>n. X ^ n \\<cdot> Y)", "by (auto simp add: star_elim c_prod_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, kleene_algebra_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<subseteq> x\\<^sup>\\<star>\n 2. \\<And>z x y.\n       z + x \\<cdot> y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<subseteq> y\n 3. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "fix X Y Z :: \"'a set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<subseteq> x\\<^sup>\\<star>\n 2. \\<And>z x y.\n       z + x \\<cdot> y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<subseteq> y\n 3. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "show \"1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "have \"1 + X \\<cdot> X\\<^sup>\\<star> = (X ^ 0) \\<union> (\\<Union>n. X ^ (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> = X ^ 0 \\<union> (\\<Union>n. X ^ Suc n)", "by (auto simp add: star_def c_prod_def plus_set_def one_set_def)"], ["proof (state)\nthis:\n  1 + X \\<cdot> X\\<^sup>\\<star> = X ^ 0 \\<union> (\\<Union>n. X ^ Suc n)\n\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  1 + X \\<cdot> X\\<^sup>\\<star> = X ^ 0 \\<union> (\\<Union>n. X ^ Suc n)\n\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "have \"... = (\\<Union>n. X ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X ^ 0 \\<union> (\\<Union>n. X ^ Suc n) = \\<Union> (range ((^) X))", "by (metis Un_0_Suc)"], ["proof (state)\nthis:\n  X ^ 0 \\<union> (\\<Union>n. X ^ Suc n) = \\<Union> (range ((^) X))\n\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  X ^ 0 \\<union> (\\<Union>n. X ^ Suc n) = \\<Union> (range ((^) X))\n\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "have \"... = X\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range ((^) X)) = X\\<^sup>\\<star>", "by (simp only: star_def)"], ["proof (state)\nthis:\n  \\<Union> (range ((^) X)) = X\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  1 + X \\<cdot> X\\<^sup>\\<star> = X\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  1 + X \\<cdot> X\\<^sup>\\<star> = X\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. 1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>", "by (metis subset_refl)"], ["proof (state)\nthis:\n  1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + X \\<cdot> X\\<^sup>\\<star> \\<subseteq> X\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z + x \\<cdot> y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<subseteq> y\n 2. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z + x \\<cdot> y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<subseteq> y\n 2. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "fix X Y Z :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z + x \\<cdot> y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<subseteq> y\n 2. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "assume hyp: \"Z + X \\<cdot> Y \\<subseteq> Y\""], ["proof (state)\nthis:\n  Z + X \\<cdot> Y \\<subseteq> Y\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z + x \\<cdot> y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<subseteq> y\n 2. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "show  \"X\\<^sup>\\<star> \\<cdot> Z \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sup>\\<star> \\<cdot> Z \\<subseteq> Y", "by (simp add: star_contr SUP_le_iff) (meson hyp dioid_one_zero_class.power_inductl)"], ["proof (state)\nthis:\n  X\\<^sup>\\<star> \\<cdot> Z \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "fix X Y Z :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "assume hyp: \"Z + Y \\<cdot> X \\<subseteq> Y\""], ["proof (state)\nthis:\n  Z + Y \\<cdot> X \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z + y \\<cdot> x \\<subseteq> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<subseteq> y", "show  \"Z \\<cdot> X\\<^sup>\\<star> \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<cdot> X\\<^sup>\\<star> \\<subseteq> Y", "by (simp add: star_contl SUP_le_iff) (meson dioid_one_zero_class.power_inductr hyp)"], ["proof (state)\nthis:\n  Z \\<cdot> X\\<^sup>\\<star> \\<subseteq> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* instantiation *)"], ["", "subsection \\<open>Language Kleene Algebras\\<close>"], ["", "text \\<open>We now specialise this fact to languages.\\<close>"], ["", "interpretation lan_kleene_algebra: kleene_algebra \"(+)\" \"(\\<cdot>)\" \"1::'a lan\" \"0\" \"(\\<subseteq>)\" \"(\\<subset>)\" star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (+) (\\<cdot>) 1 0 (\\<subseteq>) (\\<subset>) star", ".."], ["", "subsection \\<open>Regular Languages\\<close>"], ["", "text \\<open>{\\ldots} and further to regular languages. For the sake of\nsimplicity we just copy in the axiomatisation of regular expressions\nby Krauss and Nipkow~\\cite{krauss12regular}.\\<close>"], ["", "datatype 'a rexp =\n  Zero\n| One\n| Atom 'a\n| Plus \"'a rexp\" \"'a rexp\"\n| Times \"'a rexp\" \"'a rexp\"\n| Star \"'a rexp\""], ["", "text \\<open>The interpretation map that induces regular languages as the\nimages of regular expressions in the set of languages has also been\nadapted from there.\\<close>"], ["", "fun lang :: \"'a rexp \\<Rightarrow> 'a lan\" where\n  \"lang Zero = 0\"  \\<comment> \\<open>{}\\<close>\n| \"lang One = 1\"  \\<comment> \\<open>{[]}\\<close>\n| \"lang (Atom a) = {[a]}\"\n| \"lang (Plus x y) = lang x + lang y\"\n| \"lang (Times x y) = lang x \\<cdot> lang y\"\n| \"lang (Star x) = (lang x)\\<^sup>\\<star>\""], ["", "typedef 'a reg_lan = \"range lang :: 'a lan set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range lang", "by auto"], ["", "setup_lifting type_definition_reg_lan"], ["", "instantiation reg_lan :: (type) kleene_algebra\nbegin"], ["", "lift_definition star_reg_lan :: \"'a reg_lan \\<Rightarrow> 'a reg_lan\"\n    is star"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       set \\<in> range lang \\<Longrightarrow>\n       set\\<^sup>\\<star> \\<in> range lang", "by (metis (hide_lams, no_types) image_iff lang.simps(6) rangeI)"], ["", "lift_definition zero_reg_lan :: \"'a reg_lan\"\n    is 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> range lang", "by (metis lang.simps(1) rangeI)"], ["", "lift_definition one_reg_lan :: \"'a reg_lan\"\n    is 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> range lang", "by (metis lang.simps(2) rangeI)"], ["", "lift_definition less_eq_reg_lan :: \"'a reg_lan \\<Rightarrow> 'a reg_lan \\<Rightarrow> bool\"\n    is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_reg_lan :: \"'a reg_lan \\<Rightarrow> 'a reg_lan \\<Rightarrow> bool\"\n    is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition plus_reg_lan :: \"'a reg_lan \\<Rightarrow> 'a reg_lan \\<Rightarrow> 'a reg_lan\"\n    is plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>set1 \\<in> range lang; set2 \\<in> range lang\\<rbrakk>\n       \\<Longrightarrow> set1 + set2 \\<in> range lang", "by (metis (hide_lams, no_types) image_iff lang.simps(4) rangeI)"], ["", "lift_definition times_reg_lan :: \"'a reg_lan \\<Rightarrow> 'a reg_lan \\<Rightarrow> 'a reg_lan\"\n    is times"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>set1 \\<in> range lang; set2 \\<in> range lang\\<rbrakk>\n       \\<Longrightarrow> set1 \\<cdot> set2 \\<in> range lang", "by (metis (hide_lams, no_types) image_iff lang.simps(5) rangeI)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a reg_lan, kleene_algebra_class)", "proof"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\n 5. \\<And>x. 1 \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> 1 = x\n 7. \\<And>x. 0 + x = x\n 8. \\<And>x. 0 \\<cdot> x = 0\n 9. \\<And>x. x \\<cdot> 0 = 0\n 10. \\<And>x y. (x \\<le> y) = (x + y = y)\nA total of 17 subgoals...", "fix x y z :: \"'a reg_lan\""], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\n 5. \\<And>x. 1 \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> 1 = x\n 7. \\<And>x. 0 + x = x\n 8. \\<And>x. 0 \\<cdot> x = 0\n 9. \\<And>x. x \\<cdot> 0 = 0\n 10. \\<And>x y. (x \\<le> y) = (x + y = y)\nA total of 17 subgoals...", "show \"x + y + z = x + (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y + z = x + (y + z)", "by transfer (metis join_semilattice_class.add_assoc')"], ["proof (state)\nthis:\n  x + y + z = x + (y + z)\n\ngoal (16 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 3. \\<And>x y z. (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\n 4. \\<And>x. 1 \\<cdot> x = x\n 5. \\<And>x. x \\<cdot> 1 = x\n 6. \\<And>x. 0 + x = x\n 7. \\<And>x. 0 \\<cdot> x = 0\n 8. \\<And>x. x \\<cdot> 0 = 0\n 9. \\<And>x y. (x \\<le> y) = (x + y = y)\n 10. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\nA total of 16 subgoals...", "show \"x + y = y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = y + x", "by transfer (metis join_semilattice_class.add_comm)"], ["proof (state)\nthis:\n  x + y = y + x\n\ngoal (15 subgoals):\n 1. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 2. \\<And>x y z. (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\n 3. \\<And>x. 1 \\<cdot> x = x\n 4. \\<And>x. x \\<cdot> 1 = x\n 5. \\<And>x. 0 + x = x\n 6. \\<And>x. 0 \\<cdot> x = 0\n 7. \\<And>x. x \\<cdot> 0 = 0\n 8. \\<And>x y. (x \\<le> y) = (x + y = y)\n 9. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 10. \\<And>x. x + x = x\nA total of 15 subgoals...", "show \"x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)", "by transfer (metis semigroup_mult_class.mult.assoc)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)\n\ngoal (14 subgoals):\n 1. \\<And>x y z. (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\n 2. \\<And>x. 1 \\<cdot> x = x\n 3. \\<And>x. x \\<cdot> 1 = x\n 4. \\<And>x. 0 + x = x\n 5. \\<And>x. 0 \\<cdot> x = 0\n 6. \\<And>x. x \\<cdot> 0 = 0\n 7. \\<And>x y. (x \\<le> y) = (x + y = y)\n 8. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 9. \\<And>x. x + x = x\n 10. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\nA total of 14 subgoals...", "show \"(x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z", "by transfer (metis semiring_class.distrib_right)"], ["proof (state)\nthis:\n  (x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\n\ngoal (13 subgoals):\n 1. \\<And>x. 1 \\<cdot> x = x\n 2. \\<And>x. x \\<cdot> 1 = x\n 3. \\<And>x. 0 + x = x\n 4. \\<And>x. 0 \\<cdot> x = 0\n 5. \\<And>x. x \\<cdot> 0 = 0\n 6. \\<And>x y. (x \\<le> y) = (x + y = y)\n 7. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 8. \\<And>x. x + x = x\n 9. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 10. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\nA total of 13 subgoals...", "show \"1 \\<cdot> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<cdot> x = x", "by transfer (metis monoid_mult_class.mult_1_left)"], ["proof (state)\nthis:\n  1 \\<cdot> x = x\n\ngoal (12 subgoals):\n 1. \\<And>x. x \\<cdot> 1 = x\n 2. \\<And>x. 0 + x = x\n 3. \\<And>x. 0 \\<cdot> x = 0\n 4. \\<And>x. x \\<cdot> 0 = 0\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x. x + x = x\n 8. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 9. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 10. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\nA total of 12 subgoals...", "show \"x \\<cdot> 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> 1 = x", "by transfer (metis monoid_mult_class.mult_1_right)"], ["proof (state)\nthis:\n  x \\<cdot> 1 = x\n\ngoal (11 subgoals):\n 1. \\<And>x. 0 + x = x\n 2. \\<And>x. 0 \\<cdot> x = 0\n 3. \\<And>x. x \\<cdot> 0 = 0\n 4. \\<And>x y. (x \\<le> y) = (x + y = y)\n 5. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 6. \\<And>x. x + x = x\n 7. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 8. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 9. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 10. \\<And>z x y.\n        z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n        x\\<^sup>\\<star> \\<cdot> z \\<le> y\nA total of 11 subgoals...", "show \"0 + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "by transfer (metis join_semilattice_zero_class.add_zero_l)"], ["proof (state)\nthis:\n  0 + x = x\n\ngoal (10 subgoals):\n 1. \\<And>x. 0 \\<cdot> x = 0\n 2. \\<And>x. x \\<cdot> 0 = 0\n 3. \\<And>x y. (x \\<le> y) = (x + y = y)\n 4. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 5. \\<And>x. x + x = x\n 6. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 7. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 8. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 9. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 10. \\<And>z y x.\n        z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n        z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"0 \\<cdot> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<cdot> x = 0", "by transfer (metis ab_near_semiring_one_zerol_class.annil)"], ["proof (state)\nthis:\n  0 \\<cdot> x = 0\n\ngoal (9 subgoals):\n 1. \\<And>x. x \\<cdot> 0 = 0\n 2. \\<And>x y. (x \\<le> y) = (x + y = y)\n 3. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 4. \\<And>x. x + x = x\n 5. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 6. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 7. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 8. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 9. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"x \\<cdot> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> 0 = 0", "by transfer (metis ab_near_semiring_one_zero_class.annir)"], ["proof (state)\nthis:\n  x \\<cdot> 0 = 0\n\ngoal (8 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x. x + x = x\n 4. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 5. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 6. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 7. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 8. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"x \\<le> y \\<longleftrightarrow> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x + y = y)", "by transfer (metis plus_ord_class.less_eq_def)"], ["proof (state)\nthis:\n  (x \\<le> y) = (x + y = y)\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 2. \\<And>x. x + x = x\n 3. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 4. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 5. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 6. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 7. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"x < y \\<longleftrightarrow> x \\<le> y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)", "by transfer (metis plus_ord_class.less_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n\ngoal (6 subgoals):\n 1. \\<And>x. x + x = x\n 2. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 3. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 4. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 5. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 6. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"x + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x = x", "by transfer (metis join_semilattice_class.add_idem)"], ["proof (state)\nthis:\n  x + x = x\n\ngoal (5 subgoals):\n 1. \\<And>a b c. a \\<cdot> (b + c) = a \\<cdot> b + a \\<cdot> c\n 2. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 3. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 4. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 5. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"x \\<cdot> (y + z) = x \\<cdot> y + x \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y + z) = x \\<cdot> y + x \\<cdot> z", "by transfer (metis semiring_class.distrib_left)"], ["proof (state)\nthis:\n  x \\<cdot> (y + z) = x \\<cdot> y + x \\<cdot> z\n\ngoal (4 subgoals):\n 1. \\<And>z x y. z \\<cdot> x \\<le> z \\<cdot> (x + y)\n 2. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 3. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 4. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"z \\<cdot> x \\<le> z \\<cdot> (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x \\<le> z \\<cdot> (x + y)", "by transfer (metis pre_dioid_class.subdistl)"], ["proof (state)\nthis:\n  z \\<cdot> x \\<le> z \\<cdot> (x + y)\n\ngoal (3 subgoals):\n 1. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 2. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 3. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>", "by transfer (metis star_unfoldl)"], ["proof (state)\nthis:\n  1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 2. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> \\<cdot> z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n    x\\<^sup>\\<star> \\<cdot> z \\<le> y", "by transfer (metis star_inductl)"], ["proof (state)\nthis:\n  z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n  x\\<^sup>\\<star> \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y", "show \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> x\\<^sup>\\<star> \\<le> y", "by transfer (metis star_inductr)"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n  z \\<cdot> x\\<^sup>\\<star> \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* instantiation *)"], ["", "interpretation reg_lan_kleene_algebra: kleene_algebra \"(+)\" \"(\\<cdot>)\" \"1::'a reg_lan\" 0 \"(\\<le>)\" \"(<)\" star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (+) (\\<cdot>) 1 0 (\\<le>) (<) star", ".."], ["", "subsection \\<open>Relation Kleene Algebras\\<close>"], ["", "text \\<open>We now show that binary relations form Kleene algebras. While\nwe could have used the reflexive transitive closure operation as the\nKleene star, we prefer the equivalent definition of the star as the\nsum of powers. This essentially allows us to copy previous proofs.\\<close>"], ["", "lemma power_is_relpow: \"rel_dioid.power X n = X ^^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dioid.power X n = X ^^ n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_dioid.power X 0 = X ^^ 0\n 2. \\<And>n.\n       rel_dioid.power X n = X ^^ n \\<Longrightarrow>\n       rel_dioid.power X (Suc n) = X ^^ Suc n", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rel_dioid.power X 0 = X ^^ 0\n 2. \\<And>n.\n       rel_dioid.power X n = X ^^ n \\<Longrightarrow>\n       rel_dioid.power X (Suc n) = X ^^ Suc n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dioid.power X 0 = X ^^ 0", "by (metis rel_dioid.power_0 relpow.simps(1))"], ["proof (state)\nthis:\n  rel_dioid.power X 0 = X ^^ 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       rel_dioid.power X n = X ^^ n \\<Longrightarrow>\n       rel_dioid.power X (Suc n) = X ^^ Suc n", "case Suc"], ["proof (state)\nthis:\n  rel_dioid.power X n_ = X ^^ n_\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       rel_dioid.power X n = X ^^ n \\<Longrightarrow>\n       rel_dioid.power X (Suc n) = X ^^ Suc n", "thus ?case"], ["proof (prove)\nusing this:\n  rel_dioid.power X n_ = X ^^ n_\n\ngoal (1 subgoal):\n 1. rel_dioid.power X (Suc n_) = X ^^ Suc n_", "by (metis rel_dioid.power_Suc2 relpow.simps(2))"], ["proof (state)\nthis:\n  rel_dioid.power X (Suc n_) = X ^^ Suc n_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_star_def: \"X^* = (\\<Union>n. rel_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sup>* = \\<Union> (range (rel_dioid.power X))", "by (simp add: power_is_relpow rtrancl_is_UN_relpow)"], ["", "lemma rel_star_contl: \"X O Y^* = (\\<Union>n. X O rel_dioid.power Y n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X O Y\\<^sup>* = (\\<Union>n. X O rel_dioid.power Y n)", "by (metis rel_star_def relcomp_UNION_distrib)"], ["", "lemma rel_star_contr: \"X^* O Y = (\\<Union>n. (rel_dioid.power X n) O Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sup>* O Y = (\\<Union>n. rel_dioid.power X n O Y)", "by (metis rel_star_def relcomp_UNION_distrib2)"], ["", "interpretation rel_kleene_algebra: kleene_algebra \"(\\<union>)\" \"(O)\" Id \"{}\" \"(\\<subseteq>)\" \"(\\<subset>)\" rtrancl"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (\\<union>) (O) Id {} (\\<subseteq>) (\\<subset>)\n     rtrancl", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. Id \\<union> x O x\\<^sup>* \\<subseteq> x\\<^sup>*\n 2. \\<And>z x y.\n       z \\<union> x O y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* O z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "fix x y z :: \"'a rel\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. Id \\<union> x O x\\<^sup>* \\<subseteq> x\\<^sup>*\n 2. \\<And>z x y.\n       z \\<union> x O y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* O z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "show \"Id \\<union> x O x\\<^sup>* \\<subseteq> x\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<union> x O x\\<^sup>* \\<subseteq> x\\<^sup>*", "by (metis order_refl r_comp_rtrancl_eq rtrancl_unfold)"], ["proof (state)\nthis:\n  Id \\<union> x O x\\<^sup>* \\<subseteq> x\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> x O y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* O z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> x O y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* O z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "fix x y z :: \"'a rel\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> x O y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* O z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "assume \"z \\<union> x O y \\<subseteq> y\""], ["proof (state)\nthis:\n  z \\<union> x O y \\<subseteq> y\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> x O y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* O z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "thus \"x\\<^sup>* O z \\<subseteq> y\""], ["proof (prove)\nusing this:\n  z \\<union> x O y \\<subseteq> y\n\ngoal (1 subgoal):\n 1. x\\<^sup>* O z \\<subseteq> y", "by (simp only: rel_star_contr, metis (lifting) SUP_le_iff rel_dioid.power_inductl)"], ["proof (state)\nthis:\n  x\\<^sup>* O z \\<subseteq> y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "fix x y z :: \"'a rel\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "assume \"z \\<union> y O x \\<subseteq> y\""], ["proof (state)\nthis:\n  z \\<union> y O x \\<subseteq> y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> y O x \\<subseteq> y \\<Longrightarrow>\n       z O x\\<^sup>* \\<subseteq> y", "thus \"z O x\\<^sup>* \\<subseteq> y\""], ["proof (prove)\nusing this:\n  z \\<union> y O x \\<subseteq> y\n\ngoal (1 subgoal):\n 1. z O x\\<^sup>* \\<subseteq> y", "by (simp only: rel_star_contl, metis (lifting) SUP_le_iff rel_dioid.power_inductr)"], ["proof (state)\nthis:\n  z O x\\<^sup>* \\<subseteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Trace Kleene Algebras\\<close>"], ["", "text \\<open>Again, the proof that sets of traces form Kleene algebras\nfollows the same schema.\\<close>"], ["", "definition t_star :: \"('p, 'a) trace set \\<Rightarrow> ('p, 'a) trace set\" where\n  \"t_star X \\<equiv> \\<Union>n. trace_dioid.power X n\""], ["", "lemma t_star_elim: \"x \\<in> t_star X \\<longleftrightarrow> (\\<exists>n. x \\<in> trace_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> t_star X) = (\\<exists>n. x \\<in> trace_dioid.power X n)", "by (simp add: t_star_def)"], ["", "lemma t_star_contl: \"t_prod X (t_star Y) = (\\<Union>n. t_prod X (trace_dioid.power Y n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_prod X (t_star Y) = (\\<Union>n. t_prod X (trace_dioid.power Y n))", "by (auto simp add: t_star_elim t_prod_def)"], ["", "lemma t_star_contr: \"t_prod (t_star X) Y = (\\<Union>n. t_prod (trace_dioid.power X n) Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_prod (t_star X) Y = (\\<Union>n. t_prod (trace_dioid.power X n) Y)", "by (auto simp add: t_star_elim t_prod_def)"], ["", "interpretation trace_kleene_algebra: kleene_algebra \"(\\<union>)\" t_prod t_one t_zero \"(\\<subseteq>)\" \"(\\<subset>)\" t_star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (\\<union>) t_prod t_one t_zero (\\<subseteq>)\n     (\\<subset>) t_star", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. t_one \\<union> t_prod x (t_star x) \\<subseteq> t_star x\n 2. \\<And>z x y.\n       z \\<union> t_prod x y \\<subseteq> y \\<Longrightarrow>\n       t_prod (t_star x) z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> t_prod y x \\<subseteq> y \\<Longrightarrow>\n       t_prod z (t_star x) \\<subseteq> y", "fix X Y Z :: \"('a, 'b) trace set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. t_one \\<union> t_prod x (t_star x) \\<subseteq> t_star x\n 2. \\<And>z x y.\n       z \\<union> t_prod x y \\<subseteq> y \\<Longrightarrow>\n       t_prod (t_star x) z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> t_prod y x \\<subseteq> y \\<Longrightarrow>\n       t_prod z (t_star x) \\<subseteq> y", "show \"t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "have \"t_one \\<union> t_prod X (t_star X) = (trace_dioid.power X 0) \\<union> (\\<Union>n. trace_dioid.power X (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) =\n    trace_dioid.power X 0 \\<union> (\\<Union>n. trace_dioid.power X (Suc n))", "by (auto simp add: t_star_def t_prod_def)"], ["proof (state)\nthis:\n  t_one \\<union> t_prod X (t_star X) =\n  trace_dioid.power X 0 \\<union> (\\<Union>n. trace_dioid.power X (Suc n))\n\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "also"], ["proof (state)\nthis:\n  t_one \\<union> t_prod X (t_star X) =\n  trace_dioid.power X 0 \\<union> (\\<Union>n. trace_dioid.power X (Suc n))\n\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "have \"... = (\\<Union>n. trace_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_dioid.power X 0 \\<union>\n    (\\<Union>n. trace_dioid.power X (Suc n)) =\n    \\<Union> (range (trace_dioid.power X))", "by (metis Un_0_Suc)"], ["proof (state)\nthis:\n  trace_dioid.power X 0 \\<union> (\\<Union>n. trace_dioid.power X (Suc n)) =\n  \\<Union> (range (trace_dioid.power X))\n\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "also"], ["proof (state)\nthis:\n  trace_dioid.power X 0 \\<union> (\\<Union>n. trace_dioid.power X (Suc n)) =\n  \\<Union> (range (trace_dioid.power X))\n\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "have \"... = t_star X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range (trace_dioid.power X)) = t_star X", "by (metis t_star_def)"], ["proof (state)\nthis:\n  \\<Union> (range (trace_dioid.power X)) = t_star X\n\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "finally"], ["proof (chain)\npicking this:\n  t_one \\<union> t_prod X (t_star X) = t_star X", "show ?thesis"], ["proof (prove)\nusing this:\n  t_one \\<union> t_prod X (t_star X) = t_star X\n\ngoal (1 subgoal):\n 1. t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X", "by (metis subset_refl)"], ["proof (state)\nthis:\n  t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_one \\<union> t_prod X (t_star X) \\<subseteq> t_star X\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> t_prod x y \\<subseteq> y \\<Longrightarrow>\n       t_prod (t_star x) z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> t_prod y x \\<subseteq> y \\<Longrightarrow>\n       t_prod z (t_star x) \\<subseteq> y", "show \"Z \\<union> t_prod X Y \\<subseteq> Y \\<Longrightarrow> t_prod (t_star X) Z \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<union> t_prod X Y \\<subseteq> Y \\<Longrightarrow>\n    t_prod (t_star X) Z \\<subseteq> Y", "by (simp only: ball_UNIV t_star_contr SUP_le_iff) (metis trace_dioid.power_inductl)"], ["proof (state)\nthis:\n  Z \\<union> t_prod X Y \\<subseteq> Y \\<Longrightarrow>\n  t_prod (t_star X) Z \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> t_prod y x \\<subseteq> y \\<Longrightarrow>\n       t_prod z (t_star x) \\<subseteq> y", "show \"Z \\<union> t_prod Y X \\<subseteq> Y \\<Longrightarrow> t_prod Z (t_star X) \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<union> t_prod Y X \\<subseteq> Y \\<Longrightarrow>\n    t_prod Z (t_star X) \\<subseteq> Y", "by (simp only: ball_UNIV t_star_contl SUP_le_iff) (metis trace_dioid.power_inductr)"], ["proof (state)\nthis:\n  Z \\<union> t_prod Y X \\<subseteq> Y \\<Longrightarrow>\n  t_prod Z (t_star X) \\<subseteq> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Path Kleene Algebras\\<close>"], ["", "text \\<open>We start with paths that include the empty path.\\<close>"], ["", "definition p_star :: \"'a path set \\<Rightarrow> 'a path set\" where\n  \"p_star X \\<equiv> \\<Union>n. path_dioid.power X n\""], ["", "lemma p_star_elim: \"x \\<in> p_star X \\<longleftrightarrow> (\\<exists>n. x \\<in> path_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> p_star X) = (\\<exists>n. x \\<in> path_dioid.power X n)", "by (simp add: p_star_def)"], ["", "lemma p_star_contl: \"p_prod X (p_star Y) = (\\<Union>n. p_prod X (path_dioid.power Y n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_prod X (p_star Y) = (\\<Union>n. p_prod X (path_dioid.power Y n))", "apply (auto simp add: p_prod_def p_star_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>[] \\<in> X; [] \\<in> path_dioid.power Y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>ps\\<in>X.\n                               \\<exists>qs\\<in>path_dioid.power Y x.\n                                  [] = p_fusion ps qs \\<and> p_filter ps qs\n 2. \\<And>ps qs n.\n       \\<lbrakk>ps \\<in> X; ps \\<noteq> []; qs \\<noteq> [];\n        List.last ps = hd qs; qs \\<in> path_dioid.power Y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>psa\\<in>X.\n                               \\<exists>qsa\\<in>path_dioid.power Y x.\n                                  p_fusion ps qs = p_fusion psa qsa \\<and>\n                                  p_filter psa qsa\n 3. \\<And>xa.\n       \\<lbrakk>[] \\<in> X; [] \\<in> path_dioid.power Y xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps\\<in>X.\n                            \\<exists>qs\\<in>p_star Y.\n                               [] = p_fusion ps qs \\<and> p_filter ps qs\n 4. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> X; qs \\<in> path_dioid.power Y xa; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>X.\n                            \\<exists>qsa\\<in>p_star Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply (metis p_fusion.simps(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ps qs n.\n       \\<lbrakk>ps \\<in> X; ps \\<noteq> []; qs \\<noteq> [];\n        List.last ps = hd qs; qs \\<in> path_dioid.power Y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>psa\\<in>X.\n                               \\<exists>qsa\\<in>path_dioid.power Y x.\n                                  p_fusion ps qs = p_fusion psa qsa \\<and>\n                                  p_filter psa qsa\n 2. \\<And>xa.\n       \\<lbrakk>[] \\<in> X; [] \\<in> path_dioid.power Y xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps\\<in>X.\n                            \\<exists>qs\\<in>p_star Y.\n                               [] = p_fusion ps qs \\<and> p_filter ps qs\n 3. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> X; qs \\<in> path_dioid.power Y xa; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>X.\n                            \\<exists>qsa\\<in>p_star Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>[] \\<in> X; [] \\<in> path_dioid.power Y xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps\\<in>X.\n                            \\<exists>qs\\<in>p_star Y.\n                               [] = p_fusion ps qs \\<and> p_filter ps qs\n 2. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> X; qs \\<in> path_dioid.power Y xa; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>X.\n                            \\<exists>qsa\\<in>p_star Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply (metis p_fusion.simps(1) p_star_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> X; qs \\<in> path_dioid.power Y xa; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>X.\n                            \\<exists>qsa\\<in>p_star Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply (metis p_star_elim)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_star_contr: \"p_prod (p_star X) Y = (\\<Union>n. p_prod (path_dioid.power X n) Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_prod (p_star X) Y = (\\<Union>n. p_prod (path_dioid.power X n) Y)", "apply (auto simp add: p_prod_def p_star_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>[] \\<in> Y; [] \\<in> path_dioid.power X n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>ps\\<in>path_dioid.power X x.\n                               \\<exists>qs\\<in>Y.\n                                  [] = p_fusion ps qs \\<and> p_filter ps qs\n 2. \\<And>ps qs n.\n       \\<lbrakk>qs \\<in> Y; ps \\<noteq> []; qs \\<noteq> [];\n        List.last ps = hd qs; ps \\<in> path_dioid.power X n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>psa\\<in>path_dioid.power X x.\n                               \\<exists>qsa\\<in>Y.\n                                  p_fusion ps qs = p_fusion psa qsa \\<and>\n                                  p_filter psa qsa\n 3. \\<And>xa.\n       \\<lbrakk>[] \\<in> path_dioid.power X xa; [] \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps\\<in>p_star X.\n                            \\<exists>qs\\<in>Y.\n                               [] = p_fusion ps qs \\<and> p_filter ps qs\n 4. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> path_dioid.power X xa; qs \\<in> Y; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>p_star X.\n                            \\<exists>qsa\\<in>Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply (metis p_fusion.simps(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ps qs n.\n       \\<lbrakk>qs \\<in> Y; ps \\<noteq> []; qs \\<noteq> [];\n        List.last ps = hd qs; ps \\<in> path_dioid.power X n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            \\<exists>psa\\<in>path_dioid.power X x.\n                               \\<exists>qsa\\<in>Y.\n                                  p_fusion ps qs = p_fusion psa qsa \\<and>\n                                  p_filter psa qsa\n 2. \\<And>xa.\n       \\<lbrakk>[] \\<in> path_dioid.power X xa; [] \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps\\<in>p_star X.\n                            \\<exists>qs\\<in>Y.\n                               [] = p_fusion ps qs \\<and> p_filter ps qs\n 3. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> path_dioid.power X xa; qs \\<in> Y; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>p_star X.\n                            \\<exists>qsa\\<in>Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>[] \\<in> path_dioid.power X xa; [] \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps\\<in>p_star X.\n                            \\<exists>qs\\<in>Y.\n                               [] = p_fusion ps qs \\<and> p_filter ps qs\n 2. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> path_dioid.power X xa; qs \\<in> Y; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>p_star X.\n                            \\<exists>qsa\\<in>Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply (metis p_fusion.simps(1) p_star_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ps qs.\n       \\<lbrakk>ps \\<in> path_dioid.power X xa; qs \\<in> Y; ps \\<noteq> [];\n        qs \\<noteq> []; List.last ps = hd qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa\\<in>p_star X.\n                            \\<exists>qsa\\<in>Y.\n                               p_fusion ps qs = p_fusion psa qsa \\<and>\n                               p_filter psa qsa", "apply (metis p_star_elim)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation path_kleene_algebra: kleene_algebra \"(\\<union>)\" p_prod p_one \"{}\" \"(\\<subseteq>)\" \"(\\<subset>)\" p_star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (\\<union>) p_prod p_one {} (\\<subseteq>)\n     (\\<subset>) p_star", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. p_one \\<union> p_prod x (p_star x) \\<subseteq> p_star x\n 2. \\<And>z x y.\n       z \\<union> p_prod x y \\<subseteq> y \\<Longrightarrow>\n       p_prod (p_star x) z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> p_prod y x \\<subseteq> y \\<Longrightarrow>\n       p_prod z (p_star x) \\<subseteq> y", "fix X Y Z :: \"'a path set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. p_one \\<union> p_prod x (p_star x) \\<subseteq> p_star x\n 2. \\<And>z x y.\n       z \\<union> p_prod x y \\<subseteq> y \\<Longrightarrow>\n       p_prod (p_star x) z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> p_prod y x \\<subseteq> y \\<Longrightarrow>\n       p_prod z (p_star x) \\<subseteq> y", "show \"p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "have \"p_one \\<union> p_prod X (p_star X) = (path_dioid.power X 0) \\<union> (\\<Union>n. path_dioid.power X (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) =\n    path_dioid.power X 0 \\<union> (\\<Union>n. path_dioid.power X (Suc n))", "by (auto simp add: p_star_def p_prod_def)"], ["proof (state)\nthis:\n  p_one \\<union> p_prod X (p_star X) =\n  path_dioid.power X 0 \\<union> (\\<Union>n. path_dioid.power X (Suc n))\n\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "also"], ["proof (state)\nthis:\n  p_one \\<union> p_prod X (p_star X) =\n  path_dioid.power X 0 \\<union> (\\<Union>n. path_dioid.power X (Suc n))\n\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "have \"... = (\\<Union>n. path_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_dioid.power X 0 \\<union> (\\<Union>n. path_dioid.power X (Suc n)) =\n    \\<Union> (range (path_dioid.power X))", "by (metis Un_0_Suc)"], ["proof (state)\nthis:\n  path_dioid.power X 0 \\<union> (\\<Union>n. path_dioid.power X (Suc n)) =\n  \\<Union> (range (path_dioid.power X))\n\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "also"], ["proof (state)\nthis:\n  path_dioid.power X 0 \\<union> (\\<Union>n. path_dioid.power X (Suc n)) =\n  \\<Union> (range (path_dioid.power X))\n\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "have \"... = p_star X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range (path_dioid.power X)) = p_star X", "by (metis p_star_def)"], ["proof (state)\nthis:\n  \\<Union> (range (path_dioid.power X)) = p_star X\n\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "finally"], ["proof (chain)\npicking this:\n  p_one \\<union> p_prod X (p_star X) = p_star X", "show ?thesis"], ["proof (prove)\nusing this:\n  p_one \\<union> p_prod X (p_star X) = p_star X\n\ngoal (1 subgoal):\n 1. p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X", "by (metis subset_refl)"], ["proof (state)\nthis:\n  p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p_one \\<union> p_prod X (p_star X) \\<subseteq> p_star X\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> p_prod x y \\<subseteq> y \\<Longrightarrow>\n       p_prod (p_star x) z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> p_prod y x \\<subseteq> y \\<Longrightarrow>\n       p_prod z (p_star x) \\<subseteq> y", "show \"Z \\<union> p_prod X Y \\<subseteq> Y \\<Longrightarrow> p_prod (p_star X) Z \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<union> p_prod X Y \\<subseteq> Y \\<Longrightarrow>\n    p_prod (p_star X) Z \\<subseteq> Y", "by (simp only: ball_UNIV p_star_contr SUP_le_iff) (metis path_dioid.power_inductl)"], ["proof (state)\nthis:\n  Z \\<union> p_prod X Y \\<subseteq> Y \\<Longrightarrow>\n  p_prod (p_star X) Z \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> p_prod y x \\<subseteq> y \\<Longrightarrow>\n       p_prod z (p_star x) \\<subseteq> y", "show \"Z \\<union> p_prod Y X \\<subseteq> Y \\<Longrightarrow> p_prod Z (p_star X) \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<union> p_prod Y X \\<subseteq> Y \\<Longrightarrow>\n    p_prod Z (p_star X) \\<subseteq> Y", "by (simp only: ball_UNIV p_star_contl SUP_le_iff) (metis path_dioid.power_inductr)"], ["proof (state)\nthis:\n  Z \\<union> p_prod Y X \\<subseteq> Y \\<Longrightarrow>\n  p_prod Z (p_star X) \\<subseteq> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now consider a notion of paths that does not include the\nempty path.\\<close>"], ["", "definition pp_star :: \"'a ppath set \\<Rightarrow> 'a ppath set\" where\n  \"pp_star X \\<equiv> \\<Union>n. ppath_dioid.power X n\""], ["", "lemma pp_star_elim: \"x \\<in> pp_star X \\<longleftrightarrow> (\\<exists>n. x \\<in> ppath_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> pp_star X) = (\\<exists>n. x \\<in> ppath_dioid.power X n)", "by (simp add: pp_star_def)"], ["", "lemma pp_star_contl: \"pp_prod X (pp_star Y) = (\\<Union>n. pp_prod X (ppath_dioid.power Y n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_prod X (pp_star Y) = (\\<Union>n. pp_prod X (ppath_dioid.power Y n))", "by (auto simp add: pp_prod_def pp_star_elim)"], ["", "lemma pp_star_contr: \"pp_prod (pp_star X) Y = (\\<Union>n. pp_prod (ppath_dioid.power X n) Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_prod (pp_star X) Y = (\\<Union>n. pp_prod (ppath_dioid.power X n) Y)", "by (auto simp add: pp_prod_def pp_star_elim)"], ["", "interpretation ppath_kleene_algebra: kleene_algebra \"(\\<union>)\" pp_prod pp_one \"{}\" \"(\\<subseteq>)\" \"(\\<subset>)\" pp_star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (\\<union>) pp_prod pp_one {} (\\<subseteq>)\n     (\\<subset>) pp_star", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. pp_one \\<union> pp_prod x (pp_star x) \\<subseteq> pp_star x\n 2. \\<And>z x y.\n       z \\<union> pp_prod x y \\<subseteq> y \\<Longrightarrow>\n       pp_prod (pp_star x) z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> pp_prod y x \\<subseteq> y \\<Longrightarrow>\n       pp_prod z (pp_star x) \\<subseteq> y", "fix X Y Z :: \"'a ppath set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. pp_one \\<union> pp_prod x (pp_star x) \\<subseteq> pp_star x\n 2. \\<And>z x y.\n       z \\<union> pp_prod x y \\<subseteq> y \\<Longrightarrow>\n       pp_prod (pp_star x) z \\<subseteq> y\n 3. \\<And>z y x.\n       z \\<union> pp_prod y x \\<subseteq> y \\<Longrightarrow>\n       pp_prod z (pp_star x) \\<subseteq> y", "show \"pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "have \"pp_one \\<union> pp_prod X (pp_star X) = (ppath_dioid.power X 0) \\<union> (\\<Union>n. ppath_dioid.power X (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) =\n    ppath_dioid.power X 0 \\<union> (\\<Union>n. ppath_dioid.power X (Suc n))", "by (auto simp add: pp_star_def pp_prod_def)"], ["proof (state)\nthis:\n  pp_one \\<union> pp_prod X (pp_star X) =\n  ppath_dioid.power X 0 \\<union> (\\<Union>n. ppath_dioid.power X (Suc n))\n\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "also"], ["proof (state)\nthis:\n  pp_one \\<union> pp_prod X (pp_star X) =\n  ppath_dioid.power X 0 \\<union> (\\<Union>n. ppath_dioid.power X (Suc n))\n\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "have \"... = (\\<Union>n. ppath_dioid.power X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ppath_dioid.power X 0 \\<union>\n    (\\<Union>n. ppath_dioid.power X (Suc n)) =\n    \\<Union> (range (ppath_dioid.power X))", "by (metis Un_0_Suc)"], ["proof (state)\nthis:\n  ppath_dioid.power X 0 \\<union> (\\<Union>n. ppath_dioid.power X (Suc n)) =\n  \\<Union> (range (ppath_dioid.power X))\n\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "also"], ["proof (state)\nthis:\n  ppath_dioid.power X 0 \\<union> (\\<Union>n. ppath_dioid.power X (Suc n)) =\n  \\<Union> (range (ppath_dioid.power X))\n\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "have \"... = pp_star X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range (ppath_dioid.power X)) = pp_star X", "by (metis pp_star_def)"], ["proof (state)\nthis:\n  \\<Union> (range (ppath_dioid.power X)) = pp_star X\n\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "finally"], ["proof (chain)\npicking this:\n  pp_one \\<union> pp_prod X (pp_star X) = pp_star X", "show ?thesis"], ["proof (prove)\nusing this:\n  pp_one \\<union> pp_prod X (pp_star X) = pp_star X\n\ngoal (1 subgoal):\n 1. pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X", "by (metis subset_refl)"], ["proof (state)\nthis:\n  pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pp_one \\<union> pp_prod X (pp_star X) \\<subseteq> pp_star X\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<union> pp_prod x y \\<subseteq> y \\<Longrightarrow>\n       pp_prod (pp_star x) z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> pp_prod y x \\<subseteq> y \\<Longrightarrow>\n       pp_prod z (pp_star x) \\<subseteq> y", "show \"Z \\<union> pp_prod X Y \\<subseteq> Y \\<Longrightarrow> pp_prod (pp_star X) Z \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<union> pp_prod X Y \\<subseteq> Y \\<Longrightarrow>\n    pp_prod (pp_star X) Z \\<subseteq> Y", "by (simp only: ball_UNIV pp_star_contr SUP_le_iff) (metis ppath_dioid.power_inductl)"], ["proof (state)\nthis:\n  Z \\<union> pp_prod X Y \\<subseteq> Y \\<Longrightarrow>\n  pp_prod (pp_star X) Z \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       z \\<union> pp_prod y x \\<subseteq> y \\<Longrightarrow>\n       pp_prod z (pp_star x) \\<subseteq> y", "show \"Z \\<union> pp_prod Y X \\<subseteq> Y \\<Longrightarrow> pp_prod Z (pp_star X) \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<union> pp_prod Y X \\<subseteq> Y \\<Longrightarrow>\n    pp_prod Z (pp_star X) \\<subseteq> Y", "by (simp only: ball_UNIV pp_star_contl SUP_le_iff) (metis ppath_dioid.power_inductr)"], ["proof (state)\nthis:\n  Z \\<union> pp_prod Y X \\<subseteq> Y \\<Longrightarrow>\n  pp_prod Z (pp_star X) \\<subseteq> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Distributive Lattice Kleene Algebra\\<close>"], ["", "text \\<open>In the case of bounded distributive lattices, the star maps\nall elements to to the maximal element.\\<close>"], ["", "definition (in bounded_distributive_lattice) bdl_star :: \"'a \\<Rightarrow> 'a\" where\n  \"bdl_star x = top\""], ["", "sublocale bounded_distributive_lattice \\<subseteq> kleene_algebra sup inf top bot less_eq less bdl_star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra sup inf top bot (\\<le>) (<) bdl_star", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. sup top (inf x (bdl_star x)) \\<le> bdl_star x\n 2. \\<And>z x y.\n       sup z (inf x y) \\<le> y \\<Longrightarrow> inf (bdl_star x) z \\<le> y\n 3. \\<And>z y x.\n       sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y", "fix x y z :: 'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. sup top (inf x (bdl_star x)) \\<le> bdl_star x\n 2. \\<And>z x y.\n       sup z (inf x y) \\<le> y \\<Longrightarrow> inf (bdl_star x) z \\<le> y\n 3. \\<And>z y x.\n       sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y", "show \"sup top (inf x (bdl_star x)) \\<le> bdl_star x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup top (inf x (bdl_star x)) \\<le> bdl_star x", "by (simp add: bdl_star_def)"], ["proof (state)\nthis:\n  sup top (inf x (bdl_star x)) \\<le> bdl_star x\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       sup z (inf x y) \\<le> y \\<Longrightarrow> inf (bdl_star x) z \\<le> y\n 2. \\<And>z y x.\n       sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y", "show \"sup z (inf x y) \\<le> y \\<Longrightarrow> inf (bdl_star x) z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup z (inf x y) \\<le> y \\<Longrightarrow> inf (bdl_star x) z \\<le> y", "by (simp add: bdl_star_def)"], ["proof (state)\nthis:\n  sup z (inf x y) \\<le> y \\<Longrightarrow> inf (bdl_star x) z \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>z y x.\n       sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y", "show \"sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y", "by (simp add: bdl_star_def)"], ["proof (state)\nthis:\n  sup z (inf y x) \\<le> y \\<Longrightarrow> inf z (bdl_star x) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Min-Plus Kleene Algebra\\<close>"], ["", "text \\<open>One cannot define a Kleene star for max-plus and min-plus\nalgebras that range over the real numbers. Here we define the star for\na min-plus algebra restricted to natural numbers and~$+\\infty$. The\nresulting Kleene algebra is commutative. Similar variants can be\nobtained for max-plus algebras and other algebras ranging over the\npositive or negative integers.\\<close>"], ["", "instantiation pnat :: commutative_kleene_algebra\nbegin"], ["", "definition star_pnat where\n    \"x\\<^sup>\\<star> \\<equiv> (1::pnat)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pnat, commutative_kleene_algebra_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 2. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 3. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y\n 4. \\<And>x y. x \\<cdot> y = y \\<cdot> x", "fix x y z :: pnat"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n 2. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 3. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y\n 4. \\<And>x y. x \\<cdot> y = y \\<cdot> x", "show \"1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>", "by (metis star_pnat_def zero_pnat_top)"], ["proof (state)\nthis:\n  1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\n\ngoal (3 subgoals):\n 1. \\<And>z x y.\n       z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n       x\\<^sup>\\<star> \\<cdot> z \\<le> y\n 2. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y\n 3. \\<And>x y. x \\<cdot> y = y \\<cdot> x", "show \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> \\<cdot> z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n    x\\<^sup>\\<star> \\<cdot> z \\<le> y", "by (simp add: star_pnat_def)"], ["proof (state)\nthis:\n  z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n  x\\<^sup>\\<star> \\<cdot> z \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>z y x.\n       z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n       z \\<cdot> x\\<^sup>\\<star> \\<le> y\n 2. \\<And>x y. x \\<cdot> y = y \\<cdot> x", "show \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> x\\<^sup>\\<star> \\<le> y", "by (simp add: star_pnat_def)"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n  z \\<cdot> x\\<^sup>\\<star> \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<cdot> y = y \\<cdot> x", "show \"x \\<cdot> y = y \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y = y \\<cdot> x", "unfolding times_pnat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pnat_plus x y = pnat_plus y x", "by (cases x, cases y, simp_all)"], ["proof (state)\nthis:\n  x \\<cdot> y = y \\<cdot> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* instantiation *)"], ["", "end"]]}