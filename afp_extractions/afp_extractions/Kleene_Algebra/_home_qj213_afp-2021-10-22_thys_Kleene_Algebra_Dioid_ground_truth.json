{"file_name": "/home/qj213/afp-2021-10-22/thys/Kleene_Algebra/Dioid.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kleene_Algebra", "problem_names": ["lemma add_left_comm [ac_simps]: \"y + (x + z) = x + (y + z)\"", "lemma add_left_idem [ac_simps]: \"x + (x + y) = x + y\"", "lemma add_iso: \"x \\<le> y \\<Longrightarrow> x + z \\<le> y + z\"", "lemma order_prop: \"x \\<le> y \\<longleftrightarrow> (\\<exists>z. x + z = y)\"", "lemma no_trivial_inverse: \"x \\<noteq> 0 \\<Longrightarrow> \\<not>(\\<exists>y. x + y = 0)\"", "lemma mult_isor: \"x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z\"", "lemma \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\"", "lemma mult_isol_equiv_subdistl:\n  \"(\\<forall>x y z. x \\<le> y \\<longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y) \\<longleftrightarrow> (\\<forall>x y z. z \\<cdot> x \\<le> z \\<cdot> (x + y))\"", "lemma phl_cons1: \"x \\<le> w \\<Longrightarrow> w \\<cdot> y \\<le> y \\<cdot> z \\<Longrightarrow> x \\<cdot> y \\<le> y \\<cdot> z\"", "lemma subdistl_var: \"z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\"", "lemma mult_isol: \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\"", "lemma mult_isol_var: \"u \\<le> x \\<Longrightarrow> v \\<le> y \\<Longrightarrow> u \\<cdot> v \\<le> x \\<cdot> y\"", "lemma mult_double_iso: \"x \\<le> y \\<Longrightarrow> w \\<cdot> x \\<cdot> z \\<le> w \\<cdot> y \\<cdot> z\"", "lemma phl_cons2: \"w \\<le> x \\<Longrightarrow> z \\<cdot> y \\<le> y \\<cdot> w \\<Longrightarrow> z \\<cdot> y \\<le> y \\<cdot> x\"", "lemma phl_seq: \nassumes \"p \\<cdot> x \\<le> x \\<cdot> r\"\nand \"r \\<cdot> y \\<le> y \\<cdot> q\" \nshows \"p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q\"", "lemma phl_cond: \nassumes \"u \\<cdot> v \\<le> v \\<cdot> u \\<cdot> v\" and \"u \\<cdot> w \\<le> w \\<cdot> u \\<cdot> w\" \nand \"\\<And>x y. u \\<cdot> (x + y) \\<le> u \\<cdot> x + u \\<cdot> y\"\nand \"u \\<cdot> v \\<cdot> x \\<le> x \\<cdot> z\" and \"u \\<cdot> w \\<cdot> y \\<le> y \\<cdot> z\" \nshows \"u \\<cdot> (v \\<cdot> x + w \\<cdot> y) \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z\"", "lemma phl_export1:\nassumes \"x \\<cdot> y \\<le> y \\<cdot> x \\<cdot> y\"\nand \"(x \\<cdot> y) \\<cdot> z \\<le> z \\<cdot> w\"\nshows \"x \\<cdot> (y \\<cdot> z) \\<le> (y \\<cdot> z) \\<cdot> w\"", "lemma phl_export2: \nassumes \"z \\<cdot> w \\<le> w \\<cdot> z \\<cdot> w\"\nand \"x \\<cdot> y \\<le> y \\<cdot> z\"\nshows \"x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)\"", "lemma phl_skip: \"x \\<cdot> 1 \\<le> 1 \\<cdot> x\"", "lemma add_zeror [simp]: \"x + 0 = x\"", "lemma \"1 + 1 = 1\"", "lemma (in semiring_1) dual_semiring_1:\n  \"class.semiring_1 1 (\\<odot>) (+) 0\"", "lemma (in dioid_one_zero) dual_dioid_one_zero:\n  \"class.dioid_one_zero (+) (\\<odot>) 1 0 (\\<le>) (<)\"", "lemma select_alt: \"x + y \\<in> {x,y}\""], "translations": [["", "lemma add_left_comm [ac_simps]: \"y + (x + z) = x + (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + (x + z) = x + (y + z)", "using local.add_assoc' local.add_comm"], ["proof (prove)\nusing this:\n  ?x + ?y + ?z = ?x + (?y + ?z)\n  ?x + ?y = ?y + ?x\n\ngoal (1 subgoal):\n 1. y + (x + z) = x + (y + z)", "by auto"], ["", "lemma add_left_idem [ac_simps]: \"x + (x + y) = x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (x + y) = x + y", "unfolding add_assoc' [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x + y = x + y", "by simp"], ["", "text \\<open>The definition @{term \"x \\<le> y \\<longleftrightarrow> x + y = y\"} of the order is\nhidden in class @{class plus_ord}.\n\nWe show some simple order-based properties of semilattices. The\nfirst one states that every semilattice is a partial order.\\<close>"], ["", "subclass order"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order (\\<le>) (<)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y z :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x < y \\<longleftrightarrow> x \\<le> y \\<and> \\<not> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "using local.add_comm local.less_def local.less_eq_def"], ["proof (prove)\nusing this:\n  ?x + ?y = ?y + ?x\n  (?x < ?y) = (?x \\<le> ?y \\<and> ?x \\<noteq> ?y)\n  (?x \\<le> ?y) = (?x + ?y = ?y)\n\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by force"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (simp add: local.less_eq_def)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by (metis add_assoc' less_eq_def)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> y \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "by (simp add: local.add_comm local.less_eq_def)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next we show that joins are least upper bounds.\\<close>"], ["", "sublocale join: semilattice_sup \"(+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semilattice_sup (+) (\\<le>) (<)", "by (unfold_locales; simp add: ac_simps local.less_eq_def)"], ["", "text \\<open>Next we prove that joins are isotone (order preserving).\\<close>"], ["", "lemma add_iso: \"x \\<le> y \\<Longrightarrow> x + z \\<le> y + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x + z \\<le> y + z", "using join.sup_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a + ?b \\<le> ?c + ?d\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x + z \\<le> y + z", "by blast"], ["", "text \\<open>\n  The next lemma links the definition of order as @{term \"x \\<le> y \\<longleftrightarrow> x + y = y\"}\n  with a perhaps more conventional one known, e.g., from arithmetics.\n\\<close>"], ["", "lemma order_prop: \"x \\<le> y \\<longleftrightarrow> (\\<exists>z. x + z = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (\\<exists>z. x + z = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> \\<exists>z. x + z = y\n 2. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> \\<exists>z. x + z = y\n 2. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "hence \"x + y = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x + y = y", "by (simp add: less_eq_def)"], ["proof (state)\nthis:\n  x + y = y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> \\<exists>z. x + z = y\n 2. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "thus \"\\<exists>z. x + z = y\""], ["proof (prove)\nusing this:\n  x + y = y\n\ngoal (1 subgoal):\n 1. \\<exists>z. x + z = y", "by auto"], ["proof (state)\nthis:\n  \\<exists>z. x + z = y\n\ngoal (1 subgoal):\n 1. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "assume \"\\<exists>z. x + z = y\""], ["proof (state)\nthis:\n  \\<exists>z. x + z = y\n\ngoal (1 subgoal):\n 1. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<exists>z. x + z = y", "obtain c where \"x + c = y\""], ["proof (prove)\nusing this:\n  \\<exists>z. x + z = y\n\ngoal (1 subgoal):\n 1. (\\<And>c. x + c = y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x + c = y\n\ngoal (1 subgoal):\n 1. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "hence \"x + c \\<le> y\""], ["proof (prove)\nusing this:\n  x + c = y\n\ngoal (1 subgoal):\n 1. x + c \\<le> y", "by simp"], ["proof (state)\nthis:\n  x + c \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>z. x + z = y \\<Longrightarrow> x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  x + c \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by simp"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* join_semilattice *)"], ["", "subsection \\<open>Join Semilattices with an Additive Unit\\<close>"], ["", "text \\<open>We now expand join semilattices by an additive unit~$0$. Is\nthe least element with respect to the order, and therefore often\ndenoted by~\\<open>\\<bottom>\\<close>. Semilattices with a least element are often\ncalled \\emph{bounded}.\\<close>"], ["", "class join_semilattice_zero = join_semilattice + zero +\n  assumes add_zero_l [simp]: \"0 + x = x\"\n\nbegin"], ["", "subclass comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_add (+) (0::'a)", "by (unfold_locales, simp_all add: add_assoc') (simp add: add_comm)"], ["", "sublocale join: bounded_semilattice_sup_bot \"(+)\" \"(\\<le>)\" \"(<)\" 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_semilattice_sup_bot (+) (\\<le>) (<) (0::'a)", "by unfold_locales (simp add: local.order_prop)"], ["", "lemma no_trivial_inverse: \"x \\<noteq> 0 \\<Longrightarrow> \\<not>(\\<exists>y. x + y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow> \\<nexists>y. x + y = (0::'a)", "by (metis local.add_0_right local.join.sup_left_idem)"], ["", "end"], ["", "(* join_semilattice_zero *)"], ["", "subsection \\<open>Near Semirings\\<close>"], ["", "text \\<open>\\emph{Near semirings} (also called seminearrings) are\ngeneralisations of near rings to the semiring case. They have been\nstudied, for instance, in G.~Pilz's book~\\cite{pilz83nearrings} on\nnear rings. According to his definition, a near semiring consists of\nan additive and a multiplicative semigroup that interact via a single\ndistributivity law (left or right). The additive semigroup is not\nrequired to be commutative. The definition is influenced by partial\ntransformation semigroups.\n\nWe only consider near semirings in which addition is commutative, and\nin which the right distributivity law holds. We call such near\nsemirings \\emph{abelian}.\\<close>"], ["", "class ab_near_semiring = ab_semigroup_add + semigroup_mult +  \n  assumes distrib_right' [simp]: \"(x + y) \\<cdot> z = x \\<cdot> z + y \\<cdot> z\""], ["", "subclass (in semiring) ab_near_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ab_near_semiring (+) (\\<cdot>)", "by (unfold_locales, metis distrib_right)"], ["", "class ab_pre_semiring = ab_near_semiring +\n  assumes subdistl_eq: \"z \\<cdot> x + z \\<cdot> (x + y) = z \\<cdot> (x + y)\""], ["", "subsection \\<open>Variants of Dioids\\<close>"], ["", "text \\<open>A \\emph{near dioid} is an abelian near semiring in which\naddition is idempotent. This generalises the notion of (additively)\nidempotent semirings by dropping one distributivity law. Near dioids\nare a starting point for process algebras.\n\nBy modelling variants of dioids as variants of semirings in which\naddition is idempotent we follow the tradition of\nBirkhoff~\\cite{birkhoff67lattices}, but deviate from the definitions\nin Gondran and Minoux's book~\\cite{gondran10graphs}.\\<close>"], ["", "class near_dioid = ab_near_semiring + plus_ord +\n  assumes add_idem' [simp]: \"x + x = x\"\n\nbegin"], ["", "text \\<open>Since addition is idempotent, the additive (commutative)\nsemigroup reduct of a near dioid is a semilattice. Near dioids are\ntherefore ordered by the semilattice order.\\<close>"], ["", "subclass join_semilattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.join_semilattice (+) (\\<le>) (<)", "by unfold_locales (auto simp add: add.commute add.left_commute)"], ["", "text \\<open>It follows that multiplication is right-isotone (but not\nnecessarily left-isotone).\\<close>"], ["", "lemma mult_isor: \"x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "hence \"x + y = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x + y = y", "by (simp add: less_eq_def)"], ["proof (state)\nthis:\n  x + y = y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "hence \"(x + y) \\<cdot> z = y \\<cdot> z\""], ["proof (prove)\nusing this:\n  x + y = y\n\ngoal (1 subgoal):\n 1. (x + y) \\<cdot> z = y \\<cdot> z", "by simp"], ["proof (state)\nthis:\n  (x + y) \\<cdot> z = y \\<cdot> z\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "thus \"x \\<cdot> z \\<le> y \\<cdot> z\""], ["proof (prove)\nusing this:\n  (x + y) \\<cdot> z = y \\<cdot> z\n\ngoal (1 subgoal):\n 1. x \\<cdot> z \\<le> y \\<cdot> z", "by (simp add: less_eq_def)"], ["proof (state)\nthis:\n  x \\<cdot> z \\<le> y \\<cdot> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "(* nitpick [expect=genuine] -- \"3-element counterexample\" *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "oops"], ["", "text \\<open>The next lemma states that, in every near dioid, left\nisotonicity and left subdistributivity are equivalent.\\<close>"], ["", "lemma mult_isol_equiv_subdistl:\n  \"(\\<forall>x y z. x \\<le> y \\<longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y) \\<longleftrightarrow> (\\<forall>x y z. z \\<cdot> x \\<le> z \\<cdot> (x + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x \\<le> y \\<longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y) =\n    (\\<forall>x y z. z \\<cdot> x \\<le> z \\<cdot> (x + y))", "by (metis local.join.sup_absorb2 local.join.sup_ge1)"], ["", "text \\<open>The following lemma is relevant to propositional Hoare logic.\\<close>"], ["", "lemma phl_cons1: \"x \\<le> w \\<Longrightarrow> w \\<cdot> y \\<le> y \\<cdot> z \\<Longrightarrow> x \\<cdot> y \\<le> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> w; w \\<cdot> y \\<le> y \\<cdot> z\\<rbrakk>\n    \\<Longrightarrow> x \\<cdot> y \\<le> y \\<cdot> z", "using dual_order.trans mult_isor"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> w; w \\<cdot> y \\<le> y \\<cdot> z\\<rbrakk>\n    \\<Longrightarrow> x \\<cdot> y \\<le> y \\<cdot> z", "by blast"], ["", "end"], ["", "(* near_dioid *)"], ["", "text \\<open>We now make multiplication in near dioids left isotone, which\nis equivalent to left subdistributivity, as we have seen. The\ncorresponding structures form the basis of probabilistic Kleene\nalgebras~\\cite{mciverweber05pka} and game\nalgebras~\\cite{venema03gamealgebra}. We are not aware that these\nstructures have a special name, so we baptise them \\emph{pre-dioids}.\n\nWe do not explicitly define pre-semirings since we have no application\nfor them.\\<close>"], ["", "class pre_dioid = near_dioid +\n  assumes subdistl: \"z \\<cdot> x \\<le> z \\<cdot> (x + y)\"\n\nbegin"], ["", "text \\<open>Now, obviously, left isotonicity follows from left subdistributivity.\\<close>"], ["", "lemma subdistl_var: \"z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)", "using local.mult_isol_equiv_subdistl local.subdistl"], ["proof (prove)\nusing this:\n  (\\<forall>x y z.\n      x \\<le> y \\<longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y) =\n  (\\<forall>x y z. z \\<cdot> x \\<le> z \\<cdot> (x + y))\n  ?z \\<cdot> ?x \\<le> ?z \\<cdot> (?x + ?y)\n\ngoal (1 subgoal):\n 1. z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)", "by auto"], ["", "subclass ab_pre_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ab_pre_semiring (+) (\\<cdot>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y. z \\<cdot> x + z \\<cdot> (x + y) = z \\<cdot> (x + y)", "by (simp add: local.join.sup_absorb2 local.subdistl)"], ["", "lemma mult_isol: \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "hence \"x + y = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x + y = y", "by (simp add: less_eq_def)"], ["proof (state)\nthis:\n  x + y = y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "also"], ["proof (state)\nthis:\n  x + y = y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "have \"z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)", "using subdistl_var"], ["proof (prove)\nusing this:\n  ?z \\<cdot> ?x + ?z \\<cdot> ?y \\<le> ?z \\<cdot> (?x + ?y)\n\ngoal (1 subgoal):\n 1. z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)", "by blast"], ["proof (state)\nthis:\n  z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "have \"... = z \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> (x + y) = z \\<cdot> y", "by (simp add: calculation)"], ["proof (state)\nthis:\n  z \\<cdot> (x + y) = z \\<cdot> y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "ultimately"], ["proof (chain)\npicking this:\n  x + y = y\n  z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\n  z \\<cdot> (x + y) = z \\<cdot> y", "show \"z \\<cdot> x \\<le> z \\<cdot> y\""], ["proof (prove)\nusing this:\n  x + y = y\n  z \\<cdot> x + z \\<cdot> y \\<le> z \\<cdot> (x + y)\n  z \\<cdot> (x + y) = z \\<cdot> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x \\<le> z \\<cdot> y", "by auto"], ["proof (state)\nthis:\n  z \\<cdot> x \\<le> z \\<cdot> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_isol_var: \"u \\<le> x \\<Longrightarrow> v \\<le> y \\<Longrightarrow> u \\<cdot> v \\<le> x \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<le> x; v \\<le> y\\<rbrakk>\n    \\<Longrightarrow> u \\<cdot> v \\<le> x \\<cdot> y", "by (meson local.dual_order.trans local.mult_isor mult_isol)"], ["", "lemma mult_double_iso: \"x \\<le> y \\<Longrightarrow> w \\<cdot> x \\<cdot> z \\<le> w \\<cdot> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    w \\<cdot> x \\<cdot> z \\<le> w \\<cdot> y \\<cdot> z", "by (simp add: local.mult_isor mult_isol)"], ["", "text \\<open>The following lemmas are relevant to propositional Hoare logic.\\<close>"], ["", "lemma phl_cons2: \"w \\<le> x \\<Longrightarrow> z \\<cdot> y \\<le> y \\<cdot> w \\<Longrightarrow> z \\<cdot> y \\<le> y \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<le> x; z \\<cdot> y \\<le> y \\<cdot> w\\<rbrakk>\n    \\<Longrightarrow> z \\<cdot> y \\<le> y \\<cdot> x", "using local.order_trans mult_isol"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<cdot> ?x \\<le> ?z \\<cdot> ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<le> x; z \\<cdot> y \\<le> y \\<cdot> w\\<rbrakk>\n    \\<Longrightarrow> z \\<cdot> y \\<le> y \\<cdot> x", "by blast"], ["", "lemma phl_seq: \nassumes \"p \\<cdot> x \\<le> x \\<cdot> r\"\nand \"r \\<cdot> y \\<le> y \\<cdot> q\" \nshows \"p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q", "have \"p \\<cdot> x \\<cdot> y \\<le> x \\<cdot> r \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<cdot> x \\<cdot> y \\<le> x \\<cdot> r \\<cdot> y", "using assms(1) mult_isor"], ["proof (prove)\nusing this:\n  p \\<cdot> x \\<le> x \\<cdot> r\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. p \\<cdot> x \\<cdot> y \\<le> x \\<cdot> r \\<cdot> y", "by blast"], ["proof (state)\nthis:\n  p \\<cdot> x \\<cdot> y \\<le> x \\<cdot> r \\<cdot> y\n\ngoal (1 subgoal):\n 1. p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<cdot> x \\<cdot> y \\<le> x \\<cdot> r \\<cdot> y\n\ngoal (1 subgoal):\n 1. p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q", "by (metis assms(2) order_prop order_trans subdistl mult_assoc)"], ["proof (state)\nthis:\n  p \\<cdot> (x \\<cdot> y) \\<le> x \\<cdot> y \\<cdot> q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phl_cond: \nassumes \"u \\<cdot> v \\<le> v \\<cdot> u \\<cdot> v\" and \"u \\<cdot> w \\<le> w \\<cdot> u \\<cdot> w\" \nand \"\\<And>x y. u \\<cdot> (x + y) \\<le> u \\<cdot> x + u \\<cdot> y\"\nand \"u \\<cdot> v \\<cdot> x \\<le> x \\<cdot> z\" and \"u \\<cdot> w \\<cdot> y \\<le> y \\<cdot> z\" \nshows \"u \\<cdot> (v \\<cdot> x + w \\<cdot> y) \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "have a: \"u \\<cdot> v \\<cdot> x \\<le> v \\<cdot> x \\<cdot> z\" and b: \"u \\<cdot> w \\<cdot> y \\<le> w \\<cdot> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> v \\<cdot> x \\<le> v \\<cdot> x \\<cdot> z &&&\n    u \\<cdot> w \\<cdot> y \\<le> w \\<cdot> y \\<cdot> z", "by (metis assms mult_assoc phl_seq)+"], ["proof (state)\nthis:\n  u \\<cdot> v \\<cdot> x \\<le> v \\<cdot> x \\<cdot> z\n  u \\<cdot> w \\<cdot> y \\<le> w \\<cdot> y \\<cdot> z\n\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "have  \"u \\<cdot> (v \\<cdot> x + w \\<cdot> y) \\<le> u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y", "using assms(3) mult_assoc"], ["proof (prove)\nusing this:\n  u \\<cdot> (?x + ?y) \\<le> u \\<cdot> ?x + u \\<cdot> ?y\n  ?a \\<cdot> ?b \\<cdot> ?c = ?a \\<cdot> (?b \\<cdot> ?c)\n\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y", "by auto"], ["proof (state)\nthis:\n  u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n  \\<le> u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y\n\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "also"], ["proof (state)\nthis:\n  u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n  \\<le> u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y\n\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "have \"... \\<le> v \\<cdot> x \\<cdot> z + w \\<cdot> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y\n    \\<le> v \\<cdot> x \\<cdot> z + w \\<cdot> y \\<cdot> z", "using a b join.sup_mono"], ["proof (prove)\nusing this:\n  u \\<cdot> v \\<cdot> x \\<le> v \\<cdot> x \\<cdot> z\n  u \\<cdot> w \\<cdot> y \\<le> w \\<cdot> y \\<cdot> z\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a + ?b \\<le> ?c + ?d\n\ngoal (1 subgoal):\n 1. u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y\n    \\<le> v \\<cdot> x \\<cdot> z + w \\<cdot> y \\<cdot> z", "by blast"], ["proof (state)\nthis:\n  u \\<cdot> v \\<cdot> x + u \\<cdot> w \\<cdot> y\n  \\<le> v \\<cdot> x \\<cdot> z + w \\<cdot> y \\<cdot> z\n\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "finally"], ["proof (chain)\npicking this:\n  u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n  \\<le> v \\<cdot> x \\<cdot> z + w \\<cdot> y \\<cdot> z", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n  \\<le> v \\<cdot> x \\<cdot> z + w \\<cdot> y \\<cdot> z\n\ngoal (1 subgoal):\n 1. u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n    \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z", "by simp"], ["proof (state)\nthis:\n  u \\<cdot> (v \\<cdot> x + w \\<cdot> y)\n  \\<le> (v \\<cdot> x + w \\<cdot> y) \\<cdot> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phl_export1:\nassumes \"x \\<cdot> y \\<le> y \\<cdot> x \\<cdot> y\"\nand \"(x \\<cdot> y) \\<cdot> z \\<le> z \\<cdot> w\"\nshows \"x \\<cdot> (y \\<cdot> z) \\<le> (y \\<cdot> z) \\<cdot> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> z) \\<le> y \\<cdot> z \\<cdot> w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> z) \\<le> y \\<cdot> z \\<cdot> w", "have \"x \\<cdot> y \\<cdot> z \\<le> y \\<cdot> x \\<cdot> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<cdot> z \\<le> y \\<cdot> x \\<cdot> y \\<cdot> z", "by (simp add: assms(1) mult_isor)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<cdot> z \\<le> y \\<cdot> x \\<cdot> y \\<cdot> z\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> z) \\<le> y \\<cdot> z \\<cdot> w", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<cdot> z \\<le> y \\<cdot> x \\<cdot> y \\<cdot> z\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> z) \\<le> y \\<cdot> z \\<cdot> w", "using assms(1) assms(2) mult_assoc phl_seq"], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<cdot> z \\<le> y \\<cdot> x \\<cdot> y \\<cdot> z\n  x \\<cdot> y \\<le> y \\<cdot> x \\<cdot> y\n  x \\<cdot> y \\<cdot> z \\<le> z \\<cdot> w\n  ?a \\<cdot> ?b \\<cdot> ?c = ?a \\<cdot> (?b \\<cdot> ?c)\n  \\<lbrakk>?p \\<cdot> ?x \\<le> ?x \\<cdot> ?r;\n   ?r \\<cdot> ?y \\<le> ?y \\<cdot> ?q\\<rbrakk>\n  \\<Longrightarrow> ?p \\<cdot> (?x \\<cdot> ?y)\n                    \\<le> ?x \\<cdot> ?y \\<cdot> ?q\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> z) \\<le> y \\<cdot> z \\<cdot> w", "by auto"], ["proof (state)\nthis:\n  x \\<cdot> (y \\<cdot> z) \\<le> y \\<cdot> z \\<cdot> w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phl_export2: \nassumes \"z \\<cdot> w \\<le> w \\<cdot> z \\<cdot> w\"\nand \"x \\<cdot> y \\<le> y \\<cdot> z\"\nshows \"x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)", "have \"x \\<cdot> y \\<cdot> w \\<le> y \\<cdot> z \\<cdot> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<cdot> w \\<le> y \\<cdot> z \\<cdot> w", "using assms(2) mult_isor"], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<le> y \\<cdot> z\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<cdot> w \\<le> y \\<cdot> z \\<cdot> w", "by blast"], ["proof (state)\nthis:\n  x \\<cdot> y \\<cdot> w \\<le> y \\<cdot> z \\<cdot> w\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<cdot> w \\<le> y \\<cdot> z \\<cdot> w\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)", "by (metis assms(1) dual_order.trans order_prop subdistl mult_assoc)"], ["proof (state)\nthis:\n  x \\<cdot> (y \\<cdot> w) \\<le> y \\<cdot> w \\<cdot> (z \\<cdot> w)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* pre_dioid *)"], ["", "text \\<open>By adding a full left distributivity law we obtain semirings\n(which are already available in Isabelle/HOL as @{class semiring})\nfrom near semirings, and dioids from near dioids. Dioids are therefore\nidempotent semirings.\\<close>"], ["", "class dioid = near_dioid + semiring"], ["", "subclass (in dioid) pre_dioid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_dioid (+) (\\<cdot>) (\\<le>) (<)", "by unfold_locales (simp add: local.distrib_left)"], ["", "subsection \\<open>Families of Nearsemirings with a Multiplicative Unit\\<close>"], ["", "text \\<open>Multiplicative units are important, for instance, for defining\nan operation of finite iteration or Kleene star on dioids. We do not\nintroduce left and right units separately since we have no application\nfor this.\\<close>"], ["", "class ab_near_semiring_one = ab_near_semiring + one +\n  assumes mult_onel [simp]: \"1 \\<cdot> x = x\"\n  and mult_oner [simp]: \"x \\<cdot> 1 = x\"\n\nbegin"], ["", "subclass monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_mult (1::'a) (\\<cdot>)", "by (unfold_locales, simp_all)"], ["", "end"], ["", "(* ab_near_semiring_one *)"], ["", "class ab_pre_semiring_one = ab_near_semiring_one + ab_pre_semiring"], ["", "class near_dioid_one = near_dioid + ab_near_semiring_one\n\nbegin"], ["", "text \\<open>The following lemma is relevant to propositional Hoare logic.\\<close>"], ["", "lemma phl_skip: \"x \\<cdot> 1 \\<le> 1 \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (1::'a) \\<le> (1::'a) \\<cdot> x", "by simp"], ["", "end"], ["", "text \\<open>For near dioids with one, it would be sufficient to require\n$1+1=1$. This implies @{term \"x+x=x\"} for arbitray~@{term x} (but that\nwould lead to annoying redundant proof obligations in mutual\nsubclasses of @{class near_dioid_one} and @{class near_dioid} later).\n\\<close>"], ["", "class pre_dioid_one = pre_dioid + near_dioid_one"], ["", "class dioid_one = dioid + near_dioid_one"], ["", "subclass (in dioid_one) pre_dioid_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_dioid_one (+) (\\<cdot>) (1::'a) (\\<le>) (<)", ".."], ["", "subsection \\<open>Families of Nearsemirings with Additive Units\\<close>"], ["", "text \\<open>\nWe now axiomatise an additive unit~$0$ for nearsemirings. The zero is\nusually required to satisfy annihilation properties with respect to\nmultiplication. Due to applications we distinguish a zero which is\nonly a left annihilator from one that is also a right annihilator.\nMore briefly, we call zero either a left unit or a unit.\n\nSemirings and dioids with a right zero only can be obtained from those\nwith a left unit by duality.\n\\<close>"], ["", "class ab_near_semiring_one_zerol = ab_near_semiring_one + zero +\n  assumes add_zerol [simp]: \"0 + x = x\"\n  and annil [simp]: \"0 \\<cdot> x = 0\"\n\nbegin"], ["", "text \\<open>Note that we do not require~$0 \\neq 1$.\\<close>"], ["", "lemma add_zeror [simp]: \"x + 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (0::'a) = x", "by (subst add_commute) simp"], ["", "end"], ["", "(* ab_near_semiring_one_zerol *)"], ["", "class ab_pre_semiring_one_zerol = ab_near_semiring_one_zerol + ab_pre_semiring\n\nbegin"], ["", "text \\<open>The following lemma shows that there is no point defining pre-semirings separately from dioids.\\<close>"], ["", "lemma \"1 + 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) = (1::'a)", "have \"1 + 1 = 1 \\<cdot> 1 + 1 \\<cdot> (1 + 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) =\n    (1::'a) \\<cdot> (1::'a) + (1::'a) \\<cdot> ((1::'a) + (0::'a))", "by simp"], ["proof (state)\nthis:\n  (1::'a) + (1::'a) =\n  (1::'a) \\<cdot> (1::'a) + (1::'a) \\<cdot> ((1::'a) + (0::'a))\n\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) = (1::'a)", "also"], ["proof (state)\nthis:\n  (1::'a) + (1::'a) =\n  (1::'a) \\<cdot> (1::'a) + (1::'a) \\<cdot> ((1::'a) + (0::'a))\n\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) = (1::'a)", "have \"... = 1 \\<cdot> (1 + 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<cdot> (1::'a) + (1::'a) \\<cdot> ((1::'a) + (0::'a)) =\n    (1::'a) \\<cdot> ((1::'a) + (0::'a))", "using subdistl_eq"], ["proof (prove)\nusing this:\n  ?z \\<cdot> ?x + ?z \\<cdot> (?x + ?y) = ?z \\<cdot> (?x + ?y)\n\ngoal (1 subgoal):\n 1. (1::'a) \\<cdot> (1::'a) + (1::'a) \\<cdot> ((1::'a) + (0::'a)) =\n    (1::'a) \\<cdot> ((1::'a) + (0::'a))", "by presburger"], ["proof (state)\nthis:\n  (1::'a) \\<cdot> (1::'a) + (1::'a) \\<cdot> ((1::'a) + (0::'a)) =\n  (1::'a) \\<cdot> ((1::'a) + (0::'a))\n\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  (1::'a) + (1::'a) = (1::'a) \\<cdot> ((1::'a) + (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) + (1::'a) = (1::'a) \\<cdot> ((1::'a) + (0::'a))\n\ngoal (1 subgoal):\n 1. (1::'a) + (1::'a) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) + (1::'a) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* ab_pre_semiring_one_zerol *)"], ["", "class near_dioid_one_zerol = near_dioid_one + ab_near_semiring_one_zerol"], ["", "subclass (in near_dioid_one_zerol) join_semilattice_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.join_semilattice_zero (+) (\\<le>) (<) (0::'a)", "by (unfold_locales, simp)"], ["", "class pre_dioid_one_zerol = pre_dioid_one + ab_near_semiring_one_zerol"], ["", "subclass (in pre_dioid_one_zerol) near_dioid_one_zerol"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.near_dioid_one_zerol (+) (\\<cdot>) (1::'a) (0::'a) (\\<le>) (<)", ".."], ["", "class semiring_one_zerol = semiring + ab_near_semiring_one_zerol"], ["", "class dioid_one_zerol = dioid_one + ab_near_semiring_one_zerol"], ["", "subclass (in dioid_one_zerol) pre_dioid_one_zerol"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_dioid_one_zerol (+) (\\<cdot>) (1::'a) (0::'a) (\\<le>) (<)", ".."], ["", "text \\<open>We now make zero also a right annihilator.\\<close>"], ["", "class ab_near_semiring_one_zero = ab_near_semiring_one_zerol +\n  assumes annir [simp]: \"x \\<cdot> 0 = 0\""], ["", "class semiring_one_zero = semiring + ab_near_semiring_one_zero"], ["", "class near_dioid_one_zero = near_dioid_one_zerol + ab_near_semiring_one_zero"], ["", "class pre_dioid_one_zero = pre_dioid_one_zerol + ab_near_semiring_one_zero"], ["", "subclass (in pre_dioid_one_zero) near_dioid_one_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.near_dioid_one_zero (+) (\\<cdot>) (1::'a) (0::'a) (\\<le>) (<)", ".."], ["", "class dioid_one_zero = dioid_one_zerol + ab_near_semiring_one_zero"], ["", "subclass (in dioid_one_zero) pre_dioid_one_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_dioid_one_zero (+) (\\<cdot>) (1::'a) (0::'a) (\\<le>) (<)", ".."], ["", "subclass (in dioid_one_zero) semiring_one_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_one_zero (+) (\\<cdot>) (1::'a) (0::'a)", ".."], ["", "subsection \\<open>Duality by Opposition\\<close>"], ["", "text \\<open>\nSwapping the order of multiplication in a semiring (or dioid) gives\nanother semiring (or dioid), called its \\emph{dual} or\n\\emph{opposite}.\n\\<close>"], ["", "definition (in times) opp_mult (infixl \"\\<odot>\" 70)\n  where \"x \\<odot> y \\<equiv> y \\<cdot> x\""], ["", "lemma (in semiring_1) dual_semiring_1:\n  \"class.semiring_1 1 (\\<odot>) (+) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_1 (1::'a) (\\<odot>) (+) (0::'a)", "by unfold_locales (auto simp add: opp_mult_def mult.assoc distrib_right distrib_left)"], ["", "lemma (in dioid_one_zero) dual_dioid_one_zero:\n  \"class.dioid_one_zero (+) (\\<odot>) 1 0 (\\<le>) (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (+) (\\<odot>) (1::'a) (0::'a) (\\<le>) (<)", "by unfold_locales (auto simp add: opp_mult_def mult.assoc distrib_right distrib_left)"], ["", "subsection \\<open>Selective Near Semirings\\<close>"], ["", "text \\<open>In this section we briefly sketch a generalisation of the\nnotion of \\emph{dioid}. Some important models, e.g. max-plus and\nmin-plus semirings, have that property.\\<close>"], ["", "class selective_near_semiring = ab_near_semiring + plus_ord +\n  assumes select: \"x + y = x \\<or> x + y = y\"\n\nbegin"], ["", "lemma select_alt: \"x + y \\<in> {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> {x, y}", "by (simp add: local.select)"], ["", "text \\<open>It follows immediately that every selective near semiring is a near dioid.\\<close>"], ["", "subclass near_dioid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.near_dioid (+) (\\<cdot>) (\\<le>) (<)", "by (unfold_locales, meson select)"], ["", "text \\<open>Moreover, the order in a selective near semiring is obviously linear.\\<close>"], ["", "subclass linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<le>) (<)", "by (unfold_locales, metis add.commute join.sup.orderI select)"], ["", "end"], ["", "(*selective_near_semiring*)"], ["", "class selective_semiring = selective_near_semiring + semiring_one_zero\n\nbegin"], ["", "subclass dioid_one_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (+) (\\<cdot>) (1::'a) (0::'a) (\\<le>) (<)", ".."], ["", "end"], ["", "(* selective_semiring *)"], ["", "end"]]}