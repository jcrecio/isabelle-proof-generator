{"file_name": "/home/qj213/afp-2021-10-22/thys/Kleene_Algebra/Dioid_Models.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Kleene_Algebra", "problem_names": ["lemma first_conv [simp]: \"first (p, xs) = p\"", "lemma last_append [simp]: \"last (p, xs @ ys) = last (last (p, xs), ys)\"", "lemma t_fusion_leftneutral [simp]: \"t_fusion (first x, []) x = x\"", "lemma fusion_rightneutral [simp]: \"t_fusion x (last x, []) = x\"", "lemma first_t_fusion [simp]: \"last x = first y \\<Longrightarrow> first (t_fusion x y) = first x\"", "lemma last_t_fusion [simp]: \"last x = first y \\<Longrightarrow> last (t_fusion x y) = last y\"", "lemma t_fusion_assoc [simp]:\n  \"\\<lbrakk> last x = first y; last y = first z \\<rbrakk> \\<Longrightarrow> t_fusion x (t_fusion y z) = t_fusion (t_fusion x y) z\"", "lemma t_prod_iff:\n  \"w \\<in> X\\<cdot>Y \\<longleftrightarrow> (\\<exists>u v. w = t_fusion u v \\<and> u \\<in> X \\<and> v \\<in> Y \\<and> last u = first v)\"", "lemma t_prod_intro [simp, intro]:\n  \"\\<lbrakk> u \\<in> X; v \\<in> Y; last u = first v \\<rbrakk> \\<Longrightarrow> t_fusion u v \\<in> X\\<cdot>Y\"", "lemma t_prod_elim [elim]:\n  \"w \\<in> X\\<cdot>Y \\<Longrightarrow> \\<exists>u v. w = t_fusion u v \\<and> u \\<in> X \\<and> v \\<in> Y \\<and> last u = first v\"", "lemma p_fusion_assoc:\n  \"p_fusion ps (p_fusion qs rs) = p_fusion (p_fusion ps qs) rs\"", "lemma p_fusion_last:\n  assumes \"List.last ps = hd qs\"\n  and \"ps \\<noteq> []\"\n  and \"qs \\<noteq> []\"\n  shows \"List.last (p_fusion ps qs) = List.last qs\"", "lemma p_fusion_hd: \"\\<lbrakk>ps \\<noteq> []; qs \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd (p_fusion ps qs) = hd ps\"", "lemma nonempty_p_fusion: \"\\<lbrakk>ps \\<noteq> []; qs \\<noteq> []\\<rbrakk> \\<Longrightarrow> p_fusion ps qs \\<noteq> []\"", "lemma p_prod_iff:\n  \"ps \\<in> X \\<cdot> Y \\<longleftrightarrow> (\\<exists>qs rs. ps = p_fusion qs rs \\<and> qs \\<in> X \\<and> rs \\<in> Y \\<and> p_filter qs rs)\"", "lemma p_prod_assoc: \"(X \\<cdot> Y) \\<cdot> Z = X \\<cdot> (Y \\<cdot> Z)\"", "lemma p_prod_onel [simp]: \"p_one \\<cdot> X = X\"", "lemma p_prod_oner [simp]: \"X \\<cdot> p_one = X\"", "lemma p_prod_distl: \"X \\<cdot> (Y \\<union> Z) = X \\<cdot> Y \\<union> X \\<cdot> Z\"", "lemma p_prod_distr: \"(X \\<union> Y) \\<cdot> Z = X \\<cdot> Z \\<union> Y \\<cdot> Z\"", "lemma pp_fusion_leftneutral [simp]: \"pp_fusion (Node (pp_first x)) x = x\"", "lemma pp_fusion_rightneutral [simp]: \"pp_fusion x (Node (pp_last x)) = x\"", "lemma pp_first_pp_fusion [simp]:\n  \"pp_last x = pp_first y \\<Longrightarrow> pp_first (pp_fusion x y) = pp_first x\"", "lemma pp_last_pp_fusion [simp]:\n  \"pp_last x = pp_first y \\<Longrightarrow> pp_last (pp_fusion x y) = pp_last y\"", "lemma pp_fusion_assoc [simp]:\n  \"\\<lbrakk> pp_last x = pp_first y; pp_last y = pp_first z \\<rbrakk> \\<Longrightarrow> pp_fusion x (pp_fusion y z) = pp_fusion (pp_fusion x y) z\"", "lemma pp_prod_iff:\n  \"w \\<in> X\\<cdot>Y \\<longleftrightarrow> (\\<exists>u v. w = pp_fusion u v \\<and> u \\<in> X \\<and> v \\<in> Y \\<and> pp_last u = pp_first v)\"", "lemma mreal_max_simp_3 [simp]: \"mreal_max MInfty y = y\"", "lemma preal_min_simp_3 [simp]: \"preal_min PInfty y = y\"", "lemma pnat_min_simp_3 [simp]: \"pnat_min PInfty y = y\"", "lemma zero_pnat_top: \"(x::pnat) \\<le> 1\""], "translations": [["", "lemma first_conv [simp]: \"first (p, xs) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first (p, xs) = p", "by (unfold first_def, simp)"], ["", "fun last :: \"('p, 'a) trace \\<Rightarrow> 'p\" where\n  \"last (p, []) = p\"\n| \"last (_, xs) = snd (List.last xs)\""], ["", "lemma last_append [simp]: \"last (p, xs @ ys) = last (last (p, xs), ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dioid_Models.last (p, xs @ ys) =\n    Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Dioid_Models.last (p, xs @ ys) =\n    Dioid_Models.last (Dioid_Models.last (p, xs), ys)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Dioid_Models.last (p, xs @ ys) =\n       Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "show \"xs = [] \\<Longrightarrow> last (p, xs @ ys) = last (last (p, xs), ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    Dioid_Models.last (p, xs @ ys) =\n    Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "by simp"], ["proof (state)\nthis:\n  xs = [] \\<Longrightarrow>\n  Dioid_Models.last (p, xs @ ys) =\n  Dioid_Models.last (Dioid_Models.last (p, xs), ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Dioid_Models.last (p, xs @ ys) =\n       Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "show \"\\<And>a list. xs = a # list \\<Longrightarrow>\n    last (p, xs @ ys) = last (last (p, xs), ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Dioid_Models.last (p, xs @ ys) =\n       Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>xs = a # list; ys = []\\<rbrakk>\n       \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                         Dioid_Models.last (Dioid_Models.last (p, xs), ys)\n 2. \\<And>a list aa lista.\n       \\<lbrakk>xs = a # list; ys = aa # lista\\<rbrakk>\n       \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                         Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "show \"\\<And>a list. \\<lbrakk>xs = a # list; ys = []\\<rbrakk>\n      \\<Longrightarrow> last (p, xs @ ys) = last (last (p, xs), ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>xs = a # list; ys = []\\<rbrakk>\n       \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                         Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?a # ?list; ys = []\\<rbrakk>\n  \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                    Dioid_Models.last (Dioid_Models.last (p, xs), ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>xs = a # list; ys = aa # lista\\<rbrakk>\n       \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                         Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "show \"\\<And>a list aa lista. \\<lbrakk>xs = a # list; ys = aa # lista\\<rbrakk>\n      \\<Longrightarrow> last (p, xs @ ys) = last (last (p, xs), ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>xs = a # list; ys = aa # lista\\<rbrakk>\n       \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                         Dioid_Models.last (Dioid_Models.last (p, xs), ys)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?a # ?list; ys = ?aa # ?lista\\<rbrakk>\n  \\<Longrightarrow> Dioid_Models.last (p, xs @ ys) =\n                    Dioid_Models.last (Dioid_Models.last (p, xs), ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ?a # ?list \\<Longrightarrow>\n  Dioid_Models.last (p, xs @ ys) =\n  Dioid_Models.last (Dioid_Models.last (p, xs), ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The fusion product is a partial operation. It is undefined if\nthe last element of the first trace and the first element of the\nsecond trace are different. If these elements are the same, then the\nfusion product removes the first element from the second trace and\nappends the resulting object to the first trace.\\<close>"], ["", "definition t_fusion :: \"('p, 'a) trace \\<Rightarrow> ('p, 'a) trace \\<Rightarrow> ('p, 'a) trace\" where\n  \"t_fusion x y \\<equiv> if last x = first y then (fst x, snd x @ snd y) else undefined\""], ["", "text \\<open>We now show that the first element and the last element of a\ntrace are a left and right unit for that trace and prove some other\nauxiliary lemmas.\\<close>"], ["", "lemma t_fusion_leftneutral [simp]: \"t_fusion (first x, []) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_fusion (first x, []) x = x", "by (cases x, simp add: t_fusion_def)"], ["", "lemma fusion_rightneutral [simp]: \"t_fusion x (last x, []) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_fusion x (Dioid_Models.last x, []) = x", "by (simp add: t_fusion_def)"], ["", "lemma first_t_fusion [simp]: \"last x = first y \\<Longrightarrow> first (t_fusion x y) = first x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dioid_Models.last x = first y \\<Longrightarrow>\n    first (t_fusion x y) = first x", "by (simp add: first_def t_fusion_def)"], ["", "lemma last_t_fusion [simp]: \"last x = first y \\<Longrightarrow> last (t_fusion x y) = last y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dioid_Models.last x = first y \\<Longrightarrow>\n    Dioid_Models.last (t_fusion x y) = Dioid_Models.last y", "by (simp add: first_def t_fusion_def)"], ["", "text \\<open>Next we show that fusion of traces is associative.\\<close>"], ["", "lemma t_fusion_assoc [simp]:\n  \"\\<lbrakk> last x = first y; last y = first z \\<rbrakk> \\<Longrightarrow> t_fusion x (t_fusion y z) = t_fusion (t_fusion x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dioid_Models.last x = first y;\n     Dioid_Models.last y = first z\\<rbrakk>\n    \\<Longrightarrow> t_fusion x (t_fusion y z) = t_fusion (t_fusion x y) z", "by (cases x, cases y, cases z, simp add: t_fusion_def)"], ["", "subsection \\<open>Sets of Traces\\<close>"], ["", "text \\<open>We now lift the fusion product to a complex product on sets of\ntraces. This operation is total.\\<close>"], ["", "no_notation\n  times (infixl \"\\<cdot>\" 70)"], ["", "definition t_prod :: \"('p, 'a) trace set \\<Rightarrow> ('p, 'a) trace set \\<Rightarrow> ('p, 'a) trace set\" (infixl \"\\<cdot>\" 70)\nwhere \"X \\<cdot> Y = {t_fusion u v| u v. u \\<in> X \\<and> v \\<in> Y \\<and> last u = first v}\""], ["", "text \\<open>Next we define the empty set of traces and the set of traces\nof length zero as the multiplicative unit of the trace dioid.\\<close>"], ["", "definition t_zero :: \"('p, 'a) trace set\" where\n  \"t_zero \\<equiv> {}\""], ["", "definition t_one :: \"('p, 'a) trace set\" where\n  \"t_one \\<equiv> \\<Union>p. {(p, [])}\""], ["", "text \\<open>We now provide elimination rules for trace products.\\<close>"], ["", "lemma t_prod_iff:\n  \"w \\<in> X\\<cdot>Y \\<longleftrightarrow> (\\<exists>u v. w = t_fusion u v \\<and> u \\<in> X \\<and> v \\<in> Y \\<and> last u = first v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> X \\<cdot> Y) =\n    (\\<exists>u v.\n        w = t_fusion u v \\<and>\n        u \\<in> X \\<and> v \\<in> Y \\<and> Dioid_Models.last u = first v)", "by (unfold t_prod_def) auto"], ["", "lemma t_prod_intro [simp, intro]:\n  \"\\<lbrakk> u \\<in> X; v \\<in> Y; last u = first v \\<rbrakk> \\<Longrightarrow> t_fusion u v \\<in> X\\<cdot>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> X; v \\<in> Y; Dioid_Models.last u = first v\\<rbrakk>\n    \\<Longrightarrow> t_fusion u v \\<in> X \\<cdot> Y", "by (meson t_prod_iff)"], ["", "lemma t_prod_elim [elim]:\n  \"w \\<in> X\\<cdot>Y \\<Longrightarrow> \\<exists>u v. w = t_fusion u v \\<and> u \\<in> X \\<and> v \\<in> Y \\<and> last u = first v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> X \\<cdot> Y \\<Longrightarrow>\n    \\<exists>u v.\n       w = t_fusion u v \\<and>\n       u \\<in> X \\<and> v \\<in> Y \\<and> Dioid_Models.last u = first v", "by (meson t_prod_iff)"], ["", "text \\<open>Finally we prove the interpretation statement that sets of traces\nunder union and the complex product based on trace fusion together\nwith the empty set of traces and the set of traces of length one forms\na dioid.\\<close>"], ["", "interpretation trace_dioid: dioid_one_zero \"(\\<union>)\" t_prod t_one t_zero \"(\\<subseteq>)\" \"(\\<subset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (\\<union>) (\\<cdot>) t_one t_zero (\\<subseteq>)\n     (\\<subset>)", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>a b c. a \\<union> b \\<union> c = a \\<union> (b \\<union> c)\n 2. \\<And>a b. a \\<union> b = b \\<union> a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 5. \\<And>x. t_one \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> t_one = x\n 7. \\<And>x. t_zero \\<union> x = x\n 8. \\<And>x. t_zero \\<cdot> x = t_zero\n 9. \\<And>x. x \\<cdot> t_zero = t_zero\n 10. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\nA total of 13 subgoals...", "apply (auto simp add: t_prod_def t_one_def t_zero_def t_fusion_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c ab bc bd be.\n       \\<lbrakk>(Dioid_Models.last (Dioid_Models.last (ab, bd), be), bc)\n                \\<in> c;\n        (ab, bd) \\<in> a; (Dioid_Models.last (ab, bd), be) \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba bb.\n                            bd @ be @ bc = ba @ bb \\<and>\n                            (ab, ba) \\<in> a \\<and>\n                            (\\<exists>bc bd.\n                                bb = bc @ bd \\<and>\n                                (Dioid_Models.last (ab, ba), bc)\n                                \\<in> b \\<and>\n                                (Dioid_Models.last\n                                  (Dioid_Models.last (ab, ba), bc),\n                                 bd)\n                                \\<in> c)\n 2. \\<And>a b c ab bb bd be.\n       \\<lbrakk>(ab, bb) \\<in> a; (Dioid_Models.last (ab, bb), bd) \\<in> b;\n        (Dioid_Models.last (Dioid_Models.last (ab, bb), bd), be)\n        \\<in> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba bc.\n                            bb @ bd @ be = ba @ bc \\<and>\n                            (\\<exists>bb bc.\n                                ba = bb @ bc \\<and>\n                                (ab, bb) \\<in> a \\<and>\n                                (Dioid_Models.last (ab, bb), bc)\n                                \\<in> b) \\<and>\n                            (Dioid_Models.last (ab, ba), bc) \\<in> c", "apply (metis last_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c ab bb bd be.\n       \\<lbrakk>(ab, bb) \\<in> a; (Dioid_Models.last (ab, bb), bd) \\<in> b;\n        (Dioid_Models.last (Dioid_Models.last (ab, bb), bd), be)\n        \\<in> c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba bc.\n                            bb @ bd @ be = ba @ bc \\<and>\n                            (\\<exists>bb bc.\n                                ba = bb @ bc \\<and>\n                                (ab, bb) \\<in> a \\<and>\n                                (Dioid_Models.last (ab, bb), bc)\n                                \\<in> b) \\<and>\n                            (Dioid_Models.last (ab, ba), bc) \\<in> c", "apply (metis last_append append_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "no_notation\n  t_prod (infixl \"\\<cdot>\" 70)"], ["", "subsection \\<open>The Path Diod\\<close>"], ["", "text \\<open>The next model we consider are sets of paths in a graph. We\nconsider two variants, one that contains the empty path and one that\ndoesn't. The former leads to more difficult proofs and a more involved\nspecification of the complex product. We start with paths that include\nthe empty path. In this setting, a path is a list of nodes.\\<close>"], ["", "subsection \\<open>Path Models with the Empty Path\\<close>"], ["", "type_synonym 'a path = \"'a list\""], ["", "text \\<open>Path fusion is defined similarly to trace\nfusion. Mathematically it should be a partial operation. The fusion of\ntwo empty paths yields the empty path; the fusion between a non-empty\npath and an empty one is undefined; the fusion of two non-empty paths\nappends the tail of the second path to the first one.\n\nWe need to use a total alternative and make sure that undefined paths\ndo not contribute to the complex product.\\<close>"], ["", "fun p_fusion :: \"'a path \\<Rightarrow> 'a path \\<Rightarrow> 'a path\" where\n  \"p_fusion [] _ = []\"\n| \"p_fusion _ [] = []\"\n| \"p_fusion ps (q # qs) = ps @ qs\""], ["", "lemma p_fusion_assoc:\n  \"p_fusion ps (p_fusion qs rs) = p_fusion (p_fusion ps qs) rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion qs rs) = p_fusion (p_fusion ps qs) rs", "proof (induct rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. p_fusion ps (p_fusion qs []) = p_fusion (p_fusion ps qs) []\n 2. \\<And>a rs.\n       p_fusion ps (p_fusion qs rs) =\n       p_fusion (p_fusion ps qs) rs \\<Longrightarrow>\n       p_fusion ps (p_fusion qs (a # rs)) =\n       p_fusion (p_fusion ps qs) (a # rs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. p_fusion ps (p_fusion qs []) = p_fusion (p_fusion ps qs) []\n 2. \\<And>a rs.\n       p_fusion ps (p_fusion qs rs) =\n       p_fusion (p_fusion ps qs) rs \\<Longrightarrow>\n       p_fusion ps (p_fusion qs (a # rs)) =\n       p_fusion (p_fusion ps qs) (a # rs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion qs []) = p_fusion (p_fusion ps qs) []", "by (metis p_fusion.elims p_fusion.simps(2))"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion qs []) = p_fusion (p_fusion ps qs) []\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       p_fusion ps (p_fusion qs rs) =\n       p_fusion (p_fusion ps qs) rs \\<Longrightarrow>\n       p_fusion ps (p_fusion qs (a # rs)) =\n       p_fusion (p_fusion ps qs) (a # rs)", "case Cons"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion qs rs_) = p_fusion (p_fusion ps qs) rs_\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       p_fusion ps (p_fusion qs rs) =\n       p_fusion (p_fusion ps qs) rs \\<Longrightarrow>\n       p_fusion ps (p_fusion qs (a # rs)) =\n       p_fusion (p_fusion ps qs) (a # rs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion qs (a_ # rs_)) =\n    p_fusion (p_fusion ps qs) (a_ # rs_)", "proof (induct qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. p_fusion ps (p_fusion [] (a_ # rs_)) =\n    p_fusion (p_fusion ps []) (a_ # rs_)\n 2. \\<And>aa qs.\n       p_fusion ps (p_fusion qs (a_ # rs_)) =\n       p_fusion (p_fusion ps qs) (a_ # rs_) \\<Longrightarrow>\n       p_fusion ps (p_fusion (aa # qs) (a_ # rs_)) =\n       p_fusion (p_fusion ps (aa # qs)) (a_ # rs_)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. p_fusion ps (p_fusion [] (a_ # rs_)) =\n    p_fusion (p_fusion ps []) (a_ # rs_)\n 2. \\<And>aa qs.\n       p_fusion ps (p_fusion qs (a_ # rs_)) =\n       p_fusion (p_fusion ps qs) (a_ # rs_) \\<Longrightarrow>\n       p_fusion ps (p_fusion (aa # qs) (a_ # rs_)) =\n       p_fusion (p_fusion ps (aa # qs)) (a_ # rs_)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion [] (a_ # rs_)) =\n    p_fusion (p_fusion ps []) (a_ # rs_)", "by (metis neq_Nil_conv p_fusion.simps(1) p_fusion.simps(2))"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion [] (a_ # rs_)) =\n  p_fusion (p_fusion ps []) (a_ # rs_)\n\ngoal (1 subgoal):\n 1. \\<And>aa qs.\n       p_fusion ps (p_fusion qs (a_ # rs_)) =\n       p_fusion (p_fusion ps qs) (a_ # rs_) \\<Longrightarrow>\n       p_fusion ps (p_fusion (aa # qs) (a_ # rs_)) =\n       p_fusion (p_fusion ps (aa # qs)) (a_ # rs_)", "case Cons"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion qs_ (a___ # rs_)) =\n  p_fusion (p_fusion ps qs_) (a___ # rs_)\n\ngoal (1 subgoal):\n 1. \\<And>aa qs.\n       p_fusion ps (p_fusion qs (a___ # rs_)) =\n       p_fusion (p_fusion ps qs) (a___ # rs_) \\<Longrightarrow>\n       p_fusion ps (p_fusion (aa # qs) (a___ # rs_)) =\n       p_fusion (p_fusion ps (aa # qs)) (a___ # rs_)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n    p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n    p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)", "have \"\\<forall>ps. ([] = ps \\<or> hd ps # tl ps = ps) \\<and> ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps.\n       ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n       ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)", "using list.collapse"], ["proof (prove)\nusing this:\n  ?list \\<noteq> [] \\<Longrightarrow> hd ?list # tl ?list = ?list\n\ngoal (1 subgoal):\n 1. \\<forall>ps.\n       ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n       ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>ps.\n     ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n     ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)\n\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n    p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)", "moreover"], ["proof (state)\nthis:\n  \\<forall>ps.\n     ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n     ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)\n\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n    p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)", "hence \"\\<forall>ps q qs. p_fusion ps (q # qs) = ps @ qs \\<or> [] = ps\""], ["proof (prove)\nusing this:\n  \\<forall>ps.\n     ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n     ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)\n\ngoal (1 subgoal):\n 1. \\<forall>ps q qs. p_fusion ps (q # qs) = ps @ qs \\<or> [] = ps", "by (metis p_fusion.simps(3))"], ["proof (state)\nthis:\n  \\<forall>ps q qs. p_fusion ps (q # qs) = ps @ qs \\<or> [] = ps\n\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n    p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>ps.\n     ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n     ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)\n  \\<forall>ps q qs. p_fusion ps (q # qs) = ps @ qs \\<or> [] = ps", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ps.\n     ([] = ps \\<or> hd ps # tl ps = ps) \\<and>\n     ((\\<forall>q qs. q # qs \\<noteq> ps) \\<or> [] \\<noteq> ps)\n  \\<forall>ps q qs. p_fusion ps (q # qs) = ps @ qs \\<or> [] = ps\n\ngoal (1 subgoal):\n 1. p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n    p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)", "by (metis (no_types) Cons_eq_appendI append_eq_appendI p_fusion.simps(1) p_fusion.simps(3))"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n  p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion (a_ # qs_) (a___ # rs_)) =\n  p_fusion (p_fusion ps (a_ # qs_)) (a___ # rs_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p_fusion ps (p_fusion qs (a_ # rs_)) =\n  p_fusion (p_fusion ps qs) (a_ # rs_)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma overapproximates the real situation, but it holds\nin all cases where path fusion should be defined.\\<close>"], ["", "lemma p_fusion_last:\n  assumes \"List.last ps = hd qs\"\n  and \"ps \\<noteq> []\"\n  and \"qs \\<noteq> []\"\n  shows \"List.last (p_fusion ps qs) = List.last qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.last (p_fusion ps qs) = List.last qs", "by (metis (hide_lams, no_types) List.last.simps List.last_append append_Nil2 assms list.sel(1) neq_Nil_conv p_fusion.simps(3))"], ["", "lemma p_fusion_hd: \"\\<lbrakk>ps \\<noteq> []; qs \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd (p_fusion ps qs) = hd ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<noteq> []; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd (p_fusion ps qs) = hd ps", "by (metis list.exhaust p_fusion.simps(3) append_Cons list.sel(1))"], ["", "lemma nonempty_p_fusion: \"\\<lbrakk>ps \\<noteq> []; qs \\<noteq> []\\<rbrakk> \\<Longrightarrow> p_fusion ps qs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps \\<noteq> []; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> p_fusion ps qs \\<noteq> []", "by (metis list.exhaust append_Cons p_fusion.simps(3) list.simps(2))"], ["", "text \\<open>We now define a condition that filters out undefined paths in\nthe complex product.\\<close>"], ["", "abbreviation p_filter :: \"'a path \\<Rightarrow> 'a path \\<Rightarrow> bool\" where\n\"p_filter ps qs \\<equiv> ((ps = [] \\<and> qs = []) \\<or> (ps \\<noteq> [] \\<and> qs \\<noteq> [] \\<and> (List.last ps) = hd qs))\""], ["", "no_notation\n  times (infixl \"\\<cdot>\" 70)"], ["", "definition p_prod :: \"'a path set \\<Rightarrow> 'a path set \\<Rightarrow> 'a path set\" (infixl \"\\<cdot>\" 70)\nwhere \"X \\<cdot> Y = {rs . \\<exists>ps \\<in> X. \\<exists>qs \\<in> Y. rs = p_fusion ps qs \\<and> p_filter ps qs}\""], ["", "lemma p_prod_iff:\n  \"ps \\<in> X \\<cdot> Y \\<longleftrightarrow> (\\<exists>qs rs. ps = p_fusion qs rs \\<and> qs \\<in> X \\<and> rs \\<in> Y \\<and> p_filter qs rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> Y) =\n    (\\<exists>qs rs.\n        ps = p_fusion qs rs \\<and>\n        qs \\<in> X \\<and> rs \\<in> Y \\<and> p_filter qs rs)", "by (unfold p_prod_def) auto"], ["", "text \\<open>Due to the complexity of the filter condition, proving\nproperties of complex products can be tedious.\\<close>"], ["", "lemma p_prod_assoc: \"(X \\<cdot> Y) \\<cdot> Z = X \\<cdot> (Y \\<cdot> Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<cdot> Y \\<cdot> Z = X \\<cdot> (Y \\<cdot> Z)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<cdot> Y \\<cdot> Z) = (x \\<in> X \\<cdot> (Y \\<cdot> Z))", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<cdot> Y \\<cdot> Z) = (x \\<in> X \\<cdot> (Y \\<cdot> Z))", "show \"ps \\<in> (X \\<cdot> Y) \\<cdot> Z \\<longleftrightarrow> ps \\<in> X \\<cdot> (Y \\<cdot> Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "proof (cases ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "case Nil"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow>\n    (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = []\n\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "by auto (metis nonempty_p_fusion p_prod_iff)+"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "case Cons"], ["proof (state)\nthis:\n  ps = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = a_ # list_\n\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))", "by (auto simp add: p_prod_iff) (metis (hide_lams, mono_tags) nonempty_p_fusion p_fusion_assoc p_fusion_hd p_fusion_last)+"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> Y \\<cdot> Z) = (ps \\<in> X \\<cdot> (Y \\<cdot> Z))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now define the multiplicative unit of the path dioid as the\nset of all paths of length one, including the empty path, and show the\nunit laws with respect to the path product.\\<close>"], ["", "definition p_one :: \"'a path set\" where\n  \"p_one \\<equiv> {p . \\<exists>q::'a. p = [q]} \\<union> {[]}\""], ["", "lemma p_prod_onel [simp]: \"p_one \\<cdot> X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_one \\<cdot> X = X", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> p_one \\<cdot> X) = (x \\<in> X)", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> p_one \\<cdot> X) = (x \\<in> X)", "show \"ps \\<in> p_one \\<cdot> X \\<longleftrightarrow> ps \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "proof (cases ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow> (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "case Nil"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow> (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = []\n\ngoal (1 subgoal):\n 1. (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "by (auto simp add: p_one_def p_prod_def, metis nonempty_p_fusion not_Cons_self)"], ["proof (state)\nthis:\n  (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "case Cons"], ["proof (state)\nthis:\n  ps = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = a_ # list_\n\ngoal (1 subgoal):\n 1. (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)", "by (auto simp add: p_one_def p_prod_def, metis append_Cons append_Nil list.sel(1) neq_Nil_conv p_fusion.simps(3), metis Cons_eq_appendI list.sel(1) last_ConsL list.simps(3) p_fusion.simps(3) self_append_conv2)"], ["proof (state)\nthis:\n  (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ps \\<in> p_one \\<cdot> X) = (ps \\<in> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_prod_oner [simp]: \"X \\<cdot> p_one = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<cdot> p_one = X", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> X \\<cdot> p_one) = (x \\<in> X)", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> X \\<cdot> p_one) = (x \\<in> X)", "show \"ps \\<in> X \\<cdot> p_one \\<longleftrightarrow> ps \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "proof (cases ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow> (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "case Nil"], ["proof (state)\nthis:\n  ps = []\n\ngoal (2 subgoals):\n 1. ps = [] \\<Longrightarrow> (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)\n 2. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = []\n\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "by (auto simp add: p_one_def p_prod_def, metis nonempty_p_fusion not_Cons_self2, metis p_fusion.simps(1))"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "case Cons"], ["proof (state)\nthis:\n  ps = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps = a # list \\<Longrightarrow>\n       (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps = a_ # list_\n\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)", "by (auto simp add: p_one_def p_prod_def, metis append_Nil2 neq_Nil_conv p_fusion.simps(3), metis list.sel(1) list.simps(2) p_fusion.simps(3) self_append_conv)"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> p_one) = (ps \\<in> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next we show distributivity laws at the powerset level.\\<close>"], ["", "lemma p_prod_distl: \"X \\<cdot> (Y \\<union> Z) = X \\<cdot> Y \\<union> X \\<cdot> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<cdot> (Y \\<union> Z) = X \\<cdot> Y \\<union> X \\<cdot> Z", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<cdot> (Y \\<union> Z)) =\n       (x \\<in> X \\<cdot> Y \\<union> X \\<cdot> Z)", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<cdot> (Y \\<union> Z)) =\n       (x \\<in> X \\<cdot> Y \\<union> X \\<cdot> Z)", "show \"ps \\<in> X \\<cdot> (Y \\<union> Z) \\<longleftrightarrow> ps \\<in> X \\<cdot> Y \\<union> X \\<cdot> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> X \\<cdot> (Y \\<union> Z)) =\n    (ps \\<in> X \\<cdot> Y \\<union> X \\<cdot> Z)", "by (cases ps) (auto simp add: p_prod_iff)"], ["proof (state)\nthis:\n  (ps \\<in> X \\<cdot> (Y \\<union> Z)) =\n  (ps \\<in> X \\<cdot> Y \\<union> X \\<cdot> Z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_prod_distr: \"(X \\<union> Y) \\<cdot> Z = X \\<cdot> Z \\<union> Y \\<cdot> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<union> Y) \\<cdot> Z = X \\<cdot> Z \\<union> Y \\<cdot> Z", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (X \\<union> Y) \\<cdot> Z) =\n       (x \\<in> X \\<cdot> Z \\<union> Y \\<cdot> Z)", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> (X \\<union> Y) \\<cdot> Z) =\n       (x \\<in> X \\<cdot> Z \\<union> Y \\<cdot> Z)", "show \"ps \\<in> (X \\<union> Y) \\<cdot> Z \\<longleftrightarrow> ps \\<in> X \\<cdot> Z \\<union> Y \\<cdot> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps \\<in> (X \\<union> Y) \\<cdot> Z) =\n    (ps \\<in> X \\<cdot> Z \\<union> Y \\<cdot> Z)", "by (cases ps) (auto simp add: p_prod_iff)"], ["proof (state)\nthis:\n  (ps \\<in> (X \\<union> Y) \\<cdot> Z) =\n  (ps \\<in> X \\<cdot> Z \\<union> Y \\<cdot> Z)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally we show that sets of paths under union, the complex\nproduct, the unit set and the empty set form a dioid.\\<close>"], ["", "interpretation path_dioid: dioid_one_zero \"(\\<union>)\" \"(\\<cdot>)\" p_one \"{}\" \"(\\<subseteq>)\" \"(\\<subset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (\\<union>) (\\<cdot>) p_one {} (\\<subseteq>)\n     (\\<subset>)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a \\<union> b \\<union> c = a \\<union> (b \\<union> c)\n 2. \\<And>a b. a \\<union> b = b \\<union> a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 5. \\<And>x. p_one \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> p_one = x\n 7. \\<And>x. {} \\<union> x = x\n 8. \\<And>x. {} \\<cdot> x = {}\n 9. \\<And>x. x \\<cdot> {} = {}\n 10. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\nA total of 13 subgoals...", "fix x y z :: \"'a path set\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a \\<union> b \\<union> c = a \\<union> (b \\<union> c)\n 2. \\<And>a b. a \\<union> b = b \\<union> a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 5. \\<And>x. p_one \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> p_one = x\n 7. \\<And>x. {} \\<union> x = x\n 8. \\<And>x. {} \\<cdot> x = {}\n 9. \\<And>x. x \\<cdot> {} = {}\n 10. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\nA total of 13 subgoals...", "show  \"x \\<union> y \\<union> z = x \\<union> (y \\<union> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<union> y \\<union> z = x \\<union> (y \\<union> z)", "by auto"], ["proof (state)\nthis:\n  x \\<union> y \\<union> z = x \\<union> (y \\<union> z)\n\ngoal (12 subgoals):\n 1. \\<And>a b. a \\<union> b = b \\<union> a\n 2. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 3. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 4. \\<And>x. p_one \\<cdot> x = x\n 5. \\<And>x. x \\<cdot> p_one = x\n 6. \\<And>x. {} \\<union> x = x\n 7. \\<And>x. {} \\<cdot> x = {}\n 8. \\<And>x. x \\<cdot> {} = {}\n 9. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 10. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\nA total of 12 subgoals...", "show \"x \\<union> y = y \\<union> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<union> y = y \\<union> x", "by auto"], ["proof (state)\nthis:\n  x \\<union> y = y \\<union> x\n\ngoal (11 subgoals):\n 1. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 2. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 3. \\<And>x. p_one \\<cdot> x = x\n 4. \\<And>x. x \\<cdot> p_one = x\n 5. \\<And>x. {} \\<union> x = x\n 6. \\<And>x. {} \\<cdot> x = {}\n 7. \\<And>x. x \\<cdot> {} = {}\n 8. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 9. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 10. \\<And>x. x \\<union> x = x\nA total of 11 subgoals...", "show \"(x \\<cdot> y) \\<cdot> z = x \\<cdot> (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)", "by (fact p_prod_assoc)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 2. \\<And>x. p_one \\<cdot> x = x\n 3. \\<And>x. x \\<cdot> p_one = x\n 4. \\<And>x. {} \\<union> x = x\n 5. \\<And>x. {} \\<cdot> x = {}\n 6. \\<And>x. x \\<cdot> {} = {}\n 7. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 8. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 9. \\<And>x. x \\<union> x = x\n 10. \\<And>a b c.\n        a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"(x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z", "by (fact p_prod_distr)"], ["proof (state)\nthis:\n  (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n\ngoal (9 subgoals):\n 1. \\<And>x. p_one \\<cdot> x = x\n 2. \\<And>x. x \\<cdot> p_one = x\n 3. \\<And>x. {} \\<union> x = x\n 4. \\<And>x. {} \\<cdot> x = {}\n 5. \\<And>x. x \\<cdot> {} = {}\n 6. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 7. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 8. \\<And>x. x \\<union> x = x\n 9. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"p_one \\<cdot> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_one \\<cdot> x = x", "by (fact p_prod_onel)"], ["proof (state)\nthis:\n  p_one \\<cdot> x = x\n\ngoal (8 subgoals):\n 1. \\<And>x. x \\<cdot> p_one = x\n 2. \\<And>x. {} \\<union> x = x\n 3. \\<And>x. {} \\<cdot> x = {}\n 4. \\<And>x. x \\<cdot> {} = {}\n 5. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 6. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 7. \\<And>x. x \\<union> x = x\n 8. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<cdot> p_one = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> p_one = x", "by (fact p_prod_oner)"], ["proof (state)\nthis:\n  x \\<cdot> p_one = x\n\ngoal (7 subgoals):\n 1. \\<And>x. {} \\<union> x = x\n 2. \\<And>x. {} \\<cdot> x = {}\n 3. \\<And>x. x \\<cdot> {} = {}\n 4. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 5. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 6. \\<And>x. x \\<union> x = x\n 7. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"{} \\<union> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<union> x = x", "by auto"], ["proof (state)\nthis:\n  {} \\<union> x = x\n\ngoal (6 subgoals):\n 1. \\<And>x. {} \\<cdot> x = {}\n 2. \\<And>x. x \\<cdot> {} = {}\n 3. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 4. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 5. \\<And>x. x \\<union> x = x\n 6. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"{} \\<cdot> x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<cdot> x = {}", "by (metis all_not_in_conv p_prod_iff)"], ["proof (state)\nthis:\n  {} \\<cdot> x = {}\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<cdot> {} = {}\n 2. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 3. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 4. \\<And>x. x \\<union> x = x\n 5. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<cdot> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> {} = {}", "by (metis all_not_in_conv p_prod_iff)"], ["proof (state)\nthis:\n  x \\<cdot> {} = {}\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 2. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 3. \\<And>x. x \\<union> x = x\n 4. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"(x \\<subseteq> y) = (x \\<union> y = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<subseteq> y) = (x \\<union> y = y)", "by auto"], ["proof (state)\nthis:\n  (x \\<subseteq> y) = (x \\<union> y = y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 2. \\<And>x. x \\<union> x = x\n 3. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"(x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)", "by auto"], ["proof (state)\nthis:\n  (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<union> x = x\n 2. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<union> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<union> x = x", "by auto"], ["proof (state)\nthis:\n  x \\<union> x = x\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<cdot> (y \\<union> z) = x \\<cdot> y \\<union> x \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<union> z) = x \\<cdot> y \\<union> x \\<cdot> z", "by (fact p_prod_distl)"], ["proof (state)\nthis:\n  x \\<cdot> (y \\<union> z) = x \\<cdot> y \\<union> x \\<cdot> z\n\ngoal:\nNo subgoals!", "qed"], ["", "no_notation\n  p_prod (infixl \"\\<cdot>\" 70)"], ["", "subsection \\<open>Path Models without the Empty Path\\<close>"], ["", "text \\<open>We now build a model of paths that does not include the empty\npath and therefore leads to a simpler complex product.\\<close>"], ["", "datatype 'a ppath = Node 'a | Cons 'a \"'a ppath\""], ["", "primrec pp_first :: \"'a ppath \\<Rightarrow> 'a\" where\n  \"pp_first (Node x)   = x\"\n| \"pp_first (Cons x _) = x\""], ["", "primrec pp_last :: \"'a ppath \\<Rightarrow> 'a\" where\n  \"pp_last (Node x)    = x\"\n| \"pp_last (Cons _ xs) = pp_last xs\""], ["", "text \\<open>The path fusion product (although we define it as a total\nfuncion) should only be applied when the last element of the first\nargument is equal to the first element of the second argument.\\<close>"], ["", "primrec pp_fusion :: \"'a ppath \\<Rightarrow> 'a ppath \\<Rightarrow> 'a ppath\" where\n  \"pp_fusion (Node x) ys = ys\"\n| \"pp_fusion (Cons x xs) ys = Cons x (pp_fusion xs ys)\""], ["", "text \\<open>We now go through the same steps as for traces and paths\nbefore, showing that the first and last element of a trace a left or\nright unit for that trace and that the fusion product on traces is\nassociative.\\<close>"], ["", "lemma pp_fusion_leftneutral [simp]: \"pp_fusion (Node (pp_first x)) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_fusion (Node (pp_first x)) x = x", "by simp"], ["", "lemma pp_fusion_rightneutral [simp]: \"pp_fusion x (Node (pp_last x)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_fusion x (Node (pp_last x)) = x", "by (induct x) simp_all"], ["", "lemma pp_first_pp_fusion [simp]:\n  \"pp_last x = pp_first y \\<Longrightarrow> pp_first (pp_fusion x y) = pp_first x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_last x = pp_first y \\<Longrightarrow>\n    pp_first (pp_fusion x y) = pp_first x", "by (induct x) simp_all"], ["", "lemma pp_last_pp_fusion [simp]:\n  \"pp_last x = pp_first y \\<Longrightarrow> pp_last (pp_fusion x y) = pp_last y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_last x = pp_first y \\<Longrightarrow>\n    pp_last (pp_fusion x y) = pp_last y", "by (induct x) simp_all"], ["", "lemma pp_fusion_assoc [simp]:\n  \"\\<lbrakk> pp_last x = pp_first y; pp_last y = pp_first z \\<rbrakk> \\<Longrightarrow> pp_fusion x (pp_fusion y z) = pp_fusion (pp_fusion x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pp_last x = pp_first y; pp_last y = pp_first z\\<rbrakk>\n    \\<Longrightarrow> pp_fusion x (pp_fusion y z) =\n                      pp_fusion (pp_fusion x y) z", "by (induct x) simp_all"], ["", "text \\<open>We now lift the path fusion product to a complex product on\nsets of paths. This operation is total.\\<close>"], ["", "definition pp_prod :: \"'a ppath set \\<Rightarrow> 'a ppath set \\<Rightarrow> 'a ppath set\" (infixl \"\\<cdot>\" 70)\n  where \"X\\<cdot>Y = {pp_fusion u v| u v. u \\<in> X \\<and> v \\<in> Y \\<and> pp_last u = pp_first v}\""], ["", "text \\<open>Next we define the set of paths of length one as the\nmultiplicative unit of the path dioid.\\<close>"], ["", "definition pp_one :: \"'a ppath set\" where\n  \"pp_one \\<equiv> range Node\""], ["", "text \\<open>We again provide an\nelimination rule.\\<close>"], ["", "lemma pp_prod_iff:\n  \"w \\<in> X\\<cdot>Y \\<longleftrightarrow> (\\<exists>u v. w = pp_fusion u v \\<and> u \\<in> X \\<and> v \\<in> Y \\<and> pp_last u = pp_first v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> X \\<cdot> Y) =\n    (\\<exists>u v.\n        w = pp_fusion u v \\<and>\n        u \\<in> X \\<and> v \\<in> Y \\<and> pp_last u = pp_first v)", "by (unfold pp_prod_def) auto"], ["", "interpretation ppath_dioid: dioid_one_zero \"(\\<union>)\" \"(\\<cdot>)\" pp_one \"{}\" \"(\\<subseteq>)\" \"(\\<subset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (\\<union>) (\\<cdot>) pp_one {} (\\<subseteq>)\n     (\\<subset>)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a \\<union> b \\<union> c = a \\<union> (b \\<union> c)\n 2. \\<And>a b. a \\<union> b = b \\<union> a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 5. \\<And>x. pp_one \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> pp_one = x\n 7. \\<And>x. {} \\<union> x = x\n 8. \\<And>x. {} \\<cdot> x = {}\n 9. \\<And>x. x \\<cdot> {} = {}\n 10. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\nA total of 13 subgoals...", "fix x y z :: \"'a ppath set\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a \\<union> b \\<union> c = a \\<union> (b \\<union> c)\n 2. \\<And>a b. a \\<union> b = b \\<union> a\n 3. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 4. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 5. \\<And>x. pp_one \\<cdot> x = x\n 6. \\<And>x. x \\<cdot> pp_one = x\n 7. \\<And>x. {} \\<union> x = x\n 8. \\<And>x. {} \\<cdot> x = {}\n 9. \\<And>x. x \\<cdot> {} = {}\n 10. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\nA total of 13 subgoals...", "show \"x \\<union> y \\<union> z = x \\<union> (y \\<union> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<union> y \\<union> z = x \\<union> (y \\<union> z)", "by auto"], ["proof (state)\nthis:\n  x \\<union> y \\<union> z = x \\<union> (y \\<union> z)\n\ngoal (12 subgoals):\n 1. \\<And>a b. a \\<union> b = b \\<union> a\n 2. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 3. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 4. \\<And>x. pp_one \\<cdot> x = x\n 5. \\<And>x. x \\<cdot> pp_one = x\n 6. \\<And>x. {} \\<union> x = x\n 7. \\<And>x. {} \\<cdot> x = {}\n 8. \\<And>x. x \\<cdot> {} = {}\n 9. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 10. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\nA total of 12 subgoals...", "show \"x \\<union> y = y \\<union> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<union> y = y \\<union> x", "by auto"], ["proof (state)\nthis:\n  x \\<union> y = y \\<union> x\n\ngoal (11 subgoals):\n 1. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 2. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 3. \\<And>x. pp_one \\<cdot> x = x\n 4. \\<And>x. x \\<cdot> pp_one = x\n 5. \\<And>x. {} \\<union> x = x\n 6. \\<And>x. {} \\<cdot> x = {}\n 7. \\<And>x. x \\<cdot> {} = {}\n 8. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 9. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 10. \\<And>x. x \\<union> x = x\nA total of 11 subgoals...", "show \"x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)", "by (auto simp add: pp_prod_def, metis pp_first_pp_fusion pp_fusion_assoc, metis pp_last_pp_fusion)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<cdot> z = x \\<cdot> (y \\<cdot> z)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n 2. \\<And>x. pp_one \\<cdot> x = x\n 3. \\<And>x. x \\<cdot> pp_one = x\n 4. \\<And>x. {} \\<union> x = x\n 5. \\<And>x. {} \\<cdot> x = {}\n 6. \\<And>x. x \\<cdot> {} = {}\n 7. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 8. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 9. \\<And>x. x \\<union> x = x\n 10. \\<And>a b c.\n        a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"(x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z", "by (auto simp add: pp_prod_def)"], ["proof (state)\nthis:\n  (x \\<union> y) \\<cdot> z = x \\<cdot> z \\<union> y \\<cdot> z\n\ngoal (9 subgoals):\n 1. \\<And>x. pp_one \\<cdot> x = x\n 2. \\<And>x. x \\<cdot> pp_one = x\n 3. \\<And>x. {} \\<union> x = x\n 4. \\<And>x. {} \\<cdot> x = {}\n 5. \\<And>x. x \\<cdot> {} = {}\n 6. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 7. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 8. \\<And>x. x \\<union> x = x\n 9. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"pp_one \\<cdot> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_one \\<cdot> x = x", "by (auto simp add: pp_one_def pp_prod_def, metis pp_fusion.simps(1) pp_last.simps(1) rangeI)"], ["proof (state)\nthis:\n  pp_one \\<cdot> x = x\n\ngoal (8 subgoals):\n 1. \\<And>x. x \\<cdot> pp_one = x\n 2. \\<And>x. {} \\<union> x = x\n 3. \\<And>x. {} \\<cdot> x = {}\n 4. \\<And>x. x \\<cdot> {} = {}\n 5. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 6. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 7. \\<And>x. x \\<union> x = x\n 8. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<cdot> pp_one = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> pp_one = x", "by (auto simp add: pp_one_def pp_prod_def, metis pp_first.simps(1) pp_fusion_rightneutral rangeI)"], ["proof (state)\nthis:\n  x \\<cdot> pp_one = x\n\ngoal (7 subgoals):\n 1. \\<And>x. {} \\<union> x = x\n 2. \\<And>x. {} \\<cdot> x = {}\n 3. \\<And>x. x \\<cdot> {} = {}\n 4. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 5. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 6. \\<And>x. x \\<union> x = x\n 7. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"{} \\<union> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<union> x = x", "by auto"], ["proof (state)\nthis:\n  {} \\<union> x = x\n\ngoal (6 subgoals):\n 1. \\<And>x. {} \\<cdot> x = {}\n 2. \\<And>x. x \\<cdot> {} = {}\n 3. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 4. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 5. \\<And>x. x \\<union> x = x\n 6. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"{} \\<cdot> x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<cdot> x = {}", "by (simp add: pp_prod_def)"], ["proof (state)\nthis:\n  {} \\<cdot> x = {}\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<cdot> {} = {}\n 2. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 3. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 4. \\<And>x. x \\<union> x = x\n 5. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<cdot> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> {} = {}", "by (simp add: pp_prod_def)"], ["proof (state)\nthis:\n  x \\<cdot> {} = {}\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x \\<subseteq> y) = (x \\<union> y = y)\n 2. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 3. \\<And>x. x \\<union> x = x\n 4. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<subseteq> y \\<longleftrightarrow> x \\<union> y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<subseteq> y) = (x \\<union> y = y)", "by auto"], ["proof (state)\nthis:\n  (x \\<subseteq> y) = (x \\<union> y = y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n 2. \\<And>x. x \\<union> x = x\n 3. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<subset> y \\<longleftrightarrow> x \\<subseteq> y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)", "by auto"], ["proof (state)\nthis:\n  (x \\<subset> y) = (x \\<subseteq> y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<union> x = x\n 2. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<union> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<union> x = x", "by auto"], ["proof (state)\nthis:\n  x \\<union> x = x\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a \\<cdot> (b \\<union> c) = a \\<cdot> b \\<union> a \\<cdot> c", "show \"x \\<cdot> (y \\<union> z) = x \\<cdot> y \\<union> x \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<union> z) = x \\<cdot> y \\<union> x \\<cdot> z", "by (auto simp add: pp_prod_def)"], ["proof (state)\nthis:\n  x \\<cdot> (y \\<union> z) = x \\<cdot> y \\<union> x \\<cdot> z\n\ngoal:\nNo subgoals!", "qed"], ["", "no_notation\n  pp_prod (infixl \"\\<cdot>\" 70)"], ["", "subsection \\<open>The Distributive Lattice Dioid\\<close>"], ["", "text \\<open>A bounded distributive lattice is a distributive lattice with\na least and a greatest element. Using Isabelle's lattice theory file\nwe define a bounded distributive lattice as an axiomatic type class\nand show, using a sublocale statement, that every bounded distributive\nlattice is a dioid with one and zero.\\<close>"], ["", "class bounded_distributive_lattice = bounded_lattice + distrib_lattice"], ["", "sublocale bounded_distributive_lattice \\<subseteq> dioid_one_zero sup inf top bot less_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero sup inf top bot (\\<le>) (<)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. sup (sup a b) c = sup a (sup b c)\n 2. \\<And>a b. sup a b = sup b a\n 3. \\<And>a b c. inf (inf a b) c = inf a (inf b c)\n 4. \\<And>x y z. inf (sup x y) z = sup (inf x z) (inf y z)\n 5. \\<And>x. inf top x = x\n 6. \\<And>x. inf x top = x\n 7. \\<And>x. sup bot x = x\n 8. \\<And>x. inf bot x = bot\n 9. \\<And>x. inf x bot = bot\n 10. \\<And>x y. (x \\<le> y) = (sup x y = y)\nA total of 13 subgoals...", "fix x y z"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. sup (sup a b) c = sup a (sup b c)\n 2. \\<And>a b. sup a b = sup b a\n 3. \\<And>a b c. inf (inf a b) c = inf a (inf b c)\n 4. \\<And>x y z. inf (sup x y) z = sup (inf x z) (inf y z)\n 5. \\<And>x. inf top x = x\n 6. \\<And>x. inf x top = x\n 7. \\<And>x. sup bot x = x\n 8. \\<And>x. inf bot x = bot\n 9. \\<And>x. inf x bot = bot\n 10. \\<And>x y. (x \\<le> y) = (sup x y = y)\nA total of 13 subgoals...", "show \"sup (sup x y) z = sup x (sup y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup (sup x y) z = sup x (sup y z)", "by (fact sup_assoc)"], ["proof (state)\nthis:\n  sup (sup x y) z = sup x (sup y z)\n\ngoal (12 subgoals):\n 1. \\<And>a b. sup a b = sup b a\n 2. \\<And>a b c. inf (inf a b) c = inf a (inf b c)\n 3. \\<And>x y z. inf (sup x y) z = sup (inf x z) (inf y z)\n 4. \\<And>x. inf top x = x\n 5. \\<And>x. inf x top = x\n 6. \\<And>x. sup bot x = x\n 7. \\<And>x. inf bot x = bot\n 8. \\<And>x. inf x bot = bot\n 9. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 10. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\nA total of 12 subgoals...", "show \"sup x y = sup y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup x y = sup y x", "by (fact sup.commute)"], ["proof (state)\nthis:\n  sup x y = sup y x\n\ngoal (11 subgoals):\n 1. \\<And>a b c. inf (inf a b) c = inf a (inf b c)\n 2. \\<And>x y z. inf (sup x y) z = sup (inf x z) (inf y z)\n 3. \\<And>x. inf top x = x\n 4. \\<And>x. inf x top = x\n 5. \\<And>x. sup bot x = x\n 6. \\<And>x. inf bot x = bot\n 7. \\<And>x. inf x bot = bot\n 8. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 9. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 10. \\<And>x. sup x x = x\nA total of 11 subgoals...", "show \"inf (inf x y) z = inf x (inf y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (inf x y) z = inf x (inf y z)", "by (metis inf.commute inf.left_commute)"], ["proof (state)\nthis:\n  inf (inf x y) z = inf x (inf y z)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. inf (sup x y) z = sup (inf x z) (inf y z)\n 2. \\<And>x. inf top x = x\n 3. \\<And>x. inf x top = x\n 4. \\<And>x. sup bot x = x\n 5. \\<And>x. inf bot x = bot\n 6. \\<And>x. inf x bot = bot\n 7. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 8. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 9. \\<And>x. sup x x = x\n 10. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"inf (sup x y) z = sup (inf x z) (inf y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (sup x y) z = sup (inf x z) (inf y z)", "by (fact inf_sup_distrib2)"], ["proof (state)\nthis:\n  inf (sup x y) z = sup (inf x z) (inf y z)\n\ngoal (9 subgoals):\n 1. \\<And>x. inf top x = x\n 2. \\<And>x. inf x top = x\n 3. \\<And>x. sup bot x = x\n 4. \\<And>x. inf bot x = bot\n 5. \\<And>x. inf x bot = bot\n 6. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 7. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 8. \\<And>x. sup x x = x\n 9. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"inf top x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf top x = x", "by simp"], ["proof (state)\nthis:\n  inf top x = x\n\ngoal (8 subgoals):\n 1. \\<And>x. inf x top = x\n 2. \\<And>x. sup bot x = x\n 3. \\<And>x. inf bot x = bot\n 4. \\<And>x. inf x bot = bot\n 5. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x. sup x x = x\n 8. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"inf x top = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x top = x", "by simp"], ["proof (state)\nthis:\n  inf x top = x\n\ngoal (7 subgoals):\n 1. \\<And>x. sup bot x = x\n 2. \\<And>x. inf bot x = bot\n 3. \\<And>x. inf x bot = bot\n 4. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 5. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 6. \\<And>x. sup x x = x\n 7. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"sup bot x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup bot x = x", "by simp"], ["proof (state)\nthis:\n  sup bot x = x\n\ngoal (6 subgoals):\n 1. \\<And>x. inf bot x = bot\n 2. \\<And>x. inf x bot = bot\n 3. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 4. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 5. \\<And>x. sup x x = x\n 6. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"inf bot x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf bot x = bot", "by simp"], ["proof (state)\nthis:\n  inf bot x = bot\n\ngoal (5 subgoals):\n 1. \\<And>x. inf x bot = bot\n 2. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 3. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 4. \\<And>x. sup x x = x\n 5. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"inf x bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x bot = bot", "by simp"], ["proof (state)\nthis:\n  inf x bot = bot\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (sup x y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x. sup x x = x\n 4. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"(x \\<le> y) = (sup x y = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (sup x y = y)", "by (fact le_iff_sup)"], ["proof (state)\nthis:\n  (x \\<le> y) = (sup x y = y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 2. \\<And>x. sup x x = x\n 3. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"(x < y) = (x \\<le> y \\<and> x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)", "by auto"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<And>x. sup x x = x\n 2. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"sup x x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup x x = x", "by simp"], ["proof (state)\nthis:\n  sup x x = x\n\ngoal (1 subgoal):\n 1. \\<And>a b c. inf a (sup b c) = sup (inf a b) (inf a c)", "show \"inf x (sup y z) = sup (inf x y) (inf x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x (sup y z) = sup (inf x y) (inf x z)", "by (fact inf_sup_distrib1)"], ["proof (state)\nthis:\n  inf x (sup y z) = sup (inf x y) (inf x z)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Boolean Dioid\\<close>"], ["", "text \\<open>In this section we show that the booleans form a dioid,\nbecause the booleans form a bounded distributive lattice.\\<close>"], ["", "instantiation bool :: bounded_distributive_lattice\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, bounded_distributive_lattice_class)", ".."], ["", "end"], ["", "(* instantiation *)"], ["", "interpretation boolean_dioid: dioid_one_zero sup inf True False less_eq less"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero sup inf True False (\\<le>) (<)", "by (unfold_locales, simp_all add: inf_bool_def sup_bool_def)"], ["", "subsection \\<open>The Max-Plus Dioid\\<close>"], ["", "text \\<open>The following dioids have important applications in\ncombinatorial optimisations, control theory, algorithm design and\ncomputer networks.\\<close>"], ["", "text \\<open>A definition of reals extended with~\\<open>+\\<infinity>\\<close> {\\em\nand}~\\<open>-\\<infinity>\\<close> may be found in {\\em\nHOL/Library/Extended\\_Real.thy}. Alas, we require separate extensions\nwith either~\\<open>+\\<infinity>\\<close> or~\\<open>-\\<infinity>\\<close>.\\<close>"], ["", "text \\<open>The carrier set of the max-plus semiring is the set of real\nnumbers extended by minus infinity. The operation of addition is\nmaximum, the operation of multiplication is addition, the additive\nunit is minus infinity and the multiplicative unit is zero.\\<close>"], ["", "datatype mreal = mreal real | MInfty  \\<comment> \\<open>minus infinity\\<close>"], ["", "fun mreal_max where\n  \"mreal_max (mreal x) (mreal y) = mreal (max x y)\"\n| \"mreal_max x MInfty = x\"\n| \"mreal_max MInfty y = y\""], ["", "lemma mreal_max_simp_3 [simp]: \"mreal_max MInfty y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mreal_max MInfty y = y", "by (cases y, simp_all)"], ["", "fun mreal_plus where\n  \"mreal_plus (mreal x) (mreal y) = mreal (x + y)\"\n| \"mreal_plus _ _ = MInfty\""], ["", "text \\<open>We now show that the max plus-semiring satisfies the axioms of\nselective semirings, from which it follows that it satisfies the dioid\naxioms.\\<close>"], ["", "instantiation mreal :: selective_semiring\nbegin"], ["", "definition zero_mreal_def:\n    \"0 \\<equiv> MInfty\""], ["", "definition one_mreal_def:\n    \"1 \\<equiv> mreal 0\""], ["", "definition plus_mreal_def:\n    \"x + y \\<equiv> mreal_max x y\""], ["", "definition times_mreal_def:\n    \"x * y \\<equiv> mreal_plus x y\""], ["", "definition less_eq_mreal_def:\n    \"(x::mreal) \\<le> y \\<equiv> x + y = y\""], ["", "definition less_mreal_def:\n    \"(x::mreal) < y \\<equiv> x \\<le> y \\<and> x \\<noteq> y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(mreal, selective_semiring_class)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>x y z. (x + y) * z = x * z + y * z\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x y. x + y = x \\<or> x + y = y\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x * 1 = x\n 10. \\<And>x. 0 + x = x\nA total of 13 subgoals...", "fix x y z :: mreal"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>x y z. (x + y) * z = x * z + y * z\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x y. x + y = x \\<or> x + y = y\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x * 1 = x\n 10. \\<And>x. 0 + x = x\nA total of 13 subgoals...", "show \"x + y + z = x + (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y + z = x + (y + z)", "by (cases x, cases y, cases z, simp_all add: plus_mreal_def)"], ["proof (state)\nthis:\n  x + y + z = x + (y + z)\n\ngoal (12 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a b c. a * b * c = a * (b * c)\n 3. \\<And>x y z. (x + y) * z = x * z + y * z\n 4. \\<And>x y. (x \\<le> y) = (x + y = y)\n 5. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 6. \\<And>x y. x + y = x \\<or> x + y = y\n 7. \\<And>x. 1 * x = x\n 8. \\<And>x. x * 1 = x\n 9. \\<And>x. 0 + x = x\n 10. \\<And>x. 0 * x = 0\nA total of 12 subgoals...", "show \"x + y = y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = y + x", "by (cases x, cases y, simp_all add: plus_mreal_def)"], ["proof (state)\nthis:\n  x + y = y + x\n\ngoal (11 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>x y z. (x + y) * z = x * z + y * z\n 3. \\<And>x y. (x \\<le> y) = (x + y = y)\n 4. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 5. \\<And>x y. x + y = x \\<or> x + y = y\n 6. \\<And>x. 1 * x = x\n 7. \\<And>x. x * 1 = x\n 8. \\<And>x. 0 + x = x\n 9. \\<And>x. 0 * x = 0\n 10. \\<And>x. x * 0 = 0\nA total of 11 subgoals...", "show \"x * y * z = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "by (cases x, cases y, cases z, simp_all add: times_mreal_def)"], ["proof (state)\nthis:\n  x * y * z = x * (y * z)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. (x + y) * z = x * z + y * z\n 2. \\<And>x y. (x \\<le> y) = (x + y = y)\n 3. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 4. \\<And>x y. x + y = x \\<or> x + y = y\n 5. \\<And>x. 1 * x = x\n 6. \\<And>x. x * 1 = x\n 7. \\<And>x. 0 + x = x\n 8. \\<And>x. 0 * x = 0\n 9. \\<And>x. x * 0 = 0\n 10. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"(x + y) * z = x * z + y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) * z = x * z + y * z", "by (cases x, cases y, cases z, simp_all add: plus_mreal_def times_mreal_def)"], ["proof (state)\nthis:\n  (x + y) * z = x * z + y * z\n\ngoal (9 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 1 * x = x\n 5. \\<And>x. x * 1 = x\n 6. \\<And>x. 0 + x = x\n 7. \\<And>x. 0 * x = 0\n 8. \\<And>x. x * 0 = 0\n 9. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"1 * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * x = x", "by (cases x, simp_all add: one_mreal_def times_mreal_def)"], ["proof (state)\nthis:\n  1 * x = x\n\ngoal (8 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. x * 1 = x\n 5. \\<And>x. 0 + x = x\n 6. \\<And>x. 0 * x = 0\n 7. \\<And>x. x * 0 = 0\n 8. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 1 = x", "by (cases x, simp_all add: one_mreal_def times_mreal_def)"], ["proof (state)\nthis:\n  x * 1 = x\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 0 + x = x\n 5. \\<And>x. 0 * x = 0\n 6. \\<And>x. x * 0 = 0\n 7. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"0 + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "by (cases x, simp_all add: plus_mreal_def zero_mreal_def)"], ["proof (state)\nthis:\n  0 + x = x\n\ngoal (6 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 0 * x = 0\n 5. \\<And>x. x * 0 = 0\n 6. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"0 * x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * x = 0", "by (cases x, simp_all add: times_mreal_def zero_mreal_def)"], ["proof (state)\nthis:\n  0 * x = 0\n\ngoal (5 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. x * 0 = 0\n 5. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 0 = 0", "by (cases x, simp_all add: times_mreal_def zero_mreal_def)"], ["proof (state)\nthis:\n  x * 0 = 0\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x \\<le> y \\<longleftrightarrow> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x + y = y)", "by (metis less_eq_mreal_def)"], ["proof (state)\nthis:\n  (x \\<le> y) = (x + y = y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 2. \\<And>x y. x + y = x \\<or> x + y = y\n 3. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x < y \\<longleftrightarrow> x \\<le> y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)", "by (metis less_mreal_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x + y = x \\<or> x + y = y\n 2. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x + y = x \\<or> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = x \\<or> x + y = y", "by (cases x, cases y, simp_all add: plus_mreal_def, metis linorder_le_cases max.absorb_iff2 max.absorb1)"], ["proof (state)\nthis:\n  x + y = x \\<or> x + y = y\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * (y + z) = x * y + x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by (cases x, cases y, cases z, simp_all add: plus_mreal_def times_mreal_def)"], ["proof (state)\nthis:\n  x * (y + z) = x * y + x * z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* instantiation *)"], ["", "subsection \\<open>The Min-Plus Dioid\\<close>"], ["", "text \\<open>The min-plus dioid is also known as {\\em tropical\nsemiring}. Here we need to add a positive infinity to the real\nnumbers. The procedere follows that of max-plus semirings.\\<close>"], ["", "datatype preal = preal real | PInfty  \\<comment> \\<open>plus infinity\\<close>"], ["", "fun preal_min where\n  \"preal_min (preal x) (preal y) = preal (min x y)\"\n| \"preal_min x PInfty = x\"\n| \"preal_min PInfty y = y\""], ["", "lemma preal_min_simp_3 [simp]: \"preal_min PInfty y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preal_min PInfty y = y", "by (cases y, simp_all)"], ["", "fun preal_plus where\n  \"preal_plus (preal x) (preal y) = preal (x + y)\"\n| \"preal_plus _ _ = PInfty\""], ["", "instantiation preal :: selective_semiring\nbegin"], ["", "definition zero_preal_def:\n    \"0 \\<equiv> PInfty\""], ["", "definition one_preal_def:\n    \"1 \\<equiv> preal 0\""], ["", "definition plus_preal_def:\n    \"x + y \\<equiv> preal_min x y\""], ["", "definition times_preal_def:\n    \"x * y \\<equiv> preal_plus x y\""], ["", "definition less_eq_preal_def:\n    \"(x::preal) \\<le> y \\<equiv> x + y = y\""], ["", "definition less_preal_def:\n    \"(x::preal) < y \\<equiv> x \\<le> y \\<and> x \\<noteq> y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(preal, selective_semiring_class)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>x y z. (x + y) * z = x * z + y * z\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x y. x + y = x \\<or> x + y = y\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x * 1 = x\n 10. \\<And>x. 0 + x = x\nA total of 13 subgoals...", "fix x y z :: preal"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>x y z. (x + y) * z = x * z + y * z\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x y. x + y = x \\<or> x + y = y\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x * 1 = x\n 10. \\<And>x. 0 + x = x\nA total of 13 subgoals...", "show \"x + y + z = x + (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y + z = x + (y + z)", "by (cases x, cases y, cases z, simp_all add: plus_preal_def)"], ["proof (state)\nthis:\n  x + y + z = x + (y + z)\n\ngoal (12 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a b c. a * b * c = a * (b * c)\n 3. \\<And>x y z. (x + y) * z = x * z + y * z\n 4. \\<And>x y. (x \\<le> y) = (x + y = y)\n 5. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 6. \\<And>x y. x + y = x \\<or> x + y = y\n 7. \\<And>x. 1 * x = x\n 8. \\<And>x. x * 1 = x\n 9. \\<And>x. 0 + x = x\n 10. \\<And>x. 0 * x = 0\nA total of 12 subgoals...", "show \"x + y = y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = y + x", "by (cases x, cases y, simp_all add: plus_preal_def)"], ["proof (state)\nthis:\n  x + y = y + x\n\ngoal (11 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>x y z. (x + y) * z = x * z + y * z\n 3. \\<And>x y. (x \\<le> y) = (x + y = y)\n 4. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 5. \\<And>x y. x + y = x \\<or> x + y = y\n 6. \\<And>x. 1 * x = x\n 7. \\<And>x. x * 1 = x\n 8. \\<And>x. 0 + x = x\n 9. \\<And>x. 0 * x = 0\n 10. \\<And>x. x * 0 = 0\nA total of 11 subgoals...", "show \"x * y * z = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "by (cases x, cases y, cases z, simp_all add: times_preal_def)"], ["proof (state)\nthis:\n  x * y * z = x * (y * z)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. (x + y) * z = x * z + y * z\n 2. \\<And>x y. (x \\<le> y) = (x + y = y)\n 3. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 4. \\<And>x y. x + y = x \\<or> x + y = y\n 5. \\<And>x. 1 * x = x\n 6. \\<And>x. x * 1 = x\n 7. \\<And>x. 0 + x = x\n 8. \\<And>x. 0 * x = 0\n 9. \\<And>x. x * 0 = 0\n 10. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"(x + y) * z = x * z + y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) * z = x * z + y * z", "by (cases x, cases y, cases z, simp_all add: plus_preal_def times_preal_def)"], ["proof (state)\nthis:\n  (x + y) * z = x * z + y * z\n\ngoal (9 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 1 * x = x\n 5. \\<And>x. x * 1 = x\n 6. \\<And>x. 0 + x = x\n 7. \\<And>x. 0 * x = 0\n 8. \\<And>x. x * 0 = 0\n 9. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"1 * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * x = x", "by (cases x, simp_all add: one_preal_def times_preal_def)"], ["proof (state)\nthis:\n  1 * x = x\n\ngoal (8 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. x * 1 = x\n 5. \\<And>x. 0 + x = x\n 6. \\<And>x. 0 * x = 0\n 7. \\<And>x. x * 0 = 0\n 8. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 1 = x", "by (cases x, simp_all add: one_preal_def times_preal_def)"], ["proof (state)\nthis:\n  x * 1 = x\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 0 + x = x\n 5. \\<And>x. 0 * x = 0\n 6. \\<And>x. x * 0 = 0\n 7. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"0 + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "by (cases x, simp_all add: plus_preal_def zero_preal_def)"], ["proof (state)\nthis:\n  0 + x = x\n\ngoal (6 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 0 * x = 0\n 5. \\<And>x. x * 0 = 0\n 6. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"0 * x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * x = 0", "by (cases x, simp_all add: times_preal_def zero_preal_def)"], ["proof (state)\nthis:\n  0 * x = 0\n\ngoal (5 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. x * 0 = 0\n 5. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 0 = 0", "by (cases x, simp_all add: times_preal_def zero_preal_def)"], ["proof (state)\nthis:\n  x * 0 = 0\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x \\<le> y \\<longleftrightarrow> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x + y = y)", "by (metis less_eq_preal_def)"], ["proof (state)\nthis:\n  (x \\<le> y) = (x + y = y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 2. \\<And>x y. x + y = x \\<or> x + y = y\n 3. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x < y \\<longleftrightarrow> x \\<le> y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)", "by (metis less_preal_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x + y = x \\<or> x + y = y\n 2. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x + y = x \\<or> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = x \\<or> x + y = y", "by (cases x, cases y, simp_all add: plus_preal_def, metis linorder_le_cases min.absorb2 min.absorb_iff1)"], ["proof (state)\nthis:\n  x + y = x \\<or> x + y = y\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * (y + z) = x * y + x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by (cases x, cases y, cases z, simp_all add: plus_preal_def times_preal_def)"], ["proof (state)\nthis:\n  x * (y + z) = x * y + x * z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* instantiation *)"], ["", "text \\<open>Variants of min-plus and max-plus semirings can easily be\nobtained. Here we formalise the min-plus semiring over the natural\nnumbers as an example.\\<close>"], ["", "datatype pnat = pnat nat | PInfty  \\<comment> \\<open>plus infinity\\<close>"], ["", "fun pnat_min where\n  \"pnat_min (pnat x) (pnat y) = pnat (min x y)\"\n| \"pnat_min x PInfty = x\"\n| \"pnat_min PInfty x = x\""], ["", "lemma pnat_min_simp_3 [simp]: \"pnat_min PInfty y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnat_min pnat.PInfty y = y", "by (cases y, simp_all)"], ["", "fun pnat_plus where\n  \"pnat_plus (pnat x) (pnat y) = pnat (x + y)\"\n| \"pnat_plus _ _ = PInfty\""], ["", "instantiation pnat :: selective_semiring\nbegin"], ["", "definition zero_pnat_def:\n    \"0 \\<equiv> PInfty\""], ["", "definition one_pnat_def:\n    \"1 \\<equiv> pnat 0\""], ["", "definition plus_pnat_def:\n    \"x + y \\<equiv> pnat_min x y\""], ["", "definition times_pnat_def:\n    \"x * y \\<equiv> pnat_plus x y\""], ["", "definition less_eq_pnat_def:\n    \"(x::pnat) \\<le> y \\<equiv> x + y = y\""], ["", "definition less_pnat_def:\n    \"(x::pnat) < y \\<equiv> x \\<le> y \\<and> x \\<noteq> y\""], ["", "lemma zero_pnat_top: \"(x::pnat) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 1", "by (cases x, simp_all add: less_eq_pnat_def plus_pnat_def one_pnat_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pnat, selective_semiring_class)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>x y z. (x + y) * z = x * z + y * z\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x y. x + y = x \\<or> x + y = y\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x * 1 = x\n 10. \\<And>x. 0 + x = x\nA total of 13 subgoals...", "fix x y z :: pnat"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>x y z. (x + y) * z = x * z + y * z\n 5. \\<And>x y. (x \\<le> y) = (x + y = y)\n 6. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 7. \\<And>x y. x + y = x \\<or> x + y = y\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x * 1 = x\n 10. \\<And>x. 0 + x = x\nA total of 13 subgoals...", "show \"x + y + z = x + (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y + z = x + (y + z)", "by (cases x, cases y, cases z, simp_all add: plus_pnat_def)"], ["proof (state)\nthis:\n  x + y + z = x + (y + z)\n\ngoal (12 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a b c. a * b * c = a * (b * c)\n 3. \\<And>x y z. (x + y) * z = x * z + y * z\n 4. \\<And>x y. (x \\<le> y) = (x + y = y)\n 5. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 6. \\<And>x y. x + y = x \\<or> x + y = y\n 7. \\<And>x. 1 * x = x\n 8. \\<And>x. x * 1 = x\n 9. \\<And>x. 0 + x = x\n 10. \\<And>x. 0 * x = 0\nA total of 12 subgoals...", "show \"x + y = y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = y + x", "by (cases x, cases y, simp_all add: plus_pnat_def)"], ["proof (state)\nthis:\n  x + y = y + x\n\ngoal (11 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>x y z. (x + y) * z = x * z + y * z\n 3. \\<And>x y. (x \\<le> y) = (x + y = y)\n 4. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 5. \\<And>x y. x + y = x \\<or> x + y = y\n 6. \\<And>x. 1 * x = x\n 7. \\<And>x. x * 1 = x\n 8. \\<And>x. 0 + x = x\n 9. \\<And>x. 0 * x = 0\n 10. \\<And>x. x * 0 = 0\nA total of 11 subgoals...", "show \"x * y * z = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "by (cases x, cases y, cases z, simp_all add: times_pnat_def)"], ["proof (state)\nthis:\n  x * y * z = x * (y * z)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. (x + y) * z = x * z + y * z\n 2. \\<And>x y. (x \\<le> y) = (x + y = y)\n 3. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 4. \\<And>x y. x + y = x \\<or> x + y = y\n 5. \\<And>x. 1 * x = x\n 6. \\<And>x. x * 1 = x\n 7. \\<And>x. 0 + x = x\n 8. \\<And>x. 0 * x = 0\n 9. \\<And>x. x * 0 = 0\n 10. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"(x + y) * z = x * z + y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) * z = x * z + y * z", "by (cases x, cases y, cases z, simp_all add: plus_pnat_def times_pnat_def)"], ["proof (state)\nthis:\n  (x + y) * z = x * z + y * z\n\ngoal (9 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 1 * x = x\n 5. \\<And>x. x * 1 = x\n 6. \\<And>x. 0 + x = x\n 7. \\<And>x. 0 * x = 0\n 8. \\<And>x. x * 0 = 0\n 9. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"1 * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * x = x", "by (cases x, simp_all add: one_pnat_def times_pnat_def)"], ["proof (state)\nthis:\n  1 * x = x\n\ngoal (8 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. x * 1 = x\n 5. \\<And>x. 0 + x = x\n 6. \\<And>x. 0 * x = 0\n 7. \\<And>x. x * 0 = 0\n 8. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 1 = x", "by (cases x, simp_all add: one_pnat_def times_pnat_def)"], ["proof (state)\nthis:\n  x * 1 = x\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 0 + x = x\n 5. \\<And>x. 0 * x = 0\n 6. \\<And>x. x * 0 = 0\n 7. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"0 + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "by (cases x, simp_all add: plus_pnat_def zero_pnat_def)"], ["proof (state)\nthis:\n  0 + x = x\n\ngoal (6 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. 0 * x = 0\n 5. \\<And>x. x * 0 = 0\n 6. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"0 * x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * x = 0", "by (cases x, simp_all add: times_pnat_def zero_pnat_def)"], ["proof (state)\nthis:\n  0 * x = 0\n\ngoal (5 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>x. x * 0 = 0\n 5. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 0 = 0", "by (cases x, simp_all add: times_pnat_def zero_pnat_def)"], ["proof (state)\nthis:\n  x * 0 = 0\n\ngoal (4 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (x + y = y)\n 2. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 3. \\<And>x y. x + y = x \\<or> x + y = y\n 4. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x \\<le> y \\<longleftrightarrow> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x + y = y)", "by (metis less_eq_pnat_def)"], ["proof (state)\nthis:\n  (x \\<le> y) = (x + y = y)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n 2. \\<And>x y. x + y = x \\<or> x + y = y\n 3. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x < y \\<longleftrightarrow> x \\<le> y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> x \\<noteq> y)", "by (metis less_pnat_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x + y = x \\<or> x + y = y\n 2. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x + y = x \\<or> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = x \\<or> x + y = y", "by (cases x, cases y, simp_all add: plus_pnat_def, metis linorder_le_cases min.absorb2 min.absorb_iff1)"], ["proof (state)\nthis:\n  x + y = x \\<or> x + y = y\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"x * (y + z) = x * y + x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by (cases x, cases y, cases z, simp_all add: plus_pnat_def times_pnat_def)"], ["proof (state)\nthis:\n  x * (y + z) = x * y + x * z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* instantiation *)"], ["", "end"]]}