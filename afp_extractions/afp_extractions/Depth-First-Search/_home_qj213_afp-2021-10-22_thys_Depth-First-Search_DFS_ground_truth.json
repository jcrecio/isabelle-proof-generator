{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search", "problem_names": ["lemma nexts_set: \"y \\<in> set (nexts g x) = ((x,y) \\<in> set g)\"", "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\"", "lemma [simp]: \"x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []\"", "lemma [simp]: \"finite (nodes_of g - set ys)\"", "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "lemma dfs_app: \"dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)\"", "lemma \"dfs2 g xs ys = dfs g xs ys\"", "lemma visit_subset_dfs: \"set ys \\<subseteq> set (dfs g xs ys)\"", "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "lemma nextss_closed_dfs'[rule_format]: \n \"nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)\"", "lemma nextss_closed_dfs: \"nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])\"", "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\"", "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\""], "translations": [["", "lemma nexts_set: \"y \\<in> set (nexts g x) = ((x,y) \\<in> set g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (nexts g x)) = ((x, y) \\<in> set g)", "by (induct g) auto"], ["", "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextss g (x # xs) = set (nexts g x) \\<union> nextss g xs", "unfolding nextss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set g `` set (x # xs) = set (nexts g x) \\<union> set g `` set xs", "by (auto simp add:Image_def nexts_set)"], ["", "definition reachable :: \"[graph, node list] \\<Rightarrow> node set\"\n  where \"reachable g xs = (set g)\\<^sup>* `` set xs\""], ["", "subsection \"Depth-First Search with Stack\""], ["", "definition nodes_of :: \"graph \\<Rightarrow> node set\"\n  where \"nodes_of g = set (map fst g @ map snd g)\""], ["", "lemma [simp]: \"x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []", "by (induct g) (auto simp add: nodes_of_def)"], ["", "lemma [simp]: \"finite (nodes_of g - set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes_of g - set ys)", "proof(rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. nodes_of g - set ys \\<subseteq> ?B\n 2. finite ?B", "show \"finite (nodes_of g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes_of g)", "by (auto simp add: nodes_of_def)"], ["proof (state)\nthis:\n  finite (nodes_of g)\n\ngoal (1 subgoal):\n 1. nodes_of g - set ys \\<subseteq> nodes_of g", "qed (auto)"], ["", "function\n  dfs :: \"graph \\<Rightarrow> node list \\<Rightarrow> node list \\<Rightarrow> node list\"\nwhere\n  dfs_base: \"dfs g [] ys = ys\"\n| dfs_inductive: \"dfs g (x#xs) ys = (if List.member ys x then dfs g xs ys \n                        else dfs g (nexts g x@xs) (x#ys))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>g ys. x = (g, [], ys) \\<Longrightarrow> P;\n        \\<And>g xa xs ys. x = (g, xa # xs, ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>g ys ga ysa.\n       (g, [], ys) = (ga, [], ysa) \\<Longrightarrow> ys = ysa\n 3. \\<And>g ys ga x xs ysa.\n       (g, [], ys) = (ga, x # xs, ysa) \\<Longrightarrow>\n       ys =\n       (if List.member ysa x then dfs_sumC (ga, xs, ysa)\n        else dfs_sumC (ga, nexts ga x @ xs, x # ysa))\n 4. \\<And>g x xs ys ga xa xsa ysa.\n       (g, x # xs, ys) = (ga, xa # xsa, ysa) \\<Longrightarrow>\n       (if List.member ys x then dfs_sumC (g, xs, ys)\n        else dfs_sumC (g, nexts g x @ xs, x # ys)) =\n       (if List.member ysa xa then dfs_sumC (ga, xsa, ysa)\n        else dfs_sumC (ga, nexts ga xa @ xsa, xa # ysa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dfs_dom", "apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (inv_image (finite_psubset <*lex*> less_than)\n         (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)))\n 2. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 3. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x @ xs, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 2. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x @ xs, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "apply (simp_all add: finite_psubset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g x ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or>\n       nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and>\n       nexts g x = []", "by (case_tac  \"x \\<in> nodes_of g\") (auto simp add: List.member_def)"], ["", "text \\<open>\n  \\begin{itemize}\n  \\item The second argument of \\isatext{\\isastyle{dfs}} is a stack of nodes that will be\n  visited.\n  \\item The third argument of \\isatext{\\isastyle{dfs}} is a list of nodes that have\n  been visited already.\n  \\end{itemize}\n\\<close>"], ["", "subsection \"Depth-First Search with Nested-Recursion\""], ["", "function\n  dfs2 :: \"graph \\<Rightarrow> node list \\<Rightarrow> node list \\<Rightarrow> node list\"\nwhere\n  \"dfs2 g [] ys = ys\"\n|  dfs2_inductive: \n          \"dfs2 g (x#xs) ys = (if List.member ys x then dfs2 g xs ys \n                               else dfs2 g xs (dfs2 g (nexts g x) (x#ys)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>g ys. x = (g, [], ys) \\<Longrightarrow> P;\n        \\<And>g xa xs ys. x = (g, xa # xs, ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>g ys ga ysa.\n       (g, [], ys) = (ga, [], ysa) \\<Longrightarrow> ys = ysa\n 3. \\<And>g ys ga x xs ysa.\n       (g, [], ys) = (ga, x # xs, ysa) \\<Longrightarrow>\n       ys =\n       (if List.member ysa x then dfs2_sumC (ga, xs, ysa)\n        else dfs2_sumC (ga, xs, dfs2_sumC (ga, nexts ga x, x # ysa)))\n 4. \\<And>g x xs ys ga xa xsa ysa.\n       (g, x # xs, ys) = (ga, xa # xsa, ysa) \\<Longrightarrow>\n       (if List.member ys x then dfs2_sumC (g, xs, ys)\n        else dfs2_sumC (g, xs, dfs2_sumC (g, nexts g x, x # ys))) =\n       (if List.member ysa xa then dfs2_sumC (ga, xsa, ysa)\n        else dfs2_sumC (ga, xsa, dfs2_sumC (ga, nexts ga xa, xa # ysa)))", "by pat_completeness auto"], ["", "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs2_dom (g, xs, ys) \\<Longrightarrow>\n    set ys \\<subseteq> set (dfs2 g xs ys)", "by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+"], ["", "termination dfs2"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dfs2_dom", "apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image (finite_psubset <*lex*> less_than)\n         (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)))\n 2. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 3. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 4. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs,\n                          ys)\n                         \\<in> inv_image (finite_psubset <*lex*> less_than)\n                                (\\<lambda>(g, xs, ys).\n                                    (nodes_of g - set ys, length xs))", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 2. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 3. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs,\n                          ys)\n                         \\<in> inv_image (finite_psubset <*lex*> less_than)\n                                (\\<lambda>(g, xs, ys).\n                                    (nodes_of g - set ys, length xs))", "apply (simp_all add: finite_psubset_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or>\n       nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and>\n       length (nexts g x) < Suc (length xs)\n 2. \\<And>g x ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys))\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - set (dfs2 g (nexts g x) (x # ys)) =\n                         nodes_of g - set ys", "apply (case_tac  \"x \\<in> nodes_of g\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x; x \\<in> nodes_of g\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - insert x (set ys)\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - insert x (set ys) =\n                         nodes_of g - set ys \\<and>\n                         length (nexts g x) < Suc (length xs)\n 2. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x; x \\<notin> nodes_of g\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - insert x (set ys)\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - insert x (set ys) =\n                         nodes_of g - set ys \\<and>\n                         length (nexts g x) < Suc (length xs)\n 3. \\<And>g x ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys))\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - set (dfs2 g (nexts g x) (x # ys)) =\n                         nodes_of g - set ys", "apply (auto simp add: List.member_def)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g x ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys))\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - set (dfs2 g (nexts g x) (x # ys)) =\n                         nodes_of g - set ys", "by (insert dfs2_invariant) force"], ["", "(*lemma dfs2_induct[induct type]:\n  assumes B: \"\\<And>g ys. P g [] ys\" and\n  H: \"\\<And>g x xs ys.\n        \\<lbrakk>\\<not> x mem ys \\<longrightarrow> P g xs (dfs2 (g, nexts g x, x # ys));\n         \\<not> x mem ys \\<longrightarrow> P g (nexts g x) (x # ys); x mem ys \\<longrightarrow> P g xs ys\\<rbrakk>\n         \\<Longrightarrow> P g (x # xs) ys\"\n  shows \"P u v w\"\n\nproof (induct u v w rule: dfs2.induct)\n  case 1 show ?case by (rule B)\nnext\n  case (2 g x xs ys)\n  show ?case\n  proof (rule H)\n    show \"\\<not> x mem ys \\<longrightarrow> P g xs (dfs2 (g, nexts g x, x # ys))\"\n    proof \n      assume *: \"\\<not> x mem ys\"\n      have \"set (x#ys) \\<subseteq> set (dfs2 (g, nexts g x, x # ys))\"\n        by (rule dfs2_inv)\n      with 2 * show \"P g xs (dfs2 (g, nexts g x, x # ys))\"\n        by auto\n    qed\n  qed (rule 2)+\nqed\n*)"], ["", "lemma dfs_app: \"dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs g (xs @ ys) zs = dfs g ys (dfs g xs zs)", "by (induct g xs zs rule: dfs.induct) auto"], ["", "lemma \"dfs2 g xs ys = dfs g xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs2 g xs ys = dfs g xs ys", "by (induct g xs ys rule: dfs2.induct) (auto simp add: dfs_app)"], ["", "subsection \"Basic Properties\""], ["", "lemma visit_subset_dfs: \"set ys \\<subseteq> set (dfs g xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (dfs g xs ys)", "by (induct g xs ys rule: dfs.induct) auto"], ["", "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set (dfs g xs ys)", "proof(induct g xs ys rule:dfs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set xs \\<subseteq> set (dfs g xs ys);\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (nexts g x @ xs)\n        \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\\<rbrakk>\n       \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "case(2 g x xs ys)"], ["proof (state)\nthis:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n\ngoal (2 subgoals):\n 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set xs \\<subseteq> set (dfs g xs ys);\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (nexts g x @ xs)\n        \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\\<rbrakk>\n       \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "proof(cases \"x \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "case True"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "have \"set ys \\<subseteq> set (dfs g xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (dfs g xs ys)", "by (rule visit_subset_dfs)"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (dfs g xs ys)\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "with 2 and True"], ["proof (chain)\npicking this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<in> set ys\n  set ys \\<subseteq> set (dfs g xs ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<in> set ys\n  set ys \\<subseteq> set (dfs g xs ys)\n\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "by (auto simp add: List.member_def)"], ["proof (state)\nthis:\n  set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "case False"], ["proof (state)\nthis:\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))", "by(rule visit_subset_dfs)"], ["proof (state)\nthis:\n  set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "with 2 and False"], ["proof (chain)\npicking this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<notin> set ys\n  set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<notin> set ys\n  set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "by (auto simp add: List.member_def)"], ["proof (state)\nthis:\n  set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)", "qed(simp)"], ["", "lemma nextss_closed_dfs'[rule_format]: \n \"nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow>\n    nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)", "by (induct g xs ys rule:dfs.induct, auto simp add:nextss_Cons List.member_def)"], ["", "lemma nextss_closed_dfs: \"nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])", "by (rule nextss_closed_dfs', simp add: nextss_def)"], ["", "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X = X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. r\\<^sup>* `` X \\<subseteq> X\n 2. X \\<subseteq> r\\<^sup>* `` X", "show \"r\\<^sup>* `` X \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "assume y: \"y \\<in> X\""], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "assume \"(y,x) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "then"], ["proof (chain)\npicking this:\n  (y, x) \\<in> r\\<^sup>*", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by (induct) (insert assms y, auto simp add: Image_def)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "unfolding Image_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>X. (x, y) \\<in> r\\<^sup>*} \\<subseteq> X", "by auto"], ["proof (state)\nthis:\n  r\\<^sup>* `` X \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r\\<^sup>* `` X \\<subseteq> X\n\ngoal (1 subgoal):\n 1. X \\<subseteq> r\\<^sup>* `` X", "qed auto"], ["", "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> reachable g (dfs g xs [])", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set xs\n    \\<subseteq> (set g)\\<^sup>* `` set (dfs g xs [])", "by (rule Image_mono) (auto simp add: next_subset_dfs)"], ["proof (state)\nthis:\n  reachable g xs \\<subseteq> reachable g (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "also"], ["proof (state)\nthis:\n  reachable g xs \\<subseteq> reachable g (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "have \"\\<dots> = set(dfs g xs [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g (dfs g xs []) = set (dfs g xs [])", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set (dfs g xs []) = set (dfs g xs [])", "proof (rule Image_closed_trancl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])", "from nextss_closed_dfs"], ["proof (chain)\npicking this:\n  nextss ?g (dfs ?g ?xs []) \\<subseteq> set (dfs ?g ?xs [])", "show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\""], ["proof (prove)\nusing this:\n  nextss ?g (dfs ?g ?xs []) \\<subseteq> set (dfs ?g ?xs [])\n\ngoal (1 subgoal):\n 1. set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])", "by (simp add: nextss_def)"], ["proof (state)\nthis:\n  set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable g (dfs g xs []) = set (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "finally"], ["proof (chain)\npicking this:\n  reachable g xs \\<subseteq> set (dfs g xs [])", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable g xs \\<subseteq> set (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "."], ["proof (state)\nthis:\n  reachable g xs \\<subseteq> set (dfs g xs [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g (nexts g x) \\<subseteq> reachable g [x]", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set (nexts g x)\n    \\<subseteq> (set g)\\<^sup>* `` set [x]", "by (auto intro: converse_rtrancl_into_rtrancl simp: nexts_set)"], ["", "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set (xs @ ys) =\n    (set g)\\<^sup>* `` set xs \\<union> (set g)\\<^sup>* `` set ys", "by auto"], ["", "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys", "proof(induct g xs ys rule: dfs.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g ys. set (dfs g [] ys) \\<subseteq> reachable g [] \\<union> set ys\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>g ys. set (dfs g [] ys) \\<subseteq> reachable g [] \\<union> set ys\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g_ [] ys_) \\<subseteq> reachable g_ [] \\<union> set ys_", "by simp"], ["proof (state)\nthis:\n  set (dfs g_ [] ys_) \\<subseteq> reachable g_ [] \\<union> set ys_\n\ngoal (1 subgoal):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "case (2 g x xs ys)"], ["proof (state)\nthis:\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n\ngoal (1 subgoal):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "proof (cases \"x \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "case True"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "with 2"], ["proof (chain)\npicking this:\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  x \\<in> set ys", "show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\""], ["proof (prove)\nusing this:\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "by (auto simp add: reachable_def List.member_def)"], ["proof (state)\nthis:\n  set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "case False"], ["proof (state)\nthis:\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable g (nexts g x) \\<subseteq> reachable g [x]", "by (rule reachable_nexts)"], ["proof (state)\nthis:\n  reachable g (nexts g x) \\<subseteq> reachable g [x]\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\""], ["proof (prove)\nusing this:\n  reachable g (nexts g x) \\<subseteq> reachable g [x]\n\ngoal (1 subgoal):\n 1. reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)", "by(simp add: reachable_append, auto simp add: reachable_def)"], ["proof (state)\nthis:\n  reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "with False 2"], ["proof (chain)\npicking this:\n  x \\<notin> set ys\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)", "show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\""], ["proof (prove)\nusing this:\n  x \\<notin> set ys\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)\n\ngoal (1 subgoal):\n 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "by (auto simp add: reachable_def List.member_def)"], ["proof (state)\nthis:\n  set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Correctness\""], ["", "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g xs []) = reachable g xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs\n 2. reachable g xs \\<subseteq> set (dfs g xs [])", "have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []", "by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])"], ["proof (state)\nthis:\n  set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\n\ngoal (2 subgoals):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs\n 2. reachable g xs \\<subseteq> set (dfs g xs [])", "thus \"set (dfs g xs []) \\<subseteq> reachable g xs\""], ["proof (prove)\nusing this:\n  set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\n\ngoal (1 subgoal):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs", "by simp"], ["proof (state)\nthis:\n  set (dfs g xs []) \\<subseteq> reachable g xs\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "qed(rule reachable_closed_dfs)"], ["", "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (dfs g [x] [])) = ((x, y) \\<in> (set g)\\<^sup>*)", "by(simp only:dfs_eq_reachable reachable_def, auto)"], ["", "subsection \"Executable Code\""], ["", "consts Node :: \"int \\<Rightarrow> node\""], ["", "code_datatype Node"], ["", "instantiation node :: equal\nbegin"], ["", "definition equal_node :: \"node \\<Rightarrow> node \\<Rightarrow> bool\"\nwhere\n  [code del]: \"equal_node = HOL.eq\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(node, equal_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "qed (simp add: equal_node_def)"], ["", "end"], ["", "declare [[code abort: \"HOL.equal :: node \\<Rightarrow> node \\<Rightarrow> bool\"]]"], ["", "export_code dfs dfs2 in SML file \\<open>dfs.ML\\<close>"], ["", "end"]]}